import{Vector3 as i,Quaternion as t}from"three";class s{constructor(i){this.ssp=i,this.prevObjects=new Set,this.childDirs=new Map,this.childPositions=new Map}start(s,e){this.prevObjects.add(s);const{ssp:n}=this,o=n.utils.getBoundingBox(s),h=o.getSize(new i),d=o.getCenter(new i),r=null!=e?e:Math.max(h.x,h.y,h.z);s.traverse((s=>{if("Mesh"===s.type){if(!this.childDirs.has(s.uuid)||!this.childPositions.has(s.uuid)){const e=n.utils.getBoundingBox(s).getCenter(new i),o=(new i).subVectors(e,d).normalize();if(s.parent){const i=s.parent.getWorldQuaternion(new t);i.invert(),o.applyQuaternion(i)}this.childDirs.set(s.uuid,o),this.childPositions.set(s.uuid,s.position.clone())}s.position.copy((new i).copy(this.childPositions.get(s.uuid)).add((new i).copy(this.childDirs.get(s.uuid)).multiplyScalar(r))),this.ssp.render()}}))}stop(i){let t=i;if(!t){const i=[...this.prevObjects].at(-1);i&&(this.prevObjects.delete(i),t=i)}null==t||t.traverse((i=>{"Mesh"===i.type&&this.childDirs.has(i.uuid)&&this.childPositions.has(i.uuid)&&(i.position.copy(this.childPositions.get(i.uuid)),this.childDirs.delete(i.uuid),this.childPositions.delete(i.uuid))})),this.ssp.render()}}export{s as default};
