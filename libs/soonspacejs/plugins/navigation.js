import{OrthographicCamera as t,Matrix4 as e,Quaternion as i,Euler as o,Vector3 as n,PerspectiveCamera as s,Object3D as r,MathUtils as a}from"three";class h{constructor(t,e){this.ssp=t,this.nativeCamera=e,this._isActive=!1,this.ssp.signals.cameraObjectChange.add((()=>{const t=this.ssp.viewport.cameraManager.currentCamera;this._isActive&&t===this.nativeCamera||(t===this.nativeCamera?(this._onBeforeEnter(),this.onEnter()):this._isActive&&t!==this.nativeCamera&&(this._onBeforeQuit(),this.onQuit()))}))}active(){this.ssp.viewport.cameraManager.setCurrentCamera(this.nativeCamera)}_onBeforeEnter(){this._isActive=!0}_onBeforeQuit(){this._isActive=!1}onEnter(){}onQuit(){}}class l extends h{get zoom(){return this._zoom}set zoom(t){this._zoom=t,this.resizeCamera()}constructor(e){const i=new t;super(e,i),this.ssp=e,this.resizeObserver=new ResizeObserver((()=>{this.resizeCamera()})),this._zoom=.01,i.far=2e5}resizeCamera(){if(this._isActive){const{clientWidth:t,clientHeight:e}=this.ssp.viewport.renderer.domElement,i=t*this.zoom/2,o=e*this.zoom/2;this.nativeCamera.left=-i,this.nativeCamera.right=i,this.nativeCamera.top=o,this.nativeCamera.bottom=-o,this.nativeCamera.updateProjectionMatrix()}}onEnter(){console.log("map camera enter"),this.ssp.domElement&&(this.resizeObserver.observe(this.ssp.domElement),this.resizeCamera())}onQuit(){this.ssp.domElement&&(this.resizeObserver.unobserve(this.ssp.domElement),console.log("map camera quit"))}}class u{constructor(t,e,i,o){this.gyroEvent=null,this.onChange=()=>{},this._isActive=!1,this.defaultBeta=null,this.defaultAlpha=null,this.defaultGamma=null,this.cache=null,this.beta=null,this.alpha=null,this.gamma=null,this.gyroX=null==t||t,this.gyroY=null==e||e,this.gyroZ=null==i||i,this.absolute=null==o||o}requestPermisson(){return new Promise(((t,e)=>{var i;window.DeviceOrientationEvent.requestPermission||t(!0),null===(i=window.DeviceOrientationEvent)||void 0===i||i.requestPermission().then((i=>{"granted"===i?t(!0):e("用户拒绝使用陀螺仪权限")}))}))}async active(){await this.requestPermisson(),this._isActive=!0,this.gyroEvent&&this.inActive(),this.gyroEvent=t=>{const{defaultAlpha:e,defaultBeta:i,defaultGamma:o,gyroX:n,gyroY:s,gyroZ:r}=this,{alpha:a,beta:h,gamma:l}=t,u=s&&null!=a?a:e,c=n&&null!=h?h:i,p=r&&null!=l?l:o;if(this.absolute)this.alpha=u,this.beta=c,this.gamma=p;else if(this.cache){const{alpha:t,beta:e,gamma:i}=this.cache;this.alpha=null===u?null:null===t?u:u-t,this.beta=null===c?null:null===e?c:c-e,this.gamma=null===p?null:null===i?p:p-i}else this.cache={alpha:u,beta:c,gamma:p};this.onChange(this.alpha,this.beta,this.gamma)},window.addEventListener("deviceorientation",this.gyroEvent)}inActive(){this._isActive=!1,this.gyroEvent&&(window.removeEventListener("deviceorientation",this.gyroEvent),this.gyroEvent=null)}}var c,p;function g(t){const s=new e,r=new i,a=new o;return s.lookAt(new n,t,new n(0,1,0)),r.setFromRotationMatrix(s),a.setFromQuaternion(r),a}function d(t){return new n(0,0,-1).applyQuaternion((new i).setFromEuler(t))}function m(t){return d(t).normalize()}function v(t,e){return"function"==typeof t?t(e):t}function y(t,e){return"function"==typeof t?t(e):t}!function(t){t.FIRST_VISION="first",t.THIRD_VISION="third",t.UP_VISION="up",t.LEFT_VISION="left"}(c||(c={})),function(t){t.RELATIVE_ORIENTATION="relative",t.FIXED_ORIENTATION="fixed",t.GYRO_ORIENTATION="gyro"}(p||(p={}));const T=Object.freeze({disabledAnimate:!1,fixedOrientation:!1,autoRestoreOrientation:1500,oppositeCamera:!1,oppositeType:{x:!1,y:!0,z:!1},orientationTarget:"main",vision:c.THIRD_VISION,orientationType:p.RELATIVE_ORIENTATION,rotationToTarget:new n(0,4,-10),distanceToTarget:1,targetRotationFix:[0,0,0,"XYZ"],isFixRotationRelativeTarget:!0,targetPositionFix:[0,2,0],isFixPositionRelativeTarget:!1,enableGyro:!1,gyroX:!1,gyroY:!0,gyroZ:!1,gyroAbsolute:!0,onControlStart:null,onControlRender:null,onControlEnd:null});function f(t){const e=(new i).setFromEuler((new o).fromArray(t));this.quaternion.multiply(e)}class _ extends h{get position(){return this.nativeCamera.position}get rotation(){return this.nativeCamera.rotation}get quaternion(){return this.nativeCamera.quaternion}_lookAt(...t){this.nativeCamera.lookAt(...t),this.isFixRotationRelativeTarget||f.call(this.nativeCamera,this.targetRotationAfterFix)}get enableGyro(){return this._enableGyro}set enableGyro(t){this._enableGyro=t,t?this._gyroListener.active():this._gyroListener.inActive()}get gyroX(){return this._gyroListener.gyroX}set gyroX(t){this._gyroListener.gyroX=t}get gyroY(){return this._gyroListener.gyroY}set gyroY(t){this._gyroListener.gyroY=t}get gyroZ(){return this._gyroListener.gyroZ}set gyroZ(t){this._gyroListener.gyroZ=t}get gyroAbsolute(){return this._gyroListener.absolute}set gyroAbsolute(t){this._gyroListener.absolute=t}get targetRotationAfterFix(){return y(this.targetRotationFix)}get targetPositionAfterFix(){return v(this.targetPositionFix)}get realDistanceToTarget(){return"first"===this.vision?1:this.distanceToTarget}get realRotationToTarget(){switch(this.vision){case"first":return new n(0,0,-1);case"up":return new n(0,1,-.01);case"left":return new n(1,0,0);default:return this.rotationToTarget}}get orientationType(){return this._orientationType}set orientationType(t){this._orientationType=t,t===p.GYRO_ORIENTATION?this._gyroListener.active():this._gyroListener.inActive(),t===p.FIXED_ORIENTATION&&this._fixedOrientationRotation.copy(this.followRotation),this.restoreOrientation()}get orientationTarget(){return this._orientationTarget}set orientationTarget(t){this._orientationTarget=t,this.restoreOrientation()}get vision(){return this._vision}set vision(t){this._vision=t,this.followTarget.visible=t!==c.FIRST_VISION,this.restoreOrientation()}get followTarget(){return this._followTarget}set followTarget(t){this._followTarget=t,this.restoreOrientation()}get followPosition(){const t=new n;return t.fromArray(this.targetPositionAfterFix),this.isFixPositionRelativeTarget&&t.applyEuler(this.followRotation),this.followTarget.position.clone().add(t)}get followRotation(){const t=this.followTarget.rotation;if(this.isFixRotationRelativeTarget){const e=(new o).copy(t),n=(new i).setFromEuler(e),s=(new i).setFromEuler((new o).fromArray(this.targetRotationAfterFix));return n.multiply(s),(new o).setFromQuaternion(n)}return this.followTarget.rotation}get fixedOrientation(){return this._fixedOrientation}set fixedOrientation(t){this._fixedOrientation=t,t||this.restoreOrientation()}constructor(t,e,i){const n=null!=e?e:new s(80,1,.1,100);super(t,n),this.ssp=t,this.initOptions=T,this.cameraKey="navigatorCamera"+~~(1e4*Math.random()),this._events={onRender:()=>{},onMouseDown:t=>{}},this._restoreTimer=void 0,this._positionTween=null,this.autoFollowRender=!0,this._cameraPlaceholder=new r,this.disabledAnimate=T.disabledAnimate,this.distanceToTarget=T.distanceToTarget,this.rotationToTarget=T.rotationToTarget,this.oppositeCamera=T.oppositeCamera,this.oppositeType=T.oppositeType,this.isFixRotationRelativeTarget=T.isFixRotationRelativeTarget,this.targetRotationFix=T.targetRotationFix,this.isFixPositionRelativeTarget=T.isFixPositionRelativeTarget,this.targetPositionFix=T.targetPositionFix,this.autoRestoreOrientation=T.autoRestoreOrientation,this.onControlStart=null,this.onControlRender=null,this.onControlEnd=null,this._enableGyro=!1,this._gyroRotation=new o,this._orientationType=T.orientationType,this._fixedOrientationRotation=new o,this._orientationTarget=T.orientationTarget,this._vision=T.vision,this._followTarget=new r,this._fixedOrientation=T.fixedOrientation,this.initGyroListener();const a=Object.freeze(Object.assign(Object.assign({},T),null!=i?i:{}));this.initOptions=a,this.setOptions(a),this.setCamera(n)}initGyroListener(){const t=this.initOptions;this._gyroListener=new u(t.gyroX,t.gyroY,t.gyroZ,t.gyroAbsolute),this._gyroListener.onChange=(t,e,i)=>{const n=null===t?0:a.degToRad(t),s=null===e?0:a.degToRad(e),r=null===i?0:a.degToRad(i);this._gyroRotation=new o(s,n,r)}}setCameraOrientationOnControl(){const{rotation:t}=this.ssp.viewport.cameraManager.mainCamera,{realDistanceToTarget:e,followPosition:i}=this,o=m(t);this.position.copy(i.clone().add(o.multiplyScalar(-e))),this._lookAt(this.followPosition)}updateCameraPlaceholder(){const t=this.getRenderCameraPosition();this._cameraPlaceholder.position.copy(t)}setCameraOrientationOnRender(){this.position.copy(this._cameraPlaceholder.position),this._lookAt(this.followPosition)}getRenderCameraOrientation(){const{_fixedOrientationRotation:t,_orientationType:e,_orientationTarget:i}=this,s=new o;switch(e===p.GYRO_ORIENTATION&&s.copy(this._gyroRotation),!0){case"main"===i:s.copy(e===p.FIXED_ORIENTATION?t:this.followRotation);break;case i instanceof n:{const t=this.orientationTarget.clone().sub(this.followPosition);s.copy(g(t));break}case i instanceof r:{const t=i;switch(e){case p.RELATIVE_ORIENTATION:s.copy(t.rotation);break;case p.FIXED_ORIENTATION:s.copy(g(t.position.clone().sub(this.followPosition)))}break}case i instanceof o:s.copy(i)}return s}getRenderCameraPosition(){const t=new n,e=this.getRenderCameraOrientation(),{realDistanceToTarget:i,realRotationToTarget:o}=this;if(t.copy(this.followPosition.clone().add(o.clone().applyEuler(e).normalize().multiplyScalar(i))),this.oppositeCamera){const e=this.followPosition.clone().sub(t).multiplyScalar(2),{x:i,y:o,z:n}=this.oppositeType;[i,o,n].includes(!1)&&[i,o,n].includes(!0)?(i&&(e.x=0),o&&(e.y=0),n&&(e.z=0),t.add(e)):i&&t.add(e)}return t}onRender(){this.followTarget&&(this.updateCameraPlaceholder(),this._positionTween||(this.autoFollowRender||this.fixedOrientation?this.setCameraOrientationOnRender():this.onControlRender?this.onControlRender(this.nativeCamera,this.followTarget):this.setCameraOrientationOnControl()))}initEvents(){var t;const e=this.ssp.viewport.renderer.domElement,n=this.ssp.viewport.cameraManager.mainCamera,s=this.onRender.bind(this),r=t=>{var e,s;const r=!1===this.autoFollowRender;if(this.autoFollowRender=!1,null===(e=this._positionTween)||void 0===e||e.stop(),window.clearTimeout(this._restoreTimer),document.removeEventListener("mouseup",a),document.removeEventListener("touchend",a),document.addEventListener("mouseup",a,!0),document.addEventListener("touchend",a,!0),!r){if(this.isFixRotationRelativeTarget)n.quaternion.copy(this.quaternion);else{const t=(new i).setFromEuler((new o).fromArray(this.targetRotationAfterFix)).invert();n.quaternion.copy((new i).copy(this.quaternion).multiply(t))}null===(s=this.onControlStart)||void 0===s||s.call(this,this.nativeCamera,this.followTarget,t)}},a=t=>{const e=()=>{var e;this.restoreOrientation(),this.autoFollowRender=!0,null===(e=this.onControlEnd)||void 0===e||e.call(this,this.nativeCamera,this.followTarget,t),document.removeEventListener("mouseup",a,!0),document.removeEventListener("touchend",a,!0)};"number"==typeof this.autoRestoreOrientation?(window.clearTimeout(this._restoreTimer),this._restoreTimer=setTimeout(e,this.autoRestoreOrientation)):this.autoRestoreOrientation&&e()};this._events.onRender=s,this._events.onMouseDown=r;const h=this.ssp.signals;h.beforeRender.add(s),h.mouseDown.add(r),null===(t=e.parentElement)||void 0===t||t.addEventListener("touchstart",r,!0)}clearEvents(){var t;const{onRender:e,onMouseDown:i}=this._events,o=this.ssp.signals,n=this.ssp.viewport.renderer.domElement;o.beforeRender.remove(e),o.mouseDown.remove(i),null===(t=n.parentElement)||void 0===t||t.removeEventListener("touchstart",i,!0)}onEnter(){console.log("onenter"),this.initEvents()}onQuit(){console.log("onquit"),this.clearEvents(),this._gyroListener.inActive()}resetOptions(){this.setOptions(Object.assign({},this.initOptions))}setOptions(t){const e=this.disabledAnimate;this.disabledAnimate=!0,void 0!==t.isFixPositionRelativeTarget&&(this.isFixPositionRelativeTarget=t.isFixPositionRelativeTarget),void 0!==t.targetPositionFix&&(this.targetPositionFix=t.targetPositionFix),void 0!==t.isFixRotationRelativeTarget&&(this.isFixRotationRelativeTarget=t.isFixRotationRelativeTarget),void 0!==t.targetRotationFix&&(this.targetRotationFix=t.targetRotationFix),void 0!==t.rotationToTarget&&(this.rotationToTarget=t.rotationToTarget),void 0!==t.distanceToTarget&&(this.distanceToTarget=t.distanceToTarget),void 0!==t.fixedOrientation&&(this.fixedOrientation=t.fixedOrientation),void 0!==t.oppositeCamera&&(this.oppositeCamera=t.oppositeCamera),void 0!==t.oppositeType&&(this.oppositeType=t.oppositeType),void 0!==t.orientationTarget&&(this.orientationTarget=t.orientationTarget),void 0!==t.orientationType&&(this.orientationType=t.orientationType),void 0!==t.vision&&(this.vision=t.vision),void 0!==t.autoRestoreOrientation&&(this.autoRestoreOrientation=t.autoRestoreOrientation),void 0!==t.gyroX&&(this.gyroX=t.gyroX),void 0!==t.gyroY&&(this.gyroY=t.gyroY),void 0!==t.gyroZ&&(this.gyroZ=t.gyroZ),void 0!==t.gyroAbsolute&&(this.gyroAbsolute=t.gyroAbsolute),void 0!==t.enableGyro&&(this.enableGyro=t.enableGyro),void 0!==t.onControlStart&&(this.onControlStart=t.onControlStart),void 0!==t.onControlRender&&(this.onControlRender=t.onControlRender),void 0!==t.onControlEnd&&(this.onControlEnd=t.onControlEnd),this.disabledAnimate=e,void 0!==t.disabledAnimate&&(this.disabledAnimate=t.disabledAnimate)}setCamera(t){return this._isActive&&this.ssp.viewport.cameraManager.removeCamera(this.cameraKey),this.nativeCamera=t,this.ssp.viewport.cameraManager.cameras[this.cameraKey]=t,this._isActive&&this.ssp.viewport.cameraManager.setCurrentCamera(t),this}restoreOrientation(){if(this.followTarget&&!this.fixedOrientation){if(this._positionTween&&(this._positionTween.stop(),this._positionTween=null),this.disabledAnimate)return this.position.copy(this._cameraPlaceholder.position),void this._lookAt(this.followPosition);this.ssp.animation(this.position,this._cameraPlaceholder.position,{duration:1e3},(t=>{this._lookAt(this.followPosition)}),(t=>this._positionTween=t)).finally((()=>{this._positionTween=null}))}}}var w;!function(t){t.PENDING="pending",t.STOP="stop",t.PLAYING="playing",t.PAUSE="pause",t.FINISHED="finished"}(w||(w={}));var O=Object.defineProperty,R=(t,e,i)=>(((t,e,i)=>{e in t?O(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i})(t,"symbol"!=typeof e?e+"":e,i),i);function A(t,e,i){let o=function(t,e){const i=Math.sqrt(t.lengthSq()*e.lengthSq());if(0===i)return 0;let o=t.dot(e)/i;return o=Math.max(-1,Math.min(1,o)),Math.acos(o)}(t,e);return 0===o?o:t.clone().cross(e).dot(i)<0?-o:o}const E=180/Math.PI,C={yaw:[{name:"前",range:[-15,15]},{name:"左",range:[15,165]},{name:"右",range:[-165,-15]},{name:"后",range:[-180.1,-165]},{name:"后",range:[165,180.1]}],pitch:[{name:"前",range:[-15,15]},{name:"上",range:[15,165]},{name:"下",range:[-165,-15]},{name:"后",range:[-180.1,-165]},{name:"后",range:[165,180.1]}],roll:[{name:"上",range:[-15,15]},{name:"左",range:[15,165]},{name:"右",range:[-165,-15]},{name:"下",range:[-180.1,-165]},{name:"下",range:[165,180.1]}]};const b={degrees:!0,map:C,front:{x:0,y:0,z:1},up:{x:0,y:1,z:0}};class x{constructor(t){R(this,"_options"),R(this,"_listMap"),R(this,"_front"),R(this,"_up"),t&&(this.options=t)}static get options(){return this._options??(this.options=b)}static set options(t){this._options=Object.assign({},structuredClone(C),t)}get defaultOptions(){return this.constructor.options}get options(){return this._options??(this.options=this.defaultOptions)}set options(t){this._options=Object.assign({},structuredClone(this.defaultOptions),t),this._listMap=null,this._front=null,this._up=null}get degrees(){return this.options.degrees??(this.options.degrees=this.defaultOptions.degrees??!0)}set degrees(t){this.options.degrees=t}get map(){return this.options.map||(this.map=this.defaultOptions.map),this.options.map}set map(t){const e=structuredClone(this.defaultOptions.map),i=structuredClone(C);t=t?{yaw:t.yaw??e.yaw??i.yaw,pitch:t.pitch??e.pitch??i.pitch,roll:t.roll??e.roll??i.roll}:e,this.options.map=t,this._listMap=null}get listMap(){return this._listMap??(this._listMap=function(t){const e={};for(const[i,o]of Object.entries(t))e[i]=Array.isArray(o)?o:Object.entries(o).map((([t,e])=>({name:t,range:e})));return e}(this.map??{}))}get front(){return this._front||(this.front=this.options.front??this.defaultOptions.front??b.front),this._front}set front(t){this._front=(new n).copy(t)}get up(){return this._up||(this.up=this.options.up??this.defaultOptions.up??b.up),this._up}set up(t){this._up=(new n).copy(t)}computeAzimuth(t,e,i){const o=(new n).copy(t),s=(new n).copy(e??this.front),r=(new n).copy(i??this.up);let{yaw:a,pitch:h,roll:l}=function(t,e,i){const o=e.clone().negate(),n=i.clone().projectOnPlane(e),s=A(e,t.clone().projectOnPlane(n),n),r=e.clone().cross(n);return{yaw:s,pitch:A(e,t.clone().projectOnPlane(r),r),roll:A(n,t.clone().projectOnPlane(o),o)}}(o,s,r);return this.degrees&&(a*=E,h*=E,l*=E),{yaw:{angle:a,name:this.findAzimuthNames("yaw",a)},pitch:{angle:h,name:this.findAzimuthNames("pitch",h)},roll:{angle:l,name:this.findAzimuthNames("roll",l)}}}findAzimuthNames(t,e){const i=[],o=this.listMap[t];if(!o)return i;for(const{name:t,range:[n,s]}of o)(e>=n&&e<s||e<=n&&e>s)&&i.push(t);return i}}R(x,"_options");const P=new x;function F(t,e){P.map={yaw:{left:[20,170],right:[-170,-20]},pitch:{up:[20,170],down:[-170,-20]}};const{yaw:i,pitch:o}=P.computeAzimuth(t,e),n=i.name,s=o.name;return n&&s?s?n?`${n}-${s}`:s:n:"straight"}function I(t,e){return e.reverse().map((e=>{t.removeObjectById(e.sid);const i=e.nodes.reverse().map((t=>({id:t.id,position:t.position,graphs:t.graphs})));return t.createTopology(Object.assign(Object.assign({},e.info),{nodes:i}))}))}function N(t,e,i){if(!e||!i)return"straight";return F(e.position.clone().sub(t.position),i.position.clone().sub(e.position))}function S(t){const e=t.nodes,i=t.getLength();let o=0,n=0;return e.reduce(((t,s,r)=>{const a=e[r+1],h=e[r+2],l=a?a.position.clone().distanceTo(s.position):0,u=N(s,a,h),c=o+l,p=c/i,g={progressArea:[n,p],distanceArea:[o,c],node:s,nextNode:a,distanceToStart:o,distanceToEnd:i-o,distanceToNext:l,frontDirection:u};return o=c,n=p,t.push(g),t}),[])}function L(t,e){return 0===t?e[0]:100===t?e[e.length-1]:e.find((e=>{const[i,o]=e.progressArea;return t>=i&&t<o}))}function z(t,e){if(!e)return{distanceToStartNode:0,distanceToEndNode:0,distanceToStart:0,distanceToEnd:0};const[i,o]=e.progressArea,{distanceToNext:n,distanceToEnd:s,distanceToStart:r}=e,a=(t-i)/(o-i),h=n*a,l=n*(1-a);return{distanceToStartNode:h,distanceToEndNode:l,distanceToStart:h+r,distanceToEnd:s-l}}class M{get model(){return this._model}set model(t){this._model=t}get speed(){return this._speed}set speed(t){this._speed=t}get pathProgress(){return this._pathProgress}set pathProgress(t){this._pathProgress=t}get totalProgress(){return this._pathProgress}set totalProgress(t){this._pathProgress=t}get currentPath(){return this.paths[this.currentPathIndex]}get currentPathIndex(){return this._currentPathIndex}get currentRotationVector(){return this._nextNode&&this._currentNode?this._nextNode.clone().sub(this._currentNode):new n}constructor(t,e){this.ssp=t,this.paths=e,this.onPlay=()=>{},this.onStatusChange=()=>{},this.loop=!1,this.autoNext=!0,this.playAfterStart=!1,this.flyToModelAfterStart=!0,this.backStartPointWhenStop=!0,this._model=new r,this._speed=1,this._pathProgress=0,this._totalProgress=0,this._currentPathIndex=0,this._currentNode=null,this._nextNode=null,this._playStatus=w.PENDING}changeStatus(t){this._playStatus=t,this.onStatusChange(t)}start(){}restart(){this.stop(),this.start()}play(t=0,e){this.changeStatus(w.PLAYING),this.paths[t]}pause(){this.changeStatus(w.PAUSE)}stop(){this.changeStatus(w.STOP)}flip(){}over(){this.changeStatus(w.PENDING)}}const D=new x;export{x as Azimuth,u as GyroListener,l as MapCamera,p as NAVIGATE_ORIENTATION_TYPE,c as NAVIGATE_VISION_TYPE,_ as NavigateCamera,M as Navigator,w as PLAY_STATUS,h as SoonSpaceCamera,g as Vector3ToEuler,D as azimuth,d as eulerToVector3,F as getDirection,N as getDirectionByNodes,z as getDistanceInfoByProgress,y as getFixEuler,v as getFixVector,L as getNavigatorNodeInfoByProgress,S as getNavigatorNodeInfosByTopology,m as normalizeEuler,I as reverseTopologies};
