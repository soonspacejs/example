const t="/SceneMetadata.json",e="/db/sign",a="/db/tree_models.json",s="/db/topology_paths.json",o="/db/properties.json",i="/db/animations.json",n="/db/model_visions.json",r="properties";var l;!function(t){t[t.BIDIRECTION=0]="BIDIRECTION",t[t.POSITIVE=1]="POSITIVE",t[t.OPPOSITE=2]="OPPOSITE",t[t.FORBID=3]="FORBID"}(l||(l={}));class c{get path(){return this._path}set path(t){this._path=t}constructor(t){this.ssp=t,this._path="",this._treeDataMaps=new Map,this.metaData=null,this.treeData=null,this.topologyData=null,this.propertiesData=null,this.animationsData=null,this.modelVisionsData=null}_resolvePath(t){return`${this._path}${t}`}async _fetchData(t){const{utils:e}=this.ssp;return e.fetchFile(this._resolvePath(t)).then((t=>t.json()))}async fetchMetaData(){return this._fetchData(t)}async _fetchSign(){const{utils:t}=this.ssp;return t.fetchFile(this._resolvePath(e))}async _fetchTreeDataResponse(){const t=this._treeDataMaps.get(this.path);if(t)return t;const{utils:e}=this.ssp,s=e.fetchFile(this._resolvePath(a));return this._treeDataMaps.set(this.path,s),s}async fetchTreeData(){return this._fetchTreeDataResponse().then((t=>t.clone().json()))}async fetchTopologyData(){return this._fetchData(s).then((t=>{const e={linkWidth:.1,linkColor:["#00ff00"],nodeRadius:.05,nodeColor:"#0000ff"};return t.map((t=>{const a=Object.assign(Object.assign({},e),t);return a.imgUrl&&(a.imgUrl=`${this.path}${a.imgUrl}`),a}))}))}async fetchPropertiesData(){return this._fetchData(o).then((t=>h(t,"modelId")))}async fetchAnimationsData(){return this._fetchData(i).then((t=>h(t,"modelId")))}async fetchModelVisionsData(){return this._fetchData(n).then((t=>new Map(Object.entries(t))))}async loadObjects(t){if(!this.treeData)return void console.error("treeData is null");const{syncProperties:e}=t,a=async(t,s)=>{const{ssp:o}=this,{THREE:{Matrix4:i}}=o,{id:n,name:l,renderType:c,path:h,matrix:p}=t,d=(new i).fromArray(p);let y=null;if("3D"===c)if(h)try{const e=Object.assign({},t);Reflect.deleteProperty(e,"children");const a=h.replaceAll(/#/g,"%23");y=await o.loadModel({id:n,name:l,url:this._resolvePath(a),userData:e})}catch(t){console.error(t)}else o.utils.warn(`id: ${n} path 为空`);else"GROUP"!==c&&"STUB"!==c||(y=o.createGroup({id:n,name:l,userData:Object.assign({},t)}));if(y&&(d.decompose(y.position,y.quaternion,y.scale),s&&o.addObject(y,s),e&&this.propertiesData)){const t=this.propertiesData.get(n);t&&(y.userData[r]=t)}t.children.length>0&&await Promise.allSettled(t.children.map((t=>a(t,y))))};await Promise.allSettled(this.treeData.map((t=>a(t,null))))}setPath(t){this.path=t}async loadScene(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t=Object.assign({syncProperties:!0,syncModelVisions:!0,needsModelsBoundsTree:!0},t),await Promise.allSettled([(async()=>{t.syncProperties&&(this.propertiesData=await this.fetchPropertiesData())})(),(async()=>{t.syncModelVisions&&(this.modelVisionsData=await this.fetchModelVisionsData())})()]),this.treeData=await this.fetchTreeData(),await this.loadObjects(t),t.needsModelsBoundsTree&&this.ssp.computeModelsBoundsTree()}async getTopologies(){return this.topologyData=await this.fetchTopologyData(),this.topologyData}async playAnimationById(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{utils:{error:s},animation:o,THREE:i}=this.ssp,{onStart:n,onUpdate:r}=a;this.animationsData||(this.animationsData=await this.fetchAnimationsData());const l=this.ssp.getObjectById(t);if(!l)return void s(`playAnimationById: id 为 ${t} 场景对象未找到`);const c=this.animationsData.get(t);if(c){const a=c[e];if(a)for(let t=0,e=a.keyframes.length;t<e;t++){let e;if(a.keyframes[t-1]){const s=a.keyframes[t-1];e={x:s.x,y:s.y,z:s.z,rotationX:s.rotationX,rotationY:s.rotationY,rotationZ:s.rotationZ,scaleX:s.scaleX,scaleY:s.scaleY,scaleZ:s.scaleZ}}else{const t=new i.Object3D,a=(new i.Matrix4).fromArray(l.userData.matrix);t.applyMatrix4(a),e={x:t.position.x,y:t.position.y,z:t.position.z,rotationX:t.rotation.x,rotationY:t.rotation.y,rotationZ:t.rotation.z,scaleX:t.scale.x,scaleY:t.scale.y,scaleZ:t.scale.z}}const s=a.keyframes[t],{delay:c,duration:h,easing:p,repeat:d,yoyo:y}=s,u={x:s.x,y:s.y,z:s.z,rotationX:s.rotationX,rotationY:s.rotationY,rotationZ:s.rotationZ,scaleX:s.scaleX,scaleY:s.scaleY,scaleZ:s.scaleZ};await o(e,u,{delay:c,duration:h,mode:p,repeat:-1===d?1/0:d,yoyo:y},((t,e)=>{l.position.set(t.x,t.y,t.z),l.rotation.set(t.rotationX,t.rotationY,t.rotationZ),l.scale.set(t.scaleX,t.scaleY,t.scaleZ),null==r||r(t,e)}),(t=>{null==n||n(t)}))}else s(`id: ${t} 未找到索引为 ${e} 的动画`)}else s(`id: ${t} 未找到动画`)}}function h(t,e){const a=new Map;return t.reduce(((t,a)=>{const s=t.get(a[e]);return s?s.push(a):t.set(a[e],[a]),t}),a),a}export{i as ANIMATIONS_DATA_FILE_PATH,t as META_DATA_FILE_PATH,n as MODEL_VISIONS_DATA_FILE_PATH,o as PROPERTIES_DATA_FLEE_PATH,r as PROPERTIES_KEY,e as SIGN_PATH,s as TOPOLOGY_DATA_FILE_PATH,a as TREE_DATA_FILE_PATH,c as default};
