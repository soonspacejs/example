import * as THREE from 'three';
import { Vector3, Euler, Box3, Quaternion, CubeTextureLoader, FloatType, EquirectangularReflectionMapping, TextureLoader, Color, Texture, Vector2, Matrix4, BufferAttribute, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Line as Line$1, Line3, MathUtils, CurvePath, LineCurve, LineCurve3, Bone, Uint16BufferAttribute, SkinnedMesh, Skeleton, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, Object3D, InterpolateLinear, InterpolateDiscrete, Scene, Fog, Mesh, EdgesGeometry, LineSegments, MeshStandardMaterial, PerspectiveCamera, OrthographicCamera, WebGLRenderer, PCFSoftShadowMap, Sphere, Camera, sRGBEncoding, BasicDepthPacking, UnsignedByteType, MeshNormalMaterial, WebGLRenderTarget, NearestFilter, DepthTexture, DepthStencilFormat, UnsignedInt248Type, UnsignedIntType, LinearEncoding, Uniform, RepeatWrapping, LoadingManager, LinearFilter, RGBAFormat, ShaderMaterial, NoBlending, RGBADepthPacking, REVISION, EventDispatcher, BackSide, DoubleSide, FrontSide, MeshDepthMaterial, DataTexture, LuminanceFormat, Vector4, Material, RedFormat, RGFormat, ShaderChunk, WebGLCubeRenderTarget, CubeCamera, PMREMGenerator, HalfFloatType, WebGLMultipleRenderTargets, FramebufferTexture, Matrix3, TangentSpaceNormalMap, GLSL3, VideoTexture, GLBufferAttribute, InterleavedBufferAttribute, Frustum, MOUSE, TOUCH, Spherical, MeshBasicMaterial, PlaneGeometry, Clock, Raycaster, AnimationMixer, UVMapping, ACESFilmicToneMapping, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, Sprite, SpriteMaterial, SphereGeometry, CircleGeometry, ShapeGeometry, Shape, AmbientLight, DirectionalLight, HemisphereLight, SpotLight, PointLight, RectAreaLight, Loader, LoaderUtils, FileLoader, ClampToEdgeWrapping, Group as Group$2, PropertyBinding, NumberKeyframeTrack, LinearMipMapLinearFilter, ImageLoader, InstancedMesh, GridHelper, AxesHelper, Box3Helper, DirectionalLightHelper, HemisphereLightHelper, SpotLightHelper, PointLightHelper, Box2, Plane, CanvasTexture, MeshPhongMaterial } from 'three';
export * from 'three';
import { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';
import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';
import Stats from 'three/examples/jsm/libs/stats.module.js';
import { Sky } from 'three/examples/jsm/objects/Sky.js';
import { deinterleaveGeometry } from 'three/examples/jsm/utils/BufferGeometryUtils.js';
import { WorkerPool } from 'three/examples/jsm/utils/WorkerPool.js';
import { MeshBVH, computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh';
import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib.js';
import { TGALoader } from 'three/examples/jsm/loaders/TGALoader.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import * as fflate from 'three/examples/jsm/libs/fflate.module.js';
import { NURBSCurve } from 'three/examples/jsm/curves/NURBSCurve.js';
import { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper.js';

const name = "soonspacejs";
const version$1 = "2.6.10";
var configJson = {
	name: name,
	version: version$1,
	"private": false
};

/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group$1 = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group$1();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

var VERSION = '18.6.4';

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports = {
    Easing: Easing,
    Group: Group$1,
    Interpolation: Interpolation,
    now: now$1,
    Sequence: Sequence,
    nextId: nextId,
    Tween: Tween,
    VERSION: VERSION,
    getAll: getAll,
    removeAll: removeAll,
    add: add,
    remove: remove,
    update: update,
};

const INNER_ID = '[soonspacejs]: ';
const managerType = {
    GROUP_MANAGE_TYPE: 'Group',
    LIGHT_MANAGE_TYPE: 'Light',
    MODEL_MANAGE_TYPE: 'Model',
    POI_MANAGE_TYPE: 'Poi',
    POI_NODE_MANAGE_TYPE: 'PoiNode',
    CANVAS3D_MANAGE_TYPE: 'Canvas3D',
    TOPOLOGY_MANAGE_TYPE: 'Topology',
    HELPER_MANAGE_TYPE: 'Helper',
    PLUGIN_OBJECT_MANAGE_TYPE: 'PluginObject',
};

const consoleSspTitle = 'In soonspacejs: ';
const log = (text, style) => {
    let styleStr = '';
    for (const i in style)
        styleStr += `${i}: ${style[i]};`;
    console.log(`%c${text}`, styleStr);
};
const warn = (text) => {
    console.warn(consoleSspTitle + text);
};
const error = (text) => {
    console.error(consoleSspTitle + text);
};

function IVector3ToVector3(val) {
    if (val instanceof Vector3)
        return val;
    else
        return new Vector3(val.x, val.y, val.z);
}
function IVector3ToEuler(val) {
    if (val instanceof Euler)
        return val;
    else
        return new Euler(val.x, val.y, val.z);
}
/**
 * 获取 object box
 * @param object
 * @returns
 */
function getBoundingBox(object) {
    const box3 = new Box3(new Vector3(), new Vector3()).setFromObject(object);
    if (box3.isEmpty()) {
        object.getWorldPosition(box3.min);
        box3.max.copy(box3.min);
    }
    return box3;
}
function rotationAxisFix(axis, source, target) {
    const newTarget = target.clone();
    if (Math.abs(source[axis] - target[axis]) > Math.PI) {
        if (source[axis] > target[axis]) {
            newTarget[axis] += Math.PI * 2;
        }
        else {
            newTarget[axis] -= Math.PI * 2;
        }
    }
    return newTarget;
}
function rotationAFix(source, target) {
    const xFixedRotation = rotationAxisFix('x', source, target);
    const yFixedRotation = rotationAxisFix('y', source, target);
    const zFixedRotation = rotationAxisFix('z', source, target);
    return new Euler(xFixedRotation.x, yFixedRotation.y, zFixedRotation.z, target.order);
}
function deg2Euler(deg) {
    return Math.PI / 180 * deg;
}
function euler2Deg(euler) {
    return euler / (Math.PI / 180);
}
/**
 * 从 object 获取 position、rotation、scale
 * @param object
 * @param isFromWorld
 * @returns
 */
function getSpaceAttributeFromObject(object, isFromWorld = true) {
    if (isFromWorld) {
        return {
            position: object.getWorldPosition(new Vector3),
            rotation: new Euler().setFromQuaternion(object.getWorldQuaternion(new Quaternion)),
            scale: object.getWorldScale(new Vector3),
        };
    }
    else {
        return {
            position: object.position.clone(),
            rotation: object.rotation.clone(),
            scale: object.scale.clone(),
        };
    }
}
/**
 * 同步 source 的 position、rotation、scale 到 target
 * @param target
 * @param source
 * @param isFromWorld
 */
function syncSpaceAttributeToObject(target, source, isFromWorld = true) {
    const attribute = getSpaceAttributeFromObject(source, isFromWorld);
    target.position.copy(attribute.position);
    target.rotation.copy(attribute.rotation);
    target.scale.copy(attribute.scale);
}
function isObjectVisible(object) {
    if (!object.visible)
        return false;
    else if (!object.parent)
        return true;
    else
        return isObjectVisible(object.parent);
}

class MinHeap {
    constructor() {
        this.min = null;
        this.roots = [];
        this.nodes = new Map();
    }
    shift() {
        const minNode = this.min;
        // Current min is null or no more after it
        if (minNode === null || this.roots.length < 1) {
            this.min = null;
            return minNode;
        }
        // Remove it
        this.remove(minNode);
        // Consolidate
        if (this.roots.length > 50) {
            this.consolidate();
        }
        // Get next min
        let lowestDistance = Infinity;
        const length = this.roots.length;
        for (let i = 0; i < length; i++) {
            const node = this.roots[i];
            const distance = this.getDistance(node);
            if (distance < lowestDistance) {
                lowestDistance = distance;
                this.min = node;
            }
        }
        return minNode;
    }
    consolidate() {
        // Consolidate
        const depths = [[], [], [], [], [], [], []];
        // 0-index
        const maxDepth = depths.length - 1;
        // Populate depths array
        const length = this.roots.length;
        for (let i = 0; i < length; i++) {
            const nodeIndex = this.roots[i];
            const node = this.nodes.get(nodeIndex);
            if (node && node.depth < maxDepth) {
                depths[node.depth].push(nodeIndex);
            }
        }
        // Consolidate
        for (let depth = 0; depth <= maxDepth; depth++) {
            while (depths[depth].length > 1) {
                const first = depths[depth].shift();
                const second = depths[depth].shift();
                const newDepth = depth + 1;
                let pos = -1;
                if (first !== undefined && second !== undefined) {
                    const firstNode = this.nodes.get(first), secondNode = this.nodes.get(second);
                    if (firstNode && secondNode) {
                        if (firstNode.distance < secondNode.distance) {
                            firstNode.depth = newDepth;
                            firstNode.children.push(second);
                            secondNode.parent = first;
                            if (newDepth <= maxDepth) {
                                depths[newDepth].push(first);
                            }
                            // Find position in roots where adopted node is
                            pos = this.roots.indexOf(second);
                        }
                        else {
                            secondNode.depth = newDepth;
                            secondNode.children.push(first);
                            firstNode.parent = second;
                            if (newDepth <= maxDepth) {
                                depths[newDepth].push(second);
                            }
                            // Find position in roots where adopted node is
                            pos = this.roots.indexOf(first);
                        }
                    }
                }
                // Remove roots that have been made children
                if (pos > -1) {
                    this.roots.splice(pos, 1);
                }
            }
        }
    }
    add(nodeIndex, distance) {
        // Add the node
        this.nodes.set(nodeIndex, {
            nodeIndex,
            distance,
            depth: 0,
            parent: null,
            children: [],
        });
        // Is it the minimum?
        if (this.min === null) {
            this.min = nodeIndex;
        }
        else {
            const minNode = this.nodes.get(this.min);
            if (minNode && distance < minNode.distance) {
                this.min = nodeIndex;
            }
        }
        // Other stuff
        this.roots.push(nodeIndex);
    }
    update(nodeIndex, distance) {
        this.remove(nodeIndex);
        this.add(nodeIndex, distance);
    }
    remove(nodeIndex) {
        var _a, _b;
        if (!this.nodes.has(nodeIndex))
            return;
        // Move children to be children of the parent
        const children = (_a = this.nodes.get(nodeIndex)) === null || _a === void 0 ? void 0 : _a.children;
        if (children && children.length > 0) {
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                const childNode = this.nodes.get(child), parentNode = this.nodes.get(nodeIndex);
                if (childNode && parentNode) {
                    childNode.parent = parentNode.parent;
                }
                // No parent, then add to roots
                if (childNode && childNode.parent === null) {
                    this.roots.push(child);
                }
            }
        }
        let parent = (_b = this.nodes.get(nodeIndex)) === null || _b === void 0 ? void 0 : _b.parent;
        // Root, so remove from roots
        if (parent === null) {
            const pos = this.roots.indexOf(nodeIndex);
            if (pos > -1) {
                this.roots.splice(pos, 1);
            }
        }
        else {
            // Go up the parents and decrease their depth
            while (parent) {
                const parentNode = this.nodes.get(parent);
                if (parentNode) {
                    parentNode.depth--;
                    parent = parentNode.parent;
                }
            }
        }
    }
    getDistance(nodeIndex) {
        const node = this.nodes.get(nodeIndex);
        if (node) {
            return node.distance;
        }
        return Infinity;
    }
}

async function getTexture({ path = '', file, }) {
    if (Array.isArray(file)) {
        return new CubeTextureLoader()
            .setPath(path)
            .loadAsync(file);
    }
    else {
        const extension = getExtension(file);
        if (extension === 'hdr' || extension === 'pic') {
            const hdrTexture = await new RGBELoader().setPath(path).setDataType(FloatType).loadAsync(file);
            hdrTexture.mapping = EquirectangularReflectionMapping;
            return hdrTexture;
        }
        else {
            const texture = await new TextureLoader().setPath(path).loadAsync(file);
            texture.mapping = EquirectangularReflectionMapping;
            return texture;
        }
    }
}
function gradientTexture(options) {
    if (!options)
        return null;
    const { colors, stops, size = 1024, } = options;
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    if (!context)
        return null;
    canvas.width = 16;
    canvas.height = size;
    const gradient = context.createLinearGradient(0, 0, 0, size);
    const _tempColor = new Color();
    const cssColors = colors.map(color => _tempColor.set(color).getStyle());
    for (let i = 0, l = cssColors.length - 1; i <= l; i++) {
        gradient.addColorStop(stops ? stops[i] : i / l, cssColors[i]);
    }
    context.fillStyle = gradient;
    context.fillRect(0, 0, 16, size);
    const texture = new Texture(canvas);
    texture.needsUpdate = true;
    return texture;
}

const parseFilePath = (url) => {
    const index = url.lastIndexOf('/');
    if (index === -1)
        return './';
    return url.slice(0, index + 1);
};

function cloneDeep(val) {
    if (isArray(val)) {
        return cloneArrayDeep(val);
    }
    else if (isObject(val)) {
        return cloneObjectDeep(val);
    }
    return val;
}
function cloneObjectDeep(val) {
    if (isObject(val)) {
        const res = {};
        for (const key in val) {
            res[key] = cloneDeep(val[key]);
        }
        return res;
    }
    return val;
}
function cloneArrayDeep(val) {
    return val.map(item => cloneDeep(item));
}

const materialHandle = (material, handler) => {
    if (isArray(material)) {
        return material.map(handler);
    }
    else {
        return handler(material);
    }
};
const cloneMaterials = (material) => {
    return materialHandle(material, m => m.clone());
};
const disposeMaterials = (material) => {
    return materialHandle(material, m => m.dispose());
};

const fetchFile = async (url) => {
    const response = await fetch(url);
    if (response.status === 200) {
        return response;
    }
    throw new Error(`Failed to fetch file: ${url}`);
};

const v1 = new Vector3();
const v2 = new Vector3();
const v3 = new Vector3();
function isObjectBehindCamera(el, camera) {
    const objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    const cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    const deltaCamObj = objectPos.sub(cameraPos);
    const camDir = camera.getWorldDirection(v3);
    return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}
function isObjectOccludeVisible(el, camera, raycaster, occlude) {
    const elPos = v1.setFromMatrixPosition(el.matrixWorld);
    const screenPos = elPos.clone();
    screenPos.project(camera);
    raycaster.setFromCamera(new Vector2(screenPos.x, screenPos.y), camera);
    const intersects = raycaster.intersectObjects(occlude, true);
    if (intersects.length) {
        const intersectionDistance = intersects[0].distance;
        const pointDistance = elPos.distanceTo(raycaster.ray.origin);
        return pointDistance < intersectionDistance;
    }
    return true;
}

const idleTask = (callback) => {
    if (typeof requestIdleCallback === 'function')
        requestIdleCallback(callback);
    else
        setTimeout(callback);
};

var e=function(){function e(){}return e.prototype.toJson=function(e,t){var o=this.xmlStringToXmlDom(e),r=this.xmlToJson(o);return t?(t.removeLineBreaks&&this.removeLineBreaks(r),t.removeComments&&this.removeCommentProperties(r),t.transformTextOnly&&this.transformTextOnly(r),r):r},e.prototype.xmlStringToXmlDom=function(e){return (new DOMParser).parseFromString(e,"text/xml")},e.prototype.removeLineBreaks=function(e){var t=this;Object.keys(e).forEach((function(o,r){"#text"===o&&Array.isArray(e[o])&&delete e[o],"object"==typeof e[o]&&t.removeLineBreaks(e[o]);}));},e.prototype.removeCommentProperties=function(e){var t=this;Object.keys(e).forEach((function(o,r){"#comment"===o&&delete e[o],"object"==typeof e[o]&&t.removeCommentProperties(e[o]);}));},e.prototype.transformTextOnly=function(e){var t=this;Object.keys(e).forEach((function(o,r){var n=Object.keys(e[o]).length>1,i=Object.keys(e[o])[0];n||"object"==typeof e[o][i]?t.transformTextOnly(e[o]):"object"==typeof e[o]&&e[o]["#text"]&&(e[o]=e[o]["#text"]);}));},e.prototype.xmlToJson=function(e){var t={};if(1==e.nodeType){if(e.attributes.length>0){t._attributes={};for(var o=0;o<e.attributes.length;o++){var r=e.attributes.item(o);t._attributes[r.nodeName]=r.nodeValue;}}}else 3==e.nodeType&&(t=e.nodeValue);if(e.hasChildNodes())for(var n=0;n<e.childNodes.length;n++){var i=e.childNodes.item(n),s=i.nodeName;if(void 0===t[s])t[s]=this.xmlToJson(i);else {if(void 0===t[s].push){var a=t[s];t[s]=[],t[s].push(a);}t[s].push(this.xmlToJson(i));}}return t},e}();

function xmlToJson(url) {
    function toJson(text) {
        return new e().toJson(text, {
            transformTextOnly: true,
            removeComments: true,
            removeLineBreaks: true,
        });
    }
    return fetchFile(url)
        .then(res => res.text())
        .then(text => Promise.resolve(toJson(text)));
}

/**
 * Mesh GPU Instancing extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing
 */
class GLTFExporterMeshGPUInstancingExtension {

  name = 'EXT_mesh_gpu_instancing'

  constructor ( writer ) {

    this.writer = writer;

  }

  writeNode ( node, nodeDef ) {

    if ( node.isInstancedMesh !== true ) {

      return
    
    }

    const count = node.count;
    const matrix = new Matrix4();
    const positions = new Float32Array( count * 3 );
    const quaternions = new Float32Array( count * 4 );
    const scales = new Float32Array( count * 3 );

    const p = new Vector3();
    const q = new Quaternion();
    const s = new Vector3();

    for ( let i = 0; i < count; i++ ) {

      node.getMatrixAt( i, matrix );
      matrix.decompose( p, q, s );

      positions[ i * 3 ] = p.x;
      positions[ i * 3 + 1 ] = p.y;
      positions[ i * 3 + 2 ] = p.z;

      quaternions[ i * 4 ] = q.x;
      quaternions[ i * 4 + 1 ] = q.y;
      quaternions[ i * 4 + 2 ] = q.z;
      quaternions[ i * 4 + 3 ] = q.w;

      scales[ i * 3 ] = s.x;
      scales[ i * 3 + 1 ] = s.y;
      scales[ i * 3 + 2 ] = s.z;
    
    }

    const writer = this.writer;
    const extensionDef = {};

    // @TODO: Export attributes only if the values are not default values?
    // @TODO: Support colors
    extensionDef.attributes = {
      TRANSLATION: writer.processAccessor( new BufferAttribute( positions, 3 ) ),
      ROTATION: writer.processAccessor( new BufferAttribute( quaternions, 4 ) ),
      SCALE: writer.processAccessor( new BufferAttribute( scales, 3 ) ),
    };

    nodeDef.extensions = nodeDef.extensions || {};
    nodeDef.extensions[ this.name ] = extensionDef;
    writer.extensionsUsed[ this.name ] = true;
  
  }

}

function exportGltf(object, options = {}) {
    return new Promise((resolve, reject) => {
        const exporter = new GLTFExporter();
        exporter.register(writer => new GLTFExporterMeshGPUInstancingExtension(writer));
        exporter.parse(object, (data) => resolve(data), (error) => reject(error), options);
    });
}

const hasOwnProperty = Object.prototype.hasOwnProperty;
// 
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
// 
const isString = (val) => getValueType(val) === 'String';
const isBoolean = (val) => getValueType(val) === 'Boolean';
const isNumber = (val) => getValueType(val) === 'Number';
const isNull = (val) => getValueType(val) === 'Null';
const isUndefined = (val) => getValueType(val) === 'Undefined';
const isSymbol = (val) => getValueType(val) === 'Symbol';
// 
const isDate = (val) => getValueType(val) === 'Date';
const isArray = Array.isArray;
const isObject = (val) => getValueType(val) === 'Object';
const isFunction = (val) => getValueType(val) === 'Function';
const isPromise = (val) => getValueType(val) === 'Promise';
// 
const getValueType = (val) => {
    return Object.prototype.toString.call(val).slice(8, -1);
};
const sleep = (time) => {
    return new Promise(resolve => setTimeout(() => resolve(), time));
};
const getAsciiString = (buf, offset, len) => {
    return String.fromCodePoint(...new Uint8Array(buf, offset, len));
};
const randomString = () => INNER_ID + Math.random().toString(36).substring(7).split('').join('_');
const getExtension = (url) => {
    var _a;
    const { pathname, } = new URL(url, location.origin);
    return (_a = pathname.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
};

var shared = /*#__PURE__*/Object.freeze({
  __proto__: null,
  IVector3ToEuler: IVector3ToEuler,
  IVector3ToVector3: IVector3ToVector3,
  MinHeap: MinHeap,
  cloneDeep: cloneDeep,
  cloneMaterials: cloneMaterials,
  deg2Euler: deg2Euler,
  disposeMaterials: disposeMaterials,
  error: error,
  euler2Deg: euler2Deg,
  exportGltf: exportGltf,
  fetchFile: fetchFile,
  getAsciiString: getAsciiString,
  getBoundingBox: getBoundingBox,
  getExtension: getExtension,
  getSpaceAttributeFromObject: getSpaceAttributeFromObject,
  getTexture: getTexture,
  getValueType: getValueType,
  gradientTexture: gradientTexture,
  hasOwn: hasOwn,
  idleTask: idleTask,
  isArray: isArray,
  isBoolean: isBoolean,
  isDate: isDate,
  isFunction: isFunction,
  isNull: isNull,
  isNumber: isNumber,
  isObject: isObject,
  isObjectBehindCamera: isObjectBehindCamera,
  isObjectOccludeVisible: isObjectOccludeVisible,
  isObjectVisible: isObjectVisible,
  isPromise: isPromise,
  isString: isString,
  isSymbol: isSymbol,
  isUndefined: isUndefined,
  log: log,
  materialHandle: materialHandle,
  parseFilePath: parseFilePath,
  randomString: randomString,
  rotationAFix: rotationAFix,
  rotationAxisFix: rotationAxisFix,
  sleep: sleep,
  syncSpaceAttributeToObject: syncSpaceAttributeToObject,
  warn: warn,
  xmlToJson: xmlToJson
});

const animationModeEnum = {
    'Linear.None': Easing.Linear.None,
    'Quadratic.In': Easing.Quadratic.In,
    'Quadratic.Out': Easing.Quadratic.Out,
    'Quadratic.InOut': Easing.Quadratic.InOut,
    'Cubic.In': Easing.Cubic.In,
    'Cubic.Out': Easing.Cubic.Out,
    'Cubic.InOut': Easing.Cubic.InOut,
    'Quartic.In': Easing.Quartic.In,
    'Quartic.Out': Easing.Quartic.Out,
    'Quartic.InOut': Easing.Quartic.InOut,
    'Quintic.In': Easing.Quintic.In,
    'Quintic.Out': Easing.Quintic.Out,
    'Quintic.InOut': Easing.Quintic.InOut,
    'Sinusoidal.In': Easing.Sinusoidal.In,
    'Sinusoidal.Out': Easing.Sinusoidal.Out,
    'Sinusoidal.InOut': Easing.Sinusoidal.InOut,
    'Exponential.In': Easing.Exponential.In,
    'Exponential.Out': Easing.Exponential.Out,
    'Exponential.InOut': Easing.Exponential.InOut,
    'Circular.In': Easing.Circular.In,
    'Circular.Out': Easing.Circular.Out,
    'Circular.InOut': Easing.Circular.InOut,
    'Elastic.In': Easing.Elastic.In,
    'Elastic.Out': Easing.Elastic.Out,
    'Elastic.InOut': Easing.Elastic.InOut,
    'Back.In': Easing.Back.In,
    'Back.Out': Easing.Back.Out,
    'Back.InOut': Easing.Back.InOut,
    'Bounce.In': Easing.Bounce.In,
    'Bounce.Out': Easing.Bounce.Out,
    'Bounce.InOut': Easing.Bounce.InOut,
};
function Animation(source, target, options = {}, onUpdate, onStart) {
    return new Promise((resolve, reject) => {
        const { duration = 1000, delay = 0, repeat = false, mode = 'Linear.None', yoyo = false, } = options;
        const TweenMode = animationModeEnum[mode];
        const tween = new Tween(source)
            .to(target, duration)
            .easing(TweenMode)
            .delay(delay)
            .onUpdate((e) => {
            // Euler
            if (source instanceof Euler && target instanceof Euler && e instanceof Euler)
                e.order = target.order;
            onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(e, tween);
        })
            .onComplete(() => {
            resolve();
        })
            .onStop(() => {
            reject('animation stop');
        })
            .onStart(() => {
            onStart === null || onStart === void 0 ? void 0 : onStart(tween);
        });
        if (isNumber(repeat))
            tween.repeat(repeat);
        else if (isBoolean(repeat) && repeat)
            tween.repeat(Infinity);
        tween.yoyo(yoyo);
        tween.start();
    });
}

/**
 * 路径动画
 */
class PathAnimation {
    /**
     *
     * @param target - 被动画的目标对象
     * @param points - 路径点列表
     * @param options - 选项
     */
    constructor(target, points, options = {}) {
        this.target = target;
        this.points = points;
        /**
         * 移动速度
         */
        this.speed = 1;
        /**
         * 反向播放
         */
        this.reverse = false;
        /**
         * 是否需要旋转
         */
        this.needsRotate = true;
        /**
         * 当前目标点的索引
         */
        this.index = 1;
        this._tween = null;
        Object.assign(this, options);
    }
    /**
     * 是否正在播放
     */
    get isPlaying() {
        var _a;
        return !!((_a = this._tween) === null || _a === void 0 ? void 0 : _a.isPlaying());
    }
    /**
     * 播放
     */
    async play() {
        if (this.isPlaying)
            return false;
        this.index = 1;
        let points = this.points.slice();
        if (this.reverse) {
            points = points.reverse();
        }
        return this._play(points);
    }
    async _play(points) {
        var _a, _b;
        const { target, } = this;
        const speed = (_a = this.speed) !== null && _a !== void 0 ? _a : 1;
        const index = this.index;
        let sourcePoint = points[index - 1];
        if (!sourcePoint)
            return true;
        if (!sourcePoint.isVector3) {
            sourcePoint = IVector3ToVector3(sourcePoint);
        }
        sourcePoint = sourcePoint.clone();
        let targetPoint = points[index];
        if (!targetPoint)
            return true;
        if (!targetPoint.isVector3) {
            targetPoint = IVector3ToVector3(targetPoint).clone();
        }
        targetPoint = targetPoint.clone();
        const distance = sourcePoint.distanceTo(targetPoint);
        const duration = distance / speed;
        /**
         * 旋转
         */
        if (this.needsRotate) {
            if (index === 1 && target.parent) {
                target.position.copy(target.parent.worldToLocal(sourcePoint.clone()));
            }
            target.lookAt(targetPoint);
        }
        await Animation(sourcePoint, targetPoint, {
            duration,
        }, (_target, tween) => {
            var _a;
            if (target.parent) {
                const local = target.parent.worldToLocal(_target.clone());
                target.position.copy(local);
            }
            (_a = this.onUpdate) === null || _a === void 0 ? void 0 : _a.call(this, _target, tween);
        }, (tween) => {
            var _a, _b;
            if (index === 1) {
                (_a = this.onStart) === null || _a === void 0 ? void 0 : _a.call(this, tween);
            }
            (_b = this.onEveryStart) === null || _b === void 0 ? void 0 : _b.call(this, tween);
            this._tween = tween;
        });
        (_b = this.onPoint) === null || _b === void 0 ? void 0 : _b.call(this, index, targetPoint);
        this.index++;
        await this._play(points);
    }
    /**
     * 暂停
     */
    pause() {
        var _a;
        (_a = this._tween) === null || _a === void 0 ? void 0 : _a.pause();
    }
    resume() {
        var _a;
        (_a = this._tween) === null || _a === void 0 ? void 0 : _a.resume();
    }
    /**
     * 停止
     */
    stop() {
        var _a;
        (_a = this._tween) === null || _a === void 0 ? void 0 : _a.stop();
        this._tween = null;
    }
}

var le = Object.defineProperty;
var ue = (n, e, t) => e in n ? le(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var E = (n, e, t) => (ue(n, typeof e != "symbol" ? e + "" : e, t), t);
function Qe(n, e) {
  if (e = e ?? n.arcLengthDivisions, n.cacheArcULengths && n.cacheArcULengths.length === e + 1 && !n.needsUpdate) {
    const s = n.cacheArcULengths;
    return { lengths: s, length: s[e] };
  }
  n.needsUpdate = !1;
  const t = [0];
  let o = n.getPoint(0), r = 0;
  for (let s = 1; s <= e; s++) {
    const c = n.getPointAt(s / e);
    r += c.distanceTo(o), t.push(r), o = c;
  }
  return n.cacheArcULengths = t, { lengths: t, length: r };
}
function Te(n, e, t) {
  const o = t ? (l) => n.getPointAt(l) : (l) => n.getPoint(l);
  let r = e[0], s = o(r), c = s.length();
  const i = [c], g = e.length;
  for (let l = 1; l < g; l++) {
    r = e[l];
    const d = o(r);
    c += d.distanceTo(s), i.push(c), s = d;
  }
  return { lengths: i, length: i[g - 1] };
}
function Yt(n, e) {
  let t = n.sampleLength;
  if (!t) {
    const o = n.sampleNum;
    if (o)
      return o;
    t = 1;
  }
  return Math.ceil(e / t);
}
function Wt(n) {
  const { curve: e } = n;
  let t = e.getLength();
  const o = Yt(n, t);
  return e.arcLengthDivisions < o && (e.arcLengthDivisions = o, e.updateArcLengths(), t = e.getLength()), { length: t, division: o };
}
function Me(n, e) {
  const t = n.getLength(), o = Yt(e ?? {}, t), r = n.getPoints(o), s = n.getLengths(o);
  return Zt(r, { ...e, lengths: s });
}
function Zt(n, e) {
  const { startColor: t, endColor: o, color: r, lengths: s } = e ?? {}, c = r ? new Color(r) : null, i = t ? new Color(t) : c ?? new Color(0, 1, 0), g = o ? new Color(o) : c ?? new Color(0, 0, 1), l = [], d = [];
  n[0].toArray(l, 0);
  const m = l.length, p = s ?? te(n).lengths, h = p[p.length - 1], f = new Color();
  n.forEach((k, P) => {
    k.toArray(l, P * m);
    const A = p[P] / h;
    f.lerpColors(i, g, A), f.toArray(d, P * 3);
  });
  const x = new BufferGeometry();
  return x.setAttribute("position", new Float32BufferAttribute(l, m)), x.setAttribute("color", new Float32BufferAttribute(d, 3)), x;
}
function Je(n, e) {
  e = e ?? {};
  let { material: t, linewidth: o } = e;
  o = o ?? 1, t = t ?? new LineBasicMaterial({ vertexColors: !0, linewidth: o });
  const r = Array.isArray(n) ? Zt(n, e) : Me(n, e);
  return new Line$1(r, t);
}
function te(n) {
  const e = Bt(n), t = [0], o = e.reduce((r, s) => (r += s.distance(), t.push(r), r), 0);
  return { lines: e, lengths: t, length: o };
}
function Bt(n) {
  const e = [];
  return n.reduce((t, o) => {
    const r = new Line3(t, o);
    return e.push(r), o;
  }), e;
}
function Xe(n, e) {
  const t = [];
  return { lines: e.filter((r, s) => {
    const c = r.closestPointToPointParameter(n), i = 0 <= c || c >= 1;
    return i && t.push(s), i;
  }), indexs: t };
}
function Pe(n, e) {
  const { distSortIndexs: t, clampDists: o, clampPoints: r, ts: s, clampTs: c } = ve(n, e), i = t[0];
  return { line: e[i], index: i, clampDist: o[i], clampPoint: r[i], t: s[i], clampT: c[i] };
}
function ve(n, e) {
  const t = {
    clampDists: [],
    clampPoints: [],
    distSortIndexs: [],
    ts: [],
    clampTs: []
  };
  return e.forEach((o, r) => {
    const s = o.closestPointToPointParameter(n), c = MathUtils.clamp(s, 0, 1), i = o.at(c, new Vector3()), g = n.distanceTo(i);
    t.clampDists.push(g), t.clampPoints.push(i), t.distSortIndexs.push(r), t.ts.push(s), t.clampTs.push(c);
  }), t.distSortIndexs.sort((o, r) => t.clampDists[o] - t.clampDists[r]), t;
}
function be(n) {
  const e = new CurvePath(), t = n[0].z == null ? LineCurve : LineCurve3;
  return n.reduce((o, r) => {
    const s = new t(o, r);
    return e.add(s), r;
  }), e;
}
var Ot = /* @__PURE__ */ ((n) => (n.back = "back", n.front = "front", n))(Ot || {});
function ee(n) {
  const { curve: e, distance: t, fromU: o = 0, side: r, tolerance: s = t * 0.1 } = n, c = n.length ?? e.getLength(), i = e.getPointAt(o);
  let g = t / c;
  const l = r === "front" ? -1 : 1;
  let d = !0, m = o, p = i, h = 0, f = !0;
  do {
    m = l * g + o;
    let x = !1;
    m > 1 ? (m = 1, x = !0) : m < 0 && (m = 0, x = !0), p = e.getPointAt(m), h = p.distanceTo(i), d = Math.abs(t - h) > s;
    const k = t / h;
    if (x && d && k > 1) {
      f = !1;
      break;
    }
    g *= k;
  } while (d);
  return {
    succeed: f,
    u: m,
    point: p,
    distance: h
  };
}
function He(n) {
  const { curve: e, distance: t, fromU: o = 0, tolerance: r = t * 0.1, origin: s } = n, c = n.length ?? e.getLength(), i = e.getPointAt(o), g = i.distanceTo(s), l = t - g;
  let d = l / c, m = !0, p = o, h = i;
  do {
    p = d + o;
    let f = !1;
    p > 1 ? (p = 1, f = !0) : p < 0 && (p = 0, f = !0), h = e.getPointAt(p);
    const x = h.distanceTo(s);
    m = Math.abs(t - x) > r;
    const k = l / (x - g);
    if (f && m && k > 1)
      return null;
    d *= k;
  } while (m);
  return {
    u: p,
    point: h
  };
}
const At = new Vector3(), ne = new Vector3(1, 1, 1);
new Quaternion();
const wt = new Matrix4();
function oe(n) {
  const { joints: e, axials: t } = n;
  if (e)
    var o = Ae(e);
  else
    t ? o = Vt(n) : o = Ie(n);
  return o;
}
function Vt(n) {
  const { axials: e, start: t } = n, o = new Bone();
  t && (o.position.copy(t), o.updateMatrix());
  const r = [o];
  return e.reduce((s, c) => {
    const i = new Bone();
    return i.position.copy(c), s.add(i), r.push(i), i.updateMatrix(), i;
  }, o), o.updateWorldMatrix(!0, !0), r;
}
function Ae(n) {
  const e = [];
  return n.reduce((t, o) => {
    const r = o.clone().sub(t);
    return e.push(r), o;
  }), Vt({ axials: e, start: n[0] });
}
function Ie(n) {
  const { start: e, axial: t } = n;
  let o = n.number;
  const r = new Array(o - 1);
  return r.fill(t), Vt({ axials: r, start: e });
}
function Le(n) {
  const { geometry: e, flexible: t = 1, axial: o, number: r } = n, s = n.start ?? new Vector3(), c = o.clone().normalize(), i = o.length(), g = r - 1, l = new Quaternion().setFromUnitVectors(new Vector3(1, 0, 0), c), m = new Matrix4().compose(s, l, new Vector3(1, 1, 1)).invert(), p = e.getAttribute("position").clone(), h = p.count;
  p.applyMatrix4(m);
  const f = [], x = [];
  for (let k = 0; k < h; k++) {
    const P = p.getX(k);
    if (P < 0) {
      f.push(0, 0, 0, 0), x.push(1, 0, 0, 0);
      continue;
    }
    const A = Math.trunc(P / i);
    if (A < g) {
      const I = P % i / i * t;
      f.push(A, A + 1, 0, 0), x.push(1 - I, I, 0, 0);
      continue;
    }
    f.push(g, 0, 0, 0), x.push(1, 0, 0, 0);
  }
  return e.setAttribute("skinIndex", new Uint16BufferAttribute(f, 4)), e.setAttribute("skinWeight", new Float32BufferAttribute(x, 4)), e;
}
function Ye(n) {
  const { skeleton: e, geometryFrame: t } = n, o = e.boneInverses[0].clone().invert(), r = e.boneInverses[1].clone().invert();
  if (t) {
    const i = t.clone().invert();
    o.premultiply(i), r.premultiply(i);
  }
  const s = new Vector3().setFromMatrixPosition(o), c = new Vector3().setFromMatrixPosition(r);
  return c.sub(s), Le({
    ...n,
    start: s,
    axial: c,
    number: e.bones.length
  });
}
function re(n) {
  const { skeleton: e, geometry: t, flexible: o = 1, geometryFrame: r } = n, s = (r == null ? void 0 : r.clone().invert()) ?? wt.clone(), c = e.boneInverses.map((h) => {
    const f = h.clone().invert().premultiply(s);
    return new Vector3().setFromMatrixPosition(f);
  }), i = Bt(c), g = t.getAttribute("position"), l = g.count, d = [], m = [], p = new Vector3();
  for (let h = 0; h < l; h++) {
    p.fromBufferAttribute(g, h);
    const { index: f, clampT: x } = Pe(p, i), k = x * o;
    d.push(f, f + 1, 0, 0), m.push(1 - k, k, 0, 0);
  }
  return t.setAttribute("skinIndex", new Uint16BufferAttribute(d, 4)), t.setAttribute("skinWeight", new Float32BufferAttribute(m, 4)), t;
}
function Ze(n) {
  const { geometry: e } = n, t = n.material ?? void 0, o = new SkinnedMesh(e, t), r = oe(n);
  o.add(r[0]);
  const s = new Skeleton(r);
  return o.bind(s), re({ ...n, skeleton: s }), o;
}
function tn(n) {
  const { skeleton: e } = n, t = se(n);
  return t.updateMatrix(), t.updateMatrixWorld(), t.bind(e), t;
}
function se(n) {
  const { mesh: e, skeleton: t } = n, o = e.geometry, r = new SkinnedMesh();
  return e.copy.call(r, e, !1), re({ ...n, geometry: o, skeleton: t, geometryFrame: e.matrixWorld }), r;
}
function Ce(n) {
  const { model: e } = n;
  let { skeleton: t } = n;
  if (t)
    var o = t.bones[0];
  else {
    const s = oe(n);
    t = new Skeleton(s), o = s[0];
  }
  e.add(o), e.updateWorldMatrix(!1, !0), t.calculateInverses(), o.removeFromParent();
  const r = ie({ ...n, model: e, skeleton: t });
  return r.add(o), { model: r, skeleton: t, rootBone: o };
}
function ie(n) {
  const { model: e, skeleton: t, parent: o } = n, r = e.isMesh, s = r ? se({ ...n, mesh: e, skeleton: t }) : e.clone(!1);
  o && o.add(s), s.updateMatrixWorld(!0), r && s.bind(t, e.matrixWorld);
  const c = e.children;
  for (const i of c)
    ie({ ...n, model: i, parent: s });
  return s;
}
function en(n) {
  return n.filter((e) => {
    var t;
    return !((t = e.parent) != null && t.isBone);
  });
}
function Fe(n) {
  return n.find((e) => {
    var t;
    return !((t = e.parent) != null && t.isBone);
  });
}
function nn(n) {
  return Fe(n) ?? n[0];
}
function on(n) {
  return n.curve ? Re(n) : Ne(n);
}
function Re(n) {
  const { keyframeTracks: e, duration: t } = ce(n);
  return new AnimationClip(n.name, t, e);
}
function ce(n) {
  const { curve: e, lookDistance: t } = n, o = n.targetPath ?? "", r = Wt(n).division, s = Ct(n, e.getLength()), c = InterpolateLinear, i = [], g = qt(r), l = { ...n, duration: s, division: r, ts: g, lookPoint: { distance: t } }, d = $t(l), { points: m, rotates: p } = Gt(l);
  if (m.length) {
    const h = [];
    m.forEach((x, k) => {
      x.toArray(h, k * 3);
    });
    const f = new VectorKeyframeTrack(`${o}.position`, d, h, c);
    i.push(f);
  }
  if (p.length) {
    const h = [];
    p.forEach((x, k) => {
      x.toArray(h, k * 4);
    });
    const f = new QuaternionKeyframeTrack(`${o}.quaternion`, d, h, c);
    i.push(f);
  }
  return { keyframeTracks: i, duration: s };
}
function Ct(n, e) {
  let t = n.duration;
  if (!t) {
    const o = n.speed;
    if (o == null)
      throw "缺少选项 duration 或者 speed";
    if (!e)
      throw "缺少参数 length";
    t = e / o;
  }
  return t;
}
function Gt(n) {
  var b, F;
  const { curve: e, target: t, lookPoint: o, enableUp: r } = n, s = n.position ?? !0, c = n.rotate ?? !0, i = [], g = [], l = [], d = { rotates: i, points: g };
  if (!(s || c))
    return d;
  const m = (n.anchor ?? At).clone(), p = n.ts ?? n.us, h = !n.ts;
  if (!p)
    throw "缺少参数：至少传递 ts 和 us 任意之一";
  let f = wt.clone(), x = wt.clone(), k = ne.clone(), P = Object3D.DEFAULT_UP;
  t && (t.updateMatrixWorld(!0), f = t.matrix, x = t.matrixWorld, k = t.scale, P = t.up);
  const A = f.clone().invert(), v = x.clone().multiply(A).clone().invert(), U = e.getTangent(0);
  U.transformDirection(v);
  const G = ((b = n.front) == null ? void 0 : b.clone().transformDirection(f)) ?? U, j = new Quaternion().setFromUnitVectors(new Vector3(0, 0, 1), G), _ = ((F = n.up) == null ? void 0 : F.clone().transformDirection(f)) ?? P.clone().transformDirection(v);
  let B = f.clone().setPosition(0, 0, 0), S = (u) => e.getPoint(u), O = (u) => e.getTangent(u);
  h && (S = (u) => e.getPointAt(u), O = (u) => e.getTangentAt(u));
  const V = p.length, N = V - 1;
  let { distance: q, curveLength: Q, lengths: K } = o ?? {};
  q = q ?? 0;
  let Y = O;
  q !== 0 && (K || (K = Te(e, p, h).lengths), Q == null && (Q = K[N]), Y = (u, M) => {
    const a = S(u);
    let T = (K[M] + q) / Q;
    return T > 1 && (T = 1), e.getPointAt(T).sub(a).normalize();
  });
  let L = (u) => {
    const M = p[u], a = Y(M, u);
    a.transformDirection(v), l.push(a);
    const w = u - 1, T = w < 0, C = T ? G : l[w], R = new Quaternion().setFromUnitVectors(C, a);
    if (!T) {
      const W = i[w];
      R.multiply(W);
    }
    return R;
  };
  r && (L = (u) => {
    const M = p[u], a = Y(M, u);
    a.transformDirection(v), l.push(a);
    const w = u - 1;
    let T = j;
    const C = new Quaternion();
    if (w < 0) {
      const R = new Matrix4().lookAt(new Vector3(), a, _);
      C.setFromRotationMatrix(R);
    } else {
      const R = l[w];
      C.setFromUnitVectors(R, a), T = i[w];
    }
    return C.multiply(T), C;
  });
  for (let u = 0; u < V; u++) {
    const M = p[u];
    if (c) {
      const a = L(u);
      i.push(a), B = new Matrix4().compose(At, a, k);
    }
    if (s) {
      const a = S(M);
      a.applyMatrix4(v);
      const w = m.clone().applyMatrix4(B);
      a.sub(w), g.push(a);
    }
  }
  return d;
}
function qt(n) {
  const e = [];
  for (let t = 0; t <= n; t++)
    e.push(t / n);
  return e;
}
function $t(n) {
  const { curve: e, division: t, duration: o } = n, r = e.getLengths(t), s = r.length, c = r[s - 1];
  return r.map((g) => g / c * o);
}
function Ne(n) {
  const { smooth: e, points: t } = n;
  if (e === !1)
    var { keyframeTracks: o, duration: r } = De(n);
  else {
    const s = be(t);
    var { keyframeTracks: o, duration: r } = ce({ ...n, curve: s });
  }
  return new AnimationClip(n.name, r, o);
}
function De(n) {
  const e = n.targetPath ?? "", t = n.points, { lines: o, length: r, lengths: s } = te(t), c = Ct(n, r), i = [], g = s.map((h) => h / r * c), { points: l, pointTimes: d, rotates: m, rotateTimes: p } = Ue({ ...n, times: g }, o);
  if (l.length) {
    const h = [];
    l.forEach((x, k) => {
      x.toArray(h, k * 3);
    });
    const f = new VectorKeyframeTrack(`${e}.position`, d, h, InterpolateLinear);
    i.push(f);
  }
  if (m.length) {
    const h = [];
    m.forEach((x, k) => {
      x.toArray(h, k * 4);
    });
    const f = new QuaternionKeyframeTrack(`${e}.quaternion`, p, h, InterpolateDiscrete);
    i.push(f);
  }
  return { keyframeTracks: i, duration: c };
}
function Ue(n, e) {
  var K, Y;
  const { points: t, target: o, lookPoint: r, times: s, enableUp: c } = n, i = n.position ?? !0, g = n.rotate ?? !0, l = t.length, d = l - 1;
  e = e ?? Bt(t);
  const m = [], p = s, h = [], f = [], x = [], k = { rotates: m, points: h, rotateTimes: p, pointTimes: f };
  if (!(i || g))
    return k;
  const P = (n.anchor ?? At).clone();
  let A = wt.clone(), I = wt.clone(), v = ne.clone(), U = Object3D.DEFAULT_UP;
  o && (o.updateMatrixWorld(!0), A = o.matrix, I = o.matrixWorld, v = o.scale, U = o.up);
  const G = A.clone().invert(), _ = I.clone().multiply(G).clone().invert(), B = e[0].delta(new Vector3());
  B.transformDirection(_);
  const S = ((K = n.front) == null ? void 0 : K.clone().transformDirection(A)) ?? B, O = new Quaternion().setFromUnitVectors(new Vector3(0, 0, 1), S), V = ((Y = n.up) == null ? void 0 : Y.clone().transformDirection(A)) ?? U.clone().transformDirection(_);
  let N = A.clone().setPosition(0, 0, 0), q = N, Q = (L) => {
    const b = e[L].delta(new Vector3()).normalize();
    b.transformDirection(_), x.push(b);
    const F = L - 1, u = F < 0, M = u ? S : x[F], a = new Quaternion().setFromUnitVectors(M, b);
    if (!u) {
      const w = m[F];
      a.multiply(w);
    }
    return a;
  };
  c && (Q = (L) => {
    const b = e[L].delta(new Vector3()).normalize();
    b.transformDirection(_), x.push(b);
    const F = L - 1;
    let u = O;
    const M = new Quaternion();
    if (F < 0) {
      const a = new Matrix4().lookAt(new Vector3(), b, V);
      M.setFromRotationMatrix(a);
    } else {
      const a = x[F];
      M.setFromUnitVectors(a, b), u = m[F];
    }
    return M.multiply(u), M;
  });
  for (let L = 0; L < l; L++) {
    if (g)
      if (L < d) {
        const b = Q(L);
        m.push(b), N = new Matrix4().compose(At, b, v);
      } else
        m.push(m[L - 1].clone());
    if (i) {
      const b = s[L], F = t[L].clone();
      if (F.applyMatrix4(_), L > 0) {
        const M = P.clone().applyMatrix4(q), a = F.clone().sub(M);
        h.push(a), f.push(b);
      }
      const u = P.clone().applyMatrix4(N);
      F.sub(u), h.push(F), f.push(b);
    }
    q = N;
  }
  return k;
}
function rn(n) {
  const e = n.mixer, t = Ce(n), { model: o, skeleton: r } = t, s = Ke({ ...n, skeleton: r });
  o.animations.push(s);
  const c = e == null ? void 0 : e.clipAction(s, o);
  return { ...t, clip: s, action: c };
}
function Ke(n) {
  const { boneTracks: e, duration: t } = _e(n), o = e.flat();
  return new AnimationClip(n.name, t, o);
}
function _e(n) {
  const { skeleton: e, targetPath: t } = n, o = e.bones, { times: r, boneSampleDatas: s, duration: c } = Se(n), i = r.length, g = InterpolateLinear;
  return { boneTracks: s.map((d, m) => {
    const { points: p, rotates: h } = d, f = o[m], x = t ? `${t}.skeleton.bones[${m}]` : `${f.name || f.uuid}`, k = [], P = [];
    for (let v = 0; v < i; v++)
      p && p[v].toArray(k, v * 3), h[v].toArray(P, v * 4);
    const A = [];
    if (p) {
      const v = new VectorKeyframeTrack(`${x}.position`, r, k, g);
      A.push(v);
    }
    const I = new QuaternionKeyframeTrack(`${x}.quaternion`, r, P, g);
    return A.push(I), A;
  }), duration: c };
}
function Se(n) {
  var F;
  const { curve: e, skeleton: t, stretch: o } = n, { bones: r, boneInverses: s } = t, c = r[0], i = n.target ?? c.parent;
  if (!i)
    throw "target 或 根骨骼的 parent 不存在";
  const g = n.tolerance ?? 0.1;
  c.updateWorldMatrix(!0, !0);
  const { division: l, length: d } = Wt(n), { matrixWorld: m } = i, p = m.clone().invert(), h = [], f = [];
  s.reduce((u, M) => {
    const a = M.clone().invert();
    h.push(a);
    const w = u.clone().multiply(a);
    return f.push(w), M;
  }, p);
  const x = f[0], k = new Vector3(), P = new Quaternion(), A = new Vector3();
  x.decompose(k, P, A);
  const I = x.clone().invert(), v = Ct(n), U = qt(l), G = $t({ curve: e, division: l, duration: v }), j = U.length, _ = [], B = new Vector3().setFromMatrixPosition(f[1]).negate(), S = (F = n.up) == null ? void 0 : F.clone().transformDirection(I), { points: O, rotates: V } = Gt({ ...n, curve: e, ts: U, target: c, rotate: !0, front: B, up: S, anchor: null });
  for (let u = 0; u < j; u++)
    _.push(m.clone());
  const N = O.map((u, M) => {
    const a = V[M];
    a.premultiply(P);
    const w = new Matrix4().compose(u, a, A);
    return w.premultiply(m), w;
  }), Q = e.getLengths(l).map((u) => u / d), K = [{ points: O, rotates: V, us: Q, matrixs: N }], Y = o ? function(u, M, a) {
    const T = K[u].us[M] - a / d;
    return {
      u: T,
      point: T < 0 ? null : e.getPointAt(T)
    };
  } : function(u, M, a) {
    const T = K[u].us[M], { u: C, point: R, succeed: W } = ee({
      curve: e,
      distance: a,
      fromU: T,
      length: d,
      side: Ot.front,
      tolerance: g * a
    });
    return { u: C, point: W ? R : null };
  }, L = s.length, b = L - 1;
  for (let u = 1; u < L; u++) {
    const M = [], a = [], w = [], T = [];
    K.push({ points: M, rotates: a, us: w, matrixs: T });
    const C = f[u], R = h[u], W = u - 1, ht = K[W], Z = f[W], Ft = h[W], { matrixs: Rt, points: Nt, rotates: Dt } = ht, ct = new Vector3().setFromMatrixScale(Z), Tt = W - 1, Mt = Tt < 0 ? _ : K[Tt].matrixs, et = new Vector3(), nt = new Quaternion(), at = new Vector3();
    C.decompose(et, nt, at);
    const ot = new Vector3().setFromMatrixPosition(R).sub(new Vector3().setFromMatrixPosition(Ft)).length(), lt = et.length();
    for (let $ = 0; $ < j; $++) {
      const { point: H, u: pt } = Y(W, $, ot);
      w.push(pt), a.push(nt.clone());
      const rt = Rt[$];
      if (pt < 0 || !H) {
        M.push(et);
        const it = rt.clone().multiply(C);
        T.push(it);
        continue;
      }
      const J = Mt[$];
      let X = J.clone().invert();
      const ut = H.clone().applyMatrix4(X), tt = Nt[$];
      ut.sub(tt).normalize();
      const mt = Dt[$], Ut = new Matrix4().compose(tt, mt, ct), Pt = et.clone().transformDirection(Ut), gt = new Quaternion().setFromUnitVectors(Pt, ut);
      mt.premultiply(gt), rt.compose(tt, mt, ct), rt.premultiply(J);
      const st = rt.clone().invert();
      H.applyMatrix4(st);
      const Kt = H.length();
      H.copy(et).multiplyScalar(Kt / lt), M.push(H);
      const dt = new Matrix4().compose(H, nt, at);
      if (u === b) {
        const it = e.getTangentAt(pt);
        it.negate().transformDirection(st);
        const xt = new Quaternion().setFromUnitVectors(H.clone().normalize(), it);
        xt.premultiply(nt), a[$] = xt, dt.compose(H, xt, at);
      }
      dt.premultiply(rt), T.push(dt);
    }
  }
  return { times: G, boneSampleDatas: K, duration: v };
}
function sn(n) {
  const { boneTracks: e, targetTracks: t, duration: o } = We(n), r = t.concat(e.flat());
  return new AnimationClip(n.name, o, r);
}
function We(n) {
  const { skeleton: e, targetPath: t } = n, { times: o, boneSampleDatas: r, duration: s, targetSampleDatas: c } = Be(n), i = o.length, g = e.bones, l = InterpolateLinear, d = [], m = [], { points: p, rotates: h } = c;
  for (let I = 0; I < i; I++)
    p[I].toArray(d, I * 3), h[I].toArray(m, I * 4);
  const f = t ?? "", x = new VectorKeyframeTrack(`${f}.position`, o, d, l), k = new QuaternionKeyframeTrack(`${f}.quaternion`, o, m, l), P = [x, k];
  return { boneTracks: r.map((I, v) => {
    const { points: U, rotates: G } = I, j = g[v], _ = t ? `${t}.skeleton.bones[${v}]` : `${j.name || j.uuid}`, B = [], S = [];
    for (let N = 0; N < i; N++)
      U && U[N].toArray(B, N * 3), G[N].toArray(S, N * 4);
    const O = [];
    if (U) {
      const N = new VectorKeyframeTrack(`${_}.position`, o, B, l);
      O.push(N);
    }
    const V = new QuaternionKeyframeTrack(`${_}.quaternion`, o, S, l);
    return O.push(V), O;
  }), targetTracks: P, duration: s };
}
function Be(n) {
  const { curve: e, skeleton: t, stretch: o } = n, { bones: r, boneInverses: s } = t, c = r[0], i = n.target ?? c.parent;
  if (!i)
    throw "target 或 根骨骼的 parent 不存在";
  const g = n.tolerance ?? 0.1;
  c.updateWorldMatrix(!0, !0);
  const { division: l, length: d } = Wt(n), { matrix: m, matrixWorld: p, scale: h } = i, f = p.clone().multiply(m.clone().invert()), x = p.clone().invert(), k = [], P = [];
  s.reduce((a, w) => {
    const T = w.clone().invert();
    k.push(T);
    const C = a.clone().multiply(T);
    return P.push(C), w;
  }, x);
  const A = P[0], I = new Vector3(), v = new Quaternion(), U = new Vector3();
  A.decompose(I, v, U);
  const G = Ct(n), j = qt(l), _ = new Vector3().setFromMatrixPosition(P[1]).negate().transformDirection(A), { rotates: B, points: S } = Gt({ ...n, curve: e, target: i, position: !0, rotate: !0, anchor: I, front: _, ts: j }), O = $t({ curve: e, division: l, duration: G }), V = S.map((a, w) => {
    const T = B[w], C = new Matrix4().compose(a, T, h);
    return C.premultiply(f), C;
  }), N = { points: S, rotates: B, matrixs: V }, q = [], Q = V.map((a) => (q.push(v.clone()), a.clone().multiply(A))), K = j.length, L = e.getLengths(l).map((a) => a / d), b = [{ rotates: q, us: L, matrixs: Q }], F = o ? function(a, w, T) {
    const R = b[a].us[w] - T / d;
    return {
      u: R,
      point: R < 0 ? null : e.getPointAt(R)
    };
  } : function(a, w, T) {
    const R = b[a].us[w], { u: W, point: ht, succeed: Z } = ee({
      curve: e,
      distance: T,
      fromU: R,
      length: d,
      side: Ot.front,
      tolerance: g * T
    });
    return { u: W, point: Z ? ht : null };
  }, u = s.length, M = u - 1;
  for (let a = 1; a < u; a++) {
    const w = [], T = [], C = [], R = [];
    b.push({ points: w, rotates: T, us: C, matrixs: R });
    const W = P[a], ht = k[a], Z = a - 1, Ft = b[Z], Rt = P[Z], Nt = k[Z], { matrixs: Dt, points: ct, rotates: Tt } = Ft, Mt = new Vector3(), et = new Quaternion(), nt = new Vector3();
    Rt.decompose(Mt, et, nt);
    const at = Z - 1, Et = at < 0 ? V : b[at].matrixs, ot = new Vector3(), lt = new Quaternion(), $ = new Vector3();
    W.decompose(ot, lt, $);
    const pt = new Vector3().setFromMatrixPosition(ht).sub(new Vector3().setFromMatrixPosition(Nt)).length(), rt = ot.length();
    for (let J = 0; J < K; J++) {
      const { point: X, u: ut } = F(Z, J, pt);
      C.push(ut), T.push(lt.clone());
      const tt = Dt[J];
      if (ut < 0 || !X) {
        w.push(ot);
        const vt = tt.clone().multiply(W);
        R.push(vt);
        continue;
      }
      const mt = Et[J];
      let Ut = mt.clone().invert();
      const Pt = X.clone().applyMatrix4(Ut), gt = (ct == null ? void 0 : ct[J]) ?? Mt;
      Pt.sub(gt).normalize();
      const st = Tt[J], Kt = new Matrix4().compose(gt, st, nt), dt = ot.clone().transformDirection(Kt);
      st.setFromUnitVectors(dt, Pt), st.premultiply(et), tt.compose(gt, st, nt), tt.premultiply(mt);
      const it = tt.clone().invert();
      X.applyMatrix4(it);
      const xt = X.length();
      X.copy(ot).multiplyScalar(xt / rt), w.push(X);
      const _t = new Matrix4().compose(X, lt, $);
      if (a === M) {
        const vt = e.getTangentAt(ut);
        vt.negate().transformDirection(it);
        const St = new Quaternion().setFromUnitVectors(X.clone().normalize(), vt);
        St.premultiply(lt), T[J] = St, _t.compose(X, St, $);
      }
      _t.premultiply(tt), R.push(_t);
    }
  }
  return { times: O, boneSampleDatas: b, targetSampleDatas: N, duration: G };
}
function Oe(n) {
  const { duration: e, tracks: t } = n;
  return t.map((o) => Array.from(o.times.map((r) => r / e)));
}
class Ve {
  constructor(e) {
    E(this, "_tracksTimeRatios", null);
    E(this, "_lastGetTime", 0);
    E(this, "_lastGetKeyframeIndexs", null);
    this.clip = e;
  }
  /**
   * 关键帧时间比率列表
   */
  get tracksTimeRatios() {
    return this._tracksTimeRatios ?? (this._tracksTimeRatios = Oe(this.clip));
  }
  /**
   * 获取指定时间对应的关键帧索引；
   * @param time 
   * @returns 
   */
  getTracksKeyframeIndexs(e) {
    const { clip: t, _lastGetTime: o } = this, r = e / t.duration, s = this.tracksTimeRatios;
    this._lastGetTime = e, e < o && (this._lastGetKeyframeIndexs = null), this._lastGetTime = e;
    const c = this._lastGetKeyframeIndexs;
    return this._lastGetKeyframeIndexs = s.map((i, g) => {
      const l = (c == null ? void 0 : c[g]) ?? 0, d = i.length;
      for (let m = l; m < d; m++)
        if (r < i[m])
          return m - 1;
      return d - 1;
    });
  }
  /**
   * 获取所有轨道的关键帧
   * @param time 
   * @returns 
   */
  getTracksKeyframes(e) {
    const t = this.getTracksKeyframeIndexs(e), o = this.clip.tracks;
    return t.map((r, s) => {
      let c = null;
      if (r !== -1) {
        const i = o[s], g = i.getValueSize(), l = r * g, d = l + g;
        c = Array.from(i.values.slice(l, d));
      }
      return { index: r, value: c };
    });
  }
}
class Ge extends Ve {
  constructor(t) {
    super(t.getClip());
    E(this, "_trackNames");
    E(this, "_positionTrackName");
    E(this, "_quaternionTrackName");
    E(this, "_rotationTrackName");
    E(this, "_scaleTrackName");
    this.action = t;
  }
  /**
   * 动画的当前时间
   */
  get time() {
    return this.action.time;
  }
  /**
   * 动画的持续时间
   */
  get duration() {
    return this.clip.duration;
  }
  /**
   * 动画的进度
   */
  get progress() {
    return this.time / this.duration;
  }
  set progress(t) {
    const o = this.action;
    o.time = t * this.duration;
  }
  /**
   * 动画的所有轨道的名字
   */
  get trackNames() {
    return this._trackNames ?? (this._trackNames = this.clip.tracks.map((t) => t.name));
  }
  /**
   * 动画所有轨道的当前关键帧的索引
   */
  get keyframeIndexs() {
    const t = this.getTracksKeyframeIndexs(this.time);
    return this.trackNames.reduce((o, r, s) => (o[r] = t[s], o), {});
  }
  get keyframes() {
    const t = this.getTracksKeyframes(this.time);
    return this.trackNames.reduce((o, r, s) => (o[r] = t[s], o), {});
  }
  get positionTrackName() {
    return this._positionTrackName === void 0 && (this._positionTrackName = this.trackNames.find((t) => t.endsWith(".position")) ?? null), this._positionTrackName;
  }
  get positionkeyframeIndex() {
    const t = this.positionTrackName;
    return t ? this.keyframeIndexs[t] : null;
  }
  get positionKeyframe() {
    const t = this.positionTrackName;
    if (t) {
      const { index: o, value: r } = this.keyframes[t], s = r ? new Vector3(...r) : null;
      return { index: o, value: s };
    }
    return null;
  }
  get quaternionTrackName() {
    return this._quaternionTrackName === void 0 && (this._quaternionTrackName = this.trackNames.find((t) => t.endsWith(".quaternion")) ?? null), this._quaternionTrackName;
  }
  get quaternionKeyframeIndex() {
    const t = this.quaternionTrackName;
    return t ? this.keyframeIndexs[t] : null;
  }
  get quaternionKeyframe() {
    const t = this.quaternionTrackName;
    if (t) {
      const { index: o, value: r } = this.keyframes[t], s = r ? new Quaternion(...r) : null;
      return { index: o, value: s };
    }
    return null;
  }
  get rotationTrackName() {
    return this._rotationTrackName === void 0 && (this._rotationTrackName = this.trackNames.find((t) => t.endsWith(".rotation")) ?? null), this._rotationTrackName;
  }
  get rotationkeyframeIndex() {
    const t = this.rotationTrackName;
    return t ? this.keyframeIndexs[t] : null;
  }
  get rotationKeyframe() {
    const t = this.rotationTrackName;
    if (t) {
      const { index: o, value: r } = this.keyframes[t], s = r ? new Euler(...r) : null;
      return { index: o, value: s };
    }
    return null;
  }
  get scaleTrackName() {
    return this._scaleTrackName === void 0 && (this._scaleTrackName = this.trackNames.find((t) => t.endsWith(".scale")) ?? null), this._scaleTrackName;
  }
  get scaleKeyframeIndex() {
    const t = this.scaleTrackName;
    return t ? this.keyframeIndexs[t] : null;
  }
  get scaleKeyframe() {
    const t = this.scaleTrackName;
    if (t) {
      const { index: o, value: r } = this.keyframes[t], s = r ? new Vector3(...r) : null;
      return { index: o, value: s };
    }
    return null;
  }
}
class qe extends Ge {
  /**
   * 前进
   * @param scale - 比例因子
   */
  forward(e) {
    const t = this.action;
    e = Math.abs(e ?? t.timeScale), t.timeScale = e;
  }
  /**
   * 后退
   * @param scale - 比例因子
   */
  backward(e) {
    const t = this.action;
    e = Math.abs(e ?? t.timeScale), t.timeScale = -e;
  }
}
function $e(n) {
  const e = new qe(n);
  return new Proxy(e, {
    get: function(t, o, r) {
      return o in t.action ? t.action[o] : t[o];
    },
    set: function(t, o, r, s) {
      return o in t.action ? t.action[o] = r : t[o] = r, !0;
    },
    deleteProperty: function(t, o) {
      return o in t.action ? Reflect.deleteProperty(t.action, o) : Reflect.deleteProperty(t, o);
    },
    has: function(t, o) {
      return o in t.action || o in t;
    },
    ownKeys: function(t) {
      return Reflect.ownKeys(t.action).concat(Reflect.ownKeys(t));
    }
  });
}
class Ee {
  constructor(e) {
    E(this, "_action");
    this.setAction(e);
  }
  get action() {
    return this._action;
  }
  set action(e) {
    this.setAction(e);
  }
  setAction(e) {
    this._action = e && $e(e);
  }
  get play() {
    const e = this.action;
    return Boolean(e && e._mixer._isActiveAction(e) && !e.paused);
  }
  set play(e) {
    const t = this.action;
    t && (t.paused = !e, e && t.time === 0 && t.play());
  }
  stop() {
    var e;
    (e = this.action) == null || e.stop();
  }
}
function jt(n) {
  var e;
  (e = n.reset) == null || e.call(n, !0);
}
class ae extends Ee {
  constructor(t, o = []) {
    super(t);
    E(this, "_updateGUI", null);
    this.guis = o;
  }
  /**
   * gui 的更新回调
   * @defaultValue updateGUI_default
   */
  get updateGUI() {
    return this._updateGUI ?? this.constructor.updateGUI ?? jt;
  }
  set updateGUI(t) {
    this._updateGUI = t;
  }
  get action() {
    return this._action;
  }
  set action(t) {
    this.setAction(t), this.updateAllGUI();
  }
  updateAllGUI() {
    for (const t of this.guis)
      this.updateGUI(t);
  }
}
/**
 * 全局的 gui 更新回调
 * @param gui 
 */
E(ae, "updateGUI", jt);
function cn(n) {
  const e = new ae(n);
  return new Proxy(e, {
    get: function(t, o, r) {
      var s;
      return o in t ? t[o] : (s = t.action) == null ? void 0 : s[o];
    },
    set: function(t, o, r, s) {
      if (o in t)
        t[o] = r;
      else if (t.action)
        t.action[o] = r;
      else
        return !1;
      return !0;
    },
    deleteProperty: function(t, o) {
      return o in t ? Reflect.deleteProperty(t, o) : t.action ? Reflect.deleteProperty(t.action, o) : !1;
    },
    has: function(t, o) {
      return o in t || !!t.action && o in t.action;
    },
    ownKeys: function(t) {
      return t.action ? Reflect.ownKeys(t).concat(Reflect.ownKeys(t.action)) : Reflect.ownKeys(t);
    }
  });
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var lib = {};

var DeluxeSignal$1 = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.push(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.push(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
}
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

var _tslib = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get __assign () { return __assign; },
  __asyncDelegator: __asyncDelegator,
  __asyncGenerator: __asyncGenerator,
  __asyncValues: __asyncValues,
  __await: __await,
  __awaiter: __awaiter,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldIn: __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __createBinding: __createBinding,
  __decorate: __decorate,
  __esDecorate: __esDecorate,
  __exportStar: __exportStar,
  __extends: __extends$1,
  __generator: __generator,
  __importDefault: __importDefault,
  __importStar: __importStar,
  __makeTemplateObject: __makeTemplateObject,
  __metadata: __metadata,
  __param: __param,
  __propKey: __propKey,
  __read: __read,
  __rest: __rest,
  __runInitializers: __runInitializers,
  __setFunctionName: __setFunctionName,
  __spread: __spread,
  __spreadArray: __spreadArray,
  __spreadArrays: __spreadArrays,
  __values: __values
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(_tslib);

var PrioritySignal$1 = {};

var Signal$2 = {};

var OnceSignal$1 = {};

var SlotList$1 = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(SlotList$1, "__esModule", { value: true });
/**
 * The SlotList class represents an immutable list of Slot objects.
 *
 * @author Joa Ebert
 * @author Robert Penner
 */
var SlotList = /** @class */ (function () {
    /**
     * Creates and returns a new SlotList object.
     *
     * <p>A user never has to create a SlotList manually.
     * Use the <code>NIL</code> element to represent an empty list.
     * <code>NIL.prepend(value)</code> would create a list containing <code>value</code></p>.
     *
     * @param head The first slot in the list.
     * @param tail A list containing all slots except head.
     *
     * @throws ArgumentError <code>ArgumentError</code>: Parameters head and tail are null. Use the NIL element instead.
     * @throws ArgumentError <code>ArgumentError</code>: Parameter head cannot be null.
     */
    function SlotList(head, tail) {
        if (tail === void 0) { tail = null; }
        this.nonEmpty = false;
        if (!head && !tail) {
            if (SlotList.NIL) {
                throw new Error("Parameters head and tail are null. Use the NIL element instead.");
            }
            // this is the NIL element as per definition
            this.nonEmpty = false;
        }
        else if (!head) {
            throw new Error("Parameter head cannot be null.");
        }
        else {
            this.head = head;
            this.tail = tail || SlotList.NIL;
            this.nonEmpty = true;
        }
    }
    Object.defineProperty(SlotList.prototype, "length", {
        /**
         * The number of slots in the list.
         */
        get: function () {
            if (!this.nonEmpty) {
                return 0;
            }
            if (this.tail === SlotList.NIL) {
                return 1;
            }
            // We could cache the length, but it would make methods like filterNot unnecessarily complicated.
            // Instead we assume that O(n) is okay since the length property is used in rare cases.
            // We could also cache the length lazy, but that is a waste of another 8b per list node (at least).
            var result = 0;
            var p = this;
            while (p.nonEmpty) {
                ++result;
                p = p.tail;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Prepends a slot to this list.
     * @param    slot The item to be prepended.
     * @return    A list consisting of slot followed by all elements of this list.
     *
     * @throws ArgumentError <code>ArgumentError</code>: Parameter head cannot be null.
     */
    SlotList.prototype.prepend = function (slot) {
        return new SlotList(slot, this);
    };
    /**
     * Appends a slot to this list.
     * Note: appending is O(n). Where possible, prepend which is O(1).
     * In some cases, many list items must be cloned to
     * avoid changing existing lists.
     * @param    slot The item to be appended.
     * @return    A list consisting of all elements of this list followed by slot.
     */
    SlotList.prototype.append = function (slot) {
        if (!slot) {
            return this;
        }
        if (!this.nonEmpty) {
            return new SlotList(slot);
        }
        // Special case: just one slot currently in the list.
        if (this.tail === SlotList.NIL) {
            return new SlotList(slot).prepend(this.head);
        }
        // The list already has two or more slots.
        // We have to build a new list with cloned items because they are immutable.
        var wholeClone = new SlotList(this.head);
        var subClone = wholeClone;
        var current = this.tail;
        while (current.nonEmpty) {
            subClone = subClone.tail = new SlotList(current.head);
            current = current.tail;
        }
        // Append the new slot last.
        subClone.tail = new SlotList(slot);
        return wholeClone;
    };
    /**
     * Insert a slot into the list in a position according to its priority.
     * The higher the priority, the closer the item will be inserted to the list head.
     * @params slot The item to be inserted.
     *
     * @throws ArgumentError <code>ArgumentError</code>: Parameters head and tail are null. Use the NIL element instead.
     * @throws ArgumentError <code>ArgumentError</code>: Parameter head cannot be null.
     */
    SlotList.prototype.insertWithPriority = function (slot) {
        if (!this.nonEmpty) {
            return new SlotList(slot);
        }
        var priority = slot.priority;
        // Special case: new slot has the highest priority.
        if (priority > this.head.priority) {
            return this.prepend(slot);
        }
        var wholeClone = new SlotList(this.head);
        var subClone = wholeClone;
        var current = this.tail;
        // Find a slot with lower priority and go in front of it.
        while (current.nonEmpty) {
            if (priority > current.head.priority) {
                subClone.tail = current.prepend(slot);
                return wholeClone;
            }
            subClone = subClone.tail = new SlotList(current.head);
            current = current.tail;
        }
        // Slot has lowest priority.
        subClone.tail = new SlotList(slot);
        return wholeClone;
    };
    /**
     * Returns the slots in this list that do not contain the supplied listener.
     * Note: assumes the listener is not repeated within the list.
     * @param    listener The function to remove.
     * @return A list consisting of all elements of this list that do not have listener.
     */
    SlotList.prototype.filterNot = function (listener) {
        if (!this.nonEmpty || listener == null) {
            return this;
        }
        if (listener === this.head.listener) {
            return this.tail;
        }
        // The first item wasn't a match so the filtered list will contain it.
        var wholeClone = new SlotList(this.head);
        var subClone = wholeClone;
        var current = this.tail;
        while (current.nonEmpty) {
            if (current.head.listener === listener) {
                // Splice out the current head.
                subClone.tail = current.tail;
                return wholeClone;
            }
            subClone = subClone.tail = new SlotList(current.head);
            current = current.tail;
        }
        // The listener was not found so this list is unchanged.
        return this;
    };
    /**
     * Determines whether the supplied listener Function is contained within this list
     */
    SlotList.prototype.contains = function (listener) {
        if (!this.nonEmpty) {
            return false;
        }
        var p = this;
        while (p.nonEmpty) {
            if (p.head.listener === listener) {
                return true;
            }
            p = p.tail;
        }
        return false;
    };
    /**
     * Retrieves the ISlot associated with a supplied listener within the SlotList.
     * @param   listener The Function being searched for
     * @return  The ISlot in this list associated with the listener parameter through the ISlot.listener property.
     *          Returns null if no such ISlot instance exists or the list is empty.
     */
    SlotList.prototype.find = function (listener) {
        if (!this.nonEmpty) {
            return null;
        }
        var p = this;
        while (p.nonEmpty) {
            if (p.head.listener === listener) {
                return p.head;
            }
            p = p.tail;
        }
        return null;
    };
    SlotList.prototype.toString = function () {
        var buffer = "";
        var p = this;
        while (p.nonEmpty) {
            buffer += p.head + " -> ";
            p = p.tail;
        }
        buffer += "NIL";
        return "[List " + buffer + "]";
    };
    /**
     * Represents an empty list. Used as the list terminator.
     */
    SlotList.NIL = new SlotList(null, null);
    return SlotList;
}());
SlotList$1.SlotList = SlotList;

var Slot$1 = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(Slot$1, "__esModule", { value: true });
/**
 * The Slot class represents a signal slot.
 *
 * @author Robert Penner
 * @author Joa Ebert
 */
var Slot = /** @class */ (function () {
    /**
     * Creates and returns a new Slot object.
     *
     * @param listener The listener associated with the slot.
     * @param signal The signal associated with the slot.
     * @param once Whether or not the listener should be executed only once.
     * @param priority The priority of the slot.
     *
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     * @throws Error <code>Error</code>: Internal signal reference has not been set yet.
     */
    function Slot(listener, signal, once, priority) {
        if (once === void 0) { once = false; }
        if (priority === void 0) { priority = 0; }
        this._enabled = true;
        this._once = false;
        this._priority = 0;
        this._listener = listener;
        this._once = once;
        this._signal = signal;
        this._priority = priority;
        this.verifyListener(listener);
    }
    /**
     * @inheritDoc
     */
    Slot.prototype.execute0 = function () {
        if (!this._enabled) {
            return;
        }
        if (this._once) {
            this.remove();
        }
        if (this._params && this._params.length) {
            this._listener.apply(null, this._params);
            return;
        }
        this._listener();
    };
    /**
     * @inheritDoc
     */
    Slot.prototype.execute1 = function (value) {
        if (!this._enabled) {
            return;
        }
        if (this._once) {
            this.remove();
        }
        if (this._params && this._params.length) {
            this._listener.apply(null, [value].concat(this._params));
            return;
        }
        this._listener(value);
    };
    /**
     * @inheritDoc
     */
    Slot.prototype.execute = function (valueObjects) {
        if (!this._enabled) {
            return;
        }
        if (this._once) {
            this.remove();
        }
        // If we have parameters, add them to the valueObject
        // Note: This could be expensive if we're after the fastest dispatch possible.
        if (this._params && this._params.length) {
            valueObjects = valueObjects.concat(this._params);
        }
        // NOTE: simple ifs are faster than switch: http://jacksondunstan.com/articles/1007
        var numValueObjects = valueObjects.length;
        if (numValueObjects === 0) {
            this._listener();
        }
        else if (numValueObjects === 1) {
            this._listener(valueObjects[0]);
        }
        else if (numValueObjects === 2) {
            this._listener(valueObjects[0], valueObjects[1]);
        }
        else if (numValueObjects === 3) {
            this._listener(valueObjects[0], valueObjects[1], valueObjects[2]);
        }
        else {
            this._listener.apply(null, valueObjects);
        }
    };
    Object.defineProperty(Slot.prototype, "listener", {
        /**
         * @inheritDoc
         * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>. Did you want to set enabled to false instead?
         * @throws Error <code>Error</code>: Internal signal reference has not been set yet.
         */
        get: function () {
            return this._listener;
        },
        set: function (value) {
            if (null == value) {
                throw new Error("Given listener is null.\nDid you want to set enabled to false instead?");
            }
            this.verifyListener(value);
            this._listener = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slot.prototype, "once", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._once;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slot.prototype, "priority", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._priority;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and returns the string representation of the current object.
     *
     * @return The string representation of the current object.
     */
    Slot.prototype.toString = function () {
        return ("[Slot listener: " +
            this._listener +
            ", once: " +
            this._once +
            ", priority: " +
            this._priority +
            ", enabled: " +
            this._enabled +
            "]");
    };
    Object.defineProperty(Slot.prototype, "enabled", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._enabled;
        },
        set: function (value) {
            this._enabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slot.prototype, "params", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._params;
        },
        set: function (value) {
            this._params = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    Slot.prototype.remove = function () {
        this._signal.remove(this._listener);
    };
    Slot.prototype.verifyListener = function (listener) {
        if (null == listener) {
            throw new Error("Given listener is null.");
        }
        if (null == this._signal) {
            throw new Error("Internal signal reference has not been set yet.");
        }
    };
    return Slot;
}());
Slot$1.Slot = Slot;

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(OnceSignal$1, "__esModule", { value: true });
var SlotList_1$1 = SlotList$1;
var Slot_1$3 = Slot$1;
/**
 * Allows the valueClasses to be set in MXML, e.g.
 * <signals:Signal id="nameChanged">{[String, uint]}</signals:Signal>
 */
/*[DefaultProperty("valueClasses")]*/
/**
 * Signal dispatches events to multiple listeners.
 * It is inspired by C# events and delegates, and by
 * <a target="_top" href="http://en.wikipedia.org/wiki/Signals_and_slots">signals and slots</a>
 * in Qt.
 * A Signal adds event dispatching functionality through composition and interfaces,
 * rather than inheriting from a dispatcher.
 * <br/><br/>
 * Project home: <a target="_top" href="http://github.com/robertpenner/as3-signals/">http://github.com/robertpenner/as3-signals/</a>
 */
var OnceSignal = /** @class */ (function () {
    /**
     * Creates a Signal instance to dispatch value objects.
     * @param    valueClasses Any number of class references that enable type checks in dispatch().
     * For example, new Signal(String, uint)
     * would allow: signal.dispatch("the Answer", 42)
     * but not: signal.dispatch(true, 42.5)
     * nor: signal.dispatch()
     *
     * NOTE: In AS3, subclasses cannot call super.apply(null, valueClasses),
     * but this constructor has logic to support super(valueClasses).
     */
    function OnceSignal() {
        var valueClasses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueClasses[_i] = arguments[_i];
        }
        this.slots = SlotList_1$1.SlotList.NIL;
        // Cannot use super.apply(null, valueClasses), so allow the subclass to call super(valueClasses).
        this.valueClasses = valueClasses.length === 1 && valueClasses[0] instanceof Array ? valueClasses[0] : valueClasses;
    }
    Object.defineProperty(OnceSignal.prototype, "valueClasses", {
        /**
         * @inheritDoc
         * @throws ArgumentError <code>ArgumentError</code>: Invalid valueClasses argument: item at index should be a Class but was not.
         */
        /*[ArrayElementType("Class")]*/
        get: function () {
            return this._valueClasses;
        },
        set: function (value) {
            // Clone so the Array cannot be affected from outside.
            this._valueClasses = value ? value.slice() : [];
            for (var i = this._valueClasses.length; i--;) {
                if (!(this._valueClasses[i] instanceof Object)) {
                    throw new Error("Invalid valueClasses argument: " +
                        "item at index " +
                        i +
                        " should be a Class but was:<" +
                        this._valueClasses[i] +
                        ">." +
                        this._valueClasses[i]); // @CHANGED - temp replacement for getQualifiedClassByName()
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OnceSignal.prototype, "numListeners", {
        /** @inheritDoc */
        get: function () {
            return this.slots.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot addOnce() then add() the same listener without removing the relationship first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    OnceSignal.prototype.addOnce = function (listener) {
        return this.registerListener(listener, true);
    };
    /** @inheritDoc */
    OnceSignal.prototype.remove = function (listener) {
        var slot = this.slots.find(listener);
        if (!slot) {
            return null;
        }
        this.slots = this.slots.filterNot(listener);
        return slot;
    };
    /** @inheritDoc */
    OnceSignal.prototype.removeAll = function () {
        this.slots = SlotList_1$1.SlotList.NIL;
    };
    /**
     * @inheritDoc
     * @throws ArgumentError <code>ArgumentError</code>: Incorrect number of arguments.
     * @throws ArgumentError <code>ArgumentError</code>: Value object is not an instance of the appropriate valueClasses Class.
     */
    OnceSignal.prototype.dispatch = function () {
        var valueObjects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueObjects[_i] = arguments[_i];
        }
        // If valueClasses is empty, value objects are not type-checked.
        var numValueClasses = this._valueClasses.length;
        var numValueObjects = valueObjects.length;
        // Cannot dispatch fewer objects than declared classes.
        if (numValueObjects < numValueClasses) {
            throw new Error("Incorrect number of arguments. " + "Expected at least " + numValueClasses + " but received " + numValueObjects + ".");
        }
        // Cannot dispatch differently typed objects than declared classes.
        for (var i = 0; i < numValueClasses; i++) {
            // Optimized for the optimistic case that values are correct.
            if (valueObjects[i] === null ||
                valueObjects[i] instanceof this._valueClasses[i] ||
                valueObjects[i].constructor === this._valueClasses[i]) {
                continue;
            }
            throw new Error("Value object <" + valueObjects[i] + "> is not an instance of <" + this._valueClasses[i] + ">.");
        }
        // Broadcast to listeners.
        var slotsToProcess = this.slots;
        if (slotsToProcess.nonEmpty) {
            while (slotsToProcess.nonEmpty) {
                slotsToProcess.head.execute(valueObjects);
                slotsToProcess = slotsToProcess.tail;
            }
        }
    };
    OnceSignal.prototype.registerListener = function (listener, once) {
        if (once === void 0) { once = false; }
        if (this.registrationPossible(listener, once)) {
            var newSlot = new Slot_1$3.Slot(listener, this, once);
            this.slots = this.slots.prepend(newSlot);
            return newSlot;
        }
        return this.slots.find(listener);
    };
    OnceSignal.prototype.registrationPossible = function (listener, once) {
        if (!this.slots.nonEmpty) {
            return true;
        }
        var existingSlot = this.slots.find(listener);
        if (!existingSlot) {
            return true;
        }
        if (existingSlot.once !== once) {
            // If the listener was previously added, definitely don't add it again.
            // But throw an exception if their once values differ.
            throw new Error("You cannot addOnce() then add() the same listener without removing the relationship first.");
        }
        return false; // Listener was already registered.
    };
    return OnceSignal;
}());
OnceSignal$1.OnceSignal = OnceSignal;

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(Signal$2, "__esModule", { value: true });
var tslib_1$3 = require$$0;
var OnceSignal_1$2 = OnceSignal$1;
/**
 * Allows the valueClasses to be set in MXML, e.g.
 * <signals:Signal id="nameChanged">{[String, uint]}</signals:Signal>
 */
/*[DefaultProperty("valueClasses")]*/
/**
 * Signal dispatches events to multiple listeners.
 * It is inspired by C# events and delegates, and by
 * <a target="_top" href="http://en.wikipedia.org/wiki/Signals_and_slots">signals and slots</a>
 * in Qt.
 * A Signal adds event dispatching functionality through composition and interfaces,
 * rather than inheriting from a dispatcher.
 * <br/><br/>
 * Project home: <a target="_top" href="http://github.com/robertpenner/as3-signals/">http://github.com/robertpenner/as3-signals/</a>
 */
var Signal$1 = /** @class */ (function (_super) {
    tslib_1$3.__extends(Signal, _super);
    function Signal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot addOnce() then add() the same listener without removing the relationship first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    Signal.prototype.add = function (listener) {
        return this.registerListener(listener);
    };
    return Signal;
}(OnceSignal_1$2.OnceSignal));
Signal$2.Signal = Signal$1;

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(PrioritySignal$1, "__esModule", { value: true });
var tslib_1$2 = require$$0;
var Signal_1$1 = Signal$2;
var Slot_1$2 = Slot$1;
var PrioritySignal = /** @class */ (function (_super) {
    tslib_1$2.__extends(PrioritySignal, _super);
    function PrioritySignal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot addOnce() then add() the same listener without removing the relationship first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    PrioritySignal.prototype.addWithPriority = function (listener, priority) {
        if (priority === void 0) { priority = 0; }
        return this.registerListenerWithPriority(listener, false, priority);
    };
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot addOnce() then add() the same listener without removing the relationship first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    PrioritySignal.prototype.addOnceWithPriority = function (listener, priority) {
        if (priority === void 0) { priority = 0; }
        return this.registerListenerWithPriority(listener, true, priority);
    };
    /*override*/
    PrioritySignal.prototype.registerListener = function (listener, once) {
        if (once === void 0) { once = false; }
        return this.registerListenerWithPriority(listener, once);
    };
    PrioritySignal.prototype.registerListenerWithPriority = function (listener, once, priority) {
        if (priority === void 0) { priority = 0; }
        if (this.registrationPossible(listener, once)) {
            var slot = new Slot_1$2.Slot(listener, this, once, priority);
            this.slots = this.slots.insertWithPriority(slot);
            return slot;
        }
        return this.slots.find(listener);
    };
    return PrioritySignal;
}(Signal_1$1.Signal));
PrioritySignal$1.PrioritySignal = PrioritySignal;

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(DeluxeSignal$1, "__esModule", { value: true });
var tslib_1$1 = require$$0;
var PrioritySignal_1$1 = PrioritySignal$1;
/**
 * Allows the valueClasses to be set in MXML, e.g.
 * <signals:Signal id="nameChanged">{[String, uint]}</signals:Signal>
 */
/*[DefaultProperty("valueClasses")]*/
/**
 * Signal dispatches events to multiple listeners.
 * It is inspired by C# events and delegates, and by
 * <a target="_top" href="http://en.wikipedia.org/wiki/Signals_and_slots">signals and slots</a>
 * in Qt.
 * A Signal adds event dispatching functionality through composition and interfaces,
 * rather than inheriting from a dispatcher.
 * <br/><br/>
 * Project home: <a target="_top" href="http://github.com/robertpenner/as3-signals/">http://github.com/robertpenner/as3-signals/</a>
 */
var DeluxeSignal = /** @class */ (function (_super) {
    tslib_1$1.__extends(DeluxeSignal, _super);
    /**
     * Creates a DeluxeSignal instance to dispatch events on behalf of a target object.
     * @param    target The object the signal is dispatching events on behalf of.
     * @param    valueClasses Any number of class references that enable type checks in dispatch().
     * For example, new DeluxeSignal(this, String, uint)
     * would allow: signal.dispatch("the Answer", 42)
     * but not: signal.dispatch(true, 42.5)
     * nor: signal.dispatch()
     *
     * NOTE: Subclasses cannot call super.apply(null, valueClasses),
     * but this constructor has logic to support super(valueClasses).
     */
    function DeluxeSignal(target) {
        if (target === void 0) { target = null; }
        var valueClasses = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            valueClasses[_i - 1] = arguments[_i];
        }
        var _this = this;
        // Cannot use super.apply(null, valueClasses), so allow the subclass to call super(valueClasses).
        valueClasses = valueClasses.length === 1 && valueClasses[0] instanceof Array ? valueClasses[0] : valueClasses;
        /* istanbul ignore next */ _this = _super.call(this, valueClasses) || this;
        // @CHANGED - this was the first call in the constructor
        // Typescript does not allow "this" to be called before super
        _this._target = target;
        return _this;
    }
    Object.defineProperty(DeluxeSignal.prototype, "target", {
        /** @inheritDoc */
        get: function () {
            return this._target;
        },
        set: function (value) {
            if (value === this._target) {
                return;
            }
            this.removeAll();
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     * @throws ArgumentError <code>ArgumentError</code>: Incorrect number of arguments.
     * @throws ArgumentError <code>ArgumentError</code>: Value object is not an instance of the appropriate valueClasses Class.
     */
    /*override*/
    DeluxeSignal.prototype.dispatch = function () {
        var valueObjects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueObjects[_i] = arguments[_i];
        }
        // Validate value objects against pre-defined value classes.
        var numValueClasses = this._valueClasses.length;
        var numValueObjects = valueObjects.length;
        if (numValueObjects < numValueClasses) {
            throw new Error("Incorrect number of arguments. " + "Expected at least " + numValueClasses + " but received " + numValueObjects + ".");
        }
        // Cannot dispatch differently typed objects than declared classes.
        for (var i = 0; i < numValueClasses; i++) {
            // Optimized for the optimistic case that values are correct.
            if (valueObjects[i] === null || valueObjects[i].constructor === this._valueClasses[i]) {
                continue;
            }
            throw new Error("Value object <" + valueObjects[i] + "> is not an instance of <" + this._valueClasses[i] + ">.");
        }
        // Extract and clone event object if necessary.
        var event = valueObjects[0];
        if (event) {
            if (event.target) {
                event = event.clone();
                valueObjects[0] = event;
            }
            event.target = this.target;
            event.currentTarget = this.target;
            event.signal = this;
        }
        // Broadcast to listeners.
        var slotsToProcess = this.slots;
        while (slotsToProcess.nonEmpty) {
            slotsToProcess.head.execute(valueObjects);
            slotsToProcess = slotsToProcess.tail;
        }
        // Bubble the event as far as possible.
        if (!event || !event.bubbles) {
            return;
        }
        var currentTarget = this.target;
        while (currentTarget && currentTarget.hasOwnProperty("parent")) {
            currentTarget = currentTarget.parent;
            /* istanbul ignore else */
            if (currentTarget.onEventBubbled !== null) {
                event.currentTarget = currentTarget;
                // onEventBubbled() can stop the bubbling by returning false.
                if (!currentTarget.onEventBubbled(event)) {
                    break;
                }
            }
        }
    };
    return DeluxeSignal;
}(PrioritySignal_1$1.PrioritySignal));
DeluxeSignal$1.DeluxeSignal = DeluxeSignal;

var GenericEvent$1 = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(GenericEvent$1, "__esModule", { value: true });
/**
 *
 * @see org.osflash.signals.events.IEvent
 * Documentation for the event interface being maintained in IEvent to avoid duplication for now.
 */
var GenericEvent = /** @class */ (function () {
    function GenericEvent(bubbles) {
        if (bubbles === void 0) { bubbles = false; }
        this._bubbles = bubbles;
    }
    Object.defineProperty(GenericEvent.prototype, "signal", {
        /** @inheritDoc */
        get: function () {
            return this._signal;
        },
        set: function (value) {
            this._signal = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericEvent.prototype, "target", {
        /** @inheritDoc */
        get: function () {
            return this._target;
        },
        set: function (value) {
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericEvent.prototype, "currentTarget", {
        /** @inheritDoc */
        get: function () {
            return this._currentTarget;
        },
        set: function (value) {
            this._currentTarget = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericEvent.prototype, "bubbles", {
        /** @inheritDoc */
        get: function () {
            return this._bubbles;
        },
        set: function (value) {
            this._bubbles = value;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    GenericEvent.prototype.clone = function () {
        return new GenericEvent(this._bubbles);
    };
    return GenericEvent;
}());
GenericEvent$1.GenericEvent = GenericEvent;

var IOnceSignal = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(IOnceSignal, "__esModule", { value: true });
/**
 *
 */
IOnceSignal.IOnceSignal = Symbol("IOnceSignal");

var IPrioritySignal = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(IPrioritySignal, "__esModule", { value: true });
/**
 *
 */
IPrioritySignal.IPrioritySignal = Symbol("IPrioritySignal");

var ISignal = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(ISignal, "__esModule", { value: true });
/**
 *
 */
ISignal.ISignal = Symbol("ISignal");

var ISlot = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(ISlot, "__esModule", { value: true });
/**
 * The ISlot interface defines the basic properties of a
 * listener associated with a Signal.
 *
 * @author Joa Ebert
 * @author Robert Penner
 */
ISlot.ISlot = Symbol("ISlot");

var MonoSignal$1 = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(MonoSignal$1, "__esModule", { value: true });
var Slot_1$1 = Slot$1;
/**
 * Allows the valueClasses to be set in MXML, e.g.
 * <signals:Signal id="nameChanged">{[String, uint]}</signals:Signal>
 */
/*[DefaultProperty("valueClasses")]*/
/**
 * A MonoSignal can have only one listener.
 */
var MonoSignal = /** @class */ (function () {
    /**
     * Creates a MonoSignal instance to dispatch value objects.
     * @param    valueClasses Any number of class references that enable type checks in dispatch().
     * For example, new Signal(String, uint)
     * would allow: signal.dispatch("the Answer", 42)
     * but not: signal.dispatch(true, 42.5)
     * nor: signal.dispatch()
     *
     * NOTE: Subclasses cannot call super.apply(null, valueClasses),
     * but this constructor has logic to support super(valueClasses).
     */
    function MonoSignal() {
        var valueClasses = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueClasses[_i] = arguments[_i];
        }
        // Cannot use super.apply(null, valueClasses), so allow the subclass to call super(valueClasses).
        this.valueClasses = valueClasses.length === 1 && valueClasses[0] instanceof Array ? valueClasses[0] : valueClasses;
    }
    Object.defineProperty(MonoSignal.prototype, "valueClasses", {
        /**
         * @inheritDoc
         * @throws ArgumentError <code>ArgumentError</code>: Invalid valueClasses argument: item at index should be a Class but was not.
         */
        /*[ArrayElementType("Class")]*/
        get: function () {
            return this._valueClasses;
        },
        set: function (value) {
            // Clone so the Array cannot be affected from outside.
            this._valueClasses = value ? value.slice() : [];
            for (var i = this._valueClasses.length; i--;) {
                if (typeof this._valueClasses[i] !== "function") {
                    throw new Error("Invalid valueClasses argument: " +
                        "item at index " +
                        i +
                        " should be a Class but was:<" +
                        this._valueClasses[i] +
                        "'>." +
                        this._valueClasses[i]); // @CHANGED - temp replacement for getQualifiedClassByName()
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MonoSignal.prototype, "numListeners", {
        /** @inheritDoc */
        get: function () {
            return this.slot ? 1 : 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot add or addOnce with a listener already added, remove the current listener first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    MonoSignal.prototype.add = function (listener) {
        return this.registerListener(listener);
    };
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot add or addOnce with a listener already added, remove the current listener first.
     * @throws ArgumentError <code>ArgumentError</code>: Given listener is <code>null</code>.
     */
    MonoSignal.prototype.addOnce = function (listener) {
        return this.registerListener(listener, true);
    };
    /** @inheritDoc */
    MonoSignal.prototype.remove = function (listener) {
        if (this.slot && this.slot.listener === listener) {
            var theSlot = this.slot;
            this.slot = null;
            return theSlot;
        }
        return null;
    };
    /** @inheritDoc */
    MonoSignal.prototype.removeAll = function () {
        if (this.slot) {
            this.slot.remove();
        }
    };
    /**
     * @inheritDoc
     * @throws ArgumentError <code>ArgumentError</code>: Incorrect number of arguments.
     * @throws ArgumentError <code>ArgumentError</code>: Value object is not an instance of the appropriate valueClasses Class.
     */
    MonoSignal.prototype.dispatch = function () {
        var valueObjects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueObjects[_i] = arguments[_i];
        }
        // If valueClasses is empty, value objects are not type-checked.
        var numValueClasses = this._valueClasses.length;
        var numValueObjects = valueObjects.length;
        // Cannot dispatch fewer objects than declared classes.
        if (numValueObjects < numValueClasses) {
            throw new Error("Incorrect number of arguments. " + "Expected at least " + numValueClasses + " but received " + numValueObjects + ".");
        }
        // Cannot dispatch differently typed objects than declared classes.
        for (var i = 0; i < numValueClasses; i++) {
            // Optimized for the optimistic case that values are correct.
            if (valueObjects[i] === null ||
                valueObjects[i] instanceof this._valueClasses[i] ||
                valueObjects[i].constructor === this._valueClasses[i]) {
                continue;
            }
            throw new Error("Value object <" + valueObjects[i] + "> is not an instance of <" + this._valueClasses[i] + ">.");
        }
        // Broadcast to the one listener.
        if (this.slot) {
            this.slot.execute(valueObjects);
        }
    };
    MonoSignal.prototype.registerListener = function (listener, once) {
        if (once === void 0) { once = false; }
        if (this.slot) {
            // If the listener exits previously added, definitely don't add it.
            throw new Error("You cannot add or addOnce with a listener already added, remove the current listener first.");
        }
        return (this.slot = new Slot_1$1.Slot(listener, this, once));
    };
    return MonoSignal;
}());
MonoSignal$1.MonoSignal = MonoSignal;

var _Promise = {};

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(_Promise, "__esModule", { value: true });
var tslib_1 = require$$0;
var OnceSignal_1$1 = OnceSignal$1;
var Promise$1 = /** @class */ (function (_super) {
    tslib_1.__extends(Promise, _super);
    function Promise() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritDoc */
    /*override*/
    Promise.prototype.addOnce = function (listener) {
        var slot = _super.prototype.addOnce.call(this, listener);
        if (this.isDispatched) {
            slot.execute(this.valueObjects);
            slot.remove();
        }
        return slot;
    };
    /**
     * @inheritDoc
     * @throws flash.errors.IllegalOperationError <code>IllegalOperationError</code>: You cannot dispatch() a Promise more than once
     */
    /*override*/
    Promise.prototype.dispatch = function () {
        var valueObjects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            valueObjects[_i] = arguments[_i];
        }
        if (this.isDispatched) {
            throw new Error("You cannot dispatch() a Promise more than once");
        }
        else {
            this.isDispatched = true;
            this.valueObjects = valueObjects;
            _super.prototype.dispatch.apply(this, valueObjects);
        }
    };
    return Promise;
}(OnceSignal_1$1.OnceSignal));
_Promise.Promise = Promise$1;

/**
 * Copyright (c) 2017-present, RobotlegsJS. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(lib, "__esModule", { value: true });
var DeluxeSignal_1 = DeluxeSignal$1;
lib.DeluxeSignal = DeluxeSignal_1.DeluxeSignal;
var GenericEvent_1 = GenericEvent$1;
lib.GenericEvent = GenericEvent_1.GenericEvent;
var IOnceSignal_1 = IOnceSignal;
lib.IOnceSignal = IOnceSignal_1.IOnceSignal;
var IPrioritySignal_1 = IPrioritySignal;
lib.IPrioritySignal = IPrioritySignal_1.IPrioritySignal;
var ISignal_1 = ISignal;
lib.ISignal = ISignal_1.ISignal;
var ISlot_1 = ISlot;
lib.ISlot = ISlot_1.ISlot;
var MonoSignal_1 = MonoSignal$1;
lib.MonoSignal = MonoSignal_1.MonoSignal;
var OnceSignal_1 = OnceSignal$1;
lib.OnceSignal = OnceSignal_1.OnceSignal;
var PrioritySignal_1 = PrioritySignal$1;
lib.PrioritySignal = PrioritySignal_1.PrioritySignal;
var Promise_1 = _Promise;
lib.Promise = Promise_1.Promise;
var Signal_1 = Signal$2;
var Signal = lib.Signal = Signal_1.Signal;
var Slot_1 = Slot$1;
lib.Slot = Slot_1.Slot;
var SlotList_1 = SlotList$1;
lib.SlotList = SlotList_1.SlotList;

const Signals = () => ({
    // window
    windowResize: new Signal,
    cameraObjectChange: new Signal,
    // scene
    sceneChanged: new Signal,
    backgroundChanged: new Signal,
    beforeRender: new Signal,
    sceneRendered: new Signal,
    loadRendered: new Signal,
    // tween
    tweenUpdate: new Signal,
    // native event
    hover: new Signal,
    click: new Signal,
    dblClick: new Signal,
    rightClick: new Signal,
    // mouse native event
    mouseDown: new Signal,
    mouseMove: new Signal,
    mouseUp: new Signal,
    mouseWheel: new Signal,
    // key native event
    keyDown: new Signal,
    keyUp: new Signal,
    // model event
    modelHover: new Signal,
    modelUnHover: new Signal,
    modelClick: new Signal,
    modelDblClick: new Signal,
    modelRightClick: new Signal,
    // poi event
    poiHover: new Signal,
    poiUnHover: new Signal,
    poiClick: new Signal,
    poiDblClick: new Signal,
    poiRightClick: new Signal,
    // selectPosition
    selectPosition: new Signal,
    // sceneClick
    sceneClick: new Signal,
    // object opt
    objectAdded: new Signal,
    objectRemoved: new Signal,
    objectChanged: new Signal,
    // geometry 
    geometryChanged: new Signal,
    // material
    materialAdded: new Signal,
    materialChanged: new Signal,
    materialRemoved: new Signal,
    // camera
    cameraChange: new Signal,
    // outline
    outlineChange: new Signal,
    // modelAnimation
    modelAnimation: new Signal,
    // sceneInfo
    getSceneInfo: new Signal,
});

const SCENE = new Scene();
SCENE.name = 'Scene';
class Scener {
    constructor(signals, viewportState) {
        this.signals = signals;
        this.viewportState = viewportState;
        this.scene = SCENE.clone();
        this.selectedObjects = {
            edge: [],
            stroke: [],
            opacity: [],
            highlight: [],
            emissive: [],
        };
        this.intersectsList = {
            meshOfModelList: [],
            poiIconList: [],
            otherObjList: [],
            getAll: function () {
                return [...this.meshOfModelList, ...this.poiIconList, ...this.otherObjList];
            },
        };
    }
    addObject(object, parent) {
        /**
         * 判断场景是否卸载
         */
        if (this.viewportState.isDisposed) {
            this.removeObject(object);
            warn('Scene is disposed');
            return;
        }
        if (parent) {
            parent.add(object);
        }
        else {
            this.scene.add(object);
        }
        this._triggerObjectAdded(object);
        this.signals.objectAdded.dispatch(object);
    }
    removeObject(object) {
        function disposeMaterial(material) {
            if (material.map)
                disposeTexture(material.map);
            material.dispose();
        }
        function disposeTexture(texture) {
            if (texture) {
                if (texture.isTexture) {
                    texture.dispose();
                }
                /**
                 * TEMP: 临时解决模型删除导致其他同类贴图丢失问题
                 */
                // if ( texture.image instanceof ImageBitmap ) {
                //   texture.image.close()
                // }
            }
        }
        object.traverse(child => {
            if (child.type === 'Mesh') {
                const mesh = child;
                mesh.geometry.dispose();
                materialHandle(mesh.material, disposeMaterial);
            }
            if (child instanceof PoiNode)
                child.element.remove();
            const { meshOfModelList, poiIconList, otherObjList, } = this.intersectsList;
            const modelIndex = meshOfModelList.findIndex(findItem => findItem.uuid === child.uuid);
            const poiIndex = poiIconList.findIndex(findItem => findItem.uuid === child.uuid);
            const otherIndex = otherObjList.findIndex(findItem => findItem.uuid === child.uuid);
            if (modelIndex > -1)
                this.intersectsList.meshOfModelList.splice(modelIndex, 1);
            if (poiIndex > -1)
                this.intersectsList.poiIconList.splice(poiIndex, 1);
            if (otherIndex > -1)
                this.intersectsList.otherObjList.splice(otherIndex, 1);
        });
        object.removeFromParent();
        this.signals.objectRemoved.dispatch(object);
    }
    openSceneFog(options = {}) {
        const { color = 0xcce0ff, near = 500, far = 50000, } = options;
        this.scene.fog = new Fog(color, near, far);
        this.signals.sceneChanged.dispatch();
    }
    closeSceneFog() {
        this.scene.fog = null;
        this.signals.sceneChanged.dispatch();
    }
    edgeShow(object, options) {
        const objects = [];
        const selectItem = (object) => {
            if (this.selectedObjects.edge.findIndex(item => item.uuid === object.uuid) !== -1)
                return;
            objects.push(object);
        };
        if (isArray(object))
            object.forEach(item => selectItem(item));
        else if (isObject(object))
            selectItem(object);
        this.selectedObjects.edge = [...this.selectedObjects.edge, ...objects];
        this.signals.outlineChange.dispatch({
            objects: this.selectedObjects.edge,
            options,
        });
        return Promise.resolve();
    }
    unEdgeShow(objects) {
        if (!objects)
            objects = [...this.selectedObjects.edge];
        const unSelectItem = (object) => {
            const index = this.selectedObjects.edge.findIndex(findItem => findItem.uuid === object.uuid);
            if (index === -1)
                return Promise.resolve();
            this.selectedObjects.edge.splice(index, 1);
            this.signals.outlineChange.dispatch({
                objects: this.selectedObjects.edge,
            });
            return Promise.resolve();
        };
        if (isArray(objects))
            return Promise.all(objects.map(object => unSelectItem(object)));
        else if (isObject(objects))
            return unSelectItem(objects);
        else
            return Promise.resolve();
    }
    strokeShow(object, options = {}) {
        const { isOpacityShow = true, color = 0x46ebf7, opacity = 0.2, edgeColor = 0x00eeff, edgeOpacity = 1, } = options;
        const selectItem = (object) => {
            if (this.selectedObjects.stroke.findIndex(item => item.uuid === object.uuid) !== -1)
                return Promise.resolve();
            if (object.userData.strokeGroup)
                return Promise.resolve();
            const group = new Group({ id: object.uuid, });
            object.traverse(child => {
                if (child instanceof Mesh) {
                    const edges = new EdgesGeometry(child.geometry, 89);
                    const line = new LineSegments(edges, new LineBasicMaterial({ color: edgeColor, transparent: true, opacity: edgeOpacity, }));
                    syncSpaceAttributeToObject(line, child);
                    object.attach(line);
                    group.add(line);
                }
            });
            object.userData.strokeGroup = group;
            this.addObject(group, object);
            this.selectedObjects.stroke.push(object);
            return Promise.resolve();
        };
        if (isOpacityShow)
            this.opacityShow(object, { color, opacity, });
        if (isArray(object))
            return Promise.all(object.map(item => selectItem(item)));
        else if (isObject(object))
            return selectItem(object);
        else
            return Promise.resolve();
    }
    unStrokeShow(objects) {
        if (!objects)
            objects = [...this.selectedObjects.stroke];
        const unSelectItem = (object) => {
            if (!object.userData.strokeGroup)
                return Promise.resolve();
            this.removeObject(object.userData.strokeGroup);
            Reflect.deleteProperty(object.userData, 'strokeGroup');
            const index = this.selectedObjects.stroke.findIndex(findItem => findItem.uuid === object.uuid);
            if (index === -1)
                return Promise.resolve();
            this.selectedObjects.stroke.splice(index, 1);
            this.signals.geometryChanged.dispatch();
            this.unOpacityShow(object);
            return Promise.resolve();
        };
        if (isArray(objects))
            return Promise.all(objects.map(item => unSelectItem(item)));
        else if (isObject(objects))
            return unSelectItem(objects);
        else
            return Promise.resolve();
    }
    opacityShow(object, options = {}) {
        const { color = '#fff', opacity = 0.8, } = options;
        function changeMaterialProp(material) {
            const opacityMaterial = cloneMaterials(material);
            opacityMaterial.map = null;
            opacityMaterial.transparent = opacity < 1;
            opacityMaterial.depthWrite = !opacityMaterial.transparent;
            opacityMaterial.color.set(color);
            opacityMaterial.opacity = opacity;
            return opacityMaterial;
        }
        const selectItem = (object) => {
            if (this.selectedObjects.opacity.findIndex(item => item.uuid === object.uuid) !== -1)
                return Promise.resolve();
            object.traverse(object => {
                if (object instanceof Mesh) {
                    if (object.userData.material)
                        return;
                    // 保存原来的材质
                    object.userData.material = object.material;
                    object.material = materialHandle(object.material, changeMaterialProp);
                }
            });
            this.signals.materialChanged.dispatch();
            this.selectedObjects.opacity.push(object);
            return Promise.resolve();
        };
        if (isArray(object))
            return Promise.all(object.map(item => selectItem(item)));
        else if (isObject(object))
            return selectItem(object);
        else
            return Promise.resolve();
    }
    unOpacityShow(objects) {
        if (!objects)
            objects = [...this.selectedObjects.opacity];
        const unSelectItem = (object) => {
            return new Promise(resolve => {
                const index = this.selectedObjects.opacity.findIndex(findItem => findItem.uuid === object.uuid);
                if (index === -1)
                    resolve();
                this.selectedObjects.opacity.splice(index, 1);
                object.traverse(object => {
                    if (object instanceof Mesh) {
                        if (!object.userData.material)
                            return;
                        disposeMaterials(object.material);
                        object.material = object.userData.material;
                        Reflect.deleteProperty(object.userData, 'material');
                    }
                });
                this.signals.materialChanged.dispatch();
                resolve();
            });
        };
        if (isArray(objects))
            return Promise.all(objects.map(object => unSelectItem(object)));
        else if (isObject(objects))
            return unSelectItem(objects);
        else
            return Promise.resolve();
    }
    highlightShow(object, options = {}) {
        const { color = 'red', opacity = 1, } = options;
        function changeMaterialProp(material) {
            if (material instanceof MeshStandardMaterial) {
                material.color = new Color(color);
                material.opacity = opacity;
                material.transparent = opacity < 1;
                material.depthWrite = !material.transparent;
            }
        }
        const selectItem = (object) => {
            if (this.selectedObjects.highlight.findIndex(item => item.uuid === object.uuid) !== -1)
                return Promise.resolve();
            object.traverse(object => {
                if (object instanceof Mesh) {
                    if (object.userData.material)
                        return;
                    // 保存原来的材质
                    object.userData.material = object.material;
                    // 克隆材质
                    object.material = cloneMaterials(object.material);
                    materialHandle(object.material, changeMaterialProp);
                }
            });
            this.signals.materialChanged.dispatch();
            this.selectedObjects.highlight.push(object);
            return Promise.resolve();
        };
        if (isArray(object))
            return Promise.all(object.map(item => selectItem(item)));
        else if (isObject(object))
            return selectItem(object);
        else
            return Promise.resolve();
    }
    unHighlightShow(objects) {
        if (!objects)
            objects = [...this.selectedObjects.highlight];
        const unSelectItem = (object) => {
            return new Promise(resolve => {
                const index = this.selectedObjects.highlight.findIndex(findItem => findItem.uuid === object.uuid);
                if (index === -1)
                    resolve();
                this.selectedObjects.highlight.splice(index, 1);
                object.traverse(object => {
                    if (object instanceof Mesh) {
                        if (!object.userData.material)
                            return;
                        disposeMaterials(object.material);
                        object.material = object.userData.material;
                        Reflect.deleteProperty(object.userData, 'material');
                    }
                });
                this.signals.materialChanged.dispatch();
                resolve();
            });
        };
        if (isArray(objects))
            return Promise.all(objects.map(object => unSelectItem(object)));
        else if (isObject(objects))
            return unSelectItem(objects);
        else
            return Promise.resolve();
    }
    emissiveShow(object, options = {}) {
        const { color = 'red', opacity = 0.3, maxOpacity = 1, minOpacity = 0, duration = 1000, } = options;
        function changeMaterialProp(material) {
            if (material instanceof MeshStandardMaterial) {
                material.emissive.set(color);
                material.emissiveIntensity = opacity;
                if (duration !== 0) {
                    Animation({ emissiveIntensity: maxOpacity, }, { emissiveIntensity: minOpacity, }, {
                        duration,
                        repeat: true,
                    }, e => material.emissiveIntensity = e.emissiveIntensity, animation => material.userData.animation = animation);
                }
            }
        }
        const selectItem = (object) => {
            if (this.selectedObjects.emissive.findIndex(item => item.uuid === object.uuid) !== -1)
                return Promise.resolve();
            object.traverse(object => {
                if (object instanceof Mesh) {
                    if (object.userData.material)
                        return;
                    // 保存原来的材质
                    object.userData.material = object.material;
                    // 克隆材质
                    object.material = cloneMaterials(object.material);
                    materialHandle(object.material, changeMaterialProp);
                }
            });
            this.selectedObjects.emissive.push(object);
            this.signals.materialChanged.dispatch();
            return Promise.resolve();
        };
        if (isArray(object))
            return Promise.all(object.map(item => selectItem(item)));
        else if (isObject(object))
            return selectItem(object);
        else
            return Promise.resolve();
    }
    unEmissiveShow(objects) {
        if (!objects)
            objects = [...this.selectedObjects.emissive];
        function changeMaterialProp(material) {
            if (material.userData.animation)
                exports.remove(material.userData.animation);
        }
        const unSelectItem = (object) => {
            return new Promise(resolve => {
                const index = this.selectedObjects.emissive.findIndex(findItem => findItem.uuid === object.uuid);
                if (index === -1)
                    resolve();
                this.selectedObjects.emissive.splice(index, 1);
                object.traverse(object => {
                    if (object instanceof Mesh) {
                        if (!object.userData.material)
                            return;
                        materialHandle(object.material, changeMaterialProp);
                        disposeMaterials(object.material);
                        object.material = object.userData.material;
                        Reflect.deleteProperty(object.userData, 'material');
                    }
                });
                this.signals.materialChanged.dispatch();
                resolve();
            });
        };
        if (isArray(objects))
            return Promise.all(objects.map(object => unSelectItem(object)));
        else if (isObject(objects))
            return unSelectItem(objects);
        else
            return Promise.resolve();
    }
    _triggerObjectAdded(object) {
        if (object instanceof BaseObject3D) {
            if (object.stype === 'Model') {
                object.traverse(child => {
                    if (child instanceof Mesh) {
                        const index = this.intersectsList.meshOfModelList.findIndex(i => i.uuid === child.uuid);
                        if (index === -1)
                            this.intersectsList.meshOfModelList.push(child);
                    }
                });
            }
            else if (object.stype === 'Poi') {
                const index = this.intersectsList.poiIconList.findIndex(i => i.uuid === object.icon.uuid);
                if (index === -1)
                    this.intersectsList.poiIconList.push(object.icon);
            }
            else if (object.stype === 'Group') {
                object.children.forEach(child => this._triggerObjectAdded(child));
            }
            else if (object.isObject3D) {
                object.traverse(child => {
                    if (child instanceof Mesh) {
                        const index = this.intersectsList.otherObjList.findIndex(i => i.uuid === child.uuid);
                        if (index === -1)
                            this.intersectsList.otherObjList.push(child);
                    }
                });
            }
        }
        else if (object.isObject3D) {
            object.traverse(child => {
                if (child instanceof Mesh) {
                    const index = this.intersectsList.otherObjList.findIndex(i => i.uuid === child.uuid);
                    if (index === -1)
                        this.intersectsList.otherObjList.push(child);
                }
            });
        }
    }
}

class CSS2DObject extends Object3D {
    constructor(element) {
        super();
        this.isCSS2DObject = true;
        this.element = element;
        this.element.style.position = 'absolute';
        // this.element.style.userSelect = 'none'
        // this.element.setAttribute( 'draggable', 'false' )
        this.addEventListener('removed', () => {
            this.traverse(function (object) {
                if (object instanceof CSS2DObject && object.element instanceof Element && object.element.parentNode !== null) {
                    object.element.parentNode.removeChild(object.element);
                }
            });
        });
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.element = source.element.cloneNode(true);
        return this;
    }
}
//
const _vector$1 = new Vector3();
const _viewMatrix = new Matrix4();
const _viewProjectionMatrix = new Matrix4();
const _a$1 = new Vector3();
const _b = new Vector3();
class CSS2DRenderer {
    constructor(viewport) {
        this.viewport = viewport;
        this.domElement = document.createElement('div');
        let _width, _height;
        let _widthHalf, _heightHalf;
        const cache = {
            objects: new WeakMap(),
        };
        this.domElement.style.overflow = 'hidden';
        this.getSize = function () {
            return {
                width: _width,
                height: _height,
            };
        };
        this.render = function (scene, camera) {
            if (scene.matrixWorldAutoUpdate === true)
                scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
                camera.updateMatrixWorld();
            _viewMatrix.copy(camera.matrixWorldInverse);
            _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);
            renderObject(scene, scene, camera);
            zOrder(scene);
        };
        this.setSize = (width, height) => {
            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
        };
        const renderObject = (object, scene, camera) => {
            var _c;
            if (object instanceof CSS2DObject) {
                /**
                 * occlude
                 */
                const parent = object.parent;
                if (parent.occlude) {
                    const isBehindCamera = isObjectBehindCamera(object, this.viewport.camera);
                    const objectVisible = !isBehindCamera && isObjectOccludeVisible(object, this.viewport.camera, this.viewport.raycaster, this.viewport.scener.intersectsList.getAll());
                    object.visible = objectVisible;
                }
                /**
                 * visible
                 */
                _vector$1.setFromMatrixPosition(object.matrixWorld);
                _vector$1.applyMatrix4(_viewProjectionMatrix);
                const visible = isObjectVisible(object) && (_vector$1.z >= -1 && _vector$1.z <= 1) && (object.layers.test(camera.layers) === true);
                if (object.userData.prevVisible !== visible) {
                    (_c = parent.onChange) === null || _c === void 0 ? void 0 : _c.call(parent, visible);
                    if (parent.elementAutoDisplay)
                        object.element.style.display = (visible === true) ? '' : 'none';
                }
                object.userData.prevVisible = visible;
                if (visible === true) {
                    const element = object.element;
                    element.style.transform = 'translate(-50%,-50%) translate(' + (_vector$1.x * _widthHalf + _widthHalf) + 'px,' + (-_vector$1.y * _heightHalf + _heightHalf) + 'px)';
                    if (element.parentNode !== this.domElement) {
                        this.domElement.appendChild(element);
                    }
                }
                const objectData = {
                    distanceToCameraSquared: getDistanceToSquared(camera, object),
                };
                cache.objects.set(object, objectData);
            }
            for (let i = 0, l = object.children.length; i < l; i++) {
                renderObject(object.children[i], scene, camera);
            }
        };
        function getDistanceToSquared(object1, object2) {
            _a$1.setFromMatrixPosition(object1.matrixWorld);
            _b.setFromMatrixPosition(object2.matrixWorld);
            return _a$1.distanceToSquared(_b);
        }
        function filterAndFlatten(scene) {
            const result = [];
            scene.traverse(function (object) {
                if (object instanceof CSS2DObject)
                    result.push(object);
            });
            return result;
        }
        function zOrder(scene) {
            const sorted = filterAndFlatten(scene).sort(function (a, b) {
                if (a.renderOrder !== b.renderOrder) {
                    return b.renderOrder - a.renderOrder;
                }
                const distanceA = cache.objects.get(a).distanceToCameraSquared;
                const distanceB = cache.objects.get(b).distanceToCameraSquared;
                return distanceA - distanceB;
            });
            const zMax = sorted.length;
            for (let i = 0, l = sorted.length; i < l; i++) {
                sorted[i].element.style.zIndex = `${zMax - i}`;
            }
        }
    }
}

/**
 * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
 */
const _position = new Vector3();
const _quaternion = new Quaternion();
const _scale = new Vector3();
class CSS3DObject extends Object3D {
    constructor(element) {
        super();
        this.isCSS3DObject = true;
        this.element = element;
        this.element.style.position = 'absolute';
        this.addEventListener('removed', () => {
            this.traverse(function (object) {
                if (object instanceof CSS3DObject && object.element instanceof Element && object.element.parentNode !== null) {
                    object.element.parentNode.removeChild(object.element);
                }
            });
        });
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.element = source.element.cloneNode(true);
        return this;
    }
}
class CSS3DSprite extends CSS3DObject {
    constructor(element) {
        super(element);
        this.isCSS3DSprite = true;
        this.rotation2D = 0;
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.rotation2D = source.rotation2D;
        return this;
    }
}
//
const _matrix = new Matrix4();
const _matrix2 = new Matrix4();
class CSS3DRenderer {
    constructor(viewport) {
        this.viewport = viewport;
        this.domElement = document.createElement('div');
        let _width, _height;
        let _widthHalf, _heightHalf;
        const cache = {
            camera: { fov: 0, style: '', },
            objects: new WeakMap(),
        };
        this.domElement.style.overflow = 'hidden';
        const viewElement = document.createElement('div');
        viewElement.style.transformOrigin = '0 0';
        this.domElement.appendChild(viewElement);
        const cameraElement = document.createElement('div');
        cameraElement.style.transformStyle = 'preserve-3d';
        viewElement.appendChild(cameraElement);
        this.getSize = () => {
            return {
                width: _width,
                height: _height,
            };
        };
        this.render = (scene, camera) => {
            const fov = camera.projectionMatrix.elements[5] * _heightHalf;
            if (cache.camera.fov !== fov) {
                viewElement.style.perspective = camera instanceof PerspectiveCamera ? fov + 'px' : '';
                cache.camera.fov = fov;
            }
            if (camera.view && camera.view.enabled) {
                // view offset
                viewElement.style.transform = `translate( ${-camera.view.offsetX * (_width / camera.view.width)}px, ${-camera.view.offsetY * (_height / camera.view.height)}px )`;
                // view fullWidth and fullHeight, view width and height
                viewElement.style.transform += `scale( ${camera.view.fullWidth / camera.view.width}, ${camera.view.fullHeight / camera.view.height} )`;
            }
            else {
                viewElement.style.transform = '';
            }
            if (scene.matrixWorldAutoUpdate === true)
                scene.updateMatrixWorld();
            if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
                camera.updateMatrixWorld();
            let tx = 0, ty = 0;
            if (camera instanceof OrthographicCamera) {
                tx = -(camera.right + camera.left) / 2;
                ty = (camera.top + camera.bottom) / 2;
            }
            const scaleByViewOffset = camera.view && camera.view.enabled ? camera.view.height / camera.view.fullHeight : 1;
            const cameraCSSMatrix = camera instanceof OrthographicCamera ?
                `scale( ${scaleByViewOffset} )` + 'scale(' + fov + ')' + 'translate(' + epsilon(tx) + 'px,' + epsilon(ty) + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse) :
                `scale( ${scaleByViewOffset} )` + 'translateZ(' + fov + 'px)' + getCameraCSSMatrix(camera.matrixWorldInverse);
            const style = cameraCSSMatrix +
                'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';
            if (cache.camera.style !== style) {
                cameraElement.style.transform = style;
                cache.camera.style = style;
            }
            renderObject(scene, scene, camera);
        };
        this.setSize = (width, height) => {
            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;
            this.domElement.style.width = width + 'px';
            this.domElement.style.height = height + 'px';
            viewElement.style.width = width + 'px';
            viewElement.style.height = height + 'px';
            cameraElement.style.width = width + 'px';
            cameraElement.style.height = height + 'px';
        };
        function epsilon(value) {
            return Math.abs(value) < 1e-10 ? 0 : value;
        }
        function getCameraCSSMatrix(matrix) {
            const elements = matrix.elements;
            return 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(-elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(elements[6]) + ',' +
                epsilon(elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(-elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(-elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';
        }
        function getObjectCSSMatrix(matrix) {
            const elements = matrix.elements;
            const matrix3d = 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(-elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(-elements[6]) + ',' +
                epsilon(-elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';
            return 'translate(-50%,-50%)' + matrix3d;
        }
        const renderObject = (object, scene, camera, cameraCSSMatrix) => {
            var _a;
            if (object instanceof CSS3DObject) {
                /**
                 * occlude
                 */
                const parent = object.parent;
                if (parent.occlude) {
                    const isBehindCamera = isObjectBehindCamera(object, this.viewport.camera);
                    const objectVisible = !isBehindCamera && isObjectOccludeVisible(object, this.viewport.camera, this.viewport.raycaster, this.viewport.scener.intersectsList.getAll());
                    object.visible = objectVisible;
                }
                /**
                 * visible
                 */
                const visible = isObjectVisible(object) && (object.layers.test(camera.layers) === true);
                if (object.userData.prevVisible !== visible) {
                    (_a = parent.onChange) === null || _a === void 0 ? void 0 : _a.call(parent, visible);
                    if (parent.elementAutoDisplay)
                        object.element.style.display = (visible === true) ? '' : 'none';
                }
                object.userData.prevVisible = visible;
                if (visible === true) {
                    let style;
                    if (object instanceof CSS3DSprite) {
                        // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/
                        _matrix.copy(camera.matrixWorldInverse);
                        _matrix.transpose();
                        if (object.rotation2D !== 0)
                            _matrix.multiply(_matrix2.makeRotationZ(object.rotation2D));
                        object.matrixWorld.decompose(_position, _quaternion, _scale);
                        _matrix.setPosition(_position);
                        _matrix.scale(_scale);
                        _matrix.elements[3] = 0;
                        _matrix.elements[7] = 0;
                        _matrix.elements[11] = 0;
                        _matrix.elements[15] = 1;
                        style = getObjectCSSMatrix(_matrix);
                    }
                    else {
                        style = getObjectCSSMatrix(object.matrixWorld);
                    }
                    const element = object.element;
                    const cachedObject = cache.objects.get(object);
                    if (cachedObject === undefined || cachedObject.style !== style) {
                        element.style.transform = style;
                        const objectData = { style: style, };
                        cache.objects.set(object, objectData);
                    }
                    if (element.parentNode !== cameraElement) {
                        cameraElement.appendChild(element);
                    }
                }
            }
            for (let i = 0, l = object.children.length; i < l; i++) {
                renderObject(object.children[i], scene, camera);
            }
        };
    }
}

const renderer2dDomID = 'ssp_view_2DPoi';
const renderer3dDomID = 'ssp_view_3DPoi';
class RendererManager {
    constructor(viewport) {
        this.viewport = viewport;
        this.internalOptions = {
            enableRenderCss2D: false,
            enableRenderCss3D: false,
        };
        this.container = this._initContainer();
        this.renderer = this._initRenderer();
        this.rendererCSS2D = this._initRenderCSS2D();
        this.rendererCSS3D = this._initRenderCSS3D();
        this.interactiveContainer = this._initInteractiveContainer();
    }
    setInternalState(name, state) {
        this.internalOptions[name] = state;
    }
    getWidth() {
        return this.renderer.domElement.width;
    }
    getHeight() {
        return this.renderer.domElement.height;
    }
    getMouseRelativeConRatio(clientPoint) {
        const rect = this.container.getBoundingClientRect();
        return [(clientPoint.offsetX - rect.left) / rect.width, (clientPoint.offsetY - rect.top) / rect.height];
    }
    getMousePoint(clientPoint) {
        const mousePoint = new Vector2(0, 0);
        mousePoint.fromArray(this.getMouseRelativeConRatio(clientPoint));
        return mousePoint;
    }
    _initContainer() {
        const dom = document.createElement('div');
        dom.style.position = 'relative';
        dom.style.width = '100%';
        dom.style.height = '100%';
        return dom;
    }
    _initRenderer() {
        const { background = {}, logarithmicDepthBuffer, } = this.viewport.options;
        const { alpha, } = background;
        const { offsetWidth, offsetHeight, } = this.container;
        const renderer = new WebGLRenderer({
            powerPreference: 'high-performance',
            premultipliedAlpha: true,
            stencil: false,
            antialias: false,
            alpha: false,
            preserveDrawingBuffer: true,
            logarithmicDepthBuffer,
        });
        renderer.autoClear = false;
        renderer.setSize(offsetWidth, offsetHeight);
        renderer.setPixelRatio(self.devicePixelRatio);
        renderer.setClearAlpha(alpha ? 0.0 : 1.0);
        renderer.localClippingEnabled = true;
        renderer.sortObjects = true;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = PCFSoftShadowMap;
        this.container.appendChild(renderer.domElement);
        return renderer;
    }
    _initRenderCSS2D() {
        const renderer = new CSS2DRenderer(this.viewport);
        renderer.domElement.id = renderer2dDomID;
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
        this.container.appendChild(renderer.domElement);
        return renderer;
    }
    _initRenderCSS3D() {
        const renderer = new CSS3DRenderer(this.viewport);
        renderer.domElement.id = renderer3dDomID;
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.setSize(this.container.offsetWidth, this.container.offsetHeight);
        this.container.appendChild(renderer.domElement);
        return renderer;
    }
    _initInteractiveContainer() {
        return this.rendererCSS3D.domElement;
    }
}

const matrix4 = new Matrix4;
const getEuler = (y, x) => {
    const m1 = matrix4.clone();
    const m2 = matrix4.clone();
    const m3 = matrix4.clone();
    m1.makeRotationY(y);
    m2.makeRotationX(x);
    const euler = new Euler();
    m3.multiplyMatrices(m1, m2);
    euler.setFromRotationMatrix(m3);
    return euler;
};
const lt = getEuler(-Math.PI / 2, -Math.PI / 4);
const rt = getEuler(Math.PI / 2, -Math.PI / 4);
const lft = getEuler(-Math.PI / 4, -Math.PI / 4);
const rft = getEuler(Math.PI / 4, -Math.PI / 4);
const lbt = getEuler(Math.PI * 1.25, -Math.PI / 4);
const rbt = getEuler(Math.PI * 0.75, -Math.PI / 4);
const viewpoints = {
    LEFT: new Euler(0, -Math.PI / 2, 0),
    RIGHT: new Euler(0, Math.PI / 2, 0),
    FRONT: new Euler(0, 0, 0),
    BACK: new Euler(0, Math.PI, 0),
    TOP: new Euler(-Math.PI / 2, 0, 0),
    BOTTOM: new Euler(Math.PI / 2, 0, 0),
    FRONTTOP: new Euler(-Math.PI / 4, 0, 0),
    BACKTOP: new Euler(Math.PI / 4, Math.PI, 0),
    LEFTTOP: new Euler(lt.x, lt.y, lt.z),
    RIGHTTOP: new Euler(rt.x, rt.y, rt.z),
    LEFTFRONTTOP: new Euler(lft.x, lft.y, lft.z),
    RIGHTFRONTTOP: new Euler(rft.x, rft.y, rft.z),
    LEFTBACKTOP: new Euler(lbt.x, lbt.y, lbt.z),
    RIGHTBACKTOP: new Euler(rbt.x, rbt.y, rbt.z),
};

const percentage2Number = (value) => {
    if (isNumber(value))
        return value;
    else if (value.includes('%'))
        return Number(value.split('%')[0]) * 0.01;
    else if (!isNaN(+value))
        return Number(value);
    else
        return 0;
};

const _v1 = /*@__PURE__*/ new Vector3();
const _e1 = /*@__PURE__*/ new Euler();
const DEFAULT_CAMERA = new PerspectiveCamera(50, 1, 0.1, 500000);
DEFAULT_CAMERA.position.set(500, 1000, 500);
DEFAULT_CAMERA.lookAt(_v1.set(0, 0, 0));
DEFAULT_CAMERA.name = 'Camera';
class CameraManager {
    constructor(viewport) {
        this.viewport = viewport;
        this.mainCamera = DEFAULT_CAMERA.clone();
        this.mainCamera.name = 'freeCamera';
        this.currentCamera = this.mainCamera;
        this.cameras = {};
    }
    createCamera(key) {
        const cloneCamera = DEFAULT_CAMERA.clone();
        cloneCamera.name = key;
        this.cameras[key] = cloneCamera;
        return cloneCamera;
    }
    removeCamera(key) {
        if (key === 'fullFreeCamera')
            return false;
        delete this.cameras[key];
        return true;
    }
    setCurrentCamera(camera) {
        this.currentCamera = this.viewport.camera = camera;
        this.viewport.signals.cameraObjectChange.dispatch();
    }
    getMainCamera() {
        return this.mainCamera;
    }
    getCameraViewpoint() {
        if (this.viewport.controls.options.type === 'free') {
            return {
                position: this.currentCamera.position.clone(),
                rotation: {
                    x: this.currentCamera.rotation.x,
                    y: this.currentCamera.rotation.y,
                    z: this.currentCamera.rotation.z,
                },
            };
        }
        else {
            const currentControls = this.viewport.controls.currentControls;
            return {
                position: this.currentCamera.position.clone(),
                target: currentControls.target.clone(),
            };
        }
    }
    setCameraViewpoint(data) {
        if (this.viewport.controls.options.type === 'free' && isObject(data)) {
            const { position, rotation, } = data;
            this.currentCamera.position.set(position.x, position.y, position.z);
            this.currentCamera.rotation.set(rotation.x, rotation.y, rotation.z);
        }
        else if (isObject(data)) {
            const { position, target, } = data;
            const currentControls = this.viewport.controls.currentControls;
            this.currentCamera.position.set(position.x, position.y, position.z);
            currentControls.target.set(target.x, target.y, target.z);
        }
        this.viewport.signals.cameraChange.dispatch(this.currentCamera.position.clone());
    }
    // getCameraTargetView (): CameraTargetViewData | null {
    //   if ( this.viewport.controls.options.type !== 'orbit' ) {
    //     warn( 'getCameraTargetView 只在 orbit 控制器下可用' )
    //     return null
    //   }
    //   const currentControls = this.viewport.controls.currentControls as OrbitControls
    //   return {
    //     position: this.currentCamera.position.clone(),
    //     target: currentControls.target.clone(),
    //   }
    // }
    // setCameraTargetView ( data: CameraTargetViewData ) {
    //   if ( this.viewport.controls.options.type !== 'orbit' ) {
    //     warn( 'setCameraTargetView 只在 orbit 控制器下可用' )
    //     return
    //   }
    //   const { position, target, } = data
    //   const currentControls = this.viewport.controls.currentControls as OrbitControls
    //   this.currentCamera.position.set( position.x, position.y, position.z )
    //   currentControls.target.set( target.x, target.y, target.z )
    //   this.viewport.signals.cameraChange.dispatch( this.currentCamera.position.clone() )
    // }
    moveTo(position, options) {
        return Animation(this.currentCamera.position, position, options, e => this.viewport.signals.cameraChange.dispatch(e));
    }
    rotateTo(rotation, options) {
        const sourceQuaternion = this.currentCamera.quaternion.clone();
        const targetQuaternion = new Quaternion().setFromEuler(rotation);
        return Animation({ t: 0, }, { t: 1, }, options, ({ t, }) => {
            this.currentCamera.quaternion.slerpQuaternions(sourceQuaternion, targetQuaternion, t);
        });
    }
    async flyTo(position, rotation = 'frontTop', options) {
        if (isString(rotation)) {
            const viewport = rotation.toLocaleUpperCase();
            if (viewport === 'CURRENT') {
                _e1.copy(this.currentCamera.rotation);
            }
            else if (viewpoints[viewport]) {
                _e1.copy(viewpoints[viewport]);
            }
        }
        else if (rotation instanceof Euler) {
            _e1.copy(rotation);
        }
        else if (isObject(rotation)) {
            _e1.set(rotation.x, rotation.y, rotation.z);
        }
        _e1.copy(rotationAFix(this.currentCamera.rotation, _e1.clone()));
        await Promise.all([
            this.moveTo(position, options),
            this.rotateTo(_e1, options)
        ]);
    }
    async flyToBoundingBox(bbox, rotation = 'frontTop', options) {
        if (bbox.isEmpty()) {
            warn('target box is empty');
            return;
        }
        const controlsType = this.viewport.controls.options.type;
        const flyToPosition = new Vector3();
        // FlyToViewpoint
        if (isString(rotation)) {
            const viewpoint = rotation.toLocaleUpperCase();
            if (viewpoint === 'CURRENT') {
                flyToPosition.copy(this.getMovePosByBBox(bbox));
            }
            else {
                const viewpointRotation = viewpoints[rotation.toLocaleUpperCase()];
                const viewpointPostion = this.getObjectLabelPos(bbox, viewpointRotation);
                flyToPosition.copy(viewpointPostion);
            }
        }
        //  Rotation | Euler
        else {
            if (controlsType === 'orbit') {
                warn('orbit 控制器不支持 Rotation 类型 的 rotation 参数');
            }
            const viewpointRotation = IVector3ToEuler(rotation);
            const viewpointPostion = this.getObjectLabelPos(bbox, viewpointRotation);
            flyToPosition.copy(viewpointPostion);
        }
        /**
         * compat orbitcontrols
         */
        if (controlsType === 'orbit') {
            const center = bbox.getCenter(_v1);
            const orbitControls = this.viewport.controls.currentControls;
            /**
             * update target
             */
            orbitControls.target.copy(center);
            const m1 = new Matrix4();
            m1.lookAt(flyToPosition, center, orbitControls.object.up);
            rotation = _e1.setFromRotationMatrix(m1);
        }
        await this.flyTo(flyToPosition, rotation, options);
    }
    flyToObj(object, rotation = 'frontTop', options = {}) {
        if (object instanceof Poi || object instanceof PoiNode) {
            const { padding = 50, } = options;
            const poiPadding = percentage2Number(padding);
            return this.flyToBoundingBox(object.getBoundingBox(poiPadding), rotation, options);
        }
        else {
            const { padding = '30%', } = options;
            const bbox = getBoundingBox(object);
            const size = bbox.getSize(_v1);
            let modelPadding = 0;
            if (isString(padding)) {
                const maxAxisSize = Math.max(size.x, size.y, size.z);
                modelPadding = percentage2Number(padding) * maxAxisSize;
            }
            else {
                modelPadding = padding;
            }
            let minPadding = modelPadding;
            let minYPadding = modelPadding;
            if (modelPadding < 0) {
                const minAxisSize = Math.min(size.x, size.z);
                const yAxisSize = size.y - 1;
                minPadding = Math.abs(modelPadding) > minAxisSize ? -minAxisSize : modelPadding;
                minYPadding = Math.abs(minPadding) > yAxisSize ? -yAxisSize : minPadding;
            }
            if (padding !== 0) {
                bbox.max.add(_v1.set(minPadding / 2, minYPadding / 2, minPadding / 2));
                bbox.min.sub(_v1.set(minPadding / 2, minYPadding / 2, minPadding / 2));
            }
            /**
             * compat empty
             */
            if (bbox.isEmpty()) {
                _v1.setFromMatrixPosition(object.matrixWorld);
                bbox.setFromCenterAndSize(_v1, new Vector3(0, 0, 0));
            }
            return this.flyToBoundingBox(bbox, rotation, options);
        }
    }
    surroundOnTarget(target, options = {}) {
        const { speed = 1, angle = 360, onStart, } = options;
        const newTarget = IVector3ToVector3(target);
        const surroundCenter = newTarget.clone().setY(this.currentCamera.position.y);
        const radius = surroundCenter.distanceTo(this.currentCamera.position);
        const angleAbs = Math.abs(angle);
        return Animation({
            angle: 0,
        }, {
            angle: Math.PI / 180 * angleAbs,
        }, {
            duration: angleAbs / 360 * 5000 / speed,
        }, e => {
            const RoTateAngle = angle > 0 ? e.angle : Math.PI * 2 - e.angle;
            this.currentCamera.position.x = Math.sin(RoTateAngle) * radius + newTarget.x;
            this.currentCamera.position.z = Math.cos(RoTateAngle) * radius + newTarget.z;
            /**
             * compat orbit
             */
            if (this.viewport.controls.options.type === 'orbit') {
                const currentControls = this.viewport.controls.currentControls;
                currentControls.target.copy(newTarget);
                currentControls.update();
            }
            else {
                this.currentCamera.lookAt(newTarget);
            }
        }, onStart);
    }
    surroundOnObject(object, options = {}) {
        const target = new Box3().setFromObject(object).getCenter(_v1);
        return this.surroundOnTarget(target, options);
    }
    getMovePosByBBox(bbox) {
        const cPosition = this.currentCamera.position;
        const center = bbox.getCenter(_v1);
        const direct = new Vector3();
        direct.subVectors(center, cPosition).normalize();
        let bs = new Sphere();
        bs = bbox.getBoundingSphere(bs);
        const FoV2 = this.currentCamera.fov / 2;
        const th = FoV2 * Math.PI / 180.0;
        const sina = Math.sin(th);
        const R = bs.radius;
        const FL = R / sina;
        const cameraDir = new Vector3();
        this.currentCamera.getWorldDirection(cameraDir);
        const cameraOffs = cameraDir.clone();
        cameraOffs.multiplyScalar(-FL);
        //返回相机该平移到的位置
        return center.clone().add(cameraOffs);
    }
    getObjectLabelPos(bbox, rotation = 'frontTop', options = {}) {
        if (bbox instanceof BaseObject3D)
            bbox = new Box3().setFromObject(bbox);
        if (bbox.isEmpty()) {
            warn('target box is empty');
            return new Vector3();
        }
        const { extendScale = 1.6, mode = 'scene', } = options;
        // scene
        if (mode === 'scene') {
            const center = bbox.getCenter(_v1);
            const boxSize = bbox.max.clone().sub(bbox.min);
            const maxAxis = Math.max(boxSize.x, boxSize.y, boxSize.z);
            const position = center.clone();
            const positionCompute = (direct) => {
                const extendLength = (extendScale - 0.5) * Math.abs(maxAxis);
                const minExtendLength = Math.max(extendLength, this.viewport.camera.near);
                position.add(direct.multiplyScalar(minExtendLength));
            };
            let newRotation;
            if (isString(rotation)) {
                newRotation = viewpoints[rotation.toLocaleUpperCase()];
            }
            else {
                newRotation = IVector3ToEuler(rotation);
            }
            positionCompute(_v1.set(0, 0, 1).applyEuler(newRotation));
            return position;
        }
        // screen
        else if (mode === 'screen') {
            return bbox.getCenter(_v1).clone();
        }
        else {
            return new Vector3();
        }
    }
}

/**
 * postprocessing v6.30.1 build Fri Feb 24 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rüschen
 * @license Zlib
 */

// src/materials/glsl/common.vert
var common_default = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
function getTextureDecoding(texture, isWebGL2) {
  let decoding = "texel";
  if (texture !== null) {
    const revision = Number.parseInt(REVISION);
    const sRGB8Alpha8 = isWebGL2 && revision >= 133 && revision !== 135 && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding;
    if (!sRGB8Alpha8) {
      switch (texture.encoding) {
        case sRGBEncoding:
          decoding = "sRGBToLinear(texel)";
          break;
        case LinearEncoding:
          decoding = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${texture.encoding}`);
      }
    }
  }
  return decoding;
}

// src/utils/orthographicDepthToViewZ.js
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}

// src/utils/viewZToOrthographicDepth.js
function viewZToOrthographicDepth(viewZ, near, far) {
  return Math.min(Math.max((viewZ + near) / (near - far), 0), 1);
}

// src/enums/BlendFunction.js
var BlendFunction = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
};

// src/enums/EdgeDetectionMode.js
var EdgeDetectionMode = {
  DEPTH: 0,
  LUMA: 1,
  COLOR: 2
};

// src/enums/EffectAttribute.js
var EffectAttribute = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
};

// src/enums/EffectShaderSection.js
var EffectShaderSection = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
};

// src/enums/KernelSize.js
var KernelSize = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
};

// src/enums/PredicationMode.js
var PredicationMode = {
  DISABLED: 0,
  DEPTH: 1,
  CUSTOM: 2
};

// src/enums/SMAAPreset.js
var SMAAPreset = {
  LOW: 0,
  MEDIUM: 1,
  HIGH: 2,
  ULTRA: 3
};

// src/materials/glsl/convolution.kawase.frag
var convolution_kawase_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <encodings_fragment>\n}";

// src/materials/glsl/convolution.kawase.vert
var convolution_kawase_default2 = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/KawaseBlurMaterial.js
var kernelPresets = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
];
var KawaseBlurMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new convolution material.
   *
   * TODO Remove texelSize param.
   * @param {Vector4} [texelSize] - Deprecated.
   */
  constructor(texelSize = new Vector4()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector4()),
        scale: new Uniform(1),
        kernel: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_kawase_default,
      vertexShader: convolution_kawase_default2
    });
    this.toneMapped = false;
    this.setTexelSize(texelSize.x, texelSize.y);
    this.kernelSize = KernelSize.MEDIUM;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.inputBuffer = value;
  }
  /**
   * The kernel sequence for the current kernel size.
   *
   * @type {Float32Array}
   */
  get kernelSequence() {
    return kernelPresets[this.kernelSize];
  }
  /**
   * The blur scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.uniforms.scale.value;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} value - The scale.
   */
  setScale(value) {
    this.uniforms.scale.value = value;
  }
  /**
   * Returns the kernel.
   *
   * @return {Float32Array} The kernel.
   * @deprecated Implementation detail, removed with no replacement.
   */
  getKernel() {
    return null;
  }
  /**
   * The current kernel.
   *
   * @type {Number}
   */
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(value) {
    this.uniforms.kernel.value = value;
  }
  /**
   * Sets the current kernel.
   *
   * @deprecated Use kernel instead.
   * @param {Number} value - The kernel.
   */
  setKernel(value) {
    this.kernel = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const x = 1 / width, y = 1 / height;
    this.uniforms.texelSize.value.set(x, y, x * 0.5, y * 0.5);
  }
};

// src/materials/glsl/copy.frag
var copy_default = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n#include <dithering_fragment>\n}";

// src/materials/CopyMaterial.js
var CopyMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new copy material.
   */
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        opacity: new Uniform(1)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: copy_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Number} value - The buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Returns the opacity.
   *
   * @deprecated Use opacity instead.
   * @return {Number} The opacity.
   */
  getOpacity(value) {
    return this.uniforms.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @deprecated Use opacity instead.
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.uniforms.opacity.value = value;
  }
};

// src/materials/glsl/depth-comparison.frag
var depth_comparison_default = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}";

// src/materials/glsl/depth-comparison.vert
var depth_comparison_default2 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}";

// src/materials/DepthComparisonMaterial.js
var DepthComparisonMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth comparison material.
   *
   * @param {Texture} [depthTexture=null] - A depth texture.
   * @param {PerspectiveCamera} [camera] - A camera.
   */
  constructor(depthTexture = null, camera) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_comparison_default,
      vertexShader: depth_comparison_default2
    });
    this.toneMapped = false;
    this.depthBuffer = depthTexture;
    this.depthPacking = RGBADepthPacking;
    this.copyCameraSettings(camera);
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=RGBADepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = RGBADepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
};

// src/materials/glsl/depth-downsampling.frag
var depth_downsampling_default = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);\n#else\nvec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));\n#endif\ngl_FragColor=vec4(n[index],d[index]);}";

// src/materials/glsl/depth-downsampling.vert
var depth_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DepthDownsamplingMaterial.js
var DepthDownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new depth downsampling material.
   */
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: depth_downsampling_default,
      vertexShader: depth_downsampling_default2
    });
    this.toneMapped = false;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
    if (value !== null) {
      this.defines.DOWNSAMPLE_NORMALS = "1";
    } else {
      delete this.defines.DOWNSAMPLE_NORMALS;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Texture} value - The normal buffer.
   */
  setNormalBuffer(value) {
    this.normalBuffer = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/convolution.downsampling.frag
var convolution_downsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <encodings_fragment>\n}";

// src/materials/glsl/convolution.downsampling.vert
var convolution_downsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/DownsamplingMaterial.js
var DownsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new downsampling material.
   */
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_downsampling_default,
      vertexShader: convolution_downsampling_default2
    });
    this.toneMapped = false;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/edge-detection.frag
var edge_detection_default = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}";

// src/materials/glsl/edge-detection.vert
var edge_detection_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EdgeDetectionMaterial.js
var EdgeDetectionMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new edge detection material.
   *
   * TODO Remove parameters.
   * @param {Vector2} [texelSize] - The screen texel size.
   * @param {EdgeDetectionMode} [mode=EdgeDetectionMode.COLOR] - The edge detection mode.
   */
  constructor(texelSize = new Vector2(), mode = EdgeDetectionMode.COLOR) {
    super({
      name: "EdgeDetectionMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
        EDGE_THRESHOLD: "0.1",
        DEPTH_THRESHOLD: "0.01",
        PREDICATION_MODE: "0",
        PREDICATION_THRESHOLD: "0.01",
        PREDICATION_SCALE: "2.0",
        PREDICATION_STRENGTH: "1.0",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        predicationBuffer: new Uniform(null),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: edge_detection_default,
      vertexShader: edge_detection_default2
    });
    this.toneMapped = false;
    this.edgeDetectionMode = mode;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The edge detection mode.
   *
   * @type {EdgeDetectionMode}
   */
  get edgeDetectionMode() {
    return Number(this.defines.EDGE_DETECTION_MODE);
  }
  set edgeDetectionMode(value) {
    this.defines.EDGE_DETECTION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @return {EdgeDetectionMode} The mode.
   */
  getEdgeDetectionMode() {
    return this.edgeDetectionMode;
  }
  /**
   * Sets the edge detection mode.
   *
   * @deprecated Use edgeDetectionMode instead.
   * @param {EdgeDetectionMode} value - The edge detection mode.
   */
  setEdgeDetectionMode(value) {
    this.edgeDetectionMode = value;
  }
  /**
   * The local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH. Default is 2.0.
   *
   * If a neighbor edge has _factor_ times bigger contrast than the current edge, the edge will be discarded.
   *
   * This allows to eliminate spurious crossing edges and is based on the fact that if there is too much contrast in a
   * direction, the perceptual contrast in the other neighbors will be hidden.
   *
   * @type {Number}
   */
  get localContrastAdaptationFactor() {
    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
  }
  set localContrastAdaptationFactor(value) {
    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the local contrast adaptation factor.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @return {Number} The factor.
   */
  getLocalContrastAdaptationFactor() {
    return this.localContrastAdaptationFactor;
  }
  /**
   * Sets the local contrast adaptation factor. Has no effect if the edge detection mode is set to DEPTH.
   *
   * @deprecated Use localContrastAdaptationFactor instead.
   * @param {Number} value - The local contrast adaptation factor. Default is 2.0.
   */
  setLocalContrastAdaptationFactor(value) {
    this.localContrastAdaptationFactor = value;
  }
  /**
   * The edge detection threshold. Range: [0.0, 0.5].
   *
   * A lower value results in more edges being detected at the expense of performance.
   *
   * For luma- and chroma-based edge detection, 0.1 is a reasonable value and allows to catch most visible edges. 0.05
   * is a rather overkill value that allows to catch 'em all. Darker scenes may require an even lower threshold.
   *
   * If depth-based edge detection is used, the threshold will depend on the scene depth.
   *
   * @type {Number}
   */
  get edgeDetectionThreshold() {
    return Number(this.defines.EDGE_THRESHOLD);
  }
  set edgeDetectionThreshold(value) {
    this.defines.EDGE_THRESHOLD = value.toFixed("6");
    this.defines.DEPTH_THRESHOLD = (value * 0.1).toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @return {Number} The threshold.
   */
  getEdgeDetectionThreshold() {
    return this.edgeDetectionThreshold;
  }
  /**
   * Sets the edge detection threshold.
   *
   * @deprecated Use edgeDetectionThreshold instead.
   * @param {Number} value - The edge detection threshold. Range: [0.0, 0.5].
   */
  setEdgeDetectionThreshold(value) {
    this.edgeDetectionThreshold = value;
  }
  /**
   * The predication mode.
   *
   * Predicated thresholding allows to better preserve texture details and to improve edge detection using an additional
   * buffer such as a light accumulation or depth buffer.
   *
   * @type {PredicationMode}
   */
  get predicationMode() {
    return Number(this.defines.PREDICATION_MODE);
  }
  set predicationMode(value) {
    this.defines.PREDICATION_MODE = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Returns the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @return {PredicationMode} The mode.
   */
  getPredicationMode() {
    return this.predicationMode;
  }
  /**
   * Sets the predication mode.
   *
   * @deprecated Use predicationMode instead.
   * @param {PredicationMode} value - The predication mode.
   */
  setPredicationMode(value) {
    this.predicationMode = value;
  }
  /**
   * The predication buffer.
   *
   * @type {Texture}
   */
  set predicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * Sets a custom predication buffer.
   *
   * @deprecated Use predicationBuffer instead.
   * @param {Texture} value - The predication buffer.
   */
  setPredicationBuffer(value) {
    this.uniforms.predicationBuffer.value = value;
  }
  /**
   * The predication threshold.
   *
   * @type {Number}
   */
  get predicationThreshold() {
    return Number(this.defines.PREDICATION_THRESHOLD);
  }
  set predicationThreshold(value) {
    this.defines.PREDICATION_THRESHOLD = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @return {Number} The threshold.
   */
  getPredicationThreshold() {
    return this.predicationThreshold;
  }
  /**
   * Sets the predication threshold.
   *
   * @deprecated Use predicationThreshold instead.
   * @param {Number} value - The threshold.
   */
  setPredicationThreshold(value) {
    this.predicationThreshold = value;
  }
  /**
   * The predication scale. Range: [1.0, 5.0].
   *
   * Determines how much the edge detection threshold should be scaled when using predication.
   *
   * @type {Boolean|Texture|Number}
   */
  get predicationScale() {
    return Number(this.defines.PREDICATION_SCALE);
  }
  set predicationScale(value) {
    this.defines.PREDICATION_SCALE = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @return {Number} The scale.
   */
  getPredicationScale() {
    return this.predicationScale;
  }
  /**
   * Sets the predication scale.
   *
   * @deprecated Use predicationScale instead.
   * @param {Number} value - The scale. Range: [1.0, 5.0].
   */
  setPredicationScale(value) {
    this.predicationScale = value;
  }
  /**
   * The predication strength. Range: [0.0, 1.0].
   *
   * Determines how much the edge detection threshold should be decreased locally when using predication.
   *
   * @type {Number}
   */
  get predicationStrength() {
    return Number(this.defines.PREDICATION_STRENGTH);
  }
  set predicationStrength(value) {
    this.defines.PREDICATION_STRENGTH = value.toFixed("6");
    this.needsUpdate = true;
  }
  /**
   * Returns the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @return {Number} The strength.
   */
  getPredicationStrength() {
    return this.predicationStrength;
  }
  /**
   * Sets the predication strength.
   *
   * @deprecated Use predicationStrength instead.
   * @param {Number} value - The strength. Range: [0.0, 1.0].
   */
  setPredicationStrength(value) {
    this.predicationStrength = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/effect.frag
var effect_default = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}";

// src/materials/glsl/effect.vert
var effect_default2 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/EffectMaterial.js
var EffectMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new effect material.
   *
   * @param {Map<String, String>} [shaderParts] - Deprecated. Use setShaderData instead.
   * @param {Map<String, String>} [defines] - Deprecated. Use setShaderData instead.
   * @param {Map<String, Uniform>} [uniforms] - Deprecated. Use setShaderData instead.
   * @param {Camera} [camera] - A camera.
   * @param {Boolean} [dithering=false] - Deprecated.
   */
  constructor(shaderParts, defines, uniforms, camera, dithering = false) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        depthBuffer: new Uniform(null),
        resolution: new Uniform(new Vector2()),
        texelSize: new Uniform(new Vector2()),
        cameraNear: new Uniform(0.3),
        cameraFar: new Uniform(1e3),
        aspect: new Uniform(1),
        time: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      dithering
    });
    this.toneMapped = false;
    if (shaderParts) {
      this.setShaderParts(shaderParts);
    }
    if (defines) {
      this.setDefines(defines);
    }
    if (uniforms) {
      this.setUniforms(uniforms);
    }
    this.copyCameraSettings(camera);
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * Sets the shader data.
   *
   * @param {EffectShaderData} data - The shader data.
   * @return {EffectMaterial} This material.
   */
  setShaderData(data) {
    this.setShaderParts(data.shaderParts);
    this.setDefines(data.defines);
    this.setUniforms(data.uniforms);
    this.setExtensions(data.extensions);
  }
  /**
   * Sets the shader parts.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} shaderParts - A collection of shader snippets. See {@link EffectShaderSection}.
   * @return {EffectMaterial} This material.
   */
  setShaderParts(shaderParts) {
    var _a, _b, _c, _d, _e;
    this.fragmentShader = effect_default.replace(EffectShaderSection.FRAGMENT_HEAD, (_a = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD)) != null ? _a : "").replace(EffectShaderSection.FRAGMENT_MAIN_UV, (_b = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV)) != null ? _b : "").replace(EffectShaderSection.FRAGMENT_MAIN_IMAGE, (_c = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)) != null ? _c : "");
    this.vertexShader = effect_default2.replace(EffectShaderSection.VERTEX_HEAD, (_d = shaderParts.get(EffectShaderSection.VERTEX_HEAD)) != null ? _d : "").replace(EffectShaderSection.VERTEX_MAIN_SUPPORT, (_e = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)) != null ? _e : "");
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader macros.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, String>} defines - A collection of preprocessor macro definitions.
   * @return {EffectMaterial} This material.
   */
  setDefines(defines) {
    for (const entry of defines.entries()) {
      this.defines[entry[0]] = entry[1];
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets the shader uniforms.
   *
   * @deprecated Use setShaderData instead.
   * @param {Map<String, Uniform>} uniforms - A collection of uniforms.
   * @return {EffectMaterial} This material.
   */
  setUniforms(uniforms) {
    for (const entry of uniforms.entries()) {
      this.uniforms[entry[0]] = entry[1];
    }
    return this;
  }
  /**
   * Sets the required shader extensions.
   *
   * @deprecated Use setShaderData instead.
   * @param {Set<WebGLExtension>} extensions - A collection of extensions.
   * @return {EffectMaterial} This material.
   */
  setExtensions(extensions) {
    this.extensions = {};
    for (const extension of extensions) {
      this.extensions[extension] = true;
    }
    return this;
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @type {Boolean}
   */
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(value) {
    if (this.encodeOutput !== value) {
      if (value) {
        this.defines.ENCODE_OUTPUT = "1";
      } else {
        delete this.defines.ENCODE_OUTPUT;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Indicates whether output encoding is enabled.
   *
   * @deprecated Use encodeOutput instead.
   * @return {Boolean} Whether output encoding is enabled.
   */
  isOutputEncodingEnabled(value) {
    return this.encodeOutput;
  }
  /**
   * Enables or disables output encoding.
   *
   * @deprecated Use encodeOutput instead.
   * @param {Boolean} value - Whether output encoding should be enabled.
   */
  setOutputEncodingEnabled(value) {
    this.encodeOutput = value;
  }
  /**
   * The time in seconds.
   *
   * @type {Number}
   */
  get time() {
    return this.uniforms.time.value;
  }
  set time(value) {
    this.uniforms.time.value = value;
  }
  /**
   * Sets the delta time.
   *
   * @deprecated Use time instead.
   * @param {Number} value - The delta time in seconds.
   */
  setDeltaTime(value) {
    this.uniforms.time.value += value;
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNear.value = camera.near;
      this.uniforms.cameraFar.value = camera.far;
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the resolution.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.resolution.value.set(width, height);
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.aspect.value = width / height;
  }
  /**
   * An enumeration of shader code placeholders.
   *
   * @deprecated Use EffectShaderSection instead.
   * @type {Object}
   */
  static get Section() {
    return EffectShaderSection;
  }
};

// src/materials/glsl/luminance.frag
var luminance_default = "#include <common>\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*l,l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}";

// src/materials/LuminanceMaterial.js
var LuminanceMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new luminance material.
   *
   * @param {Boolean} [colorOutput=false] - Defines whether the shader should output colors scaled with their luminance value.
   * @param {Vector2} [luminanceRange] - If provided, the shader will mask out texels that aren't in the specified luminance range.
   */
  constructor(colorOutput = false, luminanceRange = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: REVISION.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        threshold: new Uniform(0),
        smoothing: new Uniform(1),
        range: new Uniform(null)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: luminance_default,
      vertexShader: common_default
    });
    this.toneMapped = false;
    this.colorOutput = colorOutput;
    this.luminanceRange = luminanceRange;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The luminance threshold.
   *
   * @type {Number}
   */
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(value) {
    if (this.smoothing > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.threshold.value = value;
  }
  /**
   * Returns the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @return {Number} The threshold.
   */
  getThreshold() {
    return this.threshold;
  }
  /**
   * Sets the luminance threshold.
   *
   * @deprecated Use threshold instead.
   * @param {Number} value - The threshold.
   */
  setThreshold(value) {
    this.threshold = value;
  }
  /**
   * The luminance threshold smoothing.
   *
   * @type {Number}
   */
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(value) {
    if (this.threshold > 0 || value > 0) {
      this.defines.THRESHOLD = "1";
    } else {
      delete this.defines.THRESHOLD;
    }
    this.uniforms.smoothing.value = value;
  }
  /**
   * Returns the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @return {Number} The smoothing factor.
   */
  getSmoothingFactor() {
    return this.smoothing;
  }
  /**
   * Sets the luminance threshold smoothing factor.
   *
   * @deprecated Use smoothing instead.
   * @param {Number} value - The smoothing factor.
   */
  setSmoothingFactor(value) {
    this.smoothing = value;
  }
  /**
   * Indicates whether the luminance threshold is enabled.
   *
   * @type {Boolean}
   * @deprecated Adjust the threshold or smoothing factor instead.
   */
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(value) {
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @type {Boolean}
   */
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(value) {
    if (value) {
      this.defines.COLOR = "1";
    } else {
      delete this.defines.COLOR;
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether color output is enabled.
   *
   * @deprecated Use colorOutput instead.
   * @return {Boolean} Whether color output is enabled.
   */
  isColorOutputEnabled(value) {
    return this.colorOutput;
  }
  /**
   * Enables or disables color output.
   *
   * @deprecated Use colorOutput instead.
   * @param {Boolean} value - Whether color output should be enabled.
   */
  setColorOutputEnabled(value) {
    this.colorOutput = value;
  }
  /**
   * Indicates whether luminance masking is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(value) {
    this.luminanceRange = null;
  }
  /**
   * The luminance range. Set to null to disable.
   *
   * @type {Boolean}
   */
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(value) {
    if (value !== null) {
      this.defines.RANGE = "1";
    } else {
      delete this.defines.RANGE;
    }
    this.uniforms.range.value = value;
    this.needsUpdate = true;
  }
  /**
   * Returns the current luminance range.
   *
   * @deprecated Use luminanceRange instead.
   * @return {Vector2} The luminance range.
   */
  getLuminanceRange() {
    return this.luminanceRange;
  }
  /**
   * Sets a luminance range. Set to null to disable.
   *
   * @deprecated Use luminanceRange instead.
   * @param {Vector2} value - The luminance range.
   */
  setLuminanceRange(value) {
    this.luminanceRange = value;
  }
};

// src/materials/glsl/outline.frag
var outline_default = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}";

// src/materials/glsl/outline.vert
var outline_default2 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/OutlineMaterial.js
var OutlineMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new outline material.
   *
   * TODO Remove texelSize param.
   * @param {Vector2} [texelSize] - The screen texel size.
   */
  constructor(texelSize = new Vector2()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2())
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: outline_default,
      vertexShader: outline_default2
    });
    this.toneMapped = false;
    this.uniforms.texelSize.value.set(texelSize.x, texelSize.y);
    this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};

// src/materials/glsl/smaa-weights.frag
var smaa_weights_default = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}";

// src/materials/glsl/smaa-weights.vert
var smaa_weights_default2 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SMAAWeightsMaterial.js
var SMAAWeightsMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SMAA weights material.
   *
   * @param {Vector2} [texelSize] - The absolute screen texel size.
   * @param {Vector2} [resolution] - The resolution.
   */
  constructor(texelSize = new Vector2(), resolution = new Vector2()) {
    super({
      name: "SMAAWeightsMaterial",
      defines: {
        // Configurable settings:
        MAX_SEARCH_STEPS_INT: "16",
        MAX_SEARCH_STEPS_FLOAT: "16.0",
        MAX_SEARCH_STEPS_DIAG_INT: "8",
        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
        CORNER_ROUNDING: "25",
        CORNER_ROUNDING_NORM: "0.25",
        // Non-configurable settings:
        AREATEX_MAX_DISTANCE: "16.0",
        AREATEX_MAX_DISTANCE_DIAG: "20.0",
        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
      },
      uniforms: {
        inputBuffer: new Uniform(null),
        searchTexture: new Uniform(null),
        areaTexture: new Uniform(null),
        resolution: new Uniform(resolution),
        texelSize: new Uniform(texelSize)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: smaa_weights_default,
      vertexShader: smaa_weights_default2
    });
    this.toneMapped = false;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * Sets the input buffer.
   *
   * @deprecated Use inputBuffer instead.
   * @param {Texture} value - The input buffer.
   */
  setInputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * The search lookup texture.
   *
   * @type {Texture}
   */
  get searchTexture() {
    return this.uniforms.searchTexture.value;
  }
  set searchTexture(value) {
    this.uniforms.searchTexture.value = value;
  }
  /**
   * The area lookup texture.
   *
   * @type {Texture}
   */
  get areaTexture() {
    return this.uniforms.areaTexture.value;
  }
  set areaTexture(value) {
    this.uniforms.areaTexture.value = value;
  }
  /**
   * Sets the search and area lookup textures.
   *
   * @deprecated Use searchTexture and areaTexture instead.
   * @param {Texture} search - The search lookup texture.
   * @param {Texture} area - The area lookup texture.
   */
  setLookupTextures(search, area2) {
    this.searchTexture = search;
    this.areaTexture = area2;
  }
  /**
   * The maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   * Range: [0, 112].
   *
   * In number of pixels, it's actually the double. So the maximum line length perfectly handled by, for example 16, is
   * 64 (perfectly means that longer lines won't look as good, but are still antialiased).
   *
   * @type {Number}
   */
  get orthogonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_INT);
  }
  set orthogonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 112);
    this.defines.MAX_SEARCH_STEPS_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Sets the maximum amount of steps performed in the horizontal/vertical pattern searches, at each side of the pixel.
   *
   * @deprecated Use orthogonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(value) {
    this.orthogonalSearchSteps = value;
  }
  /**
   * The maximum steps performed in the diagonal pattern searches, at each side of the pixel. This search
   * jumps one pixel at a time. Range: [0, 20].
   *
   * On high-end machines this search is cheap (between 0.8x and 0.9x slower for 16 steps), but it can have a
   * significant impact on older machines.
   *
   * @type {Number}
   */
  get diagonalSearchSteps() {
    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
  }
  set diagonalSearchSteps(value) {
    const s = Math.min(Math.max(value, 0), 20);
    this.defines.MAX_SEARCH_STEPS_DIAG_INT = s.toFixed("0");
    this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = s.toFixed("1");
    this.needsUpdate = true;
  }
  /**
   * Specifies the maximum steps performed in the diagonal pattern searches, at each side of the pixel.
   *
   * @deprecated Use diagonalSearchSteps instead.
   * @param {Number} value - The search steps. Range: [0, 20].
   */
  setDiagonalSearchSteps(value) {
    this.diagonalSearchSteps = value;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @type {Boolean}
   */
  get diagonalDetection() {
    return this.defines.DISABLE_DIAG_DETECTION === void 0;
  }
  set diagonalDetection(value) {
    if (value) {
      delete this.defines.DISABLE_DIAG_DETECTION;
    } else {
      this.defines.DISABLE_DIAG_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether diagonal pattern detection is enabled.
   *
   * @deprecated Use diagonalDetection instead.
   * @return {Boolean} Whether diagonal pattern detection is enabled.
   */
  isDiagonalDetectionEnabled() {
    return this.diagonalDetection;
  }
  /**
   * Enables or disables diagonal pattern detection.
   *
   * @deprecated Use diagonalDetection instead.
   * @param {Boolean} value - Whether diagonal pattern detection should be enabled.
   */
  setDiagonalDetectionEnabled(value) {
    this.diagonalDetection = value;
  }
  /**
   * Specifies how much sharp corners will be rounded. Range: [0, 100].
   *
   * @type {Number}
   */
  get cornerRounding() {
    return Number(this.defines.CORNER_ROUNDING);
  }
  set cornerRounding(value) {
    const r = Math.min(Math.max(value, 0), 100);
    this.defines.CORNER_ROUNDING = r.toFixed("4");
    this.defines.CORNER_ROUNDING_NORM = (r / 100).toFixed("4");
    this.needsUpdate = true;
  }
  /**
   * Specifies how much sharp corners will be rounded.
   *
   * @deprecated Use cornerRounding instead.
   * @param {Number} value - The corner rounding amount. Range: [0, 100].
   */
  setCornerRounding(value) {
    this.cornerRounding = value;
  }
  /**
   * Indicates whether corner detection is enabled.
   *
   * @type {Number}
   */
  get cornerDetection() {
    return this.defines.DISABLE_CORNER_DETECTION === void 0;
  }
  set cornerDetection(value) {
    if (value) {
      delete this.defines.DISABLE_CORNER_DETECTION;
    } else {
      this.defines.DISABLE_CORNER_DETECTION = "1";
    }
    this.needsUpdate = true;
  }
  /**
   * Indicates whether corner rounding is enabled.
   *
   * @deprecated Use cornerDetection instead.
   * @return {Boolean} Whether corner rounding is enabled.
   */
  isCornerRoundingEnabled() {
    return this.cornerDetection;
  }
  /**
   * Enables or disables corner rounding.
   *
   * @deprecated Use cornerDetection instead.
   * @param {Boolean} value - Whether corner rounding should be enabled.
   */
  setCornerRoundingEnabled(value) {
    this.cornerDetection = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    uniforms.texelSize.value.set(1 / width, 1 / height);
    uniforms.resolution.value.set(width, height);
  }
};

// src/materials/glsl/ssao.frag
var ssao_default = "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}";

// src/materials/glsl/ssao.vert
var ssao_default2 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/SSAOMaterial.js
var SSAOMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new SSAO material.
   *
   * @param {Camera} camera - A camera.
   */
  constructor(camera) {
    super({
      name: "SSAOMaterial",
      defines: {
        SAMPLES_INT: "0",
        INV_SAMPLES_FLOAT: "0.0",
        SPIRAL_TURNS: "0.0",
        RADIUS: "1.0",
        RADIUS_SQ: "1.0",
        DISTANCE_SCALING: "1",
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Uniform(null),
        normalBuffer: new Uniform(null),
        normalDepthBuffer: new Uniform(null),
        noiseTexture: new Uniform(null),
        inverseProjectionMatrix: new Uniform(new Matrix4()),
        projectionMatrix: new Uniform(new Matrix4()),
        texelSize: new Uniform(new Vector2()),
        cameraNearFar: new Uniform(new Vector2()),
        distanceCutoff: new Uniform(new Vector2()),
        proximityCutoff: new Uniform(new Vector2()),
        noiseScale: new Uniform(new Vector2()),
        minRadiusScale: new Uniform(0.33),
        intensity: new Uniform(1),
        fade: new Uniform(0.01),
        bias: new Uniform(0)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: ssao_default,
      vertexShader: ssao_default2
    });
    this.toneMapped = false;
    this.copyCameraSettings(camera);
    this.resolution = new Vector2();
    this.r = 1;
  }
  /**
   * The current near plane setting.
   *
   * @type {Number}
   * @private
   */
  get near() {
    return this.uniforms.cameraNearFar.value.x;
  }
  /**
   * The current far plane setting.
   *
   * @type {Number}
   * @private
   */
  get far() {
    return this.uniforms.cameraNearFar.value.y;
  }
  /**
   * A combined normal-depth buffer.
   *
   * @type {Texture}
   */
  set normalDepthBuffer(value) {
    this.uniforms.normalDepthBuffer.value = value;
    if (value !== null) {
      this.defines.NORMAL_DEPTH = "1";
    } else {
      delete this.defines.NORMAL_DEPTH;
    }
    this.needsUpdate = true;
  }
  /**
   * Sets the combined normal-depth buffer.
   *
   * @deprecated Use normalDepthBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalDepthBuffer(value) {
    this.normalDepthBuffer = value;
  }
  /**
   * The normal buffer.
   *
   * @type {Texture}
   */
  set normalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * Sets the normal buffer.
   *
   * @deprecated Use normalBuffer instead.
   * @param {Number} value - The buffer.
   */
  setNormalBuffer(value) {
    this.uniforms.normalBuffer.value = value;
  }
  /**
   * The depth buffer.
   *
   * @type {Texture}
   */
  set depthBuffer(value) {
    this.uniforms.depthBuffer.value = value;
  }
  /**
   * The depth packing strategy.
   *
   * @type {DepthPackingStrategies}
   */
  set depthPacking(value) {
    this.defines.DEPTH_PACKING = value.toFixed(0);
    this.needsUpdate = true;
  }
  /**
   * Sets the depth buffer.
   *
   * @deprecated Use depthBuffer and depthPacking instead.
   * @param {Texture} buffer - The depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthBuffer(buffer, depthPacking = BasicDepthPacking) {
    this.depthBuffer = buffer;
    this.depthPacking = depthPacking;
  }
  /**
   * The noise texture.
   *
   * @type {Texture}
   */
  set noiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * Sets the noise texture.
   *
   * @deprecated Use noiseTexture instead.
   * @param {Number} value - The texture.
   */
  setNoiseTexture(value) {
    this.uniforms.noiseTexture.value = value;
  }
  /**
   * The sample count.
   *
   * @type {Number}
   */
  get samples() {
    return Number(this.defines.SAMPLES_INT);
  }
  set samples(value) {
    this.defines.SAMPLES_INT = value.toFixed(0);
    this.defines.INV_SAMPLES_FLOAT = (1 / value).toFixed(9);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @return {Number} The sample count.
   */
  getSamples() {
    return this.samples;
  }
  /**
   * Sets the amount of occlusion samples per pixel.
   *
   * @deprecated Use samples instead.
   * @param {Number} value - The sample count.
   */
  setSamples(value) {
    this.samples = value;
  }
  /**
   * The sampling spiral ring count.
   *
   * @type {Number}
   */
  get rings() {
    return Number(this.defines.SPIRAL_TURNS);
  }
  set rings(value) {
    this.defines.SPIRAL_TURNS = value.toFixed(1);
    this.needsUpdate = true;
  }
  /**
   * Returns the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @return {Number} The radius.
   */
  getRings() {
    return this.rings;
  }
  /**
   * Sets the amount of spiral turns in the occlusion sampling pattern.
   *
   * @deprecated Use rings instead.
   * @param {Number} value - The radius.
   */
  setRings(value) {
    this.rings = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   * @deprecated Use SSAOEffect.intensity instead.
   */
  get intensity() {
    return this.uniforms.intensity.value;
  }
  set intensity(value) {
    this.uniforms.intensity.value = value;
    if (this.defines.LEGACY_INTENSITY === void 0) {
      this.defines.LEGACY_INTENSITY = "1";
      this.needsUpdate = true;
    }
  }
  /**
   * Returns the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.uniforms.intensity.value;
  }
  /**
   * Sets the intensity.
   *
   * @deprecated Use SSAOEffect.intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.uniforms.intensity.value = value;
  }
  /**
   * The depth fade factor.
   *
   * @type {Number}
   */
  get fade() {
    return this.uniforms.fade.value;
  }
  set fade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * Returns the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @return {Number} The fade factor.
   */
  getFade() {
    return this.uniforms.fade.value;
  }
  /**
   * Sets the depth fade factor.
   *
   * @deprecated Use fade instead.
   * @param {Number} value - The fade factor.
   */
  setFade(value) {
    this.uniforms.fade.value = value;
  }
  /**
   * The depth bias. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get bias() {
    return this.uniforms.bias.value;
  }
  set bias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * Returns the depth bias.
   *
   * @deprecated Use bias instead.
   * @return {Number} The bias.
   */
  getBias() {
    return this.uniforms.bias.value;
  }
  /**
   * Sets the depth bias.
   *
   * @deprecated Use bias instead.
   * @param {Number} value - The bias.
   */
  setBias(value) {
    this.uniforms.bias.value = value;
  }
  /**
   * The minimum radius scale for distance scaling. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get minRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  set minRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Returns the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @return {Number} The minimum radius scale.
   */
  getMinRadiusScale() {
    return this.uniforms.minRadiusScale.value;
  }
  /**
   * Sets the minimum radius scale for distance scaling.
   *
   * @deprecated Use minRadiusScale instead.
   * @param {Number} value - The minimum radius scale.
   */
  setMinRadiusScale(value) {
    this.uniforms.minRadiusScale.value = value;
  }
  /**
   * Updates the absolute radius.
   *
   * @private
   */
  updateRadius() {
    const radius = this.r * this.resolution.height;
    this.defines.RADIUS = radius.toFixed(11);
    this.defines.RADIUS_SQ = (radius * radius).toFixed(11);
    this.needsUpdate = true;
  }
  /**
   * The occlusion sampling radius. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get radius() {
    return this.r;
  }
  set radius(value) {
    this.r = Math.min(Math.max(value, 1e-6), 1);
    this.updateRadius();
  }
  /**
   * Returns the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @return {Number} The radius.
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Sets the occlusion sampling radius.
   *
   * @deprecated Use radius instead.
   * @param {Number} value - The radius. Range [1e-6, 1.0].
   */
  setRadius(value) {
    this.radius = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @deprecated
   * @return {Boolean} Whether distance scaling is enabled.
   */
  isDistanceScalingEnabled() {
    return this.distanceScaling;
  }
  /**
   * Enables or disables distance-based radius scaling.
   *
   * @deprecated
   * @param {Boolean} value - Whether distance scaling should be enabled.
   */
  setDistanceScalingEnabled(value) {
    this.distanceScaling = value;
  }
  /**
   * The occlusion distance threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceThreshold() {
    return this.uniforms.distanceCutoff.value.x;
  }
  set distanceThreshold(value) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.distanceFalloff, 0), 1)
    );
  }
  /**
   * The occlusion distance threshold in world units.
   *
   * @type {Number}
   */
  get worldDistanceThreshold() {
    return -orthographicDepthToViewZ(this.distanceThreshold, this.near, this.far);
  }
  set worldDistanceThreshold(value) {
    this.distanceThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion distance falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get distanceFalloff() {
    return this.uniforms.distanceCutoff.value.y - this.distanceThreshold;
  }
  set distanceFalloff(value) {
    this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + value, 0), 1);
  }
  /**
   * The occlusion distance falloff in world units.
   *
   * @type {Number}
   */
  get worldDistanceFalloff() {
    return -orthographicDepthToViewZ(this.distanceFalloff, this.near, this.far);
  }
  set worldDistanceFalloff(value) {
    this.distanceFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use distanceThreshold and distanceFalloff instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.uniforms.distanceCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityThreshold() {
    return this.uniforms.proximityCutoff.value.x;
  }
  set proximityThreshold(value) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(value, 0), 1),
      Math.min(Math.max(value + this.proximityFalloff, 0), 1)
    );
  }
  /**
   * The occlusion proximity threshold in world units.
   *
   * @type {Number}
   */
  get worldProximityThreshold() {
    return -orthographicDepthToViewZ(this.proximityThreshold, this.near, this.far);
  }
  set worldProximityThreshold(value) {
    this.proximityThreshold = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * The occlusion proximity falloff. Range: [0.0, 1.0].
   *
   * @type {Number}
   */
  get proximityFalloff() {
    return this.uniforms.proximityCutoff.value.y - this.proximityThreshold;
  }
  set proximityFalloff(value) {
    this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + value, 0), 1);
  }
  /**
   * The occlusion proximity falloff in world units.
   *
   * @type {Number}
   */
  get worldProximityFalloff() {
    return -orthographicDepthToViewZ(this.proximityFalloff, this.near, this.far);
  }
  set worldProximityFalloff(value) {
    this.proximityFalloff = viewZToOrthographicDepth(-value, this.near, this.far);
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use proximityThreshold and proximityFalloff instead.
   * @param {Number} threshold - The range threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.uniforms.proximityCutoff.value.set(
      Math.min(Math.max(threshold, 0), 1),
      Math.min(Math.max(threshold + falloff, 0), 1)
    );
  }
  /**
   * Sets the texel size.
   *
   * @deprecated Use setSize() instead.
   * @param {Number} x - The texel width.
   * @param {Number} y - The texel height.
   */
  setTexelSize(x, y) {
    this.uniforms.texelSize.value.set(x, y);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @deprecated Use copyCameraSettings instead.
   * @param {Camera} camera - A camera.
   */
  adoptCameraSettings(camera) {
    this.copyCameraSettings(camera);
  }
  /**
   * Copies the settings of the given camera.
   *
   * @param {Camera} camera - A camera.
   */
  copyCameraSettings(camera) {
    if (camera) {
      this.uniforms.cameraNearFar.value.set(camera.near, camera.far);
      this.uniforms.projectionMatrix.value.copy(camera.projectionMatrix);
      this.uniforms.inverseProjectionMatrix.value.copy(camera.projectionMatrix).invert();
      if (camera instanceof PerspectiveCamera) {
        this.defines.PERSPECTIVE_CAMERA = "1";
      } else {
        delete this.defines.PERSPECTIVE_CAMERA;
      }
      this.needsUpdate = true;
    }
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const uniforms = this.uniforms;
    const noiseTexture = uniforms.noiseTexture.value;
    if (noiseTexture !== null) {
      uniforms.noiseScale.value.set(
        width / noiseTexture.image.width,
        height / noiseTexture.image.height
      );
    }
    uniforms.texelSize.value.set(1 / width, 1 / height);
    this.resolution.set(width, height);
    this.updateRadius();
  }
};

// src/materials/glsl/convolution.upsampling.frag
var convolution_upsampling_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <encodings_fragment>\n}";

// src/materials/glsl/convolution.upsampling.vert
var convolution_upsampling_default2 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}";

// src/materials/UpsamplingMaterial.js
var UpsamplingMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new upsampling material.
   */
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Uniform(null),
        supportBuffer: new Uniform(null),
        texelSize: new Uniform(new Vector2()),
        radius: new Uniform(0.85)
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      fragmentShader: convolution_upsampling_default,
      vertexShader: convolution_upsampling_default2
    });
    this.toneMapped = false;
  }
  /**
   * The input buffer.
   *
   * @type {Texture}
   */
  set inputBuffer(value) {
    this.uniforms.inputBuffer.value = value;
  }
  /**
   * A support buffer.
   *
   * @type {Texture}
   */
  set supportBuffer(value) {
    this.uniforms.supportBuffer.value = value;
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(value) {
    this.uniforms.radius.value = value;
  }
  /**
   * Sets the size of this object.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.uniforms.texelSize.value.set(1 / width, 1 / height);
  }
};
var dummyCamera = new Camera();
var geometry = null;
function getFullscreenTriangle() {
  if (geometry === null) {
    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);
    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);
    geometry = new BufferGeometry();
    if (geometry.setAttribute !== void 0) {
      geometry.setAttribute("position", new BufferAttribute(vertices, 3));
      geometry.setAttribute("uv", new BufferAttribute(uvs, 2));
    } else {
      geometry.addAttribute("position", new BufferAttribute(vertices, 3));
      geometry.addAttribute("uv", new BufferAttribute(uvs, 2));
    }
  }
  return geometry;
}
var Pass = class {
  /**
   * Constructs a new pass.
   *
   * @param {String} [name] - The name of this pass. Does not have to be unique.
   * @param {Scene} [scene] - The scene to render. The default scene contains a single mesh that fills the screen.
   * @param {Camera} [camera] - A camera. Fullscreen effect passes don't require a camera.
   */
  constructor(name = "Pass", scene = new Scene(), camera = dummyCamera) {
    this.name = name;
    this.renderer = null;
    this.scene = scene;
    this.camera = camera;
    this.screen = null;
    this.rtt = true;
    this.needsSwap = true;
    this.needsDepthTexture = false;
    this.enabled = true;
  }
  /**
   * Sets the render to screen flag.
   *
   * If this flag is changed, the fullscreen material will be updated as well.
   *
   * @type {Boolean}
   */
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(value) {
    if (this.rtt === value) {
      const material = this.fullscreenMaterial;
      if (material !== null) {
        material.needsUpdate = true;
      }
      this.rtt = !value;
    }
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Sets the renderer
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Indicates whether this pass is enabled.
   *
   * @deprecated Use enabled instead.
   * @return {Boolean} Whether this pass is enabled.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables this pass.
   *
   * @deprecated Use enabled instead.
   * @param {Boolean} value - Whether the pass should be enabled.
   */
  setEnabled(value) {
    this.enabled = value;
  }
  /**
   * The fullscreen material.
   *
   * @type {Material}
   */
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(value) {
    let screen = this.screen;
    if (screen !== null) {
      screen.material = value;
    } else {
      screen = new Mesh(getFullscreenTriangle(), value);
      screen.frustumCulled = false;
      if (this.scene === null) {
        this.scene = new Scene();
      }
      this.scene.add(screen);
      this.screen = screen;
    }
  }
  /**
   * Returns the current fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @return {Material} The current fullscreen material, or null if there is none.
   */
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  /**
   * Sets the fullscreen material.
   *
   * @deprecated Use fullscreenMaterial instead.
   * @protected
   * @param {Material} value - A fullscreen material.
   */
  setFullscreenMaterial(value) {
    this.fullscreenMaterial = value;
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return null;
  }
  /**
   * Sets the depth texture.
   *
   * This method will be called automatically by the {@link EffectComposer}.
   * You may override this method if your pass relies on the depth information of a preceding {@link RenderPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategy} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Renders this pass.
   *
   * This is an abstract method that must be overridden.
   *
   * @abstract
   * @throws {Error} An error is thrown if the method is not overridden.
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    throw new Error("Render method not implemented!");
  }
  /**
   * Sets the size.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when this pass is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for disposable properties and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed. You can use it independently to free
   * memory when you're certain that you don't need this pass anymore.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/passes/CopyPass.js
var CopyPass = class extends Pass {
  /**
   * Constructs a new save pass.
   *
   * @param {WebGLRenderTarget} [renderTarget] - A render target.
   * @param {Boolean} [autoResize=true] - Whether the render target size should be updated automatically.
   */
  constructor(renderTarget, autoResize = true) {
    super("CopyPass");
    this.fullscreenMaterial = new CopyMaterial();
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      });
      this.renderTarget.texture.name = "CopyPass.Target";
    }
    this.autoResize = autoResize;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @type {Boolean}
   */
  get resize() {
    return this.autoResize;
  }
  set resize(value) {
    this.autoResize = value;
  }
  /**
   * The output texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the output texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Enables or disables auto resizing of the render target.
   *
   * @deprecated Use autoResize instead.
   * @param {Boolean} value - Whether the render target size should be updated automatically.
   */
  setAutoResizeEnabled(value) {
    this.autoResize = value;
  }
  /**
   * Saves the input buffer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    this.fullscreenMaterial.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    if (this.autoResize) {
      this.renderTarget.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
      }
    }
  }
};

// src/passes/ClearMaskPass.js
var ClearMaskPass = class extends Pass {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super("ClearMaskPass", null, null);
    this.needsSwap = false;
  }
  /**
   * Disables the global stencil test.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const stencil = renderer.state.buffers.stencil;
    stencil.setLocked(false);
    stencil.setTest(false);
  }
};
var color = new Color();
var ClearPass = class extends Pass {
  /**
   * Constructs a new clear pass.
   *
   * @param {Boolean} [color=true] - Determines whether the color buffer should be cleared.
   * @param {Boolean} [depth=true] - Determines whether the depth buffer should be cleared.
   * @param {Boolean} [stencil=false] - Determines whether the stencil buffer should be cleared.
   */
  constructor(color2 = true, depth = true, stencil = false) {
    super("ClearPass", null, null);
    this.needsSwap = false;
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
    this.overrideClearColor = null;
    this.overrideClearAlpha = -1;
  }
  /**
   * Sets the clear flags.
   *
   * @param {Boolean} color - Whether the color buffer should be cleared.
   * @param {Boolean} depth - Whether the depth buffer should be cleared.
   * @param {Boolean} stencil - Whether the stencil buffer should be cleared.
   */
  setClearFlags(color2, depth, stencil) {
    this.color = color2;
    this.depth = depth;
    this.stencil = stencil;
  }
  /**
   * Returns the override clear color. Default is null.
   *
   * @deprecated Use overrideClearColor instead.
   * @return {Color} The clear color.
   */
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  /**
   * Sets the override clear color.
   *
   * @deprecated Use overrideClearColor instead.
   * @param {Color} value - The clear color.
   */
  setOverrideClearColor(value) {
    this.overrideClearColor = value;
  }
  /**
   * Returns the override clear alpha. Default is -1.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @return {Number} The clear alpha.
   */
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  /**
   * Sets the override clear alpha.
   *
   * @deprecated Use overrideClearAlpha instead.
   * @param {Number} value - The clear alpha.
   */
  setOverrideClearAlpha(value) {
    this.overrideClearAlpha = value;
  }
  /**
   * Clears the input buffer or the screen.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const overrideClearColor = this.overrideClearColor;
    const overrideClearAlpha = this.overrideClearAlpha;
    const clearAlpha = renderer.getClearAlpha();
    const hasOverrideClearColor = overrideClearColor !== null;
    const hasOverrideClearAlpha = overrideClearAlpha >= 0;
    if (hasOverrideClearColor) {
      renderer.getClearColor(color);
      renderer.setClearColor(overrideClearColor, hasOverrideClearAlpha ? overrideClearAlpha : clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(overrideClearAlpha);
    }
    renderer.setRenderTarget(this.renderToScreen ? null : inputBuffer);
    renderer.clear(this.color, this.depth, this.stencil);
    if (hasOverrideClearColor) {
      renderer.setClearColor(color, clearAlpha);
    } else if (hasOverrideClearAlpha) {
      renderer.setClearAlpha(clearAlpha);
    }
  }
};
var AUTO_SIZE = -1;
var Resolution = class extends EventDispatcher {
  /**
   * Constructs a new resolution.
   *
   * TODO Remove resizable param.
   * @param {Resizable} resizable - A resizable object.
   * @param {Number} [width=Resolution.AUTO_SIZE] - The preferred width.
   * @param {Number} [height=Resolution.AUTO_SIZE] - The preferred height.
   * @param {Number} [scale=1.0] - A resolution scale.
   */
  constructor(resizable, width = AUTO_SIZE, height = AUTO_SIZE, scale = 1) {
    super();
    this.resizable = resizable;
    this.baseSize = new Vector2(1, 1);
    this.preferredSize = new Vector2(width, height);
    this.target = this.preferredSize;
    this.s = scale;
    this.effectiveSize = new Vector2();
    this.addEventListener("change", () => this.updateEffectiveSize());
    this.updateEffectiveSize();
  }
  /**
   * Calculates the effective size.
   *
   * @private
   */
  updateEffectiveSize() {
    const base = this.baseSize;
    const preferred = this.preferredSize;
    const effective = this.effectiveSize;
    const scale = this.scale;
    if (preferred.width !== AUTO_SIZE) {
      effective.width = preferred.width;
    } else if (preferred.height !== AUTO_SIZE) {
      effective.width = Math.round(preferred.height * (base.width / Math.max(base.height, 1)));
    } else {
      effective.width = Math.round(base.width * scale);
    }
    if (preferred.height !== AUTO_SIZE) {
      effective.height = preferred.height;
    } else if (preferred.width !== AUTO_SIZE) {
      effective.height = Math.round(preferred.width / Math.max(base.width / Math.max(base.height, 1), 1));
    } else {
      effective.height = Math.round(base.height * scale);
    }
  }
  /**
   * The effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @type {Number}
   */
  get width() {
    return this.effectiveSize.width;
  }
  set width(value) {
    this.preferredWidth = value;
  }
  /**
   * The effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @type {Number}
   */
  get height() {
    return this.effectiveSize.height;
  }
  set height(value) {
    this.preferredHeight = value;
  }
  /**
   * Returns the effective width.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base width will be returned.
   *
   * @deprecated Use width instead.
   * @return {Number} The effective width.
   */
  getWidth() {
    return this.width;
  }
  /**
   * Returns the effective height.
   *
   * If the preferred width and height are set to {@link Resizer.AUTO_SIZE}, the base height will be returned.
   *
   * @deprecated Use height instead.
   * @return {Number} The effective height.
   */
  getHeight() {
    return this.height;
  }
  /**
   * The resolution scale.
   *
   * @type {Number}
   */
  get scale() {
    return this.s;
  }
  set scale(value) {
    if (this.s !== value) {
      this.s = value;
      this.preferredSize.setScalar(AUTO_SIZE);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the current resolution scale.
   *
   * @deprecated Use scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * Also sets the preferred resolution to {@link Resizer.AUTO_SIZE}.
   *
   * @deprecated Use scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.scale = value;
  }
  /**
   * The base width.
   *
   * @type {Number}
   */
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(value) {
    if (this.baseSize.width !== value) {
      this.baseSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base width.
   *
   * @deprecated Use baseWidth instead.
   * @return {Number} The base width.
   */
  getBaseWidth() {
    return this.baseWidth;
  }
  /**
   * Sets the base width.
   *
   * @deprecated Use baseWidth instead.
   * @param {Number} value - The width.
   */
  setBaseWidth(value) {
    this.baseWidth = value;
  }
  /**
   * The base height.
   *
   * @type {Number}
   */
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(value) {
    if (this.baseSize.height !== value) {
      this.baseSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the base height.
   *
   * @deprecated Use baseHeight instead.
   * @return {Number} The base height.
   */
  getBaseHeight() {
    return this.baseHeight;
  }
  /**
   * Sets the base height.
   *
   * @deprecated Use baseHeight instead.
   * @param {Number} value - The height.
   */
  setBaseHeight(value) {
    this.baseHeight = value;
  }
  /**
   * Sets the base size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setBaseSize(width, height) {
    if (this.baseSize.width !== width || this.baseSize.height !== height) {
      this.baseSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * The preferred width.
   *
   * @type {Number}
   */
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(value) {
    if (this.preferredSize.width !== value) {
      this.preferredSize.width = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred width.
   *
   * @deprecated Use preferredWidth instead.
   * @return {Number} The preferred width.
   */
  getPreferredWidth() {
    return this.preferredWidth;
  }
  /**
   * Sets the preferred width.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the width based on the height and aspect ratio.
   *
   * @deprecated Use preferredWidth instead.
   * @param {Number} value - The width.
   */
  setPreferredWidth(value) {
    this.preferredWidth = value;
  }
  /**
   * The preferred height.
   *
   * @type {Number}
   */
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(value) {
    if (this.preferredSize.height !== value) {
      this.preferredSize.height = value;
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Returns the preferred height.
   *
   * @deprecated Use preferredHeight instead.
   * @return {Number} The preferred height.
   */
  getPreferredHeight() {
    return this.preferredHeight;
  }
  /**
   * Sets the preferred height.
   *
   * Use {@link Resizer.AUTO_SIZE} to automatically calculate the height based on the width and aspect ratio.
   *
   * @deprecated Use preferredHeight instead.
   * @param {Number} value - The height.
   */
  setPreferredHeight(value) {
    this.preferredHeight = value;
  }
  /**
   * Sets the preferred size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setPreferredSize(width, height) {
    if (this.preferredSize.width !== width || this.preferredSize.height !== height) {
      this.preferredSize.set(width, height);
      this.dispatchEvent({ type: "change" });
      this.resizable.setSize(this.baseSize.width, this.baseSize.height);
    }
  }
  /**
   * Copies the given resolution.
   *
   * @param {Resolution} resolution - The resolution.
   */
  copy(resolution) {
    this.s = resolution.scale;
    this.baseSize.set(resolution.baseWidth, resolution.baseHeight);
    this.preferredSize.set(resolution.preferredWidth, resolution.preferredHeight);
    this.dispatchEvent({ type: "change" });
    this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  /**
   * An auto sizing constant.
   *
   * Can be used to automatically calculate the width or height based on the original aspect ratio.
   *
   * @type {Number}
   */
  static get AUTO_SIZE() {
    return AUTO_SIZE;
  }
};
var workaroundEnabled = false;
var OverrideMaterialManager = class {
  /**
   * Constructs a new override material manager.
   *
   * @param {Material} [material=null] - An override material.
   */
  constructor(material = null) {
    this.originalMaterials = /* @__PURE__ */ new Map();
    this.material = null;
    this.materials = null;
    this.materialsBackSide = null;
    this.materialsDoubleSide = null;
    this.materialsFlatShaded = null;
    this.materialsFlatShadedBackSide = null;
    this.materialsFlatShadedDoubleSide = null;
    this.setMaterial(material);
    this.meshCount = 0;
    this.replaceMaterial = (node) => {
      if (node.isMesh) {
        let materials;
        if (node.material.flatShading) {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsFlatShadedDoubleSide;
              break;
            case BackSide:
              materials = this.materialsFlatShadedBackSide;
              break;
            default:
              materials = this.materialsFlatShaded;
              break;
          }
        } else {
          switch (node.material.side) {
            case DoubleSide:
              materials = this.materialsDoubleSide;
              break;
            case BackSide:
              materials = this.materialsBackSide;
              break;
            default:
              materials = this.materials;
              break;
          }
        }
        this.originalMaterials.set(node, node.material);
        if (node.isSkinnedMesh) {
          node.material = materials[2];
        } else if (node.isInstancedMesh) {
          node.material = materials[1];
        } else {
          node.material = materials[0];
        }
        ++this.meshCount;
      }
    };
  }
  /**
   * Sets the override material.
   *
   * @param {Material} material - The material.
   */
  setMaterial(material) {
    this.disposeMaterials();
    this.material = material;
    if (material !== null) {
      const materials = this.materials = [
        material.clone(),
        material.clone(),
        material.clone()
      ];
      for (const m2 of materials) {
        m2.uniforms = Object.assign({}, material.uniforms);
        m2.side = FrontSide;
      }
      materials[2].skinning = true;
      this.materialsBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = BackSide;
        return c2;
      });
      this.materialsDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.side = DoubleSide;
        return c2;
      });
      this.materialsFlatShaded = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        return c2;
      });
      this.materialsFlatShadedBackSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = BackSide;
        return c2;
      });
      this.materialsFlatShadedDoubleSide = materials.map((m2) => {
        const c2 = m2.clone();
        c2.uniforms = Object.assign({}, material.uniforms);
        c2.flatShading = true;
        c2.side = DoubleSide;
        return c2;
      });
    }
  }
  /**
   * Renders the scene with the override material.
   *
   * @private
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - A scene.
   * @param {Camera} camera - A camera.
   */
  render(renderer, scene, camera) {
    const shadowMapEnabled = renderer.shadowMap.enabled;
    renderer.shadowMap.enabled = false;
    if (workaroundEnabled) {
      const originalMaterials = this.originalMaterials;
      this.meshCount = 0;
      scene.traverse(this.replaceMaterial);
      renderer.render(scene, camera);
      for (const entry of originalMaterials) {
        entry[0].material = entry[1];
      }
      if (this.meshCount !== originalMaterials.size) {
        originalMaterials.clear();
      }
    } else {
      const overrideMaterial = scene.overrideMaterial;
      scene.overrideMaterial = this.material;
      renderer.render(scene, camera);
      scene.overrideMaterial = overrideMaterial;
    }
    renderer.shadowMap.enabled = shadowMapEnabled;
  }
  /**
   * Deletes cloned override materials.
   *
   * @private
   */
  disposeMaterials() {
    if (this.material !== null) {
      const materials = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const m2 of materials) {
        m2.dispose();
      }
    }
  }
  /**
   * Performs cleanup tasks.
   */
  dispose() {
    this.originalMaterials.clear();
    this.disposeMaterials();
  }
  /**
   * Indicates whether the override material workaround is enabled.
   *
   * @type {Boolean}
   */
  static get workaroundEnabled() {
    return workaroundEnabled;
  }
  /**
   * Enables or disables the override material workaround globally.
   *
   * This only affects post processing passes and effects.
   *
   * @type {Boolean}
   */
  static set workaroundEnabled(value) {
    workaroundEnabled = value;
  }
};

// src/passes/RenderPass.js
var RenderPass = class extends Pass {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Material} [overrideMaterial=null] - An override material.
   */
  constructor(scene, camera, overrideMaterial = null) {
    super("RenderPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass();
    this.overrideMaterialManager = overrideMaterial === null ? null : new OverrideMaterialManager(overrideMaterial);
    this.ignoreBackground = false;
    this.skipShadowMapUpdate = false;
    this.selection = null;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(value) {
    super.renderToScreen = value;
    this.clearPass.renderToScreen = value;
  }
  /**
   * The current override material.
   *
   * @type {Material}
   */
  get overrideMaterial() {
    const manager = this.overrideMaterialManager;
    return manager !== null ? manager.material : null;
  }
  set overrideMaterial(value) {
    const manager = this.overrideMaterialManager;
    if (value !== null) {
      if (manager !== null) {
        manager.setMaterial(value);
      } else {
        this.overrideMaterialManager = new OverrideMaterialManager(value);
      }
    } else if (manager !== null) {
      manager.dispose();
      this.overrideMaterialManager = null;
    }
  }
  /**
   * Returns the current override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} The material.
   */
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  /**
   * Sets the override material.
   *
   * @deprecated Use overrideMaterial instead.
   * @return {Material} value - The material.
   */
  setOverrideMaterial(value) {
    this.overrideMaterial = value;
  }
  /**
   * Indicates whether the target buffer should be cleared before rendering.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the selection. Default is `null` (no restriction).
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Sets the selection. Set to `null` to disable.
   *
   * @deprecated Use selection instead.
   * @param {Selection} value - The selection.
   */
  setSelection(value) {
    this.selection = value;
  }
  /**
   * Indicates whether the scene background is disabled.
   *
   * @deprecated Use ignoreBackground instead.
   * @return {Boolean} Whether the scene background is disabled.
   */
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  /**
   * Enables or disables the scene background.
   *
   * @deprecated Use ignoreBackground instead.
   * @param {Boolean} value - Whether the scene background should be disabled.
   */
  setBackgroundDisabled(value) {
    this.ignoreBackground = value;
  }
  /**
   * Indicates whether the shadow map auto update is disabled.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @return {Boolean} Whether the shadow map update is disabled.
   */
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  /**
   * Enables or disables the shadow map auto update.
   *
   * @deprecated Use skipShadowMapUpdate instead.
   * @param {Boolean} value - Whether the shadow map auto update should be disabled.
   */
  setShadowMapDisabled(value) {
    this.skipShadowMapUpdate = value;
  }
  /**
   * Returns the clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Renders the scene.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const mask = camera.layers.mask;
    const background = scene.background;
    const shadowMapAutoUpdate = renderer.shadowMap.autoUpdate;
    const renderTarget = this.renderToScreen ? null : inputBuffer;
    if (selection !== null) {
      camera.layers.set(selection.getLayer());
    }
    if (this.skipShadowMapUpdate) {
      renderer.shadowMap.autoUpdate = false;
    }
    if (this.ignoreBackground || this.clearPass.overrideClearColor !== null) {
      scene.background = null;
    }
    if (this.clearPass.enabled) {
      this.clearPass.render(renderer, inputBuffer);
    }
    renderer.setRenderTarget(renderTarget);
    if (this.overrideMaterialManager !== null) {
      this.overrideMaterialManager.render(renderer, scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    camera.layers.mask = mask;
    scene.background = background;
    renderer.shadowMap.autoUpdate = shadowMapAutoUpdate;
  }
};

// src/passes/DepthPass.js
var DepthPass = class extends Pass {
  /**
   * Constructs a new depth pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshDepthMaterial({
      depthPacking: RGBADepthPacking
    }));
    const renderPass = this.renderPass;
    renderPass.skipShadowMapUpdate = true;
    renderPass.ignoreBackground = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "DepthPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The depth texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the depth texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene depth.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var DepthDownsamplingPass = class extends Pass {
  /**
   * Constructs a new depth downsampling pass.
   *
   * @param {Object} [options] - The options.
   * @param {Texture} [options.normalBuffer=null] - A texture that contains view space normals. See {@link NormalPass}.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    normalBuffer = null,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("DepthDownsamplingPass");
    const material = new DepthDownsamplingMaterial();
    material.normalBuffer = normalBuffer;
    this.fullscreenMaterial = material;
    this.needsDepthTexture = true;
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false,
      type: FloatType
    });
    this.renderTarget.texture.name = "DepthDownsamplingPass.Target";
    this.renderTarget.texture.generateMipmaps = false;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The normal(RGB) + depth(A) texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the normal(RGB) + depth(A) texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing strategy.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
  }
  /**
   * Downsamples depth and scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.fullscreenMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    const gl = renderer.getContext();
    const renderable = gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float");
    if (!renderable) {
      throw new Error("Rendering to float texture is not supported.");
    }
  }
};
function prefixSubstrings(prefix, substrings, strings) {
  for (const substring of substrings) {
    const prefixed = "$1" + prefix + substring.charAt(0).toUpperCase() + substring.slice(1);
    const regExp = new RegExp("([^\\.])(\\b" + substring + "\\b)", "g");
    for (const entry of strings.entries()) {
      if (entry[1] !== null) {
        strings.set(entry[0], entry[1].replace(regExp, prefixed));
      }
    }
  }
}
function integrateEffect(prefix, effect, data) {
  var _a, _b, _c, _d, _e;
  let fragmentShader = effect.getFragmentShader();
  let vertexShader = effect.getVertexShader();
  const mainImageExists = fragmentShader !== void 0 && /mainImage/.test(fragmentShader);
  const mainUvExists = fragmentShader !== void 0 && /mainUv/.test(fragmentShader);
  data.attributes |= effect.getAttributes();
  if (fragmentShader === void 0) {
    throw new Error(`Missing fragment shader (${effect.name})`);
  } else if (mainUvExists && (data.attributes & EffectAttribute.CONVOLUTION) !== 0) {
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${effect.name})`);
  } else if (!mainImageExists && !mainUvExists) {
    throw new Error(`Could not find mainImage or mainUv function (${effect.name})`);
  } else {
    const functionRegExp = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g;
    const shaderParts = data.shaderParts;
    let fragmentHead = (_a = shaderParts.get(EffectShaderSection.FRAGMENT_HEAD)) != null ? _a : "";
    let fragmentMainUv = (_b = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV)) != null ? _b : "";
    let fragmentMainImage = (_c = shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE)) != null ? _c : "";
    let vertexHead = (_d = shaderParts.get(EffectShaderSection.VERTEX_HEAD)) != null ? _d : "";
    let vertexMainSupport = (_e = shaderParts.get(EffectShaderSection.VERTEX_MAIN_SUPPORT)) != null ? _e : "";
    const varyings = /* @__PURE__ */ new Set();
    const names = /* @__PURE__ */ new Set();
    if (mainUvExists) {
      fragmentMainUv += `	${prefix}MainUv(UV);
`;
      data.uvTransformation = true;
    }
    if (vertexShader !== null && /mainSupport/.test(vertexShader)) {
      const needsUv = /mainSupport *\([\w\s]*?uv\s*?\)/.test(vertexShader);
      vertexMainSupport += `	${prefix}MainSupport(`;
      vertexMainSupport += needsUv ? "vUv);\n" : ");\n";
      for (const m2 of vertexShader.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) {
        for (const n of m2[1].split(/\s*,\s*/)) {
          data.varyings.add(n);
          varyings.add(n);
          names.add(n);
        }
      }
      for (const m2 of vertexShader.matchAll(functionRegExp)) {
        names.add(m2[1]);
      }
    }
    for (const m2 of fragmentShader.matchAll(functionRegExp)) {
      names.add(m2[1]);
    }
    for (const d of effect.defines.keys()) {
      names.add(d.replace(/\([\w\s,]*\)/g, ""));
    }
    for (const u of effect.uniforms.keys()) {
      names.add(u);
    }
    names.delete("while");
    names.delete("for");
    names.delete("if");
    effect.uniforms.forEach((val, key) => data.uniforms.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    effect.defines.forEach((val, key) => data.defines.set(prefix + key.charAt(0).toUpperCase() + key.slice(1), val));
    const shaders = /* @__PURE__ */ new Map([["fragment", fragmentShader], ["vertex", vertexShader]]);
    prefixSubstrings(prefix, names, data.defines);
    prefixSubstrings(prefix, names, shaders);
    fragmentShader = shaders.get("fragment");
    vertexShader = shaders.get("vertex");
    const blendMode = effect.blendMode;
    data.blendModes.set(blendMode.blendFunction, blendMode);
    if (mainImageExists) {
      if (effect.inputColorSpace !== null && effect.inputColorSpace !== data.colorSpace) {
        fragmentMainImage += effect.inputColorSpace === sRGBEncoding ? "color0 = LinearTosRGB(color0);\n	" : "color0 = sRGBToLinear(color0);\n	";
      }
      if (effect.outputColorSpace !== null) {
        data.colorSpace = effect.outputColorSpace;
      } else if (effect.inputColorSpace !== null) {
        data.colorSpace = effect.inputColorSpace;
      }
      const depthParamRegExp = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      fragmentMainImage += `${prefix}MainImage(color0, UV, `;
      if ((data.attributes & EffectAttribute.DEPTH) !== 0 && depthParamRegExp.test(fragmentShader)) {
        fragmentMainImage += "depth, ";
        data.readDepth = true;
      }
      fragmentMainImage += "color1);\n	";
      const blendOpacity = prefix + "BlendOpacity";
      data.uniforms.set(blendOpacity, blendMode.opacity);
      fragmentMainImage += `color0 = blend${blendMode.blendFunction}(color0, color1, ${blendOpacity});

	`;
      fragmentHead += `uniform float ${blendOpacity};

`;
    }
    fragmentHead += fragmentShader + "\n";
    if (vertexShader !== null) {
      vertexHead += vertexShader + "\n";
    }
    shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    shaderParts.set(EffectShaderSection.VERTEX_HEAD, vertexHead);
    shaderParts.set(EffectShaderSection.VERTEX_MAIN_SUPPORT, vertexMainSupport);
    if (effect.extensions !== null) {
      for (const extension of effect.extensions) {
        data.extensions.add(extension);
      }
    }
  }
}
var EffectPass = class extends Pass {
  /**
   * Constructs a new effect pass.
   *
   * @param {Camera} camera - The main camera.
   * @param {...Effect} effects - The effects that will be rendered by this pass.
   */
  constructor(camera, ...effects) {
    super("EffectPass");
    this.fullscreenMaterial = new EffectMaterial(null, null, null, camera);
    this.listener = (event) => this.handleEvent(event);
    this.effects = [];
    this.setEffects(effects);
    this.skipRendering = false;
    this.minTime = 1;
    this.maxTime = Number.POSITIVE_INFINITY;
    this.timeScale = 1;
  }
  set mainScene(value) {
    for (const effect of this.effects) {
      effect.mainScene = value;
    }
  }
  set mainCamera(value) {
    this.fullscreenMaterial.copyCameraSettings(value);
    for (const effect of this.effects) {
      effect.mainCamera = value;
    }
  }
  /**
   * Indicates whether this pass encodes its output when rendering to screen.
   *
   * @type {Boolean}
   * @deprecated Use fullscreenMaterial.encodeOutput instead.
   */
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(value) {
    this.fullscreenMaterial.encodeOutput = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   */
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(value) {
    const material = this.fullscreenMaterial;
    material.dithering = value;
    material.needsUpdate = true;
  }
  /**
   * Sets the effects.
   *
   * @param {Effect[]} effects - The effects.
   * @protected
   */
  setEffects(effects) {
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
    }
    this.effects = effects.sort((a, b) => b.attributes - a.attributes);
    for (const effect of this.effects) {
      effect.addEventListener("change", this.listener);
    }
  }
  /**
   * Updates the compound shader material.
   *
   * @protected
   */
  updateMaterial() {
    const data = new EffectShaderData();
    let id = 0;
    for (const effect of this.effects) {
      if (effect.blendMode.blendFunction === BlendFunction.DST) {
        data.attributes |= effect.getAttributes() & EffectAttribute.DEPTH;
      } else if ((data.attributes & effect.getAttributes() & EffectAttribute.CONVOLUTION) !== 0) {
        throw new Error(`Convolution effects cannot be merged (${effect.name})`);
      } else {
        integrateEffect("e" + id++, effect, data);
      }
    }
    let fragmentHead = data.shaderParts.get(EffectShaderSection.FRAGMENT_HEAD);
    let fragmentMainImage = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_IMAGE);
    let fragmentMainUv = data.shaderParts.get(EffectShaderSection.FRAGMENT_MAIN_UV);
    const blendRegExp = /\bblend\b/g;
    for (const blendMode of data.blendModes.values()) {
      fragmentHead += blendMode.getShaderCode().replace(blendRegExp, `blend${blendMode.blendFunction}`) + "\n";
    }
    if ((data.attributes & EffectAttribute.DEPTH) !== 0) {
      if (data.readDepth) {
        fragmentMainImage = "float depth = readDepth(UV);\n\n	" + fragmentMainImage;
      }
      this.needsDepthTexture = this.getDepthTexture() === null;
    } else {
      this.needsDepthTexture = false;
    }
    if (data.colorSpace === sRGBEncoding) {
      fragmentMainImage += "color0 = sRGBToLinear(color0);\n	";
    }
    if (data.uvTransformation) {
      fragmentMainUv = "vec2 transformedUv = vUv;\n" + fragmentMainUv;
      data.defines.set("UV", "transformedUv");
    } else {
      data.defines.set("UV", "vUv");
    }
    data.shaderParts.set(EffectShaderSection.FRAGMENT_HEAD, fragmentHead);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_IMAGE, fragmentMainImage);
    data.shaderParts.set(EffectShaderSection.FRAGMENT_MAIN_UV, fragmentMainUv);
    data.shaderParts.forEach((value, key, map) => map.set(key, value == null ? void 0 : value.trim().replace(/^#/, "\n#")));
    this.skipRendering = id === 0;
    this.needsSwap = !this.skipRendering;
    this.fullscreenMaterial.setShaderData(data);
  }
  /**
   * Rebuilds the shader material.
   */
  recompile() {
    this.updateMaterial();
  }
  /**
   * Returns the current depth texture.
   *
   * @return {Texture} The current depth texture, or null if there is none.
   */
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.fullscreenMaterial.depthBuffer = depthTexture;
    this.fullscreenMaterial.depthPacking = depthPacking;
    for (const effect of this.effects) {
      effect.setDepthTexture(depthTexture, depthPacking);
    }
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    for (const effect of this.effects) {
      effect.update(renderer, inputBuffer, deltaTime);
    }
    if (!this.skipRendering || this.renderToScreen) {
      const material = this.fullscreenMaterial;
      material.inputBuffer = inputBuffer.texture;
      material.time += deltaTime * this.timeScale;
      renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
      renderer.render(this.scene, this.camera);
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.fullscreenMaterial.setSize(width, height);
    for (const effect of this.effects) {
      effect.setSize(width, height);
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.renderer = renderer;
    for (const effect of this.effects) {
      effect.initialize(renderer, alpha, frameBufferType);
    }
    this.updateMaterial();
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
  /**
   * Deletes disposable objects.
   */
  dispose() {
    super.dispose();
    for (const effect of this.effects) {
      effect.removeEventListener("change", this.listener);
      effect.dispose();
    }
  }
  /**
   * Handles events.
   *
   * @param {Event} event - An event.
   */
  handleEvent(event) {
    switch (event.type) {
      case "change":
        this.recompile();
        break;
    }
  }
};
var KawaseBlurPass = class extends Pass {
  /**
   * Constructs a new Kawase blur pass.
   *
   * @param {Object} [options] - The options.
   * @param {KernelSize} [options.kernelSize=KernelSize.MEDIUM] - The blur kernel size.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    kernelSize = KernelSize.MEDIUM,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("KawaseBlurPass");
    this.renderTargetA = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetA.texture.name = "Blur.Target.A";
    this.renderTargetB = this.renderTargetA.clone();
    this.renderTargetB.texture.name = "Blur.Target.B";
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this._blurMaterial = new KawaseBlurMaterial();
    this._blurMaterial.kernelSize = kernelSize;
    this.copyMaterial = new CopyMaterial();
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   */
  get blurMaterial() {
    return this._blurMaterial;
  }
  /**
   * The blur material.
   *
   * @type {KawaseBlurMaterial}
   * @protected
   */
  set blurMaterial(value) {
    this._blurMaterial = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use copyMaterial.dithering instead.
   */
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(value) {
    this.copyMaterial.dithering = value;
  }
  /**
   * The kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurMaterial.kernelSize instead.
   */
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(value) {
    this.blurMaterial.kernelSize = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  /**
   * Sets the render width.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredWidth instead.
   */
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  /**
   * Sets the render height.
   *
   * @type {Number}
   * @deprecated Use resolution.preferredHeight instead.
   */
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The current blur scale.
   *
   * @type {Number}
   * @deprecated Use blurMaterial.scale instead.
   */
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the current blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @return {Number} The scale.
   */
  getScale() {
    return this.blurMaterial.scale;
  }
  /**
   * Sets the blur scale.
   *
   * @deprecated Use blurMaterial.scale instead.
   * @param {Number} value - The scale.
   */
  setScale(value) {
    this.blurMaterial.scale = value;
  }
  /**
   * Returns the kernel size.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @return {KernelSize} The kernel size.
   */
  getKernelSize() {
    return this.kernelSize;
  }
  /**
   * Sets the kernel size.
   *
   * Larger kernels require more processing power but scale well with larger render resolutions.
   *
   * @deprecated Use blurMaterial.kernelSize instead.
   * @param {KernelSize} value - The kernel size.
   */
  setKernelSize(value) {
    this.kernelSize = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const scene = this.scene;
    const camera = this.camera;
    const renderTargetA = this.renderTargetA;
    const renderTargetB = this.renderTargetB;
    const material = this.blurMaterial;
    const kernelSequence = material.kernelSequence;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = material;
    for (let i = 0, l = kernelSequence.length; i < l; ++i) {
      const buffer = (i & 1) === 0 ? renderTargetA : renderTargetB;
      material.kernel = kernelSequence[i];
      material.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(buffer);
      renderer.render(scene, camera);
      previousBuffer = buffer;
    }
    this.fullscreenMaterial = this.copyMaterial;
    this.copyMaterial.inputBuffer = previousBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(scene, camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.renderTargetA.setSize(w, h);
    this.renderTargetB.setSize(w, h);
    this.blurMaterial.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      this.renderTargetA.texture.type = frameBufferType;
      this.renderTargetB.texture.type = frameBufferType;
      if (frameBufferType !== UnsignedByteType) {
        this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTargetA.texture.encoding = sRGBEncoding;
        this.renderTargetB.texture.encoding = sRGBEncoding;
      }
    }
  }
  /**
   * An auto sizing flag.
   *
   * @type {Number}
   * @deprecated Use {@link Resolution.AUTO_SIZE} instead.
   */
  static get AUTO_SIZE() {
    return Resolution.AUTO_SIZE;
  }
};
var LuminancePass = class extends Pass {
  /**
   * Constructs a new luminance pass.
   *
   * @param {Object} [options] - The options. See {@link LuminanceMaterial} for additional options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor({
    renderTarget,
    luminanceRange,
    colorOutput,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("LuminancePass");
    this.fullscreenMaterial = new LuminanceMaterial(colorOutput, luminanceRange);
    this.needsSwap = false;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
      this.renderTarget.texture.name = "LuminancePass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * The luminance texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the luminance texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Renders the luminance.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const material = this.fullscreenMaterial;
    material.inputBuffer = inputBuffer.texture;
    renderer.setRenderTarget(this.renderToScreen ? null : this.renderTarget);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.renderTarget.texture.type = frameBufferType;
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/passes/MaskPass.js
var MaskPass = class extends Pass {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use.
   */
  constructor(scene, camera) {
    super("MaskPass", scene, camera);
    this.needsSwap = false;
    this.clearPass = new ClearPass(false, false, true);
    this.inverse = false;
  }
  set mainScene(value) {
    this.scene = value;
  }
  set mainCamera(value) {
    this.camera = value;
  }
  /**
   * Indicates whether the mask should be inverted.
   *
   * @type {Boolean}
   */
  get inverted() {
    return this.inverse;
  }
  set inverted(value) {
    this.inverse = value;
  }
  /**
   * Indicates whether this pass should clear the stencil buffer.
   *
   * @type {Boolean}
   * @deprecated Use clearPass.enabled instead.
   */
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(value) {
    this.clearPass.enabled = value;
  }
  /**
   * Returns the internal clear pass.
   *
   * @deprecated Use clearPass.enabled instead.
   * @return {ClearPass} The clear pass.
   */
  getClearPass() {
    return this.clearPass;
  }
  /**
   * Indicates whether the mask is inverted.
   *
   * @deprecated Use inverted instead.
   * @return {Boolean} Whether the mask is inverted.
   */
  isInverted() {
    return this.inverted;
  }
  /**
   * Enables or disable mask inversion.
   *
   * @deprecated Use inverted instead.
   * @param {Boolean} value - Whether the mask should be inverted.
   */
  setInverted(value) {
    this.inverted = value;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const context = renderer.getContext();
    const buffers = renderer.state.buffers;
    const scene = this.scene;
    const camera = this.camera;
    const clearPass = this.clearPass;
    const writeValue = this.inverted ? 0 : 1;
    const clearValue = 1 - writeValue;
    buffers.color.setMask(false);
    buffers.depth.setMask(false);
    buffers.color.setLocked(true);
    buffers.depth.setLocked(true);
    buffers.stencil.setTest(true);
    buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    buffers.stencil.setClear(clearValue);
    buffers.stencil.setLocked(true);
    if (this.clearPass.enabled) {
      if (this.renderToScreen) {
        clearPass.render(renderer, null);
      } else {
        clearPass.render(renderer, inputBuffer);
        clearPass.render(renderer, outputBuffer);
      }
    }
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      renderer.render(scene, camera);
    } else {
      renderer.setRenderTarget(inputBuffer);
      renderer.render(scene, camera);
      renderer.setRenderTarget(outputBuffer);
      renderer.render(scene, camera);
    }
    buffers.color.setLocked(false);
    buffers.depth.setLocked(false);
    buffers.stencil.setLocked(false);
    buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    buffers.stencil.setLocked(true);
  }
};
var MipmapBlurPass = class extends Pass {
  /**
   * Constructs a new mipmap blur pass.
   *
   * @param {Object} [options] - The options.
   */
  constructor() {
    super("MipmapBlurPass");
    this.needsSwap = false;
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Upsampling.Mipmap0";
    this.downsamplingMipmaps = [];
    this.upsamplingMipmaps = [];
    this.downsamplingMaterial = new DownsamplingMaterial();
    this.upsamplingMaterial = new UpsamplingMaterial();
    this.resolution = new Vector2();
  }
  /**
   * A texture that contains the blurred result.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The MIP levels. Default is 8.
   *
   * @type {Number}
   */
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(value) {
    if (this.levels !== value) {
      const renderTarget = this.renderTarget;
      this.dispose();
      this.downsamplingMipmaps = [];
      this.upsamplingMipmaps = [];
      for (let i = 0; i < value; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Downsampling.Mipmap" + i;
        this.downsamplingMipmaps.push(mipmap);
      }
      this.upsamplingMipmaps.push(renderTarget);
      for (let i = 1, l = value - 1; i < l; ++i) {
        const mipmap = renderTarget.clone();
        mipmap.texture.name = "Upsampling.Mipmap" + i;
        this.upsamplingMipmaps.push(mipmap);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  /**
   * The blur radius.
   *
   * @type {Number}
   */
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(value) {
    this.upsamplingMaterial.radius = value;
  }
  /**
   * Renders the blur.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const { scene, camera } = this;
    const { downsamplingMaterial, upsamplingMaterial } = this;
    const { downsamplingMipmaps, upsamplingMipmaps } = this;
    let previousBuffer = inputBuffer;
    this.fullscreenMaterial = downsamplingMaterial;
    for (let i = 0, l = downsamplingMipmaps.length; i < l; ++i) {
      const mipmap = downsamplingMipmaps[i];
      downsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      downsamplingMaterial.inputBuffer = previousBuffer.texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
    this.fullscreenMaterial = upsamplingMaterial;
    for (let i = upsamplingMipmaps.length - 1; i >= 0; --i) {
      const mipmap = upsamplingMipmaps[i];
      upsamplingMaterial.setSize(previousBuffer.width, previousBuffer.height);
      upsamplingMaterial.inputBuffer = previousBuffer.texture;
      upsamplingMaterial.supportBuffer = downsamplingMipmaps[i].texture;
      renderer.setRenderTarget(mipmap);
      renderer.render(scene, camera);
      previousBuffer = mipmap;
    }
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.set(width, height);
    let w = resolution.width, h = resolution.height;
    for (let i = 0, l = this.downsamplingMipmaps.length; i < l; ++i) {
      w = Math.round(w * 0.5);
      h = Math.round(h * 0.5);
      this.downsamplingMipmaps[i].setSize(w, h);
      if (i < this.upsamplingMipmaps.length) {
        this.upsamplingMipmaps[i].setSize(w, h);
      }
    }
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0) {
      const mipmaps = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const mipmap of mipmaps) {
        mipmap.texture.type = frameBufferType;
      }
      if (frameBufferType !== UnsignedByteType) {
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      } else if (renderer.outputEncoding === sRGBEncoding) {
        for (const mipmap of mipmaps) {
          mipmap.texture.encoding = sRGBEncoding;
        }
      }
    }
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    super.dispose();
    for (const mipmap of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) {
      mipmap.dispose();
    }
  }
};
var NormalPass = class extends Pass {
  /**
   * Constructs a new normal pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera to use to render the scene.
   * @param {Object} [options] - The options.
   * @param {WebGLRenderTarget} [options.renderTarget] - A custom render target.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    renderTarget,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("NormalPass");
    this.needsSwap = false;
    this.renderPass = new RenderPass(scene, camera, new MeshNormalMaterial());
    const renderPass = this.renderPass;
    renderPass.ignoreBackground = true;
    renderPass.skipShadowMapUpdate = true;
    const clearPass = renderPass.getClearPass();
    clearPass.overrideClearColor = new Color(7829503);
    clearPass.overrideClearAlpha = 1;
    this.renderTarget = renderTarget;
    if (this.renderTarget === void 0) {
      this.renderTarget = new WebGLRenderTarget(1, 1, {
        minFilter: NearestFilter,
        magFilter: NearestFilter
      });
      this.renderTarget.texture.name = "NormalPass.Target";
    }
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  set mainScene(value) {
    this.renderPass.mainScene = value;
  }
  set mainCamera(value) {
    this.renderPass.mainCamera = value;
  }
  /**
   * The normal texture.
   *
   * @type {Texture}
   */
  get texture() {
    return this.renderTarget.texture;
  }
  /**
   * The normal texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.renderTarget.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution.preferredWidth or resolution.preferredHeight instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Renders the scene normals.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const renderTarget = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(renderer, renderTarget, renderTarget);
  }
  /**
   * Updates the size of this pass.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
  }
};
var ShaderPass = class extends Pass {
  /**
   * Constructs a new shader pass.
   *
   * @param {ShaderMaterial} material - A shader material.
   * @param {String} [input="inputBuffer"] - The name of the input buffer uniform.
   */
  constructor(material, input = "inputBuffer") {
    super("ShaderPass");
    this.fullscreenMaterial = material;
    this.input = input;
  }
  /**
   * Sets the name of the input buffer uniform.
   *
   * @param {String} input - The name of the input buffer uniform.
   * @deprecated Use input instead.
   */
  setInput(input) {
    this.input = input;
  }
  /**
   * Renders the effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {WebGLRenderTarget} outputBuffer - A frame buffer that serves as the output render target unless this pass renders to screen.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   * @param {Boolean} [stencilTest] - Indicates whether a stencil mask is active.
   */
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    const uniforms = this.fullscreenMaterial.uniforms;
    if (inputBuffer !== null && uniforms !== void 0 && uniforms[this.input] !== void 0) {
      uniforms[this.input].value = inputBuffer.texture;
    }
    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - A renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    if (frameBufferType !== void 0 && frameBufferType !== UnsignedByteType) {
      this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
    }
  }
};

// src/core/Timer.js
var MILLISECONDS_TO_SECONDS = 1 / 1e3;
var SECONDS_TO_MILLISECONDS = 1e3;
var Timer = class {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this.previousTime = 0;
    this.currentTime = 0;
    this._delta = 0;
    this._elapsed = 0;
    this._fixedDelta = 1e3 / 60;
    this.timescale = 1;
    this.useFixedDelta = false;
    this._autoReset = false;
  }
  /**
   * Enables or disables auto reset based on page visibility.
   *
   * If enabled, the timer will be reset when the page becomes visible. This effectively pauses the timer when the page
   * is hidden. Has no effect if the API is not supported.
   *
   * @type {Boolean}
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   */
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(value) {
    if (typeof document !== "undefined" && document.hidden !== void 0) {
      if (value) {
        document.addEventListener("visibilitychange", this);
      } else {
        document.removeEventListener("visibilitychange", this);
      }
      this._autoReset = value;
    }
  }
  get delta() {
    return this._delta * MILLISECONDS_TO_SECONDS;
  }
  get fixedDelta() {
    return this._fixedDelta * MILLISECONDS_TO_SECONDS;
  }
  set fixedDelta(value) {
    this._fixedDelta = value * SECONDS_TO_MILLISECONDS;
  }
  get elapsed() {
    return this._elapsed * MILLISECONDS_TO_SECONDS;
  }
  /**
   * Updates this timer.
   *
   * @param {Boolean} [timestamp] - The current time in milliseconds.
   */
  update(timestamp) {
    if (this.useFixedDelta) {
      this._delta = this.fixedDelta;
    } else {
      this.previousTime = this.currentTime;
      this.currentTime = timestamp !== void 0 ? timestamp : performance.now();
      this._delta = this.currentTime - this.previousTime;
    }
    this._delta *= this.timescale;
    this._elapsed += this._delta;
  }
  /**
   * Resets this timer.
   */
  reset() {
    this._delta = 0;
    this._elapsed = 0;
    this.currentTime = performance.now();
  }
  handleEvent(e) {
    if (!document.hidden) {
      this.currentTime = performance.now();
    }
  }
  dispose() {
    this.autoReset = false;
  }
};

// src/core/EffectComposer.js
var EffectComposer = class {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer that should be used.
   * @param {Object} [options] - The options.
   * @param {Boolean} [options.depthBuffer=true] - Whether the main render targets should have a depth buffer.
   * @param {Boolean} [options.stencilBuffer=false] - Whether the main render targets should have a stencil buffer.
   * @param {Boolean} [options.alpha] - Deprecated. Buffers are always RGBA since three r137.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.frameBufferType] - The type of the internal frame buffers. It's recommended to use HalfFloatType if possible.
   */
  constructor(renderer = null, {
    depthBuffer = true,
    stencilBuffer = false,
    multisampling = 0,
    frameBufferType
  } = {}) {
    this.renderer = null;
    this.inputBuffer = this.createBuffer(depthBuffer, stencilBuffer, frameBufferType, multisampling);
    this.outputBuffer = this.inputBuffer.clone();
    this.copyPass = new CopyPass();
    this.depthTexture = null;
    this.passes = [];
    this.timer = new Timer();
    this.autoRenderToScreen = true;
    this.setRenderer(renderer);
  }
  /**
   * The current amount of samples used for multisample anti-aliasing.
   *
   * @type {Number}
   */
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  /**
   * Sets the amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @type {Number}
   */
  set multisampling(value) {
    const buffer = this.inputBuffer;
    const multisampling = this.multisampling;
    if (multisampling > 0 && value > 0) {
      this.inputBuffer.samples = value;
      this.outputBuffer.samples = value;
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
    } else if (multisampling !== value) {
      this.inputBuffer.dispose();
      this.outputBuffer.dispose();
      this.inputBuffer = this.createBuffer(
        buffer.depthBuffer,
        buffer.stencilBuffer,
        buffer.texture.type,
        value
      );
      this.inputBuffer.depthTexture = this.depthTexture;
      this.outputBuffer = this.inputBuffer.clone();
    }
  }
  /**
   * Returns the internal timer.
   *
   * @return {Timer} The timer.
   */
  getTimer() {
    return this.timer;
  }
  /**
   * Returns the renderer.
   *
   * @return {WebGLRenderer} The renderer.
   */
  getRenderer() {
    return this.renderer;
  }
  /**
   * Sets the renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
    if (renderer !== null) {
      const size = renderer.getSize(new Vector2());
      const alpha = renderer.getContext().getContextAttributes().alpha;
      const frameBufferType = this.inputBuffer.texture.type;
      if (frameBufferType === UnsignedByteType && renderer.outputEncoding === sRGBEncoding) {
        this.inputBuffer.texture.encoding = sRGBEncoding;
        this.outputBuffer.texture.encoding = sRGBEncoding;
        this.inputBuffer.dispose();
        this.outputBuffer.dispose();
      }
      renderer.autoClear = false;
      this.setSize(size.width, size.height);
      for (const pass of this.passes) {
        pass.initialize(renderer, alpha, frameBufferType);
      }
    }
  }
  /**
   * Replaces the current renderer with the given one.
   *
   * The auto clear mechanism of the provided renderer will be disabled. If the new render size differs from the
   * previous one, all passes will be updated.
   *
   * By default, the DOM element of the current renderer will automatically be removed from its parent node and the DOM
   * element of the new renderer will take its place.
   *
   * @deprecated Use setRenderer instead.
   * @param {WebGLRenderer} renderer - The new renderer.
   * @param {Boolean} updateDOM - Indicates whether the old canvas should be replaced by the new one in the DOM.
   * @return {WebGLRenderer} The old renderer.
   */
  replaceRenderer(renderer, updateDOM = true) {
    const oldRenderer = this.renderer;
    const parent = oldRenderer.domElement.parentNode;
    this.setRenderer(renderer);
    if (updateDOM && parent !== null) {
      parent.removeChild(oldRenderer.domElement);
      parent.appendChild(renderer.domElement);
    }
    return oldRenderer;
  }
  /**
   * Creates a depth texture attachment that will be provided to all passes.
   *
   * Note: When a shader reads from a depth texture and writes to a render target that uses the same depth texture
   * attachment, the depth information will be lost. This happens even if `depthWrite` is disabled.
   *
   * @private
   * @return {DepthTexture} The depth texture.
   */
  createDepthTexture() {
    const depthTexture = this.depthTexture = new DepthTexture();
    this.inputBuffer.depthTexture = depthTexture;
    this.inputBuffer.dispose();
    if (this.inputBuffer.stencilBuffer) {
      depthTexture.format = DepthStencilFormat;
      depthTexture.type = UnsignedInt248Type;
    } else {
      depthTexture.type = UnsignedIntType;
    }
    return depthTexture;
  }
  /**
   * Deletes the current depth texture.
   *
   * @private
   */
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose();
      this.depthTexture = null;
      this.inputBuffer.depthTexture = null;
      this.inputBuffer.dispose();
      for (const pass of this.passes) {
        pass.setDepthTexture(null);
      }
    }
  }
  /**
   * Creates a new render target.
   *
   * @deprecated Create buffers manually via WebGLRenderTarget instead.
   * @param {Boolean} depthBuffer - Whether the render target should have a depth buffer.
   * @param {Boolean} stencilBuffer - Whether the render target should have a stencil buffer.
   * @param {Number} type - The frame buffer type.
   * @param {Number} multisampling - The number of samples to use for antialiasing.
   * @return {WebGLRenderTarget} A new render target that equals the renderer's canvas.
   */
  createBuffer(depthBuffer, stencilBuffer, type, multisampling) {
    const renderer = this.renderer;
    const size = renderer === null ? new Vector2() : renderer.getDrawingBufferSize(new Vector2());
    const options = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      stencilBuffer,
      depthBuffer,
      type
    };
    const renderTarget = new WebGLRenderTarget(size.width, size.height, options);
    if (multisampling > 0) {
      renderTarget.ignoreDepthForMultisampleCopy = false;
      renderTarget.samples = multisampling;
    }
    if (type === UnsignedByteType && renderer !== null && renderer.outputEncoding === sRGBEncoding) {
      renderTarget.texture.encoding = sRGBEncoding;
    }
    renderTarget.texture.name = "EffectComposer.Buffer";
    renderTarget.texture.generateMipmaps = false;
    return renderTarget;
  }
  /**
   * Can be used to change the main scene for all registered passes and effects.
   *
   * @param {Scene} scene - The scene.
   */
  setMainScene(scene) {
    for (const pass of this.passes) {
      pass.mainScene = scene;
    }
  }
  /**
   * Can be used to change the main camera for all registered passes and effects.
   *
   * @param {Camera} camera - The camera.
   */
  setMainCamera(camera) {
    for (const pass of this.passes) {
      pass.mainCamera = camera;
    }
  }
  /**
   * Adds a pass, optionally at a specific index.
   *
   * @param {Pass} pass - A new pass.
   * @param {Number} [index] - An index at which the pass should be inserted.
   */
  addPass(pass, index) {
    const passes = this.passes;
    const renderer = this.renderer;
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    const alpha = renderer.getContext().getContextAttributes().alpha;
    const frameBufferType = this.inputBuffer.texture.type;
    pass.setRenderer(renderer);
    pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    pass.initialize(renderer, alpha, frameBufferType);
    if (this.autoRenderToScreen) {
      if (passes.length > 0) {
        passes[passes.length - 1].renderToScreen = false;
      }
      if (pass.renderToScreen) {
        this.autoRenderToScreen = false;
      }
    }
    if (index !== void 0) {
      passes.splice(index, 0, pass);
    } else {
      passes.push(pass);
    }
    if (this.autoRenderToScreen) {
      passes[passes.length - 1].renderToScreen = true;
    }
    if (pass.needsDepthTexture || this.depthTexture !== null) {
      if (this.depthTexture === null) {
        const depthTexture = this.createDepthTexture();
        for (pass of passes) {
          pass.setDepthTexture(depthTexture);
        }
      } else {
        pass.setDepthTexture(this.depthTexture);
      }
    }
  }
  /**
   * Removes a pass.
   *
   * @param {Pass} pass - The pass.
   */
  removePass(pass) {
    const passes = this.passes;
    const index = passes.indexOf(pass);
    const exists = index !== -1;
    const removed = exists && passes.splice(index, 1).length > 0;
    if (removed) {
      if (this.depthTexture !== null) {
        const reducer = (a, b) => a || b.needsDepthTexture;
        const depthTextureRequired = passes.reduce(reducer, false);
        if (!depthTextureRequired) {
          if (pass.getDepthTexture() === this.depthTexture) {
            pass.setDepthTexture(null);
          }
          this.deleteDepthTexture();
        }
      }
      if (this.autoRenderToScreen) {
        if (index === passes.length) {
          pass.renderToScreen = false;
          if (passes.length > 0) {
            passes[passes.length - 1].renderToScreen = true;
          }
        }
      }
    }
  }
  /**
   * Removes all passes.
   */
  removeAllPasses() {
    const passes = this.passes;
    this.deleteDepthTexture();
    if (passes.length > 0) {
      if (this.autoRenderToScreen) {
        passes[passes.length - 1].renderToScreen = false;
      }
      this.passes = [];
    }
  }
  /**
   * Renders all enabled passes in the order in which they were added.
   *
   * @param {Number} [deltaTime] - The time since the last frame in seconds.
   */
  render(deltaTime) {
    const renderer = this.renderer;
    const copyPass = this.copyPass;
    let inputBuffer = this.inputBuffer;
    let outputBuffer = this.outputBuffer;
    let stencilTest = false;
    let context, stencil, buffer;
    if (deltaTime === void 0) {
      this.timer.update();
      deltaTime = this.timer.delta;
    }
    for (const pass of this.passes) {
      if (pass.enabled) {
        pass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
        if (pass.needsSwap) {
          if (stencilTest) {
            copyPass.renderToScreen = pass.renderToScreen;
            context = renderer.getContext();
            stencil = renderer.state.buffers.stencil;
            stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
            copyPass.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
            stencil.setFunc(context.EQUAL, 1, 4294967295);
          }
          buffer = inputBuffer;
          inputBuffer = outputBuffer;
          outputBuffer = buffer;
        }
        if (pass instanceof MaskPass) {
          stencilTest = true;
        } else if (pass instanceof ClearMaskPass) {
          stencilTest = false;
        }
      }
    }
  }
  /**
   * Sets the size of the buffers, passes and the renderer.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Boolean} [updateStyle] - Determines whether the style of the canvas should be updated.
   */
  setSize(width, height, updateStyle) {
    const renderer = this.renderer;
    const currentSize = renderer.getSize(new Vector2());
    if (width === void 0 || height === void 0) {
      width = currentSize.width;
      height = currentSize.height;
    }
    if (currentSize.width !== width || currentSize.height !== height) {
      renderer.setSize(width, height, updateStyle);
    }
    const drawingBufferSize = renderer.getDrawingBufferSize(new Vector2());
    this.inputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    this.outputBuffer.setSize(drawingBufferSize.width, drawingBufferSize.height);
    for (const pass of this.passes) {
      pass.setSize(drawingBufferSize.width, drawingBufferSize.height);
    }
  }
  /**
   * Resets this composer by deleting all passes and creating new buffers.
   */
  reset() {
    const autoReset = this.timer.autoReset;
    this.dispose();
    this.autoRenderToScreen = true;
    this.timer.autoReset = autoReset;
  }
  /**
   * Disposes this composer and all passes.
   */
  dispose() {
    for (const pass of this.passes) {
      pass.dispose();
    }
    this.passes = [];
    if (this.inputBuffer !== null) {
      this.inputBuffer.dispose();
    }
    if (this.outputBuffer !== null) {
      this.outputBuffer.dispose();
    }
    this.deleteDepthTexture();
    this.copyPass.dispose();
    this.timer.dispose();
  }
};
var EffectShaderData = class {
  /**
   * Constructs new shader data.
   */
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [EffectShaderSection.FRAGMENT_HEAD, null],
      [EffectShaderSection.FRAGMENT_MAIN_UV, null],
      [EffectShaderSection.FRAGMENT_MAIN_IMAGE, null],
      [EffectShaderSection.VERTEX_HEAD, null],
      [EffectShaderSection.VERTEX_MAIN_SUPPORT, null]
    ]);
    this.defines = /* @__PURE__ */ new Map();
    this.uniforms = /* @__PURE__ */ new Map();
    this.blendModes = /* @__PURE__ */ new Map();
    this.extensions = /* @__PURE__ */ new Set();
    this.attributes = EffectAttribute.NONE;
    this.varyings = /* @__PURE__ */ new Set();
    this.uvTransformation = false;
    this.readDepth = false;
    this.colorSpace = LinearEncoding;
  }
};

// src/core/Selection.js
var Selection = class extends Set {
  /**
   * Constructs a new selection.
   *
   * @param {Iterable<Object3D>} [iterable] - A collection of objects that should be added to this selection.
   * @param {Number} [layer=10] - A dedicated render layer for selected objects.
   */
  constructor(iterable, layer = 10) {
    super();
    this.l = layer;
    this.exclusive = false;
    if (iterable !== void 0) {
      this.set(iterable);
    }
  }
  /**
   * The render layer for selected objects.
   *
   * @type {Number}
   */
  get layer() {
    return this.l;
  }
  set layer(value) {
    const currentLayer = this.l;
    for (const object of this) {
      object.layers.disable(currentLayer);
      object.layers.enable(value);
    }
    this.l = value;
  }
  /**
   * Returns the current render layer for selected objects.
   *
   * The default layer is 10. If this collides with your own custom layers, please change it before rendering!
   *
   * @deprecated Use layer instead.
   * @return {Number} The layer.
   */
  getLayer() {
    return this.layer;
  }
  /**
   * Sets the render layer for selected objects.
   *
   * The current selection will be updated accordingly.
   *
   * @deprecated Use layer instead.
   * @param {Number} value - The layer. Range is [0, 31].
   */
  setLayer(value) {
    this.layer = value;
  }
  /**
   * Indicates whether objects that are added to this selection will be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @return {Number} Whether this selection is exclusive. Default is false.
   */
  isExclusive() {
    return this.exclusive;
  }
  /**
   * Controls whether objects that are added to this selection should be removed from all other layers.
   *
   * @deprecated Use exclusive instead.
   * @param {Number} value - Whether this selection should be exclusive.
   */
  setExclusive(value) {
    this.exclusive = value;
  }
  /**
   * Clears this selection.
   *
   * @return {Selection} This selection.
   */
  clear() {
    const layer = this.layer;
    for (const object of this) {
      object.layers.disable(layer);
    }
    return super.clear();
  }
  /**
   * Clears this selection and adds the given objects.
   *
   * @param {Iterable<Object3D>} objects - The objects that should be selected.
   * @return {Selection} This selection.
   */
  set(objects) {
    this.clear();
    for (const object of objects) {
      this.add(object);
    }
    return this;
  }
  /**
   * An alias for {@link has}.
   *
   * @param {Object3D} object - An object.
   * @return {Number} Returns 0 if the given object is currently selected, or -1 otherwise.
   * @deprecated Added for backward-compatibility.
   */
  indexOf(object) {
    return this.has(object) ? 0 : -1;
  }
  /**
   * Adds an object to this selection.
   *
   * If {@link exclusive} is set to `true`, the object will also be removed from all other layers.
   *
   * @param {Object3D} object - The object that should be selected.
   * @return {Selection} This selection.
   */
  add(object) {
    if (this.exclusive) {
      object.layers.set(this.layer);
    } else {
      object.layers.enable(this.layer);
    }
    return super.add(object);
  }
  /**
   * Removes an object from this selection.
   *
   * @param {Object3D} object - The object that should be deselected.
   * @return {Boolean} Returns true if an object has successfully been removed from this selection; otherwise false.
   */
  delete(object) {
    if (this.has(object)) {
      object.layers.disable(this.layer);
    }
    return super.delete(object);
  }
  /**
   * Removes an existing object from the selection. If the object doesn't exist it's added instead.
   *
   * @param {Object3D} object - The object.
   * @return {Boolean} Returns true if the object is added, false otherwise.
   */
  toggle(object) {
    let result;
    if (this.has(object)) {
      this.delete(object);
      result = false;
    } else {
      this.add(object);
      result = true;
    }
    return result;
  }
  /**
   * Sets the visibility of all selected objects.
   *
   * This method enables or disables render layer 0 of all selected objects.
   *
   * @param {Boolean} visible - Whether the selected objects should be visible.
   * @return {Selection} This selection.
   */
  setVisible(visible) {
    for (const object of this) {
      if (visible) {
        object.layers.enable(0);
      } else {
        object.layers.disable(0);
      }
    }
    return this;
  }
};

// src/effects/blending/glsl/add.frag
var add_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}";

// src/effects/blending/glsl/alpha.frag
var alpha_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}";

// src/effects/blending/glsl/average.frag
var average_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}";

// src/effects/blending/glsl/color.frag
var color_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/color-burn.frag
var color_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/color-dodge.frag
var color_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/darken.frag
var darken_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}";

// src/effects/blending/glsl/difference.frag
var difference_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}";

// src/effects/blending/glsl/divide.frag
var divide_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}";

// src/effects/blending/glsl/exclusion.frag
var exclusion_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}";

// src/effects/blending/glsl/hard-light.frag
var hard_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/hard-mix.frag
var hard_mix_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}";

// src/effects/blending/glsl/hue.frag
var hue_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/invert.frag
var invert_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}";

// src/effects/blending/glsl/invert-rgb.frag
var invert_rgb_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}";

// src/effects/blending/glsl/lighten.frag
var lighten_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}";

// src/effects/blending/glsl/linear-burn.frag
var linear_burn_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/linear-dodge.frag
var linear_dodge_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}";

// src/effects/blending/glsl/linear-light.frag
var linear_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}";

// src/effects/blending/glsl/luminosity.frag
var luminosity_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/multiply.frag
var multiply_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}";

// src/effects/blending/glsl/negation.frag
var negation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}";

// src/effects/blending/glsl/normal.frag
var normal_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}";

// src/effects/blending/glsl/overlay.frag
var overlay_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}";

// src/effects/blending/glsl/pin-light.frag
var pin_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}";

// src/effects/blending/glsl/reflect.frag
var reflect_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}";

// src/effects/blending/glsl/saturation.frag
var saturation_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}";

// src/effects/blending/glsl/screen.frag
var screen_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}";

// src/effects/blending/glsl/soft-light.frag
var soft_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}";

// src/effects/blending/glsl/src.frag
var src_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}";

// src/effects/blending/glsl/subtract.frag
var subtract_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}";

// src/effects/blending/glsl/vivid-light.frag
var vivid_light_default = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}";

// src/effects/blending/BlendMode.js
var blendFunctions = /* @__PURE__ */ new Map([
  [BlendFunction.ADD, add_default],
  [BlendFunction.ALPHA, alpha_default],
  [BlendFunction.AVERAGE, average_default],
  [BlendFunction.COLOR, color_default],
  [BlendFunction.COLOR_BURN, color_burn_default],
  [BlendFunction.COLOR_DODGE, color_dodge_default],
  [BlendFunction.DARKEN, darken_default],
  [BlendFunction.DIFFERENCE, difference_default],
  [BlendFunction.DIVIDE, divide_default],
  [BlendFunction.DST, null],
  [BlendFunction.EXCLUSION, exclusion_default],
  [BlendFunction.HARD_LIGHT, hard_light_default],
  [BlendFunction.HARD_MIX, hard_mix_default],
  [BlendFunction.HUE, hue_default],
  [BlendFunction.INVERT, invert_default],
  [BlendFunction.INVERT_RGB, invert_rgb_default],
  [BlendFunction.LIGHTEN, lighten_default],
  [BlendFunction.LINEAR_BURN, linear_burn_default],
  [BlendFunction.LINEAR_DODGE, linear_dodge_default],
  [BlendFunction.LINEAR_LIGHT, linear_light_default],
  [BlendFunction.LUMINOSITY, luminosity_default],
  [BlendFunction.MULTIPLY, multiply_default],
  [BlendFunction.NEGATION, negation_default],
  [BlendFunction.NORMAL, normal_default],
  [BlendFunction.OVERLAY, overlay_default],
  [BlendFunction.PIN_LIGHT, pin_light_default],
  [BlendFunction.REFLECT, reflect_default],
  [BlendFunction.SATURATION, saturation_default],
  [BlendFunction.SCREEN, screen_default],
  [BlendFunction.SOFT_LIGHT, soft_light_default],
  [BlendFunction.SRC, src_default],
  [BlendFunction.SUBTRACT, subtract_default],
  [BlendFunction.VIVID_LIGHT, vivid_light_default]
]);
var BlendMode = class extends EventDispatcher {
  /**
   * Constructs a new blend mode.
   *
   * @param {BlendFunction} blendFunction - The blend function.
   * @param {Number} opacity - The opacity of the color that will be blended with the base color.
   */
  constructor(blendFunction, opacity = 1) {
    super();
    this._blendFunction = blendFunction;
    this.opacity = new Uniform(opacity);
  }
  /**
   * Returns the opacity.
   *
   * @return {Number} The opacity.
   */
  getOpacity() {
    return this.opacity.value;
  }
  /**
   * Sets the opacity.
   *
   * @param {Number} value - The opacity.
   */
  setOpacity(value) {
    this.opacity.value = value;
  }
  /**
   * The blend function.
   *
   * @type {BlendFunction}
   */
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(value) {
    this._blendFunction = value;
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Returns the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @return {BlendFunction} The blend function.
   */
  getBlendFunction() {
    return this.blendFunction;
  }
  /**
   * Sets the blend function.
   *
   * @deprecated Use blendFunction instead.
   * @param {BlendFunction} value - The blend function.
   */
  setBlendFunction(value) {
    this.blendFunction = value;
  }
  /**
   * Returns the blend function shader code.
   *
   * @return {String} The blend function shader code.
   */
  getShaderCode() {
    return blendFunctions.get(this.blendFunction);
  }
};
var Effect = class extends EventDispatcher {
  /**
   * Constructs a new effect.
   *
   * @param {String} name - The name of this effect. Doesn't have to be unique.
   * @param {String} fragmentShader - The fragment shader. This shader is required.
   * @param {Object} [options] - Additional options.
   * @param {EffectAttribute} [options.attributes=EffectAttribute.NONE] - The effect attributes that determine the execution priority and resource requirements.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.NORMAL] - The blend function of this effect.
   * @param {Map<String, String>} [options.defines] - Custom preprocessor macro definitions. Keys are names and values are code.
   * @param {Map<String, Uniform>} [options.uniforms] - Custom shader uniforms. Keys are names and values are uniforms.
   * @param {Set<WebGLExtension>} [options.extensions] - WebGL extensions.
   * @param {String} [options.vertexShader=null] - The vertex shader. Most effects don't need one.
   */
  constructor(name, fragmentShader, {
    attributes = EffectAttribute.NONE,
    blendFunction = BlendFunction.NORMAL,
    defines = /* @__PURE__ */ new Map(),
    uniforms = /* @__PURE__ */ new Map(),
    extensions = null,
    vertexShader = null
  } = {}) {
    super();
    this.name = name;
    this.renderer = null;
    this.attributes = attributes;
    this.fragmentShader = fragmentShader;
    this.vertexShader = vertexShader;
    this.defines = defines;
    this.uniforms = uniforms;
    this.extensions = extensions;
    this.blendMode = new BlendMode(blendFunction);
    this.blendMode.addEventListener("change", (event) => this.setChanged());
    this._inputColorSpace = LinearEncoding;
    this._outputColorSpace = null;
  }
  /**
   * The input color space.
   *
   * @type {TextureEncoding}
   * @experimental
   */
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  /**
   * @type {TextureEncoding}
   * @protected
   * @experimental
   */
  set inputColorSpace(value) {
    this._inputColorSpace = value;
    this.setChanged();
  }
  /**
   * The output color space.
   *
   * Should only be changed if this effect converts the input colors to a different color space.
   *
   * @type {TextureEncoding}
   * @experimental
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  /**
   * @type {TextureEncoding}
   * @protected
   * @experimental
   */
  set outputColorSpace(value) {
    this._outputColorSpace = value;
    this.setChanged();
  }
  /**
   * Sets the main scene.
   *
   * @type {Scene}
   */
  set mainScene(value) {
  }
  /**
   * Sets the main camera.
   *
   * @type {Camera}
   */
  set mainCamera(value) {
  }
  /**
   * Returns the name of this effect.
   *
   * @deprecated Use name instead.
   * @return {String} The name.
   */
  getName() {
    return this.name;
  }
  /**
   * Sets the renderer.
   *
   * @deprecated
   * @param {WebGLRenderer} renderer - The renderer.
   */
  setRenderer(renderer) {
    this.renderer = renderer;
  }
  /**
   * Returns the preprocessor macro definitions.
   *
   * @deprecated Use defines instead.
   * @return {Map<String, String>} The extensions.
   */
  getDefines() {
    return this.defines;
  }
  /**
   * Returns the uniforms of this effect.
   *
   * @deprecated Use uniforms instead.
   * @return {Map<String, Uniform>} The extensions.
   */
  getUniforms() {
    return this.uniforms;
  }
  /**
   * Returns the WebGL extensions that are required by this effect.
   *
   * @deprecated Use extensions instead.
   * @return {Set<WebGLExtension>} The extensions.
   */
  getExtensions() {
    return this.extensions;
  }
  /**
   * Returns the blend mode.
   *
   * The result of this effect will be blended with the result of the previous effect using this blend mode.
   *
   * @deprecated Use blendMode instead.
   * @return {BlendMode} The blend mode.
   */
  getBlendMode() {
    return this.blendMode;
  }
  /**
   * Returns the effect attributes.
   *
   * @return {EffectAttribute} The attributes.
   */
  getAttributes() {
    return this.attributes;
  }
  /**
   * Sets the effect attributes.
   *
   * Effects that have the same attributes will be executed in the order in which they were registered. Some attributes
   * imply a higher priority.
   *
   * @protected
   * @param {EffectAttribute} attributes - The attributes.
   */
  setAttributes(attributes) {
    this.attributes = attributes;
    this.setChanged();
  }
  /**
   * Returns the fragment shader.
   *
   * @return {String} The fragment shader.
   */
  getFragmentShader() {
    return this.fragmentShader;
  }
  /**
   * Sets the fragment shader.
   *
   * @protected
   * @param {String} fragmentShader - The fragment shader.
   */
  setFragmentShader(fragmentShader) {
    this.fragmentShader = fragmentShader;
    this.setChanged();
  }
  /**
   * Returns the vertex shader.
   *
   * @return {String} The vertex shader.
   */
  getVertexShader() {
    return this.vertexShader;
  }
  /**
   * Sets the vertex shader.
   *
   * @protected
   * @param {String} vertexShader - The vertex shader.
   */
  setVertexShader(vertexShader) {
    this.vertexShader = vertexShader;
    this.setChanged();
  }
  /**
   * Informs the associated {@link EffectPass} that this effect requires a shader recompilation.
   *
   * Should be called after changing macros or extensions and after adding/removing uniforms.
   *
   * @protected
   */
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  /**
   * Sets the depth texture.
   *
   * You may override this method if your effect requires direct access to the depth texture that is bound to the
   * associated {@link EffectPass}.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
  }
  /**
   * Updates this effect by performing supporting operations.
   *
   * This method is called by the {@link EffectPass} right before the main fullscreen render operation, even if the
   * blend function is set to `SKIP`.
   *
   * You may override this method if you need to update custom uniforms or render additional off-screen textures.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
  }
  /**
   * Updates the size of this effect.
   *
   * You may override this method if you want to be informed about the size of the backbuffer/canvas.
   * This method is called before {@link initialize} and every time the size of the {@link EffectComposer} changes.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
  }
  /**
   * Performs initialization tasks.
   *
   * This method is called when the associated {@link EffectPass} is added to an {@link EffectComposer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   * @example if(!alpha && frameBufferType === UnsignedByteType) { this.myRenderTarget.texture.format = RGBFormat; }
   */
  initialize(renderer, alpha, frameBufferType) {
  }
  /**
   * Performs a shallow search for properties that define a dispose method and deletes them.
   *
   * The {@link EffectComposer} calls this method when it is being destroyed.
   */
  dispose() {
    for (const key of Object.keys(this)) {
      const property = this[key];
      const isDisposable = property instanceof WebGLRenderTarget || property instanceof Material || property instanceof Texture || property instanceof Pass;
      if (isDisposable) {
        this[key].dispose();
      }
    }
  }
};

// src/effects/glsl/bloom.frag
var bloom_default = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}";

// src/effects/BloomEffect.js
var BloomEffect = class extends Effect {
  /**
   * Constructs a new bloom effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function of this effect.
   * @param {Number} [options.luminanceThreshold=0.9] - The luminance threshold. Raise this value to mask out darker elements in the scene.
   * @param {Number} [options.luminanceSmoothing=0.025] - Controls the smoothness of the luminance threshold.
   * @param {Boolean} [options.mipmapBlur=false] - Enables or disables mipmap blur.
   * @param {Number} [options.intensity=1.0] - The bloom intensity.
   * @param {Number} [options.radius=0.85] - The blur radius. Only applies to mipmap blur.
   * @param {Number} [options.levels=8] - The amount of MIP levels. Only applies to mipmap blur.
   * @param {KernelSize} [options.kernelSize=KernelSize.LARGE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionScale=0.5] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use mipmapBlur instead.
   */
  constructor({
    blendFunction = BlendFunction.SCREEN,
    luminanceThreshold = 0.9,
    luminanceSmoothing = 0.025,
    mipmapBlur = false,
    intensity = 1,
    radius = 0.85,
    levels = 8,
    kernelSize = KernelSize.LARGE,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("BloomEffect", bloom_default, {
      blendFunction,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Uniform(null)],
        ["intensity", new Uniform(intensity)]
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "Bloom.Target";
    this.blurPass = new KawaseBlurPass({ kernelSize });
    this.luminancePass = new LuminancePass({ colorOutput: true });
    this.luminanceMaterial.threshold = luminanceThreshold;
    this.luminanceMaterial.smoothing = luminanceSmoothing;
    this.mipmapBlurPass = new MipmapBlurPass();
    this.mipmapBlurPass.enabled = mipmapBlur;
    this.mipmapBlurPass.radius = radius;
    this.mipmapBlurPass.levels = levels;
    this.uniforms.get("map").value = mipmapBlur ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
  }
  /**
   * A texture that contains the intermediate result of this effect.
   *
   * @type {Texture}
   */
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  /**
   * Returns the generated bloom texture.
   *
   * @deprecated Use texture instead.
   * @return {Texture} The texture.
   */
  getTexture() {
    return this.texture;
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the luminance pass.
   *
   * @deprecated Use luminancePass instead.
   * @return {LuminancePass} The luminance pass.
   */
  getLuminancePass() {
    return this.luminancePass;
  }
  /**
   * The luminance material.
   *
   * @type {LuminanceMaterial}
   */
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * Returns the luminance material.
   *
   * @deprecated Use luminanceMaterial instead.
   * @return {LuminanceMaterial} The material.
   */
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated Use EffectPass.dithering instead.
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * @type {Number}
   * @deprecated
   */
  get distinction() {
    console.warn(this.name, "distinction was removed");
    return 1;
  }
  set distinction(value) {
    console.warn(this.name, "distinction was removed");
  }
  /**
   * The bloom intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * The bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @return {Number} The intensity.
   */
  getIntensity() {
    return this.intensity;
  }
  /**
   * Sets the bloom intensity.
   *
   * @deprecated Use intensity instead.
   * @param {Number} value - The intensity.
   */
  setIntensity(value) {
    this.intensity = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    const luminancePass = this.luminancePass;
    if (luminancePass.enabled) {
      luminancePass.render(renderer, inputBuffer);
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, luminancePass.renderTarget);
      } else {
        this.blurPass.render(renderer, luminancePass.renderTarget, renderTarget);
      }
    } else {
      if (this.mipmapBlurPass.enabled) {
        this.mipmapBlurPass.render(renderer, inputBuffer);
      } else {
        this.blurPass.render(renderer, inputBuffer, renderTarget);
      }
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    this.renderTarget.setSize(resolution.width, resolution.height);
    this.blurPass.resolution.copy(resolution);
    this.luminancePass.setSize(width, height);
    this.mipmapBlurPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    this.blurPass.initialize(renderer, alpha, frameBufferType);
    this.luminancePass.initialize(renderer, alpha, frameBufferType);
    this.mipmapBlurPass.initialize(renderer, alpha, frameBufferType);
    if (frameBufferType !== void 0) {
      this.renderTarget.texture.type = frameBufferType;
      if (renderer.outputEncoding === sRGBEncoding) {
        this.renderTarget.texture.encoding = sRGBEncoding;
      }
    }
  }
};
function getNoise(size, format, type) {
  const channels = /* @__PURE__ */ new Map([
    [LuminanceFormat, 1],
    [RedFormat, 1],
    [RGFormat, 2],
    [RGBAFormat, 4]
  ]);
  let data;
  if (!channels.has(format)) {
    console.error("Invalid noise texture format");
  }
  if (type === UnsignedByteType) {
    data = new Uint8Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random() * 255 + 0.5;
    }
  } else {
    data = new Float32Array(size * channels.get(format));
    for (let i = 0, l = data.length; i < l; ++i) {
      data[i] = Math.random();
    }
  }
  return data;
}
var NoiseTexture = class extends DataTexture {
  /**
   * Constructs a new noise texture.
   *
   * The texture format can be either `LuminanceFormat` or `RGBAFormat`. Additionally, the formats `RedFormat` and
   * `RGFormat` can be used in a WebGL 2 context.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   * @param {Number} [format=LuminanceFormat] - The texture format.
   * @param {Number} [type=UnsignedByteType] - The texture type.
   */
  constructor(width, height, format = LuminanceFormat, type = UnsignedByteType) {
    super(getNoise(width * height, format, type), width, height, format, type);
    this.needsUpdate = true;
  }
};

// src/effects/GodRaysEffect.js
new Vector3();
new Matrix4();

// src/textures/lut/LookupTexture.js
new Color();

// src/effects/glsl/outline.frag
var outline_default3 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}";

// src/effects/glsl/outline.vert
var outline_default4 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}";

// src/effects/OutlineEffect.js
var OutlineEffect = class extends Effect {
  /**
   * Constructs a new outline effect.
   *
   * @param {Scene} scene - The main scene.
   * @param {Camera} camera - The main camera.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SCREEN] - The blend function. Use `BlendFunction.ALPHA` for dark outlines.
   * @param {Number} [options.patternTexture=null] - A pattern texture.
   * @param {Number} [options.patternScale=1.0] - The pattern scale.
   * @param {Number} [options.edgeStrength=1.0] - The edge strength.
   * @param {Number} [options.pulseSpeed=0.0] - The pulse speed. A value of zero disables the pulse effect.
   * @param {Number} [options.visibleEdgeColor=0xffffff] - The color of visible edges.
   * @param {Number} [options.hiddenEdgeColor=0x22090a] - The color of hidden edges.
   * @param {KernelSize} [options.kernelSize=KernelSize.VERY_SMALL] - The blur kernel size.
   * @param {Boolean} [options.blur=false] - Whether the outline should be blurred.
   * @param {Boolean} [options.xRay=true] - Whether occluded parts of selected objects should be visible.
   * @param {Number} [options.multisampling=0] - The number of samples used for multisample antialiasing. Requires WebGL 2.
   * @param {Number} [options.resolutionScale=0.5] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(scene, camera, {
    blendFunction = BlendFunction.SCREEN,
    patternTexture = null,
    patternScale = 1,
    edgeStrength = 1,
    pulseSpeed = 0,
    visibleEdgeColor = 16777215,
    hiddenEdgeColor = 2230538,
    kernelSize = KernelSize.VERY_SMALL,
    blur = false,
    xRay = true,
    multisampling = 0,
    resolutionScale = 0.5,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("OutlineEffect", outline_default3, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Uniform(null)],
        ["edgeTexture", new Uniform(null)],
        ["edgeStrength", new Uniform(edgeStrength)],
        ["visibleEdgeColor", new Uniform(new Color(visibleEdgeColor))],
        ["hiddenEdgeColor", new Uniform(new Color(hiddenEdgeColor))],
        ["pulse", new Uniform(1)],
        ["patternScale", new Uniform(patternScale)],
        ["patternTexture", new Uniform(null)]
      ])
    });
    this.blendMode.addEventListener("change", (event) => {
      if (this.blendMode.getBlendFunction() === BlendFunction.ALPHA) {
        this.defines.set("ALPHA", "1");
      } else {
        this.defines.delete("ALPHA");
      }
      this.setChanged();
    });
    this.blendMode.setBlendFunction(blendFunction);
    this.patternTexture = patternTexture;
    this.xRay = xRay;
    this.scene = scene;
    this.camera = camera;
    this.renderTargetMask = new WebGLRenderTarget(1, 1);
    this.renderTargetMask.samples = multisampling;
    this.renderTargetMask.texture.name = "Outline.Mask";
    this.uniforms.get("maskTexture").value = this.renderTargetMask.texture;
    this.renderTargetOutline = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetOutline.texture.name = "Outline.Edges";
    this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture;
    this.clearPass = new ClearPass();
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.depthPass = new DepthPass(scene, camera);
    this.maskPass = new RenderPass(scene, camera, new DepthComparisonMaterial(this.depthPass.texture, camera));
    const clearPass = this.maskPass.clearPass;
    clearPass.overrideClearColor = new Color(16777215);
    clearPass.overrideClearAlpha = 1;
    this.blurPass = new KawaseBlurPass({ resolutionScale, resolutionX, resolutionY, kernelSize });
    this.blurPass.enabled = blur;
    const resolution = this.blurPass.resolution;
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.outlinePass = new ShaderPass(new OutlineMaterial());
    const outlineMaterial = this.outlinePass.fullscreenMaterial;
    outlineMaterial.inputBuffer = this.renderTargetMask.texture;
    this.time = 0;
    this.active = false;
    this.selection = new Selection();
    this.selection.layer = 10;
    this.pulseSpeed = pulseSpeed;
  }
  set mainScene(value) {
    this.scene = value;
    this.depthPass.mainScene = value;
    this.maskPass.mainScene = value;
  }
  set mainCamera(value) {
    this.camera = value;
    this.depthPass.mainCamera = value;
    this.maskPass.mainCamera = value;
    this.maskPass.overrideMaterial.copyCameraSettings(value);
  }
  /**
   * The resolution of this effect.
   *
   * @type {Resolution}
   */
  get resolution() {
    return this.blurPass.resolution;
  }
  /**
   * Returns the resolution.
   *
   * @return {Resizer} The resolution.
   */
  getResolution() {
    return this.blurPass.getResolution();
  }
  /**
   * The amount of MSAA samples.
   *
   * Requires WebGL 2. Set to zero to disable multisampling.
   *
   * @experimental Requires three >= r138.
   * @type {Number}
   */
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(value) {
    this.renderTargetMask.samples = value;
    this.renderTargetMask.dispose();
  }
  /**
   * The pattern scale.
   *
   * @type {Number}
   */
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(value) {
    this.uniforms.get("patternScale").value = value;
  }
  /**
   * The edge strength.
   *
   * @type {Number}
   */
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(value) {
    this.uniforms.get("edgeStrength").value = value;
  }
  /**
   * The visible edge color.
   *
   * @type {Color}
   */
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(value) {
    this.uniforms.get("visibleEdgeColor").value = value;
  }
  /**
   * The hidden edge color.
   *
   * @type {Color}
   */
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(value) {
    this.uniforms.get("hiddenEdgeColor").value = value;
  }
  /**
   * Returns the blur pass.
   *
   * @deprecated Use blurPass instead.
   * @return {KawaseBlurPass} The blur pass.
   */
  getBlurPass() {
    return this.blurPass;
  }
  /**
   * Returns the selection.
   *
   * @deprecated Use selection instead.
   * @return {Selection} The selection.
   */
  getSelection() {
    return this.selection;
  }
  /**
   * Returns the pulse speed.
   *
   * @deprecated Use pulseSpeed instead.
   * @return {Number} The speed.
   */
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  /**
   * Sets the pulse speed. Set to zero to disable.
   *
   * @deprecated Use pulseSpeed instead.
   * @param {Number} value - The speed.
   */
  setPulseSpeed(value) {
    this.pulseSpeed = value;
  }
  /**
   * The current width of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.width instead.
   */
  get width() {
    return this.resolution.width;
  }
  set width(value) {
    this.resolution.preferredWidth = value;
  }
  /**
   * The current height of the internal render targets.
   *
   * @type {Number}
   * @deprecated Use resolution.height instead.
   */
  get height() {
    return this.resolution.height;
  }
  set height(value) {
    this.resolution.preferredHeight = value;
  }
  /**
   * The selection layer.
   *
   * @type {Number}
   * @deprecated Use selection.layer instead.
   */
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(value) {
    this.selection.layer = value;
  }
  /**
   * Indicates whether dithering is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(value) {
    this.blurPass.dithering = value;
  }
  /**
   * The blur kernel size.
   *
   * @type {KernelSize}
   * @deprecated Use blurPass.kernelSize instead.
   */
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(value) {
    this.blurPass.kernelSize = value;
  }
  /**
   * Indicates whether the outlines should be blurred.
   *
   * @type {Boolean}
   * @deprecated Use blurPass.enabled instead.
   */
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(value) {
    this.blurPass.enabled = value;
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @type {Boolean}
   */
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(value) {
    if (this.xRay !== value) {
      if (value) {
        this.defines.set("X_RAY", "1");
      } else {
        this.defines.delete("X_RAY");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether X-ray mode is enabled.
   *
   * @deprecated Use xRay instead.
   * @return {Boolean} Whether X-ray mode is enabled.
   */
  isXRayEnabled() {
    return this.xRay;
  }
  /**
   * Enables or disables X-ray outlines.
   *
   * @deprecated Use xRay instead.
   * @param {Boolean} value - Whether X-ray should be enabled.
   */
  setXRayEnabled(value) {
    this.xRay = value;
  }
  /**
   * The pattern texture. Set to `null` to disable.
   *
   * @type {Texture}
   */
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(value) {
    if (value !== null) {
      value.wrapS = value.wrapT = RepeatWrapping;
      this.defines.set("USE_PATTERN", "1");
      this.setVertexShader(outline_default4);
    } else {
      this.defines.delete("USE_PATTERN");
      this.setVertexShader(null);
    }
    if (this.renderer !== null) {
      const decoding = getTextureDecoding(value, this.renderer.capabilities.isWebGL2);
      this.defines.set("texelToLinear(texel)", decoding);
    }
    this.uniforms.get("patternTexture").value = value;
    this.setChanged();
  }
  /**
   * Sets the pattern texture.
   *
   * @deprecated Use patternTexture instead.
   * @param {Texture} value - The new texture.
   */
  setPatternTexture(value) {
    this.patternTexture = value;
  }
  /**
   * Returns the current resolution scale.
   *
   * @return {Number} The resolution scale.
   * @deprecated Use resolution instead.
   */
  getResolutionScale() {
    return this.resolution.scale;
  }
  /**
   * Sets the resolution scale.
   *
   * @param {Number} scale - The new resolution scale.
   * @deprecated Use resolution instead.
   */
  setResolutionScale(scale) {
    this.resolution.scale = scale;
  }
  /**
   * Clears the current selection and selects a list of objects.
   *
   * @param {Object3D[]} objects - The objects that should be outlined. This array will be copied.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.set() instead.
   */
  setSelection(objects) {
    this.selection.set(objects);
    return this;
  }
  /**
   * Clears the list of selected objects.
   *
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.clear() instead.
   */
  clearSelection() {
    this.selection.clear();
    return this;
  }
  /**
   * Selects an object.
   *
   * @param {Object3D} object - The object that should be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.add() instead.
   */
  selectObject(object) {
    this.selection.add(object);
    return this;
  }
  /**
   * Deselects an object.
   *
   * @param {Object3D} object - The object that should no longer be outlined.
   * @return {OutlinePass} This pass.
   * @deprecated Use selection.delete() instead.
   */
  deselectObject(object) {
    this.selection.delete(object);
    return this;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const scene = this.scene;
    const camera = this.camera;
    const selection = this.selection;
    const uniforms = this.uniforms;
    const pulse = uniforms.get("pulse");
    const background = scene.background;
    const mask = camera.layers.mask;
    if (selection.size > 0) {
      scene.background = null;
      pulse.value = 1;
      if (this.pulseSpeed > 0) {
        pulse.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625;
      }
      this.active = true;
      this.time += deltaTime;
      selection.setVisible(false);
      this.depthPass.render(renderer);
      selection.setVisible(true);
      camera.layers.set(selection.layer);
      this.maskPass.render(renderer, this.renderTargetMask);
      camera.layers.mask = mask;
      scene.background = background;
      this.outlinePass.render(renderer, null, this.renderTargetOutline);
      if (this.blurPass.enabled) {
        this.blurPass.render(renderer, this.renderTargetOutline, this.renderTargetOutline);
      }
    } else if (this.active) {
      this.clearPass.render(renderer, this.renderTargetOutline);
      this.active = false;
    }
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.blurPass.setSize(width, height);
    this.renderTargetMask.setSize(width, height);
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.depthPass.setSize(w, h);
    this.renderTargetOutline.setSize(w, h);
    this.outlinePass.fullscreenMaterial.setSize(w, h);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    const texture = this.patternTexture;
    const decoding = getTextureDecoding(texture, renderer.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", decoding);
    this.blurPass.initialize(renderer, alpha, UnsignedByteType);
    if (frameBufferType !== void 0) {
      this.depthPass.initialize(renderer, alpha, frameBufferType);
      this.maskPass.initialize(renderer, alpha, frameBufferType);
      this.outlinePass.initialize(renderer, alpha, frameBufferType);
    }
  }
};
new Vector3();
new Vector3();

// src/textures/smaa/searchImageDataURL.js
var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC";

// src/textures/smaa/areaImageDataURL.js
var areaImageDataURL_default = "data:image/png;base64,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";

// src/effects/glsl/smaa.frag
var smaa_default = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}";

// src/effects/glsl/smaa.vert
var smaa_default2 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}";

// src/effects/SMAAEffect.js
var SMAAEffect = class extends Effect {
  /**
   * Constructs a new SMAA effect.
   *
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.SRC] - The blend function of this effect.
   * @param {SMAAPreset} [options.preset=SMAAPreset.MEDIUM] - The quality preset.
   * @param {EdgeDetectionMode} [options.edgeDetectionMode=EdgeDetectionMode.COLOR] - The edge detection mode.
   * @param {PredicationMode} [options.predicationMode=PredicationMode.DISABLED] - The predication mode.
   */
  constructor({
    blendFunction = BlendFunction.SRC,
    preset = SMAAPreset.MEDIUM,
    edgeDetectionMode = EdgeDetectionMode.COLOR,
    predicationMode = PredicationMode.DISABLED
  } = {}) {
    super("SMAAEffect", smaa_default, {
      vertexShader: smaa_default2,
      blendFunction,
      attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
      uniforms: /* @__PURE__ */ new Map([
        ["weightMap", new Uniform(null)]
      ])
    });
    let searchImage, areaImage;
    if (arguments.length > 1) {
      searchImage = arguments[0];
      areaImage = arguments[1];
      if (arguments.length > 2) {
        preset = arguments[2];
      }
      if (arguments.length > 3) {
        edgeDetectionMode = arguments[3];
      }
    }
    this.renderTargetEdges = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTargetEdges.texture.name = "SMAA.Edges";
    this.renderTargetWeights = this.renderTargetEdges.clone();
    this.renderTargetWeights.texture.name = "SMAA.Weights";
    this.uniforms.get("weightMap").value = this.renderTargetWeights.texture;
    this.clearPass = new ClearPass(true, false, false);
    this.clearPass.overrideClearColor = new Color(0);
    this.clearPass.overrideClearAlpha = 1;
    this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial());
    this.edgeDetectionMaterial.edgeDetectionMode = edgeDetectionMode;
    this.edgeDetectionMaterial.predicationMode = predicationMode;
    this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
    const loadingManager = new LoadingManager();
    loadingManager.onLoad = () => {
      const searchTexture = new Texture(searchImage);
      searchTexture.name = "SMAA.Search";
      searchTexture.magFilter = NearestFilter;
      searchTexture.minFilter = NearestFilter;
      searchTexture.generateMipmaps = false;
      searchTexture.needsUpdate = true;
      searchTexture.flipY = true;
      this.weightsMaterial.searchTexture = searchTexture;
      const areaTexture = new Texture(areaImage);
      areaTexture.name = "SMAA.Area";
      areaTexture.magFilter = LinearFilter;
      areaTexture.minFilter = LinearFilter;
      areaTexture.generateMipmaps = false;
      areaTexture.needsUpdate = true;
      areaTexture.flipY = false;
      this.weightsMaterial.areaTexture = areaTexture;
      this.dispatchEvent({ type: "load" });
    };
    loadingManager.itemStart("search");
    loadingManager.itemStart("area");
    if (searchImage !== void 0 && areaImage !== void 0) {
      loadingManager.itemEnd("search");
      loadingManager.itemEnd("area");
    } else if (typeof Image !== "undefined") {
      searchImage = new Image();
      areaImage = new Image();
      searchImage.addEventListener("load", () => loadingManager.itemEnd("search"));
      areaImage.addEventListener("load", () => loadingManager.itemEnd("area"));
      searchImage.src = searchImageDataURL_default;
      areaImage.src = areaImageDataURL_default;
    }
    this.applyPreset(preset);
  }
  /**
   * The edges texture.
   *
   * @type {Texture}
   */
  get edgesTexture() {
    return this.renderTargetEdges.texture;
  }
  /**
   * Returns the edges texture.
   *
   * @deprecated Use edgesTexture instead.
   * @return {Texture} The texture.
   */
  getEdgesTexture() {
    return this.edgesTexture;
  }
  /**
   * The edge weights texture.
   *
   * @type {Texture}
   */
  get weightsTexture() {
    return this.renderTargetWeights.texture;
  }
  /**
   * Returns the edge weights texture.
   *
   * @deprecated Use weightsTexture instead.
   * @return {Texture} The texture.
   */
  getWeightsTexture() {
    return this.weightsTexture;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   */
  get edgeDetectionMaterial() {
    return this.edgeDetectionPass.fullscreenMaterial;
  }
  /**
   * The edge detection material.
   *
   * @type {EdgeDetectionMaterial}
   * @deprecated Use edgeDetectionMaterial instead.
   */
  get colorEdgesMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * Returns the edge detection material.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @return {EdgeDetectionMaterial} The material.
   */
  getEdgeDetectionMaterial() {
    return this.edgeDetectionMaterial;
  }
  /**
   * The edge weights material.
   *
   * @type {SMAAWeightsMaterial}
   */
  get weightsMaterial() {
    return this.weightsPass.fullscreenMaterial;
  }
  /**
   * Returns the edge weights material.
   *
   * @deprecated Use weightsMaterial instead.
   * @return {SMAAWeightsMaterial} The material.
   */
  getWeightsMaterial() {
    return this.weightsMaterial;
  }
  /**
   * Sets the edge detection sensitivity.
   *
   * See {@link EdgeDetectionMaterial#setEdgeDetectionThreshold} for more details.
   *
   * @deprecated Use edgeDetectionMaterial instead.
   * @param {Number} threshold - The edge detection sensitivity. Range: [0.05, 0.5].
   */
  setEdgeDetectionThreshold(threshold) {
    this.edgeDetectionMaterial.edgeDetectionThreshold = threshold;
  }
  /**
   * Sets the maximum amount of horizontal/vertical search steps.
   *
   * See {@link SMAAWeightsMaterial#setOrthogonalSearchSteps} for more details.
   *
   * @deprecated Use weightsMaterial instead.
   * @param {Number} steps - The search steps. Range: [0, 112].
   */
  setOrthogonalSearchSteps(steps) {
    this.weightsMaterial.orthogonalSearchSteps = steps;
  }
  /**
   * Applies the given quality preset.
   *
   * @param {SMAAPreset} preset - The preset.
   */
  applyPreset(preset) {
    const edgeDetectionMaterial = this.edgeDetectionMaterial;
    const weightsMaterial = this.weightsMaterial;
    switch (preset) {
      case SMAAPreset.LOW:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.15;
        weightsMaterial.orthogonalSearchSteps = 4;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.MEDIUM:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 8;
        weightsMaterial.diagonalDetection = false;
        weightsMaterial.cornerDetection = false;
        break;
      case SMAAPreset.HIGH:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.1;
        weightsMaterial.orthogonalSearchSteps = 16;
        weightsMaterial.diagonalSearchSteps = 8;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
      case SMAAPreset.ULTRA:
        edgeDetectionMaterial.edgeDetectionThreshold = 0.05;
        weightsMaterial.orthogonalSearchSteps = 32;
        weightsMaterial.diagonalSearchSteps = 16;
        weightsMaterial.cornerRounding = 25;
        weightsMaterial.diagonalDetection = true;
        weightsMaterial.cornerDetection = true;
        break;
    }
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.edgeDetectionMaterial.depthBuffer = depthTexture;
    this.edgeDetectionMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    this.clearPass.render(renderer, this.renderTargetEdges);
    this.edgeDetectionPass.render(renderer, inputBuffer, this.renderTargetEdges);
    this.weightsPass.render(renderer, this.renderTargetEdges, this.renderTargetWeights);
  }
  /**
   * Updates the size of internal render targets.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    this.edgeDetectionMaterial.setSize(width, height);
    this.weightsMaterial.setSize(width, height);
    this.renderTargetEdges.setSize(width, height);
    this.renderTargetWeights.setSize(width, height);
  }
  /**
   * Deletes internal render targets and textures.
   */
  dispose() {
    const { searchTexture, areaTexture } = this.weightsMaterial;
    if (searchTexture !== null && areaTexture !== null) {
      searchTexture.dispose();
      areaTexture.dispose();
    }
    super.dispose();
  }
  /**
   * The SMAA search image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get searchImageDataURL() {
    return searchImageDataURL_default;
  }
  /**
   * The SMAA area image, encoded as a base64 data URL.
   *
   * @type {String}
   * @deprecated
   */
  static get areaImageDataURL() {
    return areaImageDataURL_default;
  }
};

// src/effects/glsl/ssao.frag
var ssao_default3 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}";

// src/effects/SSAOEffect.js
var NOISE_TEXTURE_SIZE = 64;
var SSAOEffect = class extends Effect {
  /**
   * Constructs a new SSAO effect.
   *
   * @todo Move normalBuffer to options.
   * @param {Camera} camera - The main camera.
   * @param {Texture} normalBuffer - A texture that contains the scene normals.
   * @param {Object} [options] - The options.
   * @param {BlendFunction} [options.blendFunction=BlendFunction.MULTIPLY] - The blend function of this effect.
   * @param {Boolean} [options.distanceScaling=true] - Deprecated.
   * @param {Boolean} [options.depthAwareUpsampling=true] - Enables or disables depth-aware upsampling. Has no effect if WebGL 2 is not supported.
   * @param {Texture} [options.normalDepthBuffer=null] - Deprecated.
   * @param {Number} [options.samples=9] - The amount of samples per pixel. Should not be a multiple of the ring count.
   * @param {Number} [options.rings=7] - The amount of spiral turns in the occlusion sampling pattern. Should be a prime number.
   * @param {Number} [options.worldDistanceThreshold] - The world distance threshold at which the occlusion effect starts to fade out.
   * @param {Number} [options.worldDistanceFalloff] - The world distance falloff. Influences the smoothness of the occlusion cutoff.
   * @param {Number} [options.worldProximityThreshold] - The world proximity threshold at which the occlusion starts to fade out.
   * @param {Number} [options.worldProximityFalloff] - The world proximity falloff. Influences the smoothness of the proximity cutoff.
   * @param {Number} [options.distanceThreshold=0.97] - Deprecated.
   * @param {Number} [options.distanceFalloff=0.03] - Deprecated.
   * @param {Number} [options.rangeThreshold=0.0005] - Deprecated.
   * @param {Number} [options.rangeFalloff=0.001] - Deprecated.
   * @param {Number} [options.minRadiusScale=0.1] - The minimum radius scale.
   * @param {Number} [options.luminanceInfluence=0.7] - Determines how much the luminance of the scene influences the ambient occlusion.
   * @param {Number} [options.radius=0.1825] - The occlusion sampling radius, expressed as a scale relative to the resolution. Range [1e-6, 1.0].
   * @param {Number} [options.intensity=1.0] - The intensity of the ambient occlusion.
   * @param {Number} [options.bias=0.025] - An occlusion bias. Eliminates artifacts caused by depth discontinuities.
   * @param {Number} [options.fade=0.01] - Influences the smoothness of the shadows. A lower value results in higher contrast.
   * @param {Color} [options.color=null] - The color of the ambient occlusion.
   * @param {Number} [options.resolutionScale=1.0] - The resolution scale.
   * @param {Number} [options.resolutionX=Resolution.AUTO_SIZE] - The horizontal resolution.
   * @param {Number} [options.resolutionY=Resolution.AUTO_SIZE] - The vertical resolution.
   * @param {Number} [options.width=Resolution.AUTO_SIZE] - Deprecated. Use resolutionX instead.
   * @param {Number} [options.height=Resolution.AUTO_SIZE] - Deprecated. Use resolutionY instead.
   */
  constructor(camera, normalBuffer, {
    blendFunction = BlendFunction.MULTIPLY,
    samples = 9,
    rings = 7,
    normalDepthBuffer = null,
    depthAwareUpsampling = true,
    worldDistanceThreshold,
    worldDistanceFalloff,
    worldProximityThreshold,
    worldProximityFalloff,
    distanceThreshold = 0.97,
    distanceFalloff = 0.03,
    rangeThreshold = 5e-4,
    rangeFalloff = 1e-3,
    minRadiusScale = 0.1,
    luminanceInfluence = 0.7,
    radius = 0.1825,
    intensity = 1,
    bias = 0.025,
    fade = 0.01,
    color: color2 = null,
    resolutionScale = 1,
    width = Resolution.AUTO_SIZE,
    height = Resolution.AUTO_SIZE,
    resolutionX = width,
    resolutionY = height
  } = {}) {
    super("SSAOEffect", ssao_default3, {
      blendFunction,
      attributes: EffectAttribute.DEPTH,
      defines: /* @__PURE__ */ new Map([
        ["THRESHOLD", "0.997"]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["aoBuffer", new Uniform(null)],
        ["normalDepthBuffer", new Uniform(normalDepthBuffer)],
        ["luminanceInfluence", new Uniform(luminanceInfluence)],
        ["color", new Uniform(null)],
        ["intensity", new Uniform(intensity)],
        ["scale", new Uniform(0)]
        // Unused.
      ])
    });
    this.renderTarget = new WebGLRenderTarget(1, 1, { depthBuffer: false });
    this.renderTarget.texture.name = "AO.Target";
    this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
    const resolution = this.resolution = new Resolution(this, resolutionX, resolutionY, resolutionScale);
    resolution.addEventListener("change", (e) => this.setSize(resolution.baseWidth, resolution.baseHeight));
    this.camera = camera;
    this.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer, resolutionScale });
    this.depthDownsamplingPass.enabled = normalDepthBuffer === null;
    this.ssaoPass = new ShaderPass(new SSAOMaterial(camera));
    const noiseTexture = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE, RGBAFormat);
    noiseTexture.wrapS = noiseTexture.wrapT = RepeatWrapping;
    const ssaoMaterial = this.ssaoMaterial;
    ssaoMaterial.normalBuffer = normalBuffer;
    ssaoMaterial.noiseTexture = noiseTexture;
    ssaoMaterial.minRadiusScale = minRadiusScale;
    ssaoMaterial.samples = samples;
    ssaoMaterial.radius = radius;
    ssaoMaterial.rings = rings;
    ssaoMaterial.fade = fade;
    ssaoMaterial.bias = bias;
    ssaoMaterial.distanceThreshold = distanceThreshold;
    ssaoMaterial.distanceFalloff = distanceFalloff;
    ssaoMaterial.proximityThreshold = rangeThreshold;
    ssaoMaterial.proximityFalloff = rangeFalloff;
    if (worldDistanceThreshold !== void 0) {
      ssaoMaterial.worldDistanceThreshold = worldDistanceThreshold;
    }
    if (worldDistanceFalloff !== void 0) {
      ssaoMaterial.worldDistanceFalloff = worldDistanceFalloff;
    }
    if (worldProximityThreshold !== void 0) {
      ssaoMaterial.worldProximityThreshold = worldProximityThreshold;
    }
    if (worldProximityFalloff !== void 0) {
      ssaoMaterial.worldProximityFalloff = worldProximityFalloff;
    }
    if (normalDepthBuffer !== null) {
      this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
      this.defines.set("NORMAL_DEPTH", "1");
    }
    this.depthAwareUpsampling = depthAwareUpsampling;
    this.color = color2;
  }
  set mainCamera(value) {
    this.camera = value;
    this.ssaoMaterial.copyCameraSettings(value);
  }
  /**
   * Returns the resolution settings.
   *
   * @deprecated Use resolution instead.
   * @return {Resolution} The resolution.
   */
  getResolution() {
    return this.resolution;
  }
  /**
   * The SSAO material.
   *
   * @type {SSAOMaterial}
   */
  get ssaoMaterial() {
    return this.ssaoPass.fullscreenMaterial;
  }
  /**
   * Returns the SSAO material.
   *
   * @deprecated Use ssaoMaterial instead.
   * @return {SSAOMaterial} The material.
   */
  getSSAOMaterial() {
    return this.ssaoMaterial;
  }
  /**
   * The amount of occlusion samples per pixel.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.samples instead.
   */
  get samples() {
    return this.ssaoMaterial.samples;
  }
  set samples(value) {
    this.ssaoMaterial.samples = value;
  }
  /**
   * The amount of spiral turns in the occlusion sampling pattern.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.rings instead.
   */
  get rings() {
    return this.ssaoMaterial.rings;
  }
  set rings(value) {
    this.ssaoMaterial.rings = value;
  }
  /**
   * The occlusion sampling radius.
   *
   * @type {Number}
   * @deprecated Use ssaoMaterial.radius instead.
   */
  get radius() {
    return this.ssaoMaterial.radius;
  }
  set radius(value) {
    this.ssaoMaterial.radius = value;
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @type {Boolean}
   */
  get depthAwareUpsampling() {
    return this.defines.has("DEPTH_AWARE_UPSAMPLING");
  }
  set depthAwareUpsampling(value) {
    if (this.depthAwareUpsampling !== value) {
      if (value) {
        this.defines.set("DEPTH_AWARE_UPSAMPLING", "1");
      } else {
        this.defines.delete("DEPTH_AWARE_UPSAMPLING");
      }
      this.setChanged();
    }
  }
  /**
   * Indicates whether depth-aware upsampling is enabled.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @return {Boolean} Whether depth-aware upsampling is enabled.
   */
  isDepthAwareUpsamplingEnabled() {
    return this.depthAwareUpsampling;
  }
  /**
   * Enables or disables depth-aware upsampling.
   *
   * @deprecated Use depthAwareUpsampling instead.
   * @param {Boolean} value - Whether depth-aware upsampling should be enabled.
   */
  setDepthAwareUpsamplingEnabled(value) {
    this.depthAwareUpsampling = value;
  }
  /**
   * Indicates whether distance-based radius scaling is enabled.
   *
   * @type {Boolean}
   * @deprecated
   */
  get distanceScaling() {
    return true;
  }
  set distanceScaling(value) {
  }
  /**
   * The color of the ambient occlusion. Set to `null` to disable.
   *
   * @type {Color}
   */
  get color() {
    return this.uniforms.get("color").value;
  }
  set color(value) {
    const uniforms = this.uniforms;
    const defines = this.defines;
    if (value !== null) {
      if (defines.has("COLORIZE")) {
        uniforms.get("color").value.set(value);
      } else {
        defines.set("COLORIZE", "1");
        uniforms.get("color").value = new Color(value);
        this.setChanged();
      }
    } else if (defines.has("COLORIZE")) {
      defines.delete("COLORIZE");
      uniforms.get("color").value = null;
      this.setChanged();
    }
  }
  /**
   * The luminance influence factor. Range: [0.0, 1.0].
   *
   * @type {Boolean}
   */
  get luminanceInfluence() {
    return this.uniforms.get("luminanceInfluence").value;
  }
  set luminanceInfluence(value) {
    this.uniforms.get("luminanceInfluence").value = value;
  }
  /**
   * The intensity.
   *
   * @type {Number}
   */
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(value) {
    this.uniforms.get("intensity").value = value;
  }
  /**
   * Returns the color of the ambient occlusion.
   *
   * @deprecated Use color instead.
   * @return {Color} The color.
   */
  getColor() {
    return this.color;
  }
  /**
   * Sets the color of the ambient occlusion. Set to `null` to disable colorization.
   *
   * @deprecated Use color instead.
   * @param {Color} value - The color.
   */
  setColor(value) {
    this.color = value;
  }
  /**
   * Sets the occlusion distance cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The distance threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setDistanceCutoff(threshold, falloff) {
    this.ssaoMaterial.distanceThreshold = threshold;
    this.ssaoMaterial.distanceFalloff = falloff;
  }
  /**
   * Sets the occlusion proximity cutoff.
   *
   * @deprecated Use ssaoMaterial instead.
   * @param {Number} threshold - The proximity threshold. Range [0.0, 1.0].
   * @param {Number} falloff - The falloff. Range [0.0, 1.0].
   */
  setProximityCutoff(threshold, falloff) {
    this.ssaoMaterial.proximityThreshold = threshold;
    this.ssaoMaterial.proximityFalloff = falloff;
  }
  /**
   * Sets the depth texture.
   *
   * @param {Texture} depthTexture - A depth texture.
   * @param {DepthPackingStrategies} [depthPacking=BasicDepthPacking] - The depth packing.
   */
  setDepthTexture(depthTexture, depthPacking = BasicDepthPacking) {
    this.depthDownsamplingPass.setDepthTexture(depthTexture, depthPacking);
    this.ssaoMaterial.depthBuffer = depthTexture;
    this.ssaoMaterial.depthPacking = depthPacking;
  }
  /**
   * Updates this effect.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} inputBuffer - A frame buffer that contains the result of the previous pass.
   * @param {Number} [deltaTime] - The time between the last frame and the current one in seconds.
   */
  update(renderer, inputBuffer, deltaTime) {
    const renderTarget = this.renderTarget;
    if (this.depthDownsamplingPass.enabled) {
      this.depthDownsamplingPass.render(renderer);
    }
    this.ssaoPass.render(renderer, null, renderTarget);
  }
  /**
   * Sets the size.
   *
   * @param {Number} width - The width.
   * @param {Number} height - The height.
   */
  setSize(width, height) {
    const resolution = this.resolution;
    resolution.setBaseSize(width, height);
    const w = resolution.width, h = resolution.height;
    this.ssaoMaterial.copyCameraSettings(this.camera);
    this.ssaoMaterial.setSize(w, h);
    this.renderTarget.setSize(w, h);
    this.depthDownsamplingPass.resolution.scale = resolution.scale;
    this.depthDownsamplingPass.setSize(width, height);
  }
  /**
   * Performs initialization tasks.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Boolean} alpha - Whether the renderer uses the alpha channel or not.
   * @param {Number} frameBufferType - The type of the main frame buffers.
   */
  initialize(renderer, alpha, frameBufferType) {
    try {
      let normalDepthBuffer = this.uniforms.get("normalDepthBuffer").value;
      if (normalDepthBuffer === null) {
        this.depthDownsamplingPass.initialize(renderer, alpha, frameBufferType);
        normalDepthBuffer = this.depthDownsamplingPass.texture;
        this.uniforms.get("normalDepthBuffer").value = normalDepthBuffer;
        this.ssaoMaterial.normalDepthBuffer = normalDepthBuffer;
        this.defines.set("NORMAL_DEPTH", "1");
      }
    } catch (e) {
      this.depthDownsamplingPass.enabled = false;
    }
  }
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

var boxBlur = "#define GLSLIFY 1\nuniform float blur;uniform float blurSharpness;uniform int blurKernel;vec3 denoise(vec3 center,sampler2D tex,vec2 uv,vec2 invTexSize,float blur,float blurSharpness,int blurKernel){vec3 color;float total;vec3 col;float weight;for(int x=-blurKernel;x<=blurKernel;x++){for(int y=-blurKernel;y<=blurKernel;y++){col=textureLod(tex,uv+vec2(x,y)*invTexSize,0.).rgb;weight=1.0-abs(dot(col-center,vec3(0.25)));weight=pow(weight,blurSharpness);color+=col*weight;total+=weight;}}return color/total;}"; // eslint-disable-line

var finalSSRShader = "#define GLSLIFY 1\n#define MODE_DEFAULT 0\n#define MODE_REFLECTIONS 1\n#define MODE_RAW_REFLECTION 2\n#define MODE_BLURRED_REFLECTIONS 3\n#define MODE_INPUT 4\n#define MODE_BLUR_MIX 5\n#define FLOAT_EPSILON 0.00001\nuniform sampler2D inputTexture;uniform sampler2D reflectionsTexture;uniform float samples;\n#include <boxBlur>\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 reflectionsTexel=texture2D(reflectionsTexture,vUv);ivec2 size=textureSize(reflectionsTexture,0);vec2 invTexSize=1./vec2(size.x,size.y);vec3 reflectionClr=reflectionsTexel.xyz;if(blur>FLOAT_EPSILON){vec3 blurredReflectionsColor=denoise(reflectionsTexel.rgb,reflectionsTexture,vUv,invTexSize,blur,blurSharpness,blurKernel);reflectionClr=mix(reflectionClr,blurredReflectionsColor.rgb,blur);}\n#if RENDER_MODE == MODE_DEFAULT\noutputColor=vec4(inputColor.rgb+reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_REFLECTIONS\noutputColor=vec4(reflectionClr,1.0);\n#endif\n#if RENDER_MODE == MODE_RAW_REFLECTION\noutputColor=vec4(reflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLURRED_REFLECTIONS\noutputColor=vec4(blurredReflectionsTexel.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_INPUT\noutputColor=vec4(inputColor.xyz,1.0);\n#endif\n#if RENDER_MODE == MODE_BLUR_MIX\noutputColor=vec4(vec3(blur),1.0);\n#endif\n}"; // eslint-disable-line

var helperFunctions = "#define GLSLIFY 1\nvec3 getViewPosition(const float depth){float clipW=_projectionMatrix[2][3]*depth+_projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(_inverseProjectionMatrix*clipPosition).xyz;}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=_inverseProjectionMatrix*ndc;vec4 view=cameraMatrixWorld*(clip/clip.w);return view.xyz;}\n#define Scale (vec3(0.8, 0.8, 0.8))\n#define K (19.19)\nvec3 hash(vec3 a){a=fract(a*Scale);a+=dot(a,a.yxz+K);return fract((a.xxy+a.yxx)*a.zyx);}float fresnel_dielectric_cos(float cosi,float eta){float c=abs(cosi);float g=eta*eta-1.0+c*c;float result;if(g>0.0){g=sqrt(g);float A=(g-c)/(g+c);float B=(c*(g+c)-1.0)/(c*(g-c)+1.0);result=0.5*A*A*(1.0+B*B);}else{result=1.0;}return result;}float fresnel_dielectric(vec3 Incoming,vec3 Normal,float eta){float cosine=dot(Incoming,Normal);return min(1.0,5.0*fresnel_dielectric_cos(cosine,eta));}"; // eslint-disable-line

var trCompose = "#define GLSLIFY 1\n#define INV_EULER 0.36787944117144233\nalpha=velocityDisocclusion<FLOAT_EPSILON ?(alpha+0.0075): 0.0;alpha=clamp(alpha,0.0,1.0);bool needsBlur=!didReproject||velocityDisocclusion>0.5;\n#ifdef boxBlur\nif(needsBlur)inputColor=boxBlurredColor;\n#endif\nif(alpha==1.0){outputColor=accumulatedColor;}else{float m=mix(alpha,1.0,blend);if(needsBlur)m=0.0;outputColor=accumulatedColor*m+inputColor*(1.0-m);}"; // eslint-disable-line

// WebGL2: will render normals to RGB channel of "gNormal" buffer, roughness to A channel of "gNormal" buffer, depth to RGBA channel of "gDepth" buffer
// and velocity to "gVelocity" buffer

class MRTMaterial extends ShaderMaterial {
  constructor() {
    super({
      type: "MRTMaterial",
      defines: {
        USE_UV: "",
        TEMPORAL_RESOLVE: ""
      },
      uniforms: {
        opacity: new Uniform(1),
        normalMap: new Uniform(null),
        normalScale: new Uniform(new Vector2(1, 1)),
        uvTransform: new Uniform(new Matrix3()),
        roughness: new Uniform(1),
        roughnessMap: new Uniform(null)
      },
      vertexShader:
      /* glsl */
      `
                #ifdef USE_MRT
                 varying vec2 vHighPrecisionZW;
                #endif
                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <common>
                #include <uv_pars_vertex>
                #include <displacementmap_pars_vertex>
                #include <normal_pars_vertex>
                #include <morphtarget_pars_vertex>
                #include <skinning_pars_vertex>
                #include <logdepthbuf_pars_vertex>
                #include <clipping_planes_pars_vertex>
                void main() {
                    #include <uv_vertex>
                    #include <beginnormal_vertex>
                    #include <morphnormal_vertex>
                    #include <skinbase_vertex>
                    #include <skinnormal_vertex>
                    #include <defaultnormal_vertex>
                    #include <normal_vertex>
                    #include <begin_vertex>
                    #include <morphtarget_vertex>
                    #include <skinning_vertex>
                    #include <displacementmap_vertex>
                    #include <project_vertex>
                    #include <logdepthbuf_vertex>
                    #include <clipping_planes_vertex>
                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                        vViewPosition = - mvPosition.xyz;
                    #endif
                    #ifdef USE_MRT
                        vHighPrecisionZW = gl_Position.zw;
                    #endif 
                    #ifdef USE_UV
                        vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
                    #endif
                }
            `,
      fragmentShader:
      /* glsl */
      `
                 #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <packing>
                #include <uv_pars_fragment>
                #include <normal_pars_fragment>
                #include <bumpmap_pars_fragment>
                #include <normalmap_pars_fragment>
                #include <logdepthbuf_pars_fragment>
                #include <clipping_planes_pars_fragment>
                #include <roughnessmap_pars_fragment>
                
                #ifdef USE_MRT
                layout(location = 0) out vec4 gNormal;
                layout(location = 1) out vec4 gDepth;
                
                varying vec2 vHighPrecisionZW;
                #endif
                uniform float roughness;
                void main() {
                    #include <clipping_planes_fragment>
                    #include <logdepthbuf_fragment>
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>

                    float roughnessFactor = roughness;
                    
                    if(roughness > 10.0e9){
                        roughnessFactor = 1.;
                    }else{
                        #ifdef useRoughnessMap
                            vec4 texelRoughness = texture2D( roughnessMap, vUv );
                            // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
                            roughnessFactor *= texelRoughness.g;
                        #endif
                    }

                    vec3 normalColor = packNormalToRGB( normal );
                    #ifdef USE_MRT
                        float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        vec4 depthColor = packDepthToRGBA( fragCoordZ );
                        gNormal = vec4( normalColor, roughnessFactor );
                        gDepth = depthColor;
                    #else
                        gl_FragColor = vec4(normalColor, roughnessFactor);
                    #endif
                }
            `,
      toneMapped: false
    });
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    Object.defineProperty(this, "glslVersion", {
      get() {
        return "USE_MRT" in this.defines ? GLSL3 : null;
      },

      set(_) {}

    });
  }

}

var vertexShader$1 = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"; // eslint-disable-line

var fragmentShader = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D normalTexture;uniform sampler2D depthTexture;uniform sampler2D envMap;uniform mat4 _projectionMatrix;uniform mat4 _inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float rayDistance;uniform float intensity;uniform float maxDepthDifference;uniform float roughnessFade;uniform float maxRoughness;uniform float fade;uniform float thickness;uniform float ior;uniform float samples;uniform float jitter;uniform float jitterRoughness;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EARLY_OUT_COLOR vec4(0.0, 0.0, 0.0, 1.0)\n#define FLOAT_EPSILON 0.00001\nfloat nearMinusFar;float nearMulFar;float farMinusNear;\n#include <packing>\n#include <helperFunctions>\nvec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference);float fastGetViewZ(const in float depth);vec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON){gl_FragColor=EARLY_OUT_COLOR;return;}float unpackedDepth=unpackRGBAToDepth(depthTexel);vec4 normalTexel=textureLod(normalTexture,vUv,0.0);float roughness=normalTexel.a;float specular=1.0-roughness;nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;normalTexel.rgb=unpackRGBToNormal(normalTexel.rgb);float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 viewNormal=normalTexel.xyz;vec3 worldPos=screenSpaceToWorldSpace(vUv,unpackedDepth);vec3 jitt=vec3(0.0);if(jitterRoughness!=0.0||jitter!=0.0){vec3 randomJitter=hash(50.0*samples*worldPos)-0.5;float spread=((2.0-specular)+roughness*jitterRoughness);float jitterMix=jitter*0.25+jitterRoughness*roughness;if(jitterMix>1.0)jitterMix=1.0;jitt=mix(vec3(0.0),randomJitter*spread,jitterMix);}viewNormal+=jitt;float fresnelFactor=fresnel_dielectric(viewDir,viewNormal,ior);vec3 iblRadiance=getIBLRadiance(-viewDir,viewNormal,0.)*fresnelFactor;float lastFrameAlpha=textureLod(accumulatedTexture,vUv,0.0).a;if(roughness>maxRoughness||(roughness>1.0-FLOAT_EPSILON&&roughnessFade>1.0-FLOAT_EPSILON)){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec3 reflected=reflect(viewDir,viewNormal);vec3 rayDir=reflected*-viewPos.z;vec3 hitPos=viewPos;float rayHitDepthDifference;vec2 coords=RayMarch(rayDir,hitPos,rayHitDepthDifference);if(coords.x==-1.0){gl_FragColor=vec4(iblRadiance,lastFrameAlpha);return;}vec4 SSRTexel=textureLod(inputTexture,coords.xy,0.0);vec4 SSRTexelReflected=textureLod(accumulatedTexture,coords.xy,0.0);vec3 SSR=SSRTexel.rgb+SSRTexelReflected.rgb;float roughnessFactor=mix(specular,1.0,max(0.0,1.0-roughnessFade));vec2 coordsNDC=(coords.xy*2.0-1.0);float screenFade=0.1;float maxDimension=min(1.0,max(abs(coordsNDC.x),abs(coordsNDC.y)));float reflectionIntensity=1.0-(max(0.0,maxDimension-screenFade)/(1.0-screenFade));reflectionIntensity=max(0.,reflectionIntensity);vec3 finalSSR=mix(iblRadiance,SSR,reflectionIntensity)*roughnessFactor;if(fade!=0.0){vec3 hitWorldPos=screenSpaceToWorldSpace(coords,rayHitDepthDifference);float reflectionDistance=distance(hitWorldPos,worldPos)+1.0;float opacity=1.0/(reflectionDistance*fade*0.1);if(opacity>1.0)opacity=1.0;finalSSR*=opacity;}finalSSR*=fresnelFactor*intensity;finalSSR=min(vec3(1.0),finalSSR);float alpha=hitPos.z==1.0 ? 1.0 : SSRTexelReflected.a;alpha=min(lastFrameAlpha,alpha);gl_FragColor=vec4(finalSSR,alpha);}vec2 RayMarch(vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){dir=normalize(dir);dir*=rayDistance/float(steps);float depth;vec4 projectedCoord;vec4 lastProjectedCoord;float unpackedDepth;vec4 depthTexel;for(int i=0;i<steps;i++){hitPos+=dir;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;\n#ifndef missedRays\nif(projectedCoord.x<0.0||projectedCoord.x>1.0||projectedCoord.y<0.0||projectedCoord.y>1.0){return INVALID_RAY_COORDS;}\n#endif\ndepthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\n#if refineSteps == 0\nif(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;\n#else\nreturn BinarySearch(dir,hitPos,rayHitDepthDifference);\n#endif\n}\n#ifndef missedRays\nif(hitPos.z>0.0){return INVALID_RAY_COORDS;}\n#endif\nlastProjectedCoord=projectedCoord;}hitPos.z=1.0;\n#ifndef missedRays\nreturn INVALID_RAY_COORDS;\n#endif\nrayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}vec2 BinarySearch(in vec3 dir,inout vec3 hitPos,inout float rayHitDepthDifference){float depth;vec4 projectedCoord;vec2 lastMinProjectedCoordXY;float unpackedDepth;vec4 depthTexel;for(int i=0;i<refineSteps;i++){projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;depthTexel=textureLod(depthTexture,projectedCoord.xy,0.0);unpackedDepth=unpackRGBAToDepth(depthTexel);depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;if(rayHitDepthDifference>0.0){hitPos-=dir;}else{hitPos+=dir;}}if(dot(depthTexel.rgb,depthTexel.rgb)<FLOAT_EPSILON)return INVALID_RAY_COORDS;if(abs(rayHitDepthDifference)>maxDepthDifference)return INVALID_RAY_COORDS;projectedCoord=_projectionMatrix*vec4(hitPos,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;rayHitDepthDifference=unpackedDepth;return projectedCoord.xy;}float fastGetViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}\n#include <common>\n#include <cube_uv_reflection_fragment>\nvec3 getIBLRadiance(const in vec3 viewDir,const in vec3 normal,const in float roughness){\n#if defined(ENVMAP_TYPE_CUBE_UV)\nvec3 reflectVec=reflect(-viewDir,normal);reflectVec=normalize(mix(reflectVec,normal,roughness*roughness));reflectVec=inverseTransformDirection(reflectVec,viewMatrix);vec4 envMapColor=textureCubeUV(envMap,reflectVec,roughness);return envMapColor.rgb*intensity;\n#else\nreturn vec3(0.0);\n#endif\n}"; // eslint-disable-line

class ReflectionsMaterial extends ShaderMaterial {
  constructor() {
    super({
      type: "ReflectionsMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        normalTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        _projectionMatrix: new Uniform(new Matrix4()),
        _inverseProjectionMatrix: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        rayDistance: new Uniform(0),
        intensity: new Uniform(0),
        roughnessFade: new Uniform(0),
        fade: new Uniform(0),
        thickness: new Uniform(0),
        ior: new Uniform(0),
        maxDepthDifference: new Uniform(0),
        jitter: new Uniform(0),
        jitterRoughness: new Uniform(0),
        maxRoughness: new Uniform(0),
        samples: new Uniform(0),
        envMap: new Uniform(null),
        envMapPosition: new Uniform(new Vector3()),
        envMapSize: new Uniform(new Vector3()),
        viewMatrix: new Uniform(new Matrix4())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        CUBEUV_TEXEL_WIDTH: 0,
        CUBEUV_TEXEL_HEIGHT: 0,
        CUBEUV_MAX_MIP: 0,
        vWorldPosition: "worldPos"
      },
      fragmentShader: fragmentShader.replace("#include <helperFunctions>", helperFunctions),
      vertexShader: vertexShader$1,
      toneMapped: false,
      depthWrite: false,
      depthTest: false
    });
  }

}

const getVisibleChildren = object => {
  const queue = [object];
  const objects = [];

  while (queue.length !== 0) {
    const mesh = queue.shift();
    if (mesh.material) objects.push(mesh);

    for (const c of mesh.children) {
      if (c.visible) queue.push(c);
    }
  }

  return objects;
};
const generateCubeUVSize = parameters => {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1.0 / imageHeight;
  const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return {
    texelWidth,
    texelHeight,
    maxMip
  };
};
const setupEnvMap = (reflectionsMaterial, envMap, envMapCubeUVHeight) => {
  reflectionsMaterial.uniforms.envMap.value = envMap;
  const envMapCubeUVSize = generateCubeUVSize({
    envMapCubeUVHeight
  });
  reflectionsMaterial.defines.ENVMAP_TYPE_CUBE_UV = "";
  reflectionsMaterial.defines.CUBEUV_TEXEL_WIDTH = envMapCubeUVSize.texelWidth;
  reflectionsMaterial.defines.CUBEUV_TEXEL_HEIGHT = envMapCubeUVSize.texelHeight;
  reflectionsMaterial.defines.CUBEUV_MAX_MIP = envMapCubeUVSize.maxMip + ".0";
  reflectionsMaterial.needsUpdate = true;
};

const isWebGL2Available = () => {
  try {
    const canvas = document.createElement("canvas");
    return !!(window.WebGL2RenderingContext && canvas.getContext("webgl2"));
  } catch (e) {
    return false;
  }
};

class ReflectionsPass extends Pass {
  constructor(ssrEffect, options = {}) {
    super("ReflectionsPass");
    this.ssrEffect = void 0;
    this.cachedMaterials = new WeakMap();
    this.USE_MRT = false;
    this.webgl1DepthPass = null;
    this.visibleMeshes = [];
    this.ssrEffect = ssrEffect;
    this._scene = ssrEffect._scene;
    this._camera = ssrEffect._camera;
    this.fullscreenMaterial = new ReflectionsMaterial();
    if (ssrEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
    const width = options.width || typeof window !== "undefined" ? window.innerWidth : 2000;
    const height = options.height || typeof window !== "undefined" ? window.innerHeight : 1000;
    this.renderTarget = new WebGLRenderTarget(width, height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.renderPass = new RenderPass(this._scene, this._camera);
    this.USE_MRT = isWebGL2Available();

    if (this.USE_MRT) {
      // buffers: normal, depth (2), roughness will be written to the alpha channel of the normal buffer
      this.gBuffersRenderTarget = new WebGLMultipleRenderTargets(width, height, 2, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture[0];
      this.depthTexture = this.gBuffersRenderTarget.texture[1];
    } else {
      // depth pass
      this.webgl1DepthPass = new DepthPass(this._scene, this._camera);
      this.webgl1DepthPass.renderTarget.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.magFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.minFilter = LinearFilter;
      this.webgl1DepthPass.renderTarget.texture.magFilter = LinearFilter;
      this.webgl1DepthPass.setSize(typeof window !== "undefined" ? window.innerWidth : 2000, typeof window !== "undefined" ? window.innerHeight : 1000); // render normals (in the rgb channel) and roughness (in the alpha channel) in gBuffersRenderTarget

      this.gBuffersRenderTarget = new WebGLRenderTarget(width, height, {
        minFilter: LinearFilter,
        magFilter: LinearFilter
      });
      this.normalTexture = this.gBuffersRenderTarget.texture;
      this.depthTexture = this.webgl1DepthPass.texture;
    } // set up uniforms


    this.fullscreenMaterial.uniforms.normalTexture.value = this.normalTexture;
    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;
    this.fullscreenMaterial.uniforms._projectionMatrix.value = this._camera.projectionMatrix;
    this.fullscreenMaterial.uniforms._inverseProjectionMatrix.value = this._camera.projectionMatrixInverse;
  }

  setSize(width, height) {
    this.renderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.gBuffersRenderTarget.setSize(width * this.ssrEffect.resolutionScale, height * this.ssrEffect.resolutionScale);
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssrEffect.temporalResolvePass.accumulatedTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }

  dispose() {
    this.renderTarget.dispose();
    this.gBuffersRenderTarget.dispose();
    this.renderPass.dispose();
    if (!this.USE_MRT) this.webgl1DepthPass.dispose();
    this.fullscreenMaterial.dispose();
    this.normalTexture = null;
    this.depthTexture = null;
    this.velocityTexture = null;
  }

  keepMaterialMapUpdated(mrtMaterial, originalMaterial, prop, define) {
    if (this.ssrEffect[define]) {
      if (originalMaterial[prop] !== mrtMaterial[prop]) {
        mrtMaterial[prop] = originalMaterial[prop];
        mrtMaterial.uniforms[prop].value = originalMaterial[prop];

        if (originalMaterial[prop]) {
          mrtMaterial.defines[define] = "";
        } else {
          delete mrtMaterial.defines[define];
        }

        mrtMaterial.needsUpdate = true;
      }
    } else if (mrtMaterial[prop] !== undefined) {
      mrtMaterial[prop] = undefined;
      mrtMaterial.uniforms[prop].value = undefined;
      delete mrtMaterial.defines[define];
      mrtMaterial.needsUpdate = true;
    }
  }

  setMRTMaterialInScene() {
    this.visibleMeshes = getVisibleChildren(this._scene);

    for (const c of this.visibleMeshes) {
      if (c.material) {
        const originalMaterial = c.material;
        let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || [];

        if (originalMaterial !== cachedOriginalMaterial) {
          if (mrtMaterial) mrtMaterial.dispose();
          mrtMaterial = new MRTMaterial();
          if (this.USE_MRT) mrtMaterial.defines.USE_MRT = "";
          mrtMaterial.normalScale = originalMaterial.normalScale;
          mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale;
          const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;
          if (map) mrtMaterial.uniforms.uvTransform.value = map.matrix;
          this.cachedMaterials.set(c, [originalMaterial, mrtMaterial]);
        } // update the child's MRT material


        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "normalMap", "useNormalMap");
        this.keepMaterialMapUpdated(mrtMaterial, originalMaterial, "roughnessMap", "useRoughnessMap");
        mrtMaterial.uniforms.roughness.value = this.ssrEffect.selection.size === 0 || this.ssrEffect.selection.has(c) ? originalMaterial.roughness || 0 : 10e10;
        c.material = mrtMaterial;
      }
    }
  }

  unsetMRTMaterialInScene() {
    for (const c of this.visibleMeshes) {
      var _c$material;

      if (((_c$material = c.material) == null ? void 0 : _c$material.type) === "MRTMaterial") {
        c.visible = true; // set material back to the original one

        const [originalMaterial] = this.cachedMaterials.get(c);
        c.material = originalMaterial;
      }
    }
  }

  render(renderer, inputBuffer) {
    this.setMRTMaterialInScene();
    renderer.setRenderTarget(this.gBuffersRenderTarget);
    this.renderPass.render(renderer, this.gBuffersRenderTarget);
    this.unsetMRTMaterialInScene(); // render depth and velocity in seperate passes

    if (!this.USE_MRT) this.webgl1DepthPass.renderPass.render(renderer, this.webgl1DepthPass.renderTarget);
    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;
    this.fullscreenMaterial.uniforms.samples.value = this.ssrEffect.temporalResolvePass.samples;
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse);
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }

}

/**
* Options of the SSR effect
* @typedef {Object} SSROptions
* @property {Number} [intensity] intensity of the reflections
* @property {Number} [exponent] exponent by which reflections will be potentiated when composing the current frame's reflections and the accumulated reflections into a final reflection; higher values will make reflections clearer by highlighting darker spots less
* @property {Number} [distance] maximum distance a reflection ray can travel to find what it reflects
* @property {Number} [fade] how much reflections will fade out by distance
* @property {Number} [roughnessFade] how intense reflections should be on rough spots; a higher value will make reflections fade out quicker on rough spots
* @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance
* @property {Number} [ior] Index of Refraction, used for calculating fresnel; reflections tend to be more intense the steeper the angle between them and the viewer is, the ior parameter sets how much the intensity varies
* @property {Number} [maxRoughness] maximum roughness a texel can have to have reflections calculated for it
* @property {Number} [maxDepthDifference] maximum depth difference between a ray and the particular depth at its screen position after refining with binary search; higher values will result in better performance
* @property {Number} [blend] a value between 0 and 1 to set how much the last frame's reflections should be blended in; higher values will result in less noisy reflections when moving the camera but a more smeary look
* @property {boolean} [correction] how much pixels should be corrected when doing temporal resolving; higher values will result in less smearing but more noise
* @property {boolean} [correctionRadius] how many surrounding pixels will be used for neighborhood clamping; a higher value can reduce noise when moving the camera but will result in less performance
* @property {Number} [blur] how much the blurred reflections should be mixed with the raw reflections
* @property {Number} [blurKernel] kernel size of the Box Blur Filter; higher kernel sizes will result in blurrier reflections with more artifacts
* @property {Number} [blurSharpness] exponent of the Box Blur filter; higher values will result in more sharpness
* @property {Number} [jitter] how intense jittering should be
* @property {Number} [jitterRoughness] how intense jittering should be in relation to a material's roughness
* @property {Number} [steps] number of steps a reflection ray can maximally do to find an object it intersected (and thus reflects)
* @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps
* @property {boolean} [missedRays] if there should still be reflections for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking reflections which can look good or bad depending on the angle
* @property {boolean} [useNormalMap] if roughness maps should be taken account of when calculating reflections
* @property {boolean} [useRoughnessMap] if normal maps should be taken account of when calculating reflections
* @property {Number} [resolutionScale] resolution of the SSR effect, a resolution of 0.5 means the effect will be rendered at half resolution
* @property {Number} [velocityResolutionScale] resolution of the velocity buffer, a resolution of 0.5 means velocity will be rendered at half resolution
*/

/**
 * The options of the SSR effect
 * @type {SSROptions}
 */
const defaultSSROptions = {
  intensity: 1,
  exponent: 1,
  distance: 10,
  fade: 0,
  roughnessFade: 1,
  thickness: 10,
  ior: 1.45,
  maxRoughness: 1,
  maxDepthDifference: 10,
  blend: 0.9,
  correction: 1,
  correctionRadius: 1,
  blur: 0.5,
  blurKernel: 1,
  blurSharpness: 10,
  jitter: 0,
  jitterRoughness: 0,
  steps: 20,
  refineSteps: 5,
  missedRays: true,
  useNormalMap: true,
  useRoughnessMap: true,
  resolutionScale: 1,
  velocityResolutionScale: 1
};

var vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"; // eslint-disable-line

var temporalResolve = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D accumulatedTexture;uniform sampler2D velocityTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float correction;uniform float exponent;uniform float samples;uniform vec2 invTexSize;uniform mat4 curInverseProjectionMatrix;uniform mat4 curCameraMatrixWorld;uniform mat4 prevInverseProjectionMatrix;uniform mat4 prevCameraMatrixWorld;varying vec2 vUv;\n#define MAX_NEIGHBOR_DEPTH_DIFFERENCE 0.001\n#define FLOAT_EPSILON 0.00001\n#define FLOAT_ONE_MINUS_EPSILON 0.99999\nvec3 transformexponent;vec3 undoColorTransformExponent;vec3 transformColor(vec3 color){if(exponent==1.0)return color;return pow(abs(color),transformexponent);}vec3 undoColorTransform(vec3 color){if(exponent==1.0)return color;return max(pow(abs(color),undoColorTransformExponent),vec3(0.0));}void main(){if(exponent!=1.0){transformexponent=vec3(1.0/exponent);undoColorTransformExponent=vec3(exponent);}vec4 inputTexel=textureLod(inputTexture,vUv,0.0);vec4 accumulatedTexel;vec3 inputColor=transformColor(inputTexel.rgb);vec3 accumulatedColor;float alpha=inputTexel.a;float velocityDisocclusion;bool didReproject=false;\n#ifdef boxBlur\nvec3 boxBlurredColor=inputTexel.rgb;\n#endif\nvec4 velocity=textureLod(velocityTexture,vUv,0.0);bool isMoving=alpha<1.0||dot(velocity.xy,velocity.xy)>0.0;if(isMoving){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;vec3 col;vec2 neighborUv;vec2 reprojectedUv=vUv-velocity.xy;vec4 lastVelocity=textureLod(lastVelocityTexture,reprojectedUv,0.0);float depth=velocity.b;float closestDepth=depth;float lastClosestDepth=lastVelocity.b;float neighborDepth;float lastNeighborDepth;for(int x=-correctionRadius;x<=correctionRadius;x++){for(int y=-correctionRadius;y<=correctionRadius;y++){if(x!=0||y!=0){neighborUv=vUv+vec2(x,y)*invTexSize;vec4 neigborVelocity=textureLod(velocityTexture,neighborUv,0.0);neighborDepth=neigborVelocity.b;col=textureLod(inputTexture,neighborUv,0.0).xyz;int absX=abs(x);int absY=abs(y);\n#ifdef dilation\nif(absX==1&&absY==1){if(neighborDepth>closestDepth){velocity=neigborVelocity;closestDepth=neighborDepth;}vec4 lastNeighborVelocity=textureLod(velocityTexture,vUv+vec2(x,y)*invTexSize,0.0);lastNeighborDepth=lastNeighborVelocity.b;if(neighborDepth>closestDepth){lastVelocity=lastNeighborVelocity;lastClosestDepth=lastNeighborDepth;}}\n#endif\nif(abs(depth-neighborDepth)<MAX_NEIGHBOR_DEPTH_DIFFERENCE){\n#ifdef boxBlur\nif(absX<=2&&absY<=2)boxBlurredColor+=col;\n#endif\ncol=transformColor(col);minNeighborColor=min(col,minNeighborColor);maxNeighborColor=max(col,maxNeighborColor);}}}}float velocityLength=length(lastVelocity.xy-velocity.xy);velocityDisocclusion=(velocityLength-0.000005)*10.0;velocityDisocclusion*=velocityDisocclusion;reprojectedUv=vUv-velocity.xy;\n#ifdef boxBlur\nfloat pxRadius=correctionRadius>5 ? 121.0 : pow(float(correctionRadius*2+1),2.0);boxBlurredColor/=pxRadius;boxBlurredColor=transformColor(boxBlurredColor);\n#endif\nif(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){accumulatedTexel=textureLod(accumulatedTexture,reprojectedUv,0.0);accumulatedColor=transformColor(accumulatedTexel.rgb);vec3 clampedColor=clamp(accumulatedColor,minNeighborColor,maxNeighborColor);accumulatedColor=mix(accumulatedColor,clampedColor,correction);didReproject=true;}else{\n#ifdef boxBlur\naccumulatedColor=boxBlurredColor;\n#else\naccumulatedColor=inputColor;\n#endif\n}if(velocity.r>FLOAT_ONE_MINUS_EPSILON&&velocity.g>FLOAT_ONE_MINUS_EPSILON){alpha=0.0;velocityDisocclusion=1.0;}}else{accumulatedColor=transformColor(textureLod(accumulatedTexture,vUv,0.0).rgb);}vec3 outputColor=inputColor;\n#include <custom_compose_shader>\ngl_FragColor=vec4(undoColorTransform(outputColor),alpha);}"; // eslint-disable-line

class TemporalResolveMaterial extends ShaderMaterial {
  constructor(customComposeShader) {
    const fragmentShader = temporalResolve.replace("#include <custom_compose_shader>", customComposeShader);
    super({
      type: "TemporalResolveMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        accumulatedTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        lastVelocityTexture: new Uniform(null),
        samples: new Uniform(1),
        blend: new Uniform(0.5),
        correction: new Uniform(1),
        exponent: new Uniform(1),
        invTexSize: new Uniform(new Vector2())
      },
      defines: {
        correctionRadius: 1
      },
      vertexShader,
      fragmentShader
    });
  }

}

// this shader is from: https://github.com/gkjohnson/threejs-sandbox
// a second set of bone information from the previou frame

const prev_skinning_pars_vertex =
/* glsl */
`
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = texture2D( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ) );
				vec4 v2 = texture2D( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ) );
				vec4 v3 = texture2D( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ) );
				vec4 v4 = texture2D( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ) );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`; // Returns the body of the vertex shader for the velocity buffer and
// outputs the position of the current and last frame positions

const velocity_vertex =
/* glsl */
`
		vec3 transformed;

		// Get the normal
		${ShaderChunk.skinbase_vertex}
		${ShaderChunk.beginnormal_vertex}
		${ShaderChunk.skinnormal_vertex}
		${ShaderChunk.defaultnormal_vertex}

		// Get the current vertex position
		transformed = vec3( position );
		${ShaderChunk.skinning_vertex}
		newPosition = velocityMatrix * vec4( transformed, 1.0 );

		// Get the previous vertex position
		transformed = vec3( position );
		${ShaderChunk.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
		${ShaderChunk.skinning_vertex.replace(/vec4 /g, "")}
		prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

		gl_Position = newPosition;
`;
class VelocityMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: {
        prevVelocityMatrix: {
          value: new Matrix4()
        },
        velocityMatrix: {
          value: new Matrix4()
        },
        prevBoneTexture: {
          value: null
        },
        interpolateGeometry: {
          value: 0
        },
        intensity: {
          value: 1
        },
        boneTexture: {
          value: null
        },
        alphaTest: {
          value: 0.0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        opacity: {
          value: 1.0
        }
      },
      vertexShader:
      /* glsl */
      `
                    #define MAX_BONES 1024
                    
                    ${ShaderChunk.skinning_pars_vertex}
                    ${prev_skinning_pars_vertex}
        
                    uniform mat4 velocityMatrix;
                    uniform mat4 prevVelocityMatrix;
                    uniform float interpolateGeometry;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
        
                        ${velocity_vertex}

						vHighPrecisionZW = gl_Position.zw;
        
                    }`,
      fragmentShader:
      /* glsl */
      `
                    uniform float intensity;
                    varying vec4 prevPosition;
                    varying vec4 newPosition;
					varying vec2 vHighPrecisionZW;
        
                    void main() {
						#ifdef FULL_MOVEMENT
						gl_FragColor = vec4( 1., 1., 1. - gl_FragCoord.z, 0. );
						return;
						#endif

                        vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
                        vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;
        
                        vec2 vel = pos1 - pos0;

						float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
                        
                        gl_FragColor = vec4( vel, 1. - fragCoordZ, 0. );
        
                    }`
    });
    this.isVelocityMaterial = true;
  }

}

const backgroundColor = new Color(0);
const updateProperties = ["visible", "wireframe", "side"];
class VelocityPass extends Pass {
  constructor(scene, camera) {
    var _window, _window2;

    super("VelocityPass");
    this.cachedMaterials = new WeakMap();
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this.visibleMeshes = [];
    this.renderedMeshesThisFrame = 0;
    this.renderedMeshesLastFrame = 0;
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(((_window = window) == null ? void 0 : _window.innerWidth) || 1000, ((_window2 = window) == null ? void 0 : _window2.innerHeight) || 1000, {
      type: HalfFloatType
    });
  }

  setVelocityMaterialInScene() {
    this.renderedMeshesThisFrame = 0;
    this.visibleMeshes = getVisibleChildren(this._scene);

    for (const c of this.visibleMeshes) {
      var _c$skeleton2;

      const originalMaterial = c.material;
      let [cachedOriginalMaterial, velocityMaterial] = this.cachedMaterials.get(c) || [];

      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton;

        velocityMaterial = new VelocityMaterial();
        velocityMaterial.lastMatrixWorld = new Matrix4();
        c.material = velocityMaterial;
        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) this.saveBoneTexture(c);
        this.cachedMaterials.set(c, [originalMaterial, velocityMaterial]);
      }

      velocityMaterial.uniforms.velocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);

      if (c.userData.needsUpdatedReflections || originalMaterial.map instanceof VideoTexture) {
        if (!("FULL_MOVEMENT" in velocityMaterial.defines)) velocityMaterial.needsUpdate = true;
        velocityMaterial.defines.FULL_MOVEMENT = "";
      } else {
        if ("FULL_MOVEMENT" in velocityMaterial.defines) {
          delete velocityMaterial.defines.FULL_MOVEMENT;
          velocityMaterial.needsUpdate = true;
        }
      }

      c.visible = this.cameraMovedThisFrame || !c.matrixWorld.equals(velocityMaterial.lastMatrixWorld) || c.skeleton || "FULL_MOVEMENT" in velocityMaterial.defines;
      c.material = velocityMaterial;
      if (!c.visible) continue;
      this.renderedMeshesThisFrame++;

      for (const prop of updateProperties) velocityMaterial[prop] = originalMaterial[prop];

      if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) {
        velocityMaterial.defines.USE_SKINNING = "";
        velocityMaterial.defines.BONE_TEXTURE = "";
        velocityMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture;
      }
    }
  }

  saveBoneTexture(object) {
    let boneTexture = object.material.uniforms.prevBoneTexture.value;

    if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {
      boneTexture = object.material.uniforms.prevBoneTexture.value;
      boneTexture.image.data.set(object.skeleton.boneTexture.image.data);
    } else {
      var _boneTexture;

      (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();
      const boneMatrices = object.skeleton.boneTexture.image.data.slice();
      const size = object.skeleton.boneTexture.image.width;
      boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      object.material.uniforms.prevBoneTexture.value = boneTexture;
      boneTexture.needsUpdate = true;
    }
  }

  unsetVelocityMaterialInScene() {
    for (const c of this.visibleMeshes) {
      if (c.material.isVelocityMaterial) {
        var _c$skeleton3;

        c.visible = true;
        c.material.lastMatrixWorld.copy(c.matrixWorld);
        c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(this._camera.projectionMatrix, c.modelViewMatrix);
        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) this.saveBoneTexture(c);
        c.material = this.cachedMaterials.get(c)[0];
      }
    }
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }

  renderVelocity(renderer) {
    renderer.setRenderTarget(this.renderTarget);

    if (this.renderedMeshesThisFrame > 0) {
      const {
        background
      } = this._scene;
      this._scene.background = backgroundColor;
      renderer.render(this._scene, this._camera);
      this._scene.background = background;
    } else {
      renderer.clearColor();
    }
  }

  checkCameraMoved() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));

    if (moveDist > 0.000001 || rotateDist > 0.000001) {
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
      return true;
    }

    return false;
  }

  render(renderer) {
    this.cameraMovedThisFrame = this.checkCameraMoved();
    this.setVelocityMaterialInScene();
    if (this.renderedMeshesThisFrame > 0 || this.renderedMeshesLastFrame > 0) this.renderVelocity(renderer);
    this.unsetVelocityMaterialInScene();
    this.renderedMeshesLastFrame = this.renderedMeshesThisFrame;
  }

}

const zeroVec2 = new Vector2(); // the following variables can be accessed by the custom compose shader:
// "inputTexel", "accumulatedTexel", "inputColor", "accumulatedColor", "alpha", "velocityDisocclusion", "didReproject", "boxBlurredColor" (if using box blur)
// the custom compose shader will write the final color to the variable "outputColor"

class TemporalResolvePass extends Pass {
  constructor(scene, camera, customComposeShader, options = {}) {
    super("TemporalResolvePass");
    this.velocityPass = null;
    this.velocityResolutionScale = 1;
    this.samples = 1;
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    });
    this.velocityPass = new VelocityPass(scene, camera);
    this.fullscreenMaterial = new TemporalResolveMaterial(customComposeShader);
    this.fullscreenMaterial.defines.correctionRadius = options.correctionRadius || 1;
    if (options.dilation) this.fullscreenMaterial.defines.dilation = "";
    if (options.boxBlur) this.fullscreenMaterial.defines.boxBlur = "";
    this.setupFramebuffers(1, 1);
    this.checkCanUseSharedVelocityTexture();
  }

  dispose() {
    if (this._scene.userData.velocityTexture === this.velocityPass.renderTarget.texture) {
      delete this._scene.userData.velocityTexture;
      delete this._scene.userData.lastVelocityTexture;
    }

    this.renderTarget.dispose();
    this.accumulatedTexture.dispose();
    this.fullscreenMaterial.dispose();
    this.velocityPass.dispose();
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
    this.velocityPass.setSize(width * this.velocityResolutionScale, height * this.velocityResolutionScale);
    this.velocityPass.renderTarget.texture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.velocityPass.renderTarget.texture.needsUpdate = true;
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);
    this.setupFramebuffers(width, height);
  }

  setupFramebuffers(width, height) {
    if (this.accumulatedTexture) this.accumulatedTexture.dispose();
    if (this.lastVelocityTexture) this.lastVelocityTexture.dispose();
    this.accumulatedTexture = new FramebufferTexture(width, height, RGBAFormat);
    this.accumulatedTexture.minFilter = LinearFilter;
    this.accumulatedTexture.magFilter = LinearFilter;
    this.accumulatedTexture.type = HalfFloatType;
    this.lastVelocityTexture = new FramebufferTexture(width * this.velocityResolutionScale, height * this.velocityResolutionScale, RGBAFormat);
    this.lastVelocityTexture.minFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.magFilter = this.velocityResolutionScale === 1 ? NearestFilter : LinearFilter;
    this.lastVelocityTexture.type = HalfFloatType;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.accumulatedTexture;
    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
    this.fullscreenMaterial.needsUpdate = true;
  }

  checkCanUseSharedVelocityTexture() {
    const canUseSharedVelocityTexture = this._scene.userData.velocityTexture && this.velocityPass.renderTarget.texture !== this._scene.userData.velocityTexture;

    if (canUseSharedVelocityTexture) {
      // let's use the shared one instead
      if (this.velocityPass.renderTarget.texture === this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this._scene.userData.lastVelocityTexture;
        this.fullscreenMaterial.uniforms.velocityTexture.value = this._scene.userData.velocityTexture;
        this.fullscreenMaterial.needsUpdate = true;
      }
    } else {
      // let's stop using the shared one (if used) and mark ours as the shared one instead
      if (this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value) {
        this.fullscreenMaterial.uniforms.velocityTexture.value = this.velocityPass.renderTarget.texture;
        this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.lastVelocityTexture;
        this.fullscreenMaterial.needsUpdate = true;

        if (!this._scene.userData.velocityTexture) {
          this._scene.userData.velocityTexture = this.velocityPass.renderTarget.texture;
          this._scene.userData.lastVelocityTexture = this.lastVelocityTexture;
        }
      }
    }

    return this.velocityPass.renderTarget.texture !== this.fullscreenMaterial.uniforms.velocityTexture.value;
  }

  checkNeedsResample() {
    const moveDist = this.lastCameraTransform.position.distanceToSquared(this._camera.position);
    const rotateDist = 8 * (1 - this.lastCameraTransform.quaternion.dot(this._camera.quaternion));

    if (moveDist > 0.000001 || rotateDist > 0.000001) {
      this.samples = 1;
      this.lastCameraTransform.position.copy(this._camera.position);
      this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
    }
  }

  render(renderer) {
    this.samples++;
    this.checkNeedsResample();
    this.fullscreenMaterial.uniforms.samples.value = this.samples; // const isUsingSharedVelocityTexture = this.checkCanUseSharedVelocityTexture()
    // if (!isUsingSharedVelocityTexture) this.velocityPass.render(renderer)

    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera); // save the render target's texture for use in next frame

    renderer.copyFramebufferToTexture(zeroVec2, this.accumulatedTexture);
    renderer.setRenderTarget(this.velocityPass.renderTarget);
    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);
  }

}

// source: https://observablehq.com/@jrus/halton
const halton = function halton(index, base) {
  let fraction = 1;
  let result = 0;

  while (index > 0) {
    fraction /= base;
    result += fraction * (index % base);
    index = ~~(index / base); // floor division
  }

  return result;
}; // generates Halton tuples in the range [-0.5:0.5]


const generateHalton23Points = count => {
  const data = [];
  let i = 1;
  const end = i + count;

  for (; i < end; i++) {
    data.push([halton(i, 2) - 0.5, halton(i, 3) - 0.5]);
  }

  return data;
};

/* eslint-disable camelcase */

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
} // credits for the box-projecting shader code go to codercat (https://codercat.tk)


const worldposReplace =
/* glsl */
`
#if defined( USE_ENVMAP ) || defined(  ) || defined ( USE_SHADOWMAP )
    vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );

    #ifdef BOX_PROJECTED_ENV_MAP
        vWorldPosition = worldPosition.xyz;
    #endif
#endif
`;
const boxProjectDefinitions =
/* glsl */
`
#ifdef BOX_PROJECTED_ENV_MAP
    uniform vec3 envMapSize;
    uniform vec3 envMapPosition;
    varying vec3 vWorldPosition;
    
    vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {
        vec3 nDir = normalize( v );

        vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;
        vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;

        vec3 rbminmax;

        rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;
        rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;
        rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;

        float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );
        vec3 boxIntersection = vWorldPosition + nDir * correction;
        
        return boxIntersection - cubePos;
    }
#endif
`; // will be inserted after "vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );"

const getIBLIrradiance_patch =
/* glsl */
`
#ifdef BOX_PROJECTED_ENV_MAP
    worldNormal = parallaxCorrectNormal( worldNormal, envMapSize, envMapPosition );
#endif
`; // will be inserted after "reflectVec = inverseTransformDirection( reflectVec, viewMatrix );"

const getIBLRadiance_patch =
/* glsl */
`
#ifdef BOX_PROJECTED_ENV_MAP
    reflectVec = parallaxCorrectNormal( reflectVec, envMapSize, envMapPosition );
#endif
`;
function useBoxProjectedEnvMap(shader, envMapPosition, envMapSize) {
  // defines
  shader.defines.BOX_PROJECTED_ENV_MAP = ""; // uniforms

  shader.uniforms.envMapPosition = {
    value: envMapPosition
  };
  shader.uniforms.envMapSize = {
    value: envMapSize
  };
  const line1 = new RegExp(escapeRegExp("vec3 worldNormal = inverseTransformDirection ( normal , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g");
  const line2 = new RegExp(escapeRegExp("reflectVec = inverseTransformDirection ( reflectVec , viewMatrix ) ;").replaceAll(" ", "\\s*"), "g"); // vertex shader

  shader.vertexShader = "varying vec3 vWorldPosition;\n" + shader.vertexShader.replace("#include <worldpos_vertex>", worldposReplace); // fragment shader

  shader.fragmentShader = boxProjectDefinitions + "\n" + shader.fragmentShader.replace("#include <envmap_physical_pars_fragment>", ShaderChunk.envmap_physical_pars_fragment).replace(line1, `vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
                ${getIBLIrradiance_patch}`).replace(line2, `reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
                ${getIBLRadiance_patch}`);
}

const finalFragmentShader = finalSSRShader.replace("#include <helperFunctions>", helperFunctions).replace("#include <boxBlur>", boxBlur); // all the properties for which we don't have to resample

const noResetSamplesProperties = ["blur", "blurSharpness", "blurKernel"];
const defaultCubeRenderTarget = new WebGLCubeRenderTarget(1);
let pmremGenerator;
class SSREffect extends Effect {
  /**
   * @param {THREE.Scene} scene The scene of the SSR effect
   * @param {THREE.Camera} camera The camera with which SSR is being rendered
   * @param {SSROptions} [options] The optional options for the SSR effect
   */
  constructor(scene, camera, options = defaultSSROptions) {
    super("SSREffect", finalFragmentShader, {
      type: "FinalSSRMaterial",
      uniforms: new Map([["reflectionsTexture", new Uniform(null)], ["blur", new Uniform(0)], ["blurSharpness", new Uniform(0)], ["blurKernel", new Uniform(0)]]),
      defines: new Map([["RENDER_MODE", "0"]])
    });
    this.haltonSequence = generateHalton23Points(1024);
    this.haltonIndex = 0;
    this.selection = new Selection();
    this.lastSize = void 0;
    this.cubeCamera = new CubeCamera(0.001, 1000, defaultCubeRenderTarget);
    this.usingBoxProjectedEnvMap = false;
    this._scene = scene;
    this._camera = camera;
    const trOptions = {
      boxBlur: true,
      dilation: true
    };
    options = _extends({}, defaultSSROptions, options, trOptions); // set up passes
    // temporal resolve pass

    this.temporalResolvePass = new TemporalResolvePass(scene, camera, trCompose, options);
    this.uniforms.get("reflectionsTexture").value = this.temporalResolvePass.renderTarget.texture; // reflections pass

    this.reflectionsPass = new ReflectionsPass(this, options);
    this.temporalResolvePass.fullscreenMaterial.uniforms.inputTexture.value = this.reflectionsPass.renderTarget.texture;
    this.lastSize = {
      width: options.width,
      height: options.height,
      resolutionScale: options.resolutionScale,
      velocityResolutionScale: options.velocityResolutionScale
    };
    this.setSize(options.width, options.height);
    this.makeOptionsReactive(options);
  }

  makeOptionsReactive(options) {
    let needsUpdate = false;
    const reflectionPassFullscreenMaterialUniforms = this.reflectionsPass.fullscreenMaterial.uniforms;
    const reflectionPassFullscreenMaterialUniformsKeys = Object.keys(reflectionPassFullscreenMaterialUniforms);

    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },

        set(value) {
          if (options[key] === value && needsUpdate) return;
          options[key] = value;

          if (!noResetSamplesProperties.includes(key)) {
            this.setSize(this.lastSize.width, this.lastSize.height, true);
          }

          switch (key) {
            case "resolutionScale":
              this.setSize(this.lastSize.width, this.lastSize.height);
              break;

            case "velocityResolutionScale":
              this.temporalResolvePass.velocityResolutionScale = value;
              this.setSize(this.lastSize.width, this.lastSize.height, true);
              break;

            case "blur":
              this.uniforms.get("blur").value = value;
              break;

            case "blurSharpness":
              this.uniforms.get("blurSharpness").value = value;
              break;

            case "blurKernel":
              this.uniforms.get("blurKernel").value = value;
              break;
            // defines

            case "steps":
              this.reflectionsPass.fullscreenMaterial.defines.steps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;

            case "refineSteps":
              this.reflectionsPass.fullscreenMaterial.defines.refineSteps = parseInt(value);
              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;

            case "missedRays":
              if (value) {
                this.reflectionsPass.fullscreenMaterial.defines.missedRays = "";
              } else {
                delete this.reflectionsPass.fullscreenMaterial.defines.missedRays;
              }

              this.reflectionsPass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;

            case "correctionRadius":
              this.temporalResolvePass.fullscreenMaterial.defines.correctionRadius = Math.round(value);
              this.temporalResolvePass.fullscreenMaterial.needsUpdate = needsUpdate;
              break;

            case "blend":
              this.temporalResolvePass.fullscreenMaterial.uniforms.blend.value = value;
              break;

            case "correction":
              this.temporalResolvePass.fullscreenMaterial.uniforms.correction.value = value;
              break;

            case "exponent":
              this.temporalResolvePass.fullscreenMaterial.uniforms.exponent.value = value;
              break;

            case "distance":
              reflectionPassFullscreenMaterialUniforms.rayDistance.value = value;
            // must be a uniform

            default:
              if (reflectionPassFullscreenMaterialUniformsKeys.includes(key)) {
                reflectionPassFullscreenMaterialUniforms[key].value = value;
              }

          }
        }

      }); // apply all uniforms and defines

      this[key] = options[key];
    }

    needsUpdate = true;
  }

  setSize(width, height, force = false) {
    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale && this.velocityResolutionScale === this.lastSize.velocityResolutionScale) return;
    this.temporalResolvePass.setSize(width, height);
    this.reflectionsPass.setSize(width, height);
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale,
      velocityResolutionScale: this.velocityResolutionScale
    };
  }

  generateBoxProjectedEnvMapFallback(renderer, position = new Vector3(), size = new Vector3(), envMapSize = 512) {
    this.cubeCamera.renderTarget.dispose();
    this.cubeCamera.renderTarget = new WebGLCubeRenderTarget(envMapSize);
    this.cubeCamera.position.copy(position);
    this.cubeCamera.updateMatrixWorld();
    this.cubeCamera.update(renderer, this._scene);

    if (!pmremGenerator) {
      pmremGenerator = new PMREMGenerator(renderer);
      pmremGenerator.compileCubemapShader();
    }

    const envMap = pmremGenerator.fromCubemap(this.cubeCamera.renderTarget.texture).texture;
    envMap.minFilter = LinearFilter;
    envMap.magFilter = LinearFilter;
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    useBoxProjectedEnvMap(reflectionsMaterial, position, size);
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("vec3 worldPos", "worldPos").replace("varying vec3 vWorldPosition;", "vec3 worldPos;");
    reflectionsMaterial.uniforms.envMapPosition.value.copy(position);
    reflectionsMaterial.uniforms.envMapSize.value.copy(size);
    setupEnvMap(reflectionsMaterial, envMap, envMapSize);
    this.usingBoxProjectedEnvMap = true;
    return envMap;
  }

  setIBLRadiance(iblRadiance, renderer) {
    this._scene.traverse(c => {
      if (c.material) {
        var _renderer$properties$;

        const uniforms = (_renderer$properties$ = renderer.properties.get(c.material)) == null ? void 0 : _renderer$properties$.uniforms;

        if (uniforms && "disableIBLRadiance" in uniforms) {
          uniforms.disableIBLRadiance.value = iblRadiance;
        }
      }
    });
  }

  deleteBoxProjectedEnvMapFallback() {
    const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
    reflectionsMaterial.uniforms.envMap.value = null;
    reflectionsMaterial.fragmentShader = reflectionsMaterial.fragmentShader.replace("worldPos = ", "vec3 worldPos = ");
    delete reflectionsMaterial.defines.BOX_PROJECTED_ENV_MAP;
    reflectionsMaterial.needsUpdate = true;
    this.usingBoxProjectedEnvMap = false;
  }

  dispose() {
    super.dispose();
    this.reflectionsPass.dispose();
    this.temporalResolvePass.dispose();
  }

  update(renderer, inputBuffer) {
    if (!this.usingBoxProjectedEnvMap && this._scene.environment) {
      const reflectionsMaterial = this.reflectionsPass.fullscreenMaterial;
      let envMap = null; // not sure if there is a cleaner way to find the internal texture of a CubeTexture (when used as scene environment)

      this._scene.traverse(c => {
        if (!envMap && c.material && !c.material.envMap) {
          const properties = renderer.properties.get(c.material);
          if ("envMap" in properties && properties.envMap instanceof Texture) envMap = properties.envMap;
        }
      });

      if (envMap) {
        const envMapCubeUVHeight = this._scene.environment.image.height;
        setupEnvMap(reflectionsMaterial, envMap, envMapCubeUVHeight);
      }
    }

    this.haltonIndex = (this.haltonIndex + 1) % this.haltonSequence.length;
    const [x, y] = this.haltonSequence[this.haltonIndex];
    const {
      width,
      height
    } = this.lastSize;
    this.temporalResolvePass.velocityPass.render(renderer); // jittering the view offset each frame reduces aliasing for the reflection

    if (this._camera.setViewOffset) this._camera.setViewOffset(width, height, x, y, width, height); // render reflections of current frame

    this.reflectionsPass.render(renderer, inputBuffer); // compose reflection of last and current frame into one reflection

    this.temporalResolvePass.render(renderer);

    this._camera.clearViewOffset();
  }

  static patchDirectEnvIntensity(envMapIntensity = 0) {
    if (envMapIntensity === 0) {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {", "vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) { return vec3(0.0);");
    } else {
      ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );", "vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness ) * " + envMapIntensity.toFixed(5) + ";");
    }
  }

}

const EFFECT_PASS = 'EffectPass';
class EffectManager {
    constructor(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        this.passesMap = new Map();
        this.effectsMap = new Map();
        this.effectsNeedsUpddate = true;
        this.effectComposer = this._initEffectComposer();
        this._initPasses();
        this._initEffects();
    }
    /**
     * 更新 Effect pass
     */
    updateEffectPass() {
        if (!this.effectsNeedsUpddate) {
            return;
        }
        this.effectsNeedsUpddate = false;
        const { effectComposer, } = this;
        // remove prev effect pass
        effectComposer.passes.forEach((pass) => {
            if (pass.name === EFFECT_PASS) {
                effectComposer.removePass(pass);
                pass.dispose();
            }
        });
        // add enabled effect pass
        const effects = Array.from(this.effectsMap)
            .filter(([, { enabled, }]) => enabled)
            .map(([, { effect, }]) => effect);
        const effectPass = new EffectPass(this.camera, ...effects);
        effectPass.enabled = !!(effects.length);
        this.passesMap.set(EffectManager.CONSTANTS.effectPass, effectPass);
        effectComposer.addPass(effectPass);
    }
    /**
     * 更新 camera
     * @param camera
     */
    updateCamera(camera) {
        const { passesMap, effectsMap, } = this;
        const { CONSTANTS, } = EffectManager;
        const renderPass = passesMap.get(CONSTANTS.renderPass), normalPass = passesMap.get(CONSTANTS.normalPass), effectPass = passesMap.get(CONSTANTS.effectPass);
        renderPass.mainCamera = camera;
        normalPass.mainCamera = camera;
        effectPass.mainCamera = camera;
        const outlineEffect = effectsMap.get(CONSTANTS.outlineEffect);
        outlineEffect.effect.mainCamera = camera;
    }
    _initEffectComposer() {
        const effectComposer = new EffectComposer(this.renderer, {
            multisampling: 8,
            frameBufferType: HalfFloatType,
        });
        return effectComposer;
    }
    _initPasses() {
        const { effectComposer, } = this;
        const renderPass = this._initRenderPass();
        const normalPass = this._initNormalPass();
        // const velocityDepthNormalPass = this._initVelocityDepthNormalPass()
        const effectPass = this._initEffectPass();
        this.passesMap.set(EffectManager.CONSTANTS.renderPass, renderPass);
        this.passesMap.set(EffectManager.CONSTANTS.normalPass, normalPass);
        // this.passesMap.set( EffectManager.CONSTANTS.velocityDepthNormalPass, velocityDepthNormalPass )
        this.passesMap.set(EffectManager.CONSTANTS.effectPass, effectPass);
        effectComposer.addPass(renderPass);
        effectComposer.addPass(normalPass);
        // effectComposer.addPass( velocityDepthNormalPass )
        effectComposer.addPass(effectPass);
    }
    _initRenderPass() {
        const renderPass = new RenderPass(this.scene, this.camera);
        return renderPass;
    }
    _initNormalPass() {
        const normalPass = new NormalPass(this.scene, this.camera, { resolutionScale: 1, });
        normalPass.enabled = false;
        return normalPass;
    }
    // private _initVelocityDepthNormalPass (): VelocityDepthNormalPass {
    //   const velocityDepthNormalPass = new VelocityDepthNormalPass( this.scene, this.camera )
    //   velocityDepthNormalPass.enabled = false
    //   return velocityDepthNormalPass
    // }
    _initEffectPass() {
        const effectPass = new EffectPass(this.camera);
        effectPass.name = EFFECT_PASS;
        return effectPass;
    }
    _initEffects() {
        const { CONSTANTS, } = EffectManager;
        const smaaEffect = this._initSMAAEffect();
        // const ssgiEffect = this._initSSGIEffect()
        const outlineEffect = this._initOutlineEffect();
        const ssrEffect = this._initSSREffect();
        const bloomEffect = this._initBloomEffect();
        const ssaoEffect = this._initSSAOEffect();
        this.effectsMap.set(CONSTANTS.smaaEffect, { enabled: true, effect: smaaEffect, });
        // this.effectsMap.set( CONSTANTS.ssgiEffect, { enabled: false, effect: ssgiEffect, } )
        this.effectsMap.set(CONSTANTS.outlineEffect, { enabled: false, effect: outlineEffect, });
        this.effectsMap.set(CONSTANTS.ssrEffect, { enabled: false, effect: ssrEffect, });
        this.effectsMap.set(CONSTANTS.bloomEffect, { enabled: false, effect: bloomEffect, });
        this.effectsMap.set(CONSTANTS.ssaoEffect, { enabled: false, effect: ssaoEffect, });
    }
    _initSMAAEffect() {
        const smaaEffect = new SMAAEffect({
            preset: SMAAPreset.HIGH,
            edgeDetectionMode: EdgeDetectionMode.COLOR,
        });
        return smaaEffect;
    }
    // private _initSSGIEffect () {
    //   const { CONSTANTS, } = EffectManager
    //   const velocityDepthNormalPass = this.passesMap.get( CONSTANTS.velocityDepthNormalPass ) as VelocityDepthNormalPass
    //   const ssgiEffect = new SSGIEffect( this.scene, this.camera, velocityDepthNormalPass, { diffuseOnly: true, } as any )
    //   return ssgiEffect
    // }
    _initSSREffect() {
        const ssrEffect = new SSREffect(this.scene, this.camera);
        return ssrEffect;
    }
    _initBloomEffect() {
        const bloomEffect = new BloomEffect({
            blendFunction: BlendFunction.ADD,
        });
        return bloomEffect;
    }
    _initOutlineEffect() {
        const outlineEffect = new OutlineEffect(this.scene, this.camera, {
            blendFunction: BlendFunction.SCREEN,
        });
        return outlineEffect;
    }
    _initSSAOEffect() {
        const { CONSTANTS, } = EffectManager;
        const normalPass = this.passesMap.get(CONSTANTS.normalPass);
        const ssaoEffect = new SSAOEffect(this.camera, normalPass.texture, {
            blendFunction: BlendFunction.MULTIPLY,
        });
        return ssaoEffect;
    }
}
EffectManager.CONSTANTS = {
    renderPass: 'renderPass',
    normalPass: 'normalPass',
    velocityDepthNormalPass: 'velocityDepthNormalPass',
    effectPass: 'effectPass',
    smaaEffect: 'smaaEffect',
    ssgiEffect: 'ssgiEffect',
    ssaoEffect: 'ssaoEffect',
    outlineEffect: 'outlineEffect',
    ssrEffect: 'ssrEffect',
    bloomEffect: 'bloomEffect',
};

class GenerateMeshBVHWorker {
    constructor() {
        // this.workerPool.setWorkerCreator( () => {
        this.workerPool = new WorkerPool(4);
        //   const worker = new Worker( new URL( './generateAsync.worker.js', import.meta.url ), { type: 'module', } )
        //   worker.addEventListener( 'error', ( e ) => {
        //     if ( e.message ) {
        //       throw new Error(
        //         `GenerateMeshBVHWorker: Could not create Web Worker with error "${e.message}"`
        //       )
        //     } else {
        //       throw new Error( 'GenerateMeshBVHWorker: Could not create Web Worker.' )
        //     }
        //   } )
        //   return worker
        // } )
    }
    generate(geometry, options = {}) {
        const { workerPool, } = this;
        return new Promise((resolve, reject) => {
            const onmessage = (e) => {
                const { data, } = e;
                if (!data) {
                    return;
                }
                if (data.error) {
                    reject(new Error(data.error));
                }
                else if (data.serialized) {
                    const { serialized, position, } = data;
                    const bvh = MeshBVH.deserialize(serialized, geometry, {
                        setIndex: false,
                    });
                    const boundsOptions = Object.assign({
                        setBoundingBox: true,
                    }, options);
                    // we need to replace the arrays because they're neutered entirely by the
                    // webworker transfer.
                    if (geometry.attributes.position instanceof InterleavedBufferAttribute) {
                        geometry.attributes.position.data.array = position;
                    }
                    else if (geometry.attributes.position instanceof BufferAttribute) {
                        geometry.attributes.position.array = position;
                    }
                    if (geometry.index) {
                        geometry.index.array = serialized.index;
                    }
                    else {
                        const newIndex = new BufferAttribute(serialized.index, 1, false);
                        geometry.setIndex(newIndex);
                    }
                    if (boundsOptions.setBoundingBox) {
                        geometry.boundingBox = bvh.getBoundingBox(new Box3());
                    }
                    resolve(bvh);
                }
                else if (options.onProgress) {
                    options.onProgress(data.progress);
                }
            };
            if (geometry.attributes.position instanceof GLBufferAttribute) {
                throw new Error('GenerateMeshBVHWorker: GLBufferAttribute are not supported for the geometry attributes.');
            }
            // deinterleaves all attributes on the geometry
            deinterleaveGeometry(geometry);
            const index = geometry.index ? geometry.index.array : null;
            const position = geometry.attributes.position.array;
            workerPool.postMessage({
                index,
                position,
                options: Object.assign(Object.assign({}, options), { onProgress: null, includedProgressCallback: Boolean(options.onProgress), groups: [...geometry.groups] }),
            }).then(onmessage);
        });
    }
    dispose() {
        this.workerPool.dispose();
    }
}
const generateMeshBVHWorker = new GenerateMeshBVHWorker();

const TIME_OUT = 1000;
class Bvh {
    constructor(viewport) {
        this.viewport = viewport;
        this.cameraChanging = false;
        this.timer = null;
        this.computedGeometriesUuid = new Map();
        this.generateMeshBVHWorker = generateMeshBVHWorker;
        this.viewport.signals.cameraChange.add(() => {
            this.cameraChanging = true;
            if (this.timer) {
                clearTimeout(this.timer);
                this.timer = null;
            }
            this.timer = setTimeout(() => {
                this.cameraChanging = false;
            }, TIME_OUT);
        });
    }
    computeModelsBoundsTree(options = {}) {
        const { type = 'slice', force = false, frameSliceCount = 500, workerCreator, } = options;
        const { meshOfModelList, } = this.viewport.scener.intersectsList;
        const computeMeshBoundsTree = (mesh, computeMethod = async (mesh) => mesh.geometry.computeBoundsTree()) => {
            if (force || !this.computedGeometriesUuid.has(mesh.geometry.uuid)) {
                computeMethod(mesh).then(() => {
                    this.computedGeometriesUuid.set(mesh.geometry.uuid, mesh.geometry.uuid);
                });
            }
        };
        return new Promise((resolve, reject) => {
            if (type === 'block') {
                meshOfModelList.forEach((mesh) => computeMeshBoundsTree(mesh));
                resolve();
            }
            else if (type === 'slice') {
                let loop = 0;
                let computedCount = 0;
                const animate = () => {
                    loop = requestAnimationFrame(animate);
                    if (this.cameraChanging) {
                        return;
                    }
                    for (const mesh of meshOfModelList.slice(computedCount, computedCount + frameSliceCount)) {
                        computeMeshBoundsTree(mesh);
                        computedCount += 1;
                    }
                    if (computedCount >= meshOfModelList.length) {
                        cancelAnimationFrame(loop);
                        resolve();
                    }
                };
                animate();
            }
            else if (type === 'worker') {
                if (workerCreator) {
                    this.generateMeshBVHWorker.workerPool.setWorkerCreator(workerCreator);
                    const workerComputeMethod = (mesh) => this.generateMeshBVHWorker.generate(mesh.geometry).then(bvh => bvh && (mesh.geometry.boundsTree = bvh));
                    Promise.allSettled(meshOfModelList.map(mesh => computeMeshBoundsTree(mesh, workerComputeMethod)))
                        .then(() => resolve());
                }
                else {
                    reject('请设置 workerCreator');
                }
            }
        });
    }
    dispose() {
        this.generateMeshBVHWorker.dispose();
    }
}

const systemInfo = navigator.userAgent.toLowerCase();
const isMac = systemInfo.includes('mac');
var STATE;
(function (STATE) {
    STATE[STATE["NONE"] = -1] = "NONE";
    STATE[STATE["ROTATE"] = 0] = "ROTATE";
    STATE[STATE["ZOOM"] = 1] = "ZOOM";
    STATE[STATE["PAN"] = 2] = "PAN";
})(STATE || (STATE = {}));
const vector = new Vector3();
// 触屏
const touches = [
    new Vector3(),
    new Vector3(),
    new Vector3()
];
const prevTouches = [
    new Vector3(),
    new Vector3(),
    new Vector3()
];
let domRect = new DOMRect();
class FreeControls {
    constructor(viewport) {
        this.viewport = viewport;
        this.camera = this.viewport.cameraManager.mainCamera;
        this.domElement = this.viewport.interactiveContainer;
        this.interactivePosition = null;
        this.fallbackInteractivePosition = null;
        // 开启使用
        this.enabled = true;
        // 开启鼠标点交互
        this.enabledMousePointInteractive = true;
        // 开启缩放
        this.enableZoom = true;
        // 缩放速度
        this.zoomSpeed = 1;
        // 缩放最小距离（相机到目标点）
        this.zoomMinDistance = 1;
        // 缩放最大距离（相机到目标点）
        this.zoomMaxDistance = 100000;
        // 单步缩放最小距离
        this.zoomMinStepDistance = 0.1;
        // 单步缩放最大距离
        this.zoomMaxStepDistance = 20000;
        // 开启旋转
        this.enableRotate = true;
        // 开启屏幕水平旋转
        this.enableRotateX = true;
        // 开启屏幕垂直旋转
        this.enableRotateY = true;
        // 旋转速度
        this.rotateSpeed = 1;
        // 旋转倾斜范围
        this.rotateTiltRange = {
            max: Math.PI,
            min: 0,
        };
        // 开启自动旋转
        this.enableAutoRotate = false;
        // 自动旋转速度
        this.autoRotateSpeed = 1;
        // 自动旋转顺时针
        this.autoRotateClockwise = true;
        // 允许模型移出frustum
        this.enableOutOfScene = true;
        // 允许不移出的范围长度
        this.unOffsetOfScene = 0;
        // 开启移动
        this.enablePan = true;
        // 开启屏幕水平移动
        this.enablePanX = true;
        // 开启屏幕垂直移动
        this.enablePanY = true;
        // 开启空间 X轴 移动
        this.enablePanAxisX = true;
        // 开启空间 Y轴 移动
        this.enablePanAxisY = true;
        // 开启空间 Z轴 移动
        this.enablePanAxisZ = true;
        // 移动速度
        this.panSpeed = 2;
        this.state = STATE.NONE;
        this.sceneBoxCenter = new Vector3();
        this.dispose = () => { };
        this.domElement = viewport.interactiveContainer;
        this.init();
    }
    init() {
        const onMouseDown = (event) => {
            event.preventDefault();
            if (this.enabled === false)
                return;
            if (event.button === 0) {
                this.state = STATE.ROTATE;
            }
            else if (event.button === 1) {
                this.state = STATE.ZOOM;
            }
            else if (event.button === 2) {
                this.state = STATE.PAN;
            }
            domRect = this.domElement.getBoundingClientRect();
            if (this.state === STATE.ROTATE ||
                this.state === STATE.PAN) {
                this.interactivePosition = this.getInteractivePosition(event);
                if (!this.interactivePosition) {
                    this.sceneBoxCenter = this.getSceneBbox().getCenter(new Vector3);
                }
                this.domElement.addEventListener('mousemove', onMouseMove, false);
                window.addEventListener('mouseup', onMouseUp, true);
            }
        };
        const onMouseMove = (event) => {
            event.preventDefault();
            if (this.enabled === false)
                return;
            const { movementX, movementY, } = event;
            if (this.state === STATE.ROTATE) {
                this.rotate(new Vector3(-movementX * 0.00375, -movementY * 0.00375, 0));
            }
            else if (this.state === STATE.PAN) {
                this.pan(new Vector3(-movementX, movementY, 0));
            }
        };
        const onMouseUp = (event) => {
            event.preventDefault();
            this.domElement.removeEventListener('mousemove', onMouseMove, false);
            window.removeEventListener('mouseup', onMouseUp, true);
            this.state = STATE.NONE;
        };
        const onMouseWheel = (event) => {
            event.preventDefault();
            if (!this.enabled)
                return;
            let delta = 0;
            /**
             * 兼容mac 使用shift 组合键时，值差异
             */
            if (isMac && event.shiftKey) {
                delta = -event.deltaX * 120;
            }
            else {
                delta = -event.deltaY * 120;
            }
            this.zoom_on_point(new Vector3(0, 0, delta), event);
        };
        // 触屏
        const touchStart = (event) => {
            event.preventDefault();
            if (this.enabled === false)
                return;
            domRect = this.domElement.getBoundingClientRect();
            const startTouches = event.touches;
            switch (startTouches.length) {
                case 1:
                    touches[0].set(startTouches[0].clientX, startTouches[0].clientY, 0);
                    touches[1].set(startTouches[0].clientX, startTouches[0].clientY, 0);
                    break;
                case 2:
                    touches[0].set(startTouches[0].clientX, startTouches[0].clientY, 0);
                    touches[1].set(startTouches[1].clientX, startTouches[1].clientY, 0);
                    break;
                case 3:
                case 4:
                case 5:
                    touches[0].set(startTouches[0].clientX, startTouches[0].clientY, 0);
                    touches[1].set(startTouches[2].clientX, startTouches[2].clientY, 0);
                    break;
            }
            const domOffset = new Vector3(domRect.x, domRect.y, 0);
            touches[0].sub(domOffset);
            touches[1].sub(domOffset);
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
            this.interactivePosition = this.getInteractivePosition({ offsetX: (touches[0].x + touches[1].x) / 2, offsetY: (touches[0].y + touches[1].y) / 2, });
            if (!this.interactivePosition) {
                this.sceneBoxCenter = this.getSceneBbox().getCenter(new Vector3);
            }
            this.domElement.addEventListener('touchmove', touchMove, { passive: false, });
            this.domElement.addEventListener('touchend', touchEnd, false);
        };
        const touchMove = (event) => {
            event.preventDefault();
            if (this.enabled === false)
                return;
            const getClosest = (touch, touches) => {
                let closest = touches[0];
                for (const i in touches) {
                    if (closest.distanceTo(touch) > touches[i].distanceTo(touch))
                        closest = touches[i];
                }
                return closest;
            };
            function getRotateDirection(touches, prevTouches, axis = 'y') {
                const touch = new Vector2(touches[1].x - touches[0].x, touches[1].y - touches[0].y);
                const prevTouch = new Vector2(prevTouches[1].x - prevTouches[0].x, prevTouches[1].y - prevTouches[0].y);
                const angle = touch.angle();
                const prevAngel = prevTouch.angle();
                touch.normalize();
                prevTouch.normalize();
                const distance0 = prevTouches[0].y - touches[0].y;
                // const dir0 = prevTouches[0].y - touches[0].y
                // const dir1 = prevTouches[1].y - touches[1].y
                if (axis === 'y')
                    return new Vector3(0, distance0 * 0.005, 0);
                else if (axis === 'x')
                    return new Vector3(angle - prevAngel, 0, 0);
                else
                    return new Vector3();
            }
            switch (event.touches.length) {
                case 1: {
                    touches[0].set(event.touches[0].clientX - domRect.x, event.touches[0].clientY - domRect.y, 0);
                    touches[1].set(event.touches[0].clientX - domRect.x, event.touches[0].clientY - domRect.y, 0);
                    const offset0 = touches[0]
                        .clone()
                        .sub(getClosest(touches[0], prevTouches));
                    offset0.x = -offset0.x;
                    const dist = offset0.multiplyScalar(0.9);
                    this.pan(dist);
                    break;
                }
                case 2: {
                    touches[0].set(event.touches[0].clientX - domRect.x, event.touches[0].clientY - domRect.y, 0);
                    touches[1].set(event.touches[1].clientX - domRect.x, event.touches[1].clientY - domRect.y, 0);
                    const distance = prevTouches[0].distanceTo(prevTouches[1]) - touches[0].distanceTo(touches[1]);
                    this.zoom_touch(new Vector3(0, 0, distance * this.zoomSpeed / 25));
                    this.rotate(getRotateDirection(touches, prevTouches, 'x'));
                    break;
                }
                case 3:
                case 4:
                case 5:
                    touches[0].set(event.touches[0].clientX - domRect.x, event.touches[0].clientY - domRect.y, 0);
                    touches[1].set(event.touches[2].clientX - domRect.x, event.touches[2].clientY - domRect.y, 0);
                    this.rotate(getRotateDirection(touches, prevTouches, 'y'));
                    break;
            }
            prevTouches[0].copy(touches[0]);
            prevTouches[1].copy(touches[1]);
        };
        const touchEnd = (event) => {
            event.preventDefault();
            this.state = STATE.NONE;
            this.domElement.removeEventListener('touchmove', touchMove, false);
            this.domElement.removeEventListener('touchend', touchEnd, false);
        };
        this.domElement.addEventListener('mousedown', onMouseDown, false);
        this.domElement.addEventListener('wheel', onMouseWheel, { passive: false, });
        this.domElement.addEventListener('touchstart', touchStart, { passive: false, });
        // dispose
        this.dispose = () => {
            this.domElement.removeEventListener('mousedown', onMouseDown);
            this.domElement.removeEventListener('wheel', onMouseWheel);
            this.domElement.removeEventListener('touchstart', touchStart);
        };
    }
    // 获取交互坐标
    getInteractivePosition(event) {
        if (this.enabledMousePointInteractive) {
            const interests = this.viewport.getIntersects(event, undefined, { isFilterHideObject: true, });
            if (interests.length) {
                const [{ point, }] = interests;
                return point.clone();
            }
            else {
                return this.fallbackInteractivePosition;
            }
        }
        else {
            return this.fallbackInteractivePosition;
        }
    }
    intersectsBox(panOffset) {
        const bbox = this.getSceneBbox();
        const size = new Vector3();
        bbox.getSize(size);
        let maxXscalr = Math.max(size.x, size.y, size.z);
        if (this.unOffsetOfScene != 0)
            maxXscalr = this.unOffsetOfScene;
        const box = bbox.clone();
        box.min.addScalar(maxXscalr / 2);
        box.max.addScalar(-maxXscalr / 2);
        const tempCmara = new PerspectiveCamera().copy(this.camera);
        tempCmara.position.add(panOffset);
        tempCmara.updateMatrixWorld();
        tempCmara.updateProjectionMatrix();
        const frustum = new Frustum().setFromProjectionMatrix(new Matrix4().multiplyMatrices(tempCmara.projectionMatrix, tempCmara.matrixWorldInverse));
        const cotainer = frustum.intersectsBox(bbox);
        return cotainer;
    }
    caculateContainPoint(point, camera) {
        const temp = new Vector3().copy(point);
        const centerV = temp.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
        if ((Math.abs(centerV.x) > 1) || (Math.abs(centerV.y) > 1) || (Math.abs(centerV.z) > 1)) {
            return false;
        }
        return true;
    }
    // 右键沿水平方向拖到
    panLeft(distance) {
        const panOffset = new Vector3();
        const te = this.camera.matrix.elements;
        if (this.enablePanAxisX)
            panOffset.setX(te[0]);
        if (this.enablePanAxisY)
            panOffset.setY(te[1]);
        if (this.enablePanAxisZ)
            panOffset.setZ(te[2]);
        panOffset.multiplyScalar(distance);
        let containScene = true;
        if (!this.enableOutOfScene) {
            containScene = this.intersectsBox(panOffset);
        }
        if (containScene)
            this.camera.position.add(panOffset);
    }
    // 右键沿垂直方向拖到
    panUp(distance) {
        const panOffset = new Vector3();
        const te = this.camera.matrix.elements;
        if (this.enablePanAxisX)
            panOffset.setX(te[4]);
        if (this.enablePanAxisY)
            panOffset.setY(te[5]);
        if (this.enablePanAxisZ)
            panOffset.setZ(te[6]);
        panOffset.multiplyScalar(distance);
        let containScene = true;
        if (!this.enableOutOfScene) {
            containScene = this.intersectsBox(panOffset);
        }
        if (containScene)
            this.camera.position.add(panOffset);
    }
    // 分发拖操作
    pan(delta) {
        var _a;
        if (!this.enablePan)
            return;
        if (!this.enablePanX)
            delta.setX(0);
        if (!this.enablePanY)
            delta.setY(0);
        const panPosition = (_a = this.interactivePosition) !== null && _a !== void 0 ? _a : this.sceneBoxCenter;
        const position = this.camera.position;
        const offset = position.clone().sub(panPosition);
        let targetDistance = offset.length();
        targetDistance *= Math.tan(((this.camera.fov / 2) * Math.PI) / 180.0);
        this.panLeft((this.panSpeed * delta.x * targetDistance) / domRect.height);
        this.panUp((this.panSpeed * delta.y * targetDistance) / domRect.height);
        this.viewport.signals.cameraChange.dispatch();
    }
    // 沿相机到鼠标空间坐标方向缩放相机
    zoom_on_point(delta, event) {
        if (!this.enableZoom)
            return;
        this.interactivePosition = this.getInteractivePosition(event);
        let depth = delta.z > 0 ? 6 : -6;
        const vector = new Vector3(0, 0, 0);
        let distance;
        if (this.interactivePosition) {
            distance = this.interactivePosition.distanceTo(this.camera.position);
            const rect = this.domElement.getBoundingClientRect();
            vector.set((event.offsetX / rect.width) * 2 - 1, -(event.offsetY / rect.height) * 2 + 1, 0.1);
        }
        else {
            distance = this.camera.position.length();
            vector.set(0, 0, 0.1);
        }
        let lock = false;
        if (distance > this.zoomMaxDistance && depth < 0) {
            lock = true;
            distance = this.zoomMaxDistance;
            depth *= 2;
        }
        else if (distance < this.zoomMinDistance && depth > 0) {
            lock = true;
            distance = this.zoomMinDistance;
            depth *= 2;
        }
        vector.unproject(this.camera);
        vector.sub(this.camera.position);
        let zoomDistance = distance / depth * this.zoomSpeed;
        if (zoomDistance > 0) {
            if (zoomDistance > this.zoomMaxStepDistance)
                zoomDistance = this.zoomMaxStepDistance;
            else if (zoomDistance < this.zoomMinStepDistance)
                zoomDistance = this.zoomMinStepDistance;
        }
        else if (zoomDistance < 0) {
            if (zoomDistance < -this.zoomMaxStepDistance)
                zoomDistance = -this.zoomMaxStepDistance;
            else if (zoomDistance > -this.zoomMinStepDistance)
                zoomDistance = -this.zoomMinStepDistance;
        }
        if (lock && !event.shiftKey)
            return;
        const clonePos = this.camera.position.clone().addVectors(this.camera.position, vector.setLength(zoomDistance));
        this.camera.position.copy(clonePos);
        this.viewport.signals.cameraChange.dispatch();
    }
    zoom_touch(delta) {
        if (!this.enableZoom)
            return;
        let depth = delta.z;
        const vector = new Vector3(0, 0, 0);
        // 交互点与相机的距离
        let distance;
        if (this.interactivePosition) {
            const event = {
                offsetX: (prevTouches[0].x + prevTouches[1].x) / 2,
                offsetY: (prevTouches[0].y + prevTouches[1].y) / 2,
            };
            distance = this.interactivePosition.distanceTo(this.camera.position);
            // 转换屏幕坐标到 NDC 坐标
            vector.set((event.offsetX / domRect.width) * 2 - 1, -(event.offsetY / domRect.height) * 2 + 1, 0.1);
        }
        else {
            distance = this.camera.position.length();
            vector.set(0, 0, 0.1);
        }
        if (distance > this.zoomMaxDistance && depth > 0) {
            distance = this.zoomMaxDistance;
            depth = 0;
        }
        else if (distance < this.zoomMinDistance && depth < 0) {
            distance = this.zoomMinDistance;
        }
        if (depth === 0)
            return;
        // 转换 NDC 坐标到世界坐标
        vector.unproject(this.camera);
        vector.sub(this.camera.position);
        let zoomDistance = distance * -depth * this.zoomSpeed * 0.1;
        if (zoomDistance > 0) {
            if (zoomDistance > this.zoomMaxStepDistance)
                zoomDistance = this.zoomMaxStepDistance;
            else if (zoomDistance < this.zoomMinStepDistance)
                zoomDistance = this.zoomMinStepDistance;
        }
        else if (zoomDistance < 0) {
            if (zoomDistance < -this.zoomMaxStepDistance)
                zoomDistance = -this.zoomMaxStepDistance;
            else if (zoomDistance > -this.zoomMinStepDistance)
                zoomDistance = -this.zoomMinStepDistance;
        }
        const clonePos = this.camera.position.clone().addVectors(this.camera.position, vector.setLength(zoomDistance));
        this.camera.position.copy(clonePos);
        this.viewport.signals.cameraChange.dispatch();
    }
    // 以选中点为相机 lookAt 点旋转
    rotate(delta) {
        var _a;
        if (!this.enableRotate)
            return;
        delta.x *= this.rotateSpeed;
        delta.y *= this.rotateSpeed;
        const lookAtVector = new Vector3(0, 0, -1);
        lookAtVector.applyQuaternion(this.camera.quaternion);
        const angle = lookAtVector.angleTo(new Vector3(0, 1, 0));
        if ((angle - delta.y > this.rotateTiltRange.max && delta.y < 0) ||
            (angle - delta.y < this.rotateTiltRange.min && delta.y > 0))
            delta.y = 0;
        const rotateCenterPosition = (_a = this.interactivePosition) !== null && _a !== void 0 ? _a : this.sceneBoxCenter;
        vector.copy(this.camera.position).sub(rotateCenterPosition);
        const rotWorldMatrix1 = new Matrix4();
        const localX = new Vector3(1, 0, 0);
        if (this.enableRotateX) {
            rotWorldMatrix1.makeRotationAxis(new Vector3(0, 1, 0), delta.x);
        }
        const rotWorldMatrix2 = new Matrix4();
        if (this.enableRotateY) {
            localX.applyEuler(this.camera.rotation);
            rotWorldMatrix2.makeRotationAxis(localX, delta.y);
            rotWorldMatrix1.multiply(rotWorldMatrix2);
        }
        vector.applyMatrix4(rotWorldMatrix1);
        lookAtVector.applyMatrix4(rotWorldMatrix1);
        this.camera.position.copy(rotateCenterPosition).add(vector);
        this.camera.lookAt(lookAtVector.add(this.camera.position));
        this.viewport.signals.cameraChange.dispatch();
    }
    autoRotate() {
        const dist = this.autoRotateClockwise ? 0.01 : -0.01;
        this.rotate(new Vector3(dist * this.autoRotateSpeed, 0, 0));
    }
    update() {
        if (this.enableAutoRotate)
            this.autoRotate();
    }
    getSceneBbox() {
        const scene = this.viewport.scene;
        const box3 = new Box3();
        box3.setFromObject(scene);
        return box3;
    }
}

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move
const _changeEvent = { type: 'change', };
const _startEvent = { type: 'start', };
const _endEvent = { type: 'end', };
class OrbitControls extends EventDispatcher {
    constructor(object, domElement) {
        super();
        this.object = object;
        this.domElement = domElement;
        // Set to false to disable this control
        this.enabled = true;
        // "target" sets the location of focus, where the object orbits around
        this.target = new Vector3();
        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;
        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;
        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians
        // How far you can orbit horizontally, upper and lower limits.
        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians
        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.05;
        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;
        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;
        // Set to false to disable panning
        this.enablePan = true;
        this.panSpeed = 1.0;
        this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
        this.keyPanSpeed = 7.0; // pixels moved per arrow key push
        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.enableAutoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per orbit when fps is 60
        // The four arrow keys
        this.keys = {
            LEFT: 'ArrowLeft',
            UP: 'ArrowUp',
            RIGHT: 'ArrowRight',
            BOTTOM: 'ArrowDown',
        };
        // Mouse buttons
        this.mouseButtons = {
            LEFT: MOUSE.ROTATE,
            MIDDLE: MOUSE.DOLLY,
            RIGHT: MOUSE.PAN,
        };
        // Touch fingers
        this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN, };
        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.userData.zoom;
        // the target DOM element for key events
        this._domElementKeyEvents = null;
        this.domElement.style.touchAction = 'none'; // disable touch scroll
        //
        // public methods
        //
        this.getPolarAngle = function () {
            return spherical.phi;
        };
        this.getAzimuthalAngle = function () {
            return spherical.theta;
        };
        this.getDistance = function () {
            return this.object.position.distanceTo(this.target);
        };
        this.listenToKeyEvents = function (domElement) {
            domElement.addEventListener('keydown', onKeyDown);
            this._domElementKeyEvents = domElement;
        };
        this.saveState = function () {
            scope.target0.copy(scope.target);
            scope.position0.copy(scope.object.position);
            scope.zoom0 = scope.object.userData.zoom;
        };
        this.reset = function () {
            scope.target.copy(scope.target0);
            scope.object.position.copy(scope.position0);
            scope.object.userData.zoom = scope.zoom0;
            scope.object.updateProjectionMatrix();
            scope.dispatchEvent(_changeEvent);
            scope.update();
            state = STATE.NONE;
        };
        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = (function () {
            const offset = new Vector3();
            // so camera.up is the orbit axis
            const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
            const quatInverse = quat.clone().invert();
            const lastPosition = new Vector3();
            const lastQuaternion = new Quaternion();
            const twoPI = 2 * Math.PI;
            return function update() {
                const position = scope.object.position;
                offset.copy(position).sub(scope.target);
                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion(quat);
                // angle from z-axis around y-axis
                spherical.setFromVector3(offset);
                if (scope.enableAutoRotate && state === STATE.NONE) {
                    rotateLeft(getAutoRotationAngle());
                }
                if (scope.enableDamping) {
                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;
                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;
                }
                else {
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                }
                // restrict theta to be between desired limits
                let min = scope.minAzimuthAngle;
                let max = scope.maxAzimuthAngle;
                if (isFinite(min) && isFinite(max)) {
                    if (min < -Math.PI)
                        min += twoPI;
                    else if (min > Math.PI)
                        min -= twoPI;
                    if (max < -Math.PI)
                        max += twoPI;
                    else if (max > Math.PI)
                        max -= twoPI;
                    if (min <= max) {
                        spherical.theta = Math.max(min, Math.min(max, spherical.theta));
                    }
                    else {
                        spherical.theta =
                            spherical.theta > (min + max) / 2 ?
                                Math.max(min, spherical.theta) :
                                Math.min(max, spherical.theta);
                    }
                }
                // restrict phi to be between desired limits
                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                spherical.makeSafe();
                spherical.radius *= scale;
                // restrict radius to be between desired limits
                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                // move target to panned location
                if (scope.enableDamping === true) {
                    scope.target.addScaledVector(panOffset, scope.dampingFactor);
                }
                else {
                    scope.target.add(panOffset);
                }
                offset.setFromSpherical(spherical);
                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion(quatInverse);
                position.copy(scope.target).add(offset);
                scope.object.lookAt(scope.target);
                if (scope.enableDamping === true) {
                    sphericalDelta.theta *= 1 - scope.dampingFactor;
                    sphericalDelta.phi *= 1 - scope.dampingFactor;
                    panOffset.multiplyScalar(1 - scope.dampingFactor);
                }
                else {
                    sphericalDelta.set(0, 0, 0);
                    panOffset.set(0, 0, 0);
                }
                scale = 1;
                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8
                if (zoomChanged ||
                    lastPosition.distanceToSquared(scope.object.position) > EPS ||
                    8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                    scope.dispatchEvent(_changeEvent);
                    lastPosition.copy(scope.object.position);
                    lastQuaternion.copy(scope.object.quaternion);
                    zoomChanged = false;
                    return true;
                }
                return false;
            };
        })();
        this.dispose = function () {
            scope.domElement.removeEventListener('contextmenu', onContextMenu);
            scope.domElement.removeEventListener('pointerdown', onPointerDown);
            scope.domElement.removeEventListener('pointercancel', onPointerCancel);
            scope.domElement.removeEventListener('wheel', onMouseWheel);
            scope.domElement.removeEventListener('pointermove', onPointerMove);
            window.removeEventListener('pointerup', onPointerUp);
            if (scope._domElementKeyEvents !== null) {
                scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown);
            }
            //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
        };
        //
        // internals
        //
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const scope = this;
        const STATE = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6,
        };
        let state = STATE.NONE;
        const EPS = 0.000001;
        // current position in spherical coordinates
        const spherical = new Spherical();
        const sphericalDelta = new Spherical();
        let scale = 1;
        const panOffset = new Vector3();
        let zoomChanged = false;
        const rotateStart = new Vector2();
        const rotateEnd = new Vector2();
        const rotateDelta = new Vector2();
        const panStart = new Vector2();
        const panEnd = new Vector2();
        const panDelta = new Vector2();
        const dollyStart = new Vector2();
        const dollyEnd = new Vector2();
        const dollyDelta = new Vector2();
        const pointers = [];
        const pointerPositions = {};
        function getAutoRotationAngle() {
            return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
        }
        function getZoomScale() {
            return Math.pow(0.95, scope.zoomSpeed);
        }
        function rotateLeft(angle) {
            sphericalDelta.theta -= angle;
        }
        function rotateUp(angle) {
            sphericalDelta.phi -= angle;
        }
        const panLeft = (function () {
            const v = new Vector3();
            return function panLeft(distance, objectMatrix) {
                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
                v.multiplyScalar(-distance);
                panOffset.add(v);
            };
        })();
        const panUp = (function () {
            const v = new Vector3();
            return function panUp(distance, objectMatrix) {
                if (scope.screenSpacePanning === true) {
                    v.setFromMatrixColumn(objectMatrix, 1);
                }
                else {
                    v.setFromMatrixColumn(objectMatrix, 0);
                    v.crossVectors(scope.object.up, v);
                }
                v.multiplyScalar(distance);
                panOffset.add(v);
            };
        })();
        // deltaX and deltaY are in pixels; right and down are positive
        const pan = (function () {
            const offset = new Vector3();
            return function pan(deltaX, deltaY) {
                const element = scope.domElement;
                if (scope.object instanceof PerspectiveCamera) {
                    // perspective
                    const position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    let targetDistance = offset.length();
                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0);
                    // we use only clientHeight here so aspect ratio does not distort speed
                    panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix);
                    panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix);
                }
                else if (scope.object.isOrthographicCamera) {
                    // orthographic
                    panLeft((deltaX * (scope.object.right - scope.object.left)) /
                        scope.object.userData.zoom /
                        element.clientWidth, scope.object.matrix);
                    panUp((deltaY * (scope.object.top - scope.object.bottom)) /
                        scope.object.userData.zoom /
                        element.clientHeight, scope.object.matrix);
                }
                else {
                    // camera neither orthographic nor perspective
                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                    scope.enablePan = false;
                }
            };
        })();
        function dollyOut(dollyScale) {
            if (scope.object instanceof PerspectiveCamera) {
                scale /= dollyScale;
            }
            else if (scope.object.isOrthographicCamera) {
                scope.object.userData.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.userData.zoom * dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            }
            else {
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;
            }
        }
        function dollyIn(dollyScale) {
            if (scope.object instanceof PerspectiveCamera) {
                scale *= dollyScale;
            }
            else if (scope.object.isOrthographicCamera) {
                scope.object.userData.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.userData.zoom / dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;
            }
            else {
                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;
            }
        }
        //
        // event callbacks - update the object state
        //
        function handleMouseDownRotate(event) {
            rotateStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownDolly(event) {
            dollyStart.set(event.clientX, event.clientY);
        }
        function handleMouseDownPan(event) {
            panStart.set(event.clientX, event.clientY);
        }
        function handleMouseMoveRotate(event) {
            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta
                .subVectors(rotateEnd, rotateStart)
                .multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height
            rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
            rotateStart.copy(rotateEnd);
            scope.update();
        }
        function handleMouseMoveDolly(event) {
            dollyEnd.set(event.clientX, event.clientY);
            dollyDelta.subVectors(dollyEnd, dollyStart);
            if (dollyDelta.y > 0) {
                dollyOut(getZoomScale());
            }
            else if (dollyDelta.y < 0) {
                dollyIn(getZoomScale());
            }
            dollyStart.copy(dollyEnd);
            scope.update();
        }
        function handleMouseMovePan(event) {
            panEnd.set(event.clientX, event.clientY);
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
            scope.update();
        }
        function handleMouseWheel(event) {
            if (event.deltaY < 0) {
                dollyIn(getZoomScale());
            }
            else if (event.deltaY > 0) {
                dollyOut(getZoomScale());
            }
            scope.update();
        }
        function handleKeyDown(event) {
            let needsUpdate = false;
            switch (event.code) {
                case scope.keys.UP:
                    pan(0, scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.BOTTOM:
                    pan(0, -scope.keyPanSpeed);
                    needsUpdate = true;
                    break;
                case scope.keys.LEFT:
                    pan(scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
                case scope.keys.RIGHT:
                    pan(-scope.keyPanSpeed, 0);
                    needsUpdate = true;
                    break;
            }
            if (needsUpdate) {
                // prevent the browser from scrolling on cursor keys
                event.preventDefault();
                scope.update();
            }
        }
        function handleTouchStartRotate() {
            if (pointers.length === 1) {
                rotateStart.set(pointers[0].pageX, pointers[0].pageY);
            }
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                rotateStart.set(x, y);
            }
        }
        function handleTouchStartPan() {
            if (pointers.length === 1) {
                panStart.set(pointers[0].pageX, pointers[0].pageY);
            }
            else {
                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);
                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);
                panStart.set(x, y);
            }
        }
        function handleTouchStartDolly() {
            const dx = pointers[0].pageX - pointers[1].pageX;
            const dy = pointers[0].pageY - pointers[1].pageY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyStart.set(0, distance);
        }
        function handleTouchStartDollyPan() {
            if (scope.enableZoom)
                handleTouchStartDolly();
            if (scope.enablePan)
                handleTouchStartPan();
        }
        function handleTouchStartDollyRotate() {
            if (scope.enableZoom)
                handleTouchStartDolly();
            if (scope.enableRotate)
                handleTouchStartRotate();
        }
        function handleTouchMoveRotate(event) {
            if (pointers.length == 1) {
                rotateEnd.set(event.pageX, event.pageY);
            }
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                rotateEnd.set(x, y);
            }
            rotateDelta
                .subVectors(rotateEnd, rotateStart)
                .multiplyScalar(scope.rotateSpeed);
            const element = scope.domElement;
            rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height
            rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
            rotateStart.copy(rotateEnd);
        }
        function handleTouchMovePan(event) {
            if (pointers.length === 1) {
                panEnd.set(event.pageX, event.pageY);
            }
            else {
                const position = getSecondPointerPosition(event);
                const x = 0.5 * (event.pageX + position.x);
                const y = 0.5 * (event.pageY + position.y);
                panEnd.set(x, y);
            }
            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
            pan(panDelta.x, panDelta.y);
            panStart.copy(panEnd);
        }
        function handleTouchMoveDolly(event) {
            const position = getSecondPointerPosition(event);
            const dx = event.pageX - position.x;
            const dy = event.pageY - position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            dollyEnd.set(0, distance);
            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
            dollyOut(dollyDelta.y);
            dollyStart.copy(dollyEnd);
        }
        function handleTouchMoveDollyPan(event) {
            if (scope.enableZoom)
                handleTouchMoveDolly(event);
            if (scope.enablePan)
                handleTouchMovePan(event);
        }
        function handleTouchMoveDollyRotate(event) {
            if (scope.enableZoom)
                handleTouchMoveDolly(event);
            if (scope.enableRotate)
                handleTouchMoveRotate(event);
        }
        //
        // event handlers - FSM: listen for events and reset state
        //
        function onPointerDown(event) {
            if (scope.enabled === false)
                return;
            if (pointers.length === 0) {
                // scope.domElement.setPointerCapture( event.pointerId )
                scope.domElement.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', onPointerUp);
            }
            //
            addPointer(event);
            if (event.pointerType === 'touch') {
                onTouchStart(event);
            }
            else {
                onMouseDown(event);
            }
        }
        function onPointerMove(event) {
            event.preventDefault();
            if (scope.enabled === false)
                return;
            if (event.pointerType === 'touch') {
                onTouchMove(event);
            }
            else {
                onMouseMove(event);
            }
        }
        function onPointerUp(event) {
            removePointer(event);
            if (pointers.length === 0) {
                // scope.domElement.releasePointerCapture( event.pointerId )
                scope.domElement.removeEventListener('pointermove', onPointerMove);
                window.removeEventListener('pointerup', onPointerUp);
            }
            scope.dispatchEvent(_endEvent);
            state = STATE.NONE;
        }
        function onPointerCancel(event) {
            removePointer(event);
        }
        function onMouseDown(event) {
            let mouseAction;
            switch (event.button) {
                case 0:
                    mouseAction = scope.mouseButtons.LEFT;
                    break;
                case 1:
                    mouseAction = scope.mouseButtons.MIDDLE;
                    break;
                case 2:
                    mouseAction = scope.mouseButtons.RIGHT;
                    break;
                default:
                    mouseAction = -1;
            }
            switch (mouseAction) {
                case MOUSE.DOLLY:
                    if (scope.enableZoom === false)
                        return;
                    handleMouseDownDolly(event);
                    state = STATE.DOLLY;
                    break;
                case MOUSE.ROTATE:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enablePan === false)
                            return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    }
                    else {
                        if (scope.enableRotate === false)
                            return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    }
                    break;
                case MOUSE.PAN:
                    if (event.ctrlKey || event.metaKey || event.shiftKey) {
                        if (scope.enableRotate === false)
                            return;
                        handleMouseDownRotate(event);
                        state = STATE.ROTATE;
                    }
                    else {
                        if (scope.enablePan === false)
                            return;
                        handleMouseDownPan(event);
                        state = STATE.PAN;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) {
                scope.dispatchEvent(_startEvent);
            }
        }
        function onMouseMove(event) {
            switch (state) {
                case STATE.ROTATE:
                    if (scope.enableRotate === false)
                        return;
                    handleMouseMoveRotate(event);
                    break;
                case STATE.DOLLY:
                    if (scope.enableZoom === false)
                        return;
                    handleMouseMoveDolly(event);
                    break;
                case STATE.PAN:
                    if (scope.enablePan === false)
                        return;
                    handleMouseMovePan(event);
                    break;
            }
        }
        function onMouseWheel(event) {
            if (scope.enabled === false ||
                scope.enableZoom === false ||
                state !== STATE.NONE)
                return;
            event.preventDefault();
            scope.dispatchEvent(_startEvent);
            handleMouseWheel(event);
            scope.dispatchEvent(_endEvent);
        }
        function onKeyDown(event) {
            if (scope.enabled === false || scope.enablePan === false)
                return;
            handleKeyDown(event);
        }
        function onTouchStart(event) {
            trackPointer(event);
            switch (pointers.length) {
                case 1:
                    switch (scope.touches.ONE) {
                        case TOUCH.ROTATE:
                            if (scope.enableRotate === false)
                                return;
                            handleTouchStartRotate();
                            state = STATE.TOUCH_ROTATE;
                            break;
                        case TOUCH.PAN:
                            if (scope.enablePan === false)
                                return;
                            handleTouchStartPan();
                            state = STATE.TOUCH_PAN;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                case 2:
                    switch (scope.touches.TWO) {
                        case TOUCH.DOLLY_PAN:
                            if (scope.enableZoom === false && scope.enablePan === false)
                                return;
                            handleTouchStartDollyPan();
                            state = STATE.TOUCH_DOLLY_PAN;
                            break;
                        case TOUCH.DOLLY_ROTATE:
                            if (scope.enableZoom === false && scope.enableRotate === false)
                                return;
                            handleTouchStartDollyRotate();
                            state = STATE.TOUCH_DOLLY_ROTATE;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                    break;
                default:
                    state = STATE.NONE;
            }
            if (state !== STATE.NONE) {
                scope.dispatchEvent(_startEvent);
            }
        }
        function onTouchMove(event) {
            trackPointer(event);
            switch (state) {
                case STATE.TOUCH_ROTATE:
                    if (scope.enableRotate === false)
                        return;
                    handleTouchMoveRotate(event);
                    scope.update();
                    break;
                case STATE.TOUCH_PAN:
                    if (scope.enablePan === false)
                        return;
                    handleTouchMovePan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_PAN:
                    if (scope.enableZoom === false && scope.enablePan === false)
                        return;
                    handleTouchMoveDollyPan(event);
                    scope.update();
                    break;
                case STATE.TOUCH_DOLLY_ROTATE:
                    if (scope.enableZoom === false && scope.enableRotate === false)
                        return;
                    handleTouchMoveDollyRotate(event);
                    scope.update();
                    break;
                default:
                    state = STATE.NONE;
            }
        }
        function onContextMenu(event) {
            if (scope.enabled === false)
                return;
            event.preventDefault();
        }
        function addPointer(event) {
            pointers.push(event);
        }
        function removePointer(event) {
            delete pointerPositions[event.pointerId];
            for (let i = 0; i < pointers.length; i++) {
                if (pointers[i].pointerId == event.pointerId) {
                    pointers.splice(i, 1);
                    return;
                }
            }
        }
        function trackPointer(event) {
            let position = pointerPositions[event.pointerId];
            if (position === undefined) {
                position = new Vector2();
                pointerPositions[event.pointerId] = position;
            }
            position.set(event.pageX, event.pageY);
        }
        function getSecondPointerPosition(event) {
            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
            return pointerPositions[pointer.pointerId];
        }
        //
        scope.domElement.addEventListener('contextmenu', onContextMenu);
        scope.domElement.addEventListener('pointerdown', onPointerDown);
        scope.domElement.addEventListener('pointercancel', onPointerCancel);
        scope.domElement.addEventListener('wheel', onMouseWheel, {
            passive: false,
        });
        // force an update at start
        // this.update()
    }
}

class Controls {
    get options() {
        return this._options;
    }
    set options(val) {
        this._options = val;
        if (!val.type) {
            this._options.type = 'free';
        }
        this._onChangeCallback();
    }
    constructor(viewport) {
        this.viewport = viewport;
        this._options = { type: 'free', };
        this._disposeList = new Set();
        this.currentControls = new FreeControls(this.viewport);
    }
    handleFreeControls() {
        const _a = this.options, rest = __rest(_a, ["type"]);
        const { postRender, } = this.viewport;
        const freeControls = this.currentControls = new FreeControls(this.viewport);
        Object.assign(freeControls, rest);
        /**
         * controls update
         */
        postRender.set('FreeControlsUpdate', () => {
            freeControls.update();
        });
        this._disposeList.add(() => {
            postRender.delete('FreeControlsUpdate');
        });
    }
    handleOrbitControls() {
        const _a = Object.assign({}, this.options), rest = __rest(_a, ["type"]);
        const { cameraManager: { mainCamera, }, interactiveContainer, postRender, } = this.viewport;
        const orbitControls = this.currentControls = new OrbitControls(mainCamera, interactiveContainer);
        Object.assign(orbitControls, rest);
        // force an update at start
        orbitControls.update();
        /**
         * camera manual change
         */
        const changeHandle = () => {
            this.viewport.signals.cameraChange.dispatch();
        };
        orbitControls.addEventListener('change', changeHandle);
        this._disposeList.add(() => {
            orbitControls.removeEventListener('change', changeHandle);
        });
        /**
         * auto update
         */
        if (rest.enableDamping || rest.enableAutoRotate) {
            postRender.set('OrbitControlsUpdate', () => {
                this.viewport.render(() => {
                    orbitControls.update();
                });
            });
            this._disposeList.add(() => {
                postRender.delete('OrbitControlsUpdate');
            });
        }
        else {
            /**
             * controls update
             */
            const cameraChangeHandle = (p) => {
                if (p) {
                    orbitControls.update();
                }
            };
            this.viewport.signals.cameraChange.add(cameraChangeHandle);
            this._disposeList.add(() => {
                this.viewport.signals.cameraChange.remove(cameraChangeHandle);
            });
        }
    }
    _onChangeCallback() {
        this.dispose();
        switch (this.options.type) {
            case 'free':
                this.handleFreeControls();
                break;
            case 'orbit':
                this.handleOrbitControls();
                break;
            default:
                this.handleFreeControls();
                break;
        }
        this.viewport.triggerRender();
    }
    setOptions(options) {
        this.options = options;
    }
    dispose() {
        this.currentControls.dispose();
        this._disposeList.forEach(dispose => dispose());
        this._disposeList.clear();
    }
}

var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
function int2char(n) {
    return BI_RM.charAt(n);
}
//#region BIT_OPERATIONS
// (public) this & a
function op_and(x, y) {
    return x & y;
}
// (public) this | a
function op_or(x, y) {
    return x | y;
}
// (public) this ^ a
function op_xor(x, y) {
    return x ^ y;
}
// (public) this & ~a
function op_andnot(x, y) {
    return x & ~y;
}
// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x & 0xffff) == 0) {
        x >>= 16;
        r += 16;
    }
    if ((x & 0xff) == 0) {
        x >>= 8;
        r += 8;
    }
    if ((x & 0xf) == 0) {
        x >>= 4;
        r += 4;
    }
    if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
    }
    if ((x & 1) == 0) {
        ++r;
    }
    return r;
}
// return number of 1 bits in x
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &= x - 1;
        ++r;
    }
    return r;
}
//#endregion BIT_OPERATIONS

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";
function hex2b64(h) {
    var i;
    var c;
    var ret = "";
    for (i = 0; i + 3 <= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c << 2);
    }
    else if (i + 2 == h.length) {
        c = parseInt(h.substring(i, i + 2), 16);
        ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
    }
    while ((ret.length & 3) > 0) {
        ret += b64pad;
    }
    return ret;
}
// convert a base64 string to hex
function b64tohex(s) {
    var ret = "";
    var i;
    var k = 0; // b64 state, 0-3
    var slop = 0;
    for (i = 0; i < s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        var v = b64map.indexOf(s.charAt(i));
        if (v < 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 1;
        }
        else if (k == 1) {
            ret += int2char((slop << 2) | (v >> 4));
            slop = v & 0xf;
            k = 2;
        }
        else if (k == 2) {
            ret += int2char(slop);
            ret += int2char(v >> 2);
            slop = v & 3;
            k = 3;
        }
        else {
            ret += int2char((slop << 2) | (v >> 4));
            ret += int2char(v & 0xf);
            k = 0;
        }
    }
    if (k == 1) {
        ret += int2char(slop << 2);
    }
    return ret;
}

// Hex JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder$1;
var Hex = {
    decode: function (a) {
        var i;
        if (decoder$1 === undefined) {
            var hex = "0123456789ABCDEF";
            var ignore = " \f\n\r\t\u00A0\u2028\u2029";
            decoder$1 = {};
            for (i = 0; i < 16; ++i) {
                decoder$1[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i < 16; ++i) {
                decoder$1[hex.charAt(i)] = i;
            }
            for (i = 0; i < ignore.length; ++i) {
                decoder$1[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder$1[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 4;
            }
        }
        if (char_count) {
            throw new Error("Hex encoding incomplete: 4 bits missing");
        }
        return out;
    }
};

// Base64 JavaScript decoder
// Copyright (c) 2008-2013 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var decoder;
var Base64 = {
    decode: function (a) {
        var i;
        if (decoder === undefined) {
            var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            var ignore = "= \f\n\r\t\u00A0\u2028\u2029";
            decoder = Object.create(null);
            for (i = 0; i < 64; ++i) {
                decoder[b64.charAt(i)] = i;
            }
            decoder['-'] = 62; //+
            decoder['_'] = 63; //-
            for (i = 0; i < ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0;
        var char_count = 0;
        for (i = 0; i < a.length; ++i) {
            var c = a.charAt(i);
            if (c == "=") {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw new Error("Illegal character at offset " + i);
            }
            bits |= c;
            if (++char_count >= 4) {
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                out[out.length] = bits & 0xFF;
                bits = 0;
                char_count = 0;
            }
            else {
                bits <<= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw new Error("Base64 encoding incomplete: at least 2 bits missing");
            case 2:
                out[out.length] = (bits >> 10);
                break;
            case 3:
                out[out.length] = (bits >> 16);
                out[out.length] = (bits >> 8) & 0xFF;
                break;
        }
        return out;
    },
    re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
    unarmor: function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            }
            else if (m[2]) {
                a = m[2];
            }
            else {
                throw new Error("RegExp out of sync");
            }
        }
        return Base64.decode(a);
    }
};

// Big integer base-10 printing library
// Copyright (c) 2014 Lapo Luchini <lapo@lapo.it>
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
/*jshint browser: true, strict: true, immed: true, latedef: true, undef: true, regexdash: false */
var max = 10000000000000; // biggest integer that can still fit 2^53 when multiplied by 256
var Int10 = /** @class */ (function () {
    function Int10(value) {
        this.buf = [+value || 0];
    }
    Int10.prototype.mulAdd = function (m, c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] * m + c;
            if (t < max) {
                c = 0;
            }
            else {
                c = 0 | (t / max);
                t -= c * max;
            }
            b[i] = t;
        }
        if (c > 0) {
            b[i] = c;
        }
    };
    Int10.prototype.sub = function (c) {
        // assert(m <= 256)
        var b = this.buf;
        var l = b.length;
        var i;
        var t;
        for (i = 0; i < l; ++i) {
            t = b[i] - c;
            if (t < 0) {
                t += max;
                c = 1;
            }
            else {
                c = 0;
            }
            b[i] = t;
        }
        while (b[b.length - 1] === 0) {
            b.pop();
        }
    };
    Int10.prototype.toString = function (base) {
        if ((base || 10) != 10) {
            throw new Error("only base 10 is supported");
        }
        var b = this.buf;
        var s = b[b.length - 1].toString();
        for (var i = b.length - 2; i >= 0; --i) {
            s += (max + b[i]).toString().substring(1);
        }
        return s;
    };
    Int10.prototype.valueOf = function () {
        var b = this.buf;
        var v = 0;
        for (var i = b.length - 1; i >= 0; --i) {
            v = v * max + b[i];
        }
        return v;
    };
    Int10.prototype.simplify = function () {
        var b = this.buf;
        return (b.length == 1) ? b[0] : this;
    };
    return Int10;
}());

// ASN.1 JavaScript decoder
var ellipsis = "\u2026";
var reTimeS = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
var reTimeL = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
function stringCut(str, len) {
    if (str.length > len) {
        str = str.substring(0, len) + ellipsis;
    }
    return str;
}
var Stream = /** @class */ (function () {
    function Stream(enc, pos) {
        this.hexDigits = "0123456789ABCDEF";
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        }
        else {
            // enc should be an array or a binary string
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos >= this.enc.length) {
            throw new Error("Requesting byte offset ".concat(pos, " on a stream of length ").concat(this.enc.length));
        }
        return ("string" === typeof this.enc) ? this.enc.charCodeAt(pos) : this.enc[pos];
    };
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i & 0xF) {
                    case 0x7:
                        s += "  ";
                        break;
                    case 0xF:
                        s += "\n";
                        break;
                    default:
                        s += " ";
                }
            }
        }
        return s;
    };
    Stream.prototype.isASCII = function (start, end) {
        for (var i = start; i < end; ++i) {
            var c = this.get(i);
            if (c < 32 || c > 176) {
                return false;
            }
        }
        return true;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = "";
        for (var i = start; i < end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = "";
        for (var i = start; i < end;) {
            var c = this.get(i++);
            if (c < 128) {
                s += String.fromCharCode(c);
            }
            else if ((c > 191) && (c < 224)) {
                s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
            }
            else {
                s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = "";
        var hi;
        var lo;
        for (var i = start; i < end;) {
            hi = this.get(i++);
            lo = this.get(i++);
            str += String.fromCharCode((hi << 8) | lo);
        }
        return str;
    };
    Stream.prototype.parseTime = function (start, end, shortYear) {
        var s = this.parseStringISO(start, end);
        var m = (shortYear ? reTimeS : reTimeL).exec(s);
        if (!m) {
            return "Unrecognized time: " + s;
        }
        if (shortYear) {
            // to avoid querying the timer, use the fixed range [1970, 2069]
            // it will conform with ITU X.400 [-10, +40] sliding window until 2030
            m[1] = +m[1];
            m[1] += (+m[1] < 70) ? 2000 : 1900;
        }
        s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
        if (m[5]) {
            s += ":" + m[5];
            if (m[6]) {
                s += ":" + m[6];
                if (m[7]) {
                    s += "." + m[7];
                }
            }
        }
        if (m[8]) {
            s += " UTC";
            if (m[8] != "Z") {
                s += m[8];
                if (m[9]) {
                    s += ":" + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var v = this.get(start);
        var neg = (v > 127);
        var pad = neg ? 255 : 0;
        var len;
        var s = "";
        // skip unuseful bits (not allowed in DER)
        while (v == pad && ++start < end) {
            v = this.get(start);
        }
        len = end - start;
        if (len === 0) {
            return neg ? -1 : 0;
        }
        // show bit length of huge integers
        if (len > 4) {
            s = v;
            len <<= 3;
            while (((+s ^ pad) & 0x80) == 0) {
                s = +s << 1;
                --len;
            }
            s = "(" + len + " bit)\n";
        }
        // decode the integer
        if (neg) {
            v = v - 256;
        }
        var n = new Int10(v);
        for (var i = start + 1; i < end; ++i) {
            n.mulAdd(256, this.get(i));
        }
        return s + n.toString();
    };
    Stream.prototype.parseBitString = function (start, end, maxLength) {
        var unusedBit = this.get(start);
        var lenBit = ((end - start - 1) << 3) - unusedBit;
        var intro = "(" + lenBit + " bit)\n";
        var s = "";
        for (var i = start + 1; i < end; ++i) {
            var b = this.get(i);
            var skip = (i == end - 1) ? unusedBit : 0;
            for (var j = 7; j >= skip; --j) {
                s += (b >> j) & 1 ? "1" : "0";
            }
            if (s.length > maxLength) {
                return intro + stringCut(s, maxLength);
            }
        }
        return intro + s;
    };
    Stream.prototype.parseOctetString = function (start, end, maxLength) {
        if (this.isASCII(start, end)) {
            return stringCut(this.parseStringISO(start, end), maxLength);
        }
        var len = end - start;
        var s = "(" + len + " byte)\n";
        maxLength /= 2; // we work in bytes
        if (len > maxLength) {
            end = start + maxLength;
        }
        for (var i = start; i < end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len > maxLength) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end, maxLength) {
        var s = "";
        var n = new Int10();
        var bits = 0;
        for (var i = start; i < end; ++i) {
            var v = this.get(i);
            n.mulAdd(128, v & 0x7F);
            bits += 7;
            if (!(v & 0x80)) { // finished
                if (s === "") {
                    n = n.simplify();
                    if (n instanceof Int10) {
                        n.sub(80);
                        s = "2." + n.toString();
                    }
                    else {
                        var m = n < 80 ? n < 40 ? 0 : 1 : 2;
                        s = m + "." + (n - m * 40);
                    }
                }
                else {
                    s += "." + n.toString();
                }
                if (s.length > maxLength) {
                    return stringCut(s, maxLength);
                }
                n = new Int10();
                bits = 0;
            }
        }
        if (bits > 0) {
            s += ".incomplete";
        }
        return s;
    };
    return Stream;
}());
var ASN1 = /** @class */ (function () {
    function ASN1(stream, header, length, tag, sub) {
        if (!(tag instanceof ASN1Tag)) {
            throw new Error("Invalid tag value.");
        }
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        switch (this.tag.tagClass) {
            case 0: // universal
                switch (this.tag.tagNumber) {
                    case 0x00:
                        return "EOC";
                    case 0x01:
                        return "BOOLEAN";
                    case 0x02:
                        return "INTEGER";
                    case 0x03:
                        return "BIT_STRING";
                    case 0x04:
                        return "OCTET_STRING";
                    case 0x05:
                        return "NULL";
                    case 0x06:
                        return "OBJECT_IDENTIFIER";
                    case 0x07:
                        return "ObjectDescriptor";
                    case 0x08:
                        return "EXTERNAL";
                    case 0x09:
                        return "REAL";
                    case 0x0A:
                        return "ENUMERATED";
                    case 0x0B:
                        return "EMBEDDED_PDV";
                    case 0x0C:
                        return "UTF8String";
                    case 0x10:
                        return "SEQUENCE";
                    case 0x11:
                        return "SET";
                    case 0x12:
                        return "NumericString";
                    case 0x13:
                        return "PrintableString"; // ASCII subset
                    case 0x14:
                        return "TeletexString"; // aka T61String
                    case 0x15:
                        return "VideotexString";
                    case 0x16:
                        return "IA5String"; // ASCII
                    case 0x17:
                        return "UTCTime";
                    case 0x18:
                        return "GeneralizedTime";
                    case 0x19:
                        return "GraphicString";
                    case 0x1A:
                        return "VisibleString"; // ASCII subset
                    case 0x1B:
                        return "GeneralString";
                    case 0x1C:
                        return "UniversalString";
                    case 0x1E:
                        return "BMPString";
                }
                return "Universal_" + this.tag.tagNumber.toString();
            case 1:
                return "Application_" + this.tag.tagNumber.toString();
            case 2:
                return "[" + this.tag.tagNumber.toString() + "]"; // Context
            case 3:
                return "Private_" + this.tag.tagNumber.toString();
        }
    };
    ASN1.prototype.content = function (maxLength) {
        if (this.tag === undefined) {
            return null;
        }
        if (maxLength === undefined) {
            maxLength = Infinity;
        }
        var content = this.posContent();
        var len = Math.abs(this.length);
        if (!this.tag.isUniversal()) {
            if (this.sub !== null) {
                return "(" + this.sub.length + " elem)";
            }
            return this.stream.parseOctetString(content, content + len, maxLength);
        }
        switch (this.tag.tagNumber) {
            case 0x01: // BOOLEAN
                return (this.stream.get(content) === 0) ? "false" : "true";
            case 0x02: // INTEGER
                return this.stream.parseInteger(content, content + len);
            case 0x03: // BIT_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseBitString(content, content + len, maxLength);
            case 0x04: // OCTET_STRING
                return this.sub ? "(" + this.sub.length + " elem)" :
                    this.stream.parseOctetString(content, content + len, maxLength);
            // case 0x05: // NULL
            case 0x06: // OBJECT_IDENTIFIER
                return this.stream.parseOID(content, content + len, maxLength);
            // case 0x07: // ObjectDescriptor
            // case 0x08: // EXTERNAL
            // case 0x09: // REAL
            // case 0x0A: // ENUMERATED
            // case 0x0B: // EMBEDDED_PDV
            case 0x10: // SEQUENCE
            case 0x11: // SET
                if (this.sub !== null) {
                    return "(" + this.sub.length + " elem)";
                }
                else {
                    return "(no elem)";
                }
            case 0x0C: // UTF8String
                return stringCut(this.stream.parseStringUTF(content, content + len), maxLength);
            case 0x12: // NumericString
            case 0x13: // PrintableString
            case 0x14: // TeletexString
            case 0x15: // VideotexString
            case 0x16: // IA5String
            // case 0x19: // GraphicString
            case 0x1A: // VisibleString
                // case 0x1B: // GeneralString
                // case 0x1C: // UniversalString
                return stringCut(this.stream.parseStringISO(content, content + len), maxLength);
            case 0x1E: // BMPString
                return stringCut(this.stream.parseStringBMP(content, content + len), maxLength);
            case 0x17: // UTCTime
            case 0x18: // GeneralizedTime
                return this.stream.parseTime(content, content + len, (this.tag.tagNumber == 0x17));
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? "null" : this.sub.length) + "]";
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = "";
        }
        var s = indent + this.typeName() + " @" + this.stream.pos;
        if (this.length >= 0) {
            s += "+";
        }
        s += this.length;
        if (this.tag.tagConstructed) {
            s += " (constructed)";
        }
        else if ((this.tag.isUniversal() && ((this.tag.tagNumber == 0x03) || (this.tag.tagNumber == 0x04))) && (this.sub !== null)) {
            s += " (encapsulates)";
        }
        s += "\n";
        if (this.sub !== null) {
            indent += "  ";
            for (var i = 0, max = this.sub.length; i < max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.toHexString = function () {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get();
        var len = buf & 0x7F;
        if (len == buf) {
            return len;
        }
        // no reason to use Int10, as it would be a huge buffer anyways
        if (len > 6) {
            throw new Error("Length over 48 bits not supported at position " + (stream.pos - 1));
        }
        if (len === 0) {
            return null;
        } // undefined
        buf = 0;
        for (var i = 0; i < len; ++i) {
            buf = (buf * 256) + stream.get();
        }
        return buf;
    };
    /**
     * Retrieve the hexadecimal value (as a string) of the current ASN.1 element
     * @returns {string}
     * @public
     */
    ASN1.prototype.getHexStringValue = function () {
        var hexString = this.toHexString();
        var offset = this.header * 2;
        var length = this.length * 2;
        return hexString.substr(offset, length);
    };
    ASN1.decode = function (str) {
        var stream;
        if (!(str instanceof Stream)) {
            stream = new Stream(str, 0);
        }
        else {
            stream = str;
        }
        var streamStart = new Stream(stream);
        var tag = new ASN1Tag(stream);
        var len = ASN1.decodeLength(stream);
        var start = stream.pos;
        var header = start - streamStart.pos;
        var sub = null;
        var getSub = function () {
            var ret = [];
            if (len !== null) {
                // definite length
                var end = start + len;
                while (stream.pos < end) {
                    ret[ret.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw new Error("Content size is not correct for container starting at offset " + start);
                }
            }
            else {
                // undefined length
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag.isEOC()) {
                            break;
                        }
                        ret[ret.length] = s;
                    }
                    len = start - stream.pos; // undefined lengths are represented as negative values
                }
                catch (e) {
                    throw new Error("Exception while decoding undefined length content: " + e);
                }
            }
            return ret;
        };
        if (tag.tagConstructed) {
            // must have valid content
            sub = getSub();
        }
        else if (tag.isUniversal() && ((tag.tagNumber == 0x03) || (tag.tagNumber == 0x04))) {
            // sometimes BitString and OctetString are used to encapsulate ASN.1
            try {
                if (tag.tagNumber == 0x03) {
                    if (stream.get() != 0) {
                        throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                    }
                }
                sub = getSub();
                for (var i = 0; i < sub.length; ++i) {
                    if (sub[i].tag.isEOC()) {
                        throw new Error("EOC is not supposed to be actual content.");
                    }
                }
            }
            catch (e) {
                // but silently ignore when they don't
                sub = null;
            }
        }
        if (sub === null) {
            if (len === null) {
                throw new Error("We can't skip over an invalid tag with undefined length at offset " + start);
            }
            stream.pos = start + Math.abs(len);
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    return ASN1;
}());
var ASN1Tag = /** @class */ (function () {
    function ASN1Tag(stream) {
        var buf = stream.get();
        this.tagClass = buf >> 6;
        this.tagConstructed = ((buf & 0x20) !== 0);
        this.tagNumber = buf & 0x1F;
        if (this.tagNumber == 0x1F) { // long tag
            var n = new Int10();
            do {
                buf = stream.get();
                n.mulAdd(128, buf & 0x7F);
            } while (buf & 0x80);
            this.tagNumber = n.simplify();
        }
    }
    ASN1Tag.prototype.isUniversal = function () {
        return this.tagClass === 0x00;
    };
    ASN1Tag.prototype.isEOC = function () {
        return this.tagClass === 0x00 && this.tagNumber === 0x00;
    };
    return ASN1Tag;
}());

// Copyright (c) 2005  Tom Wu
// Bits per digit
var dbits;
// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);
//#region
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
//#endregion
// (public) Constructor
var BigInteger = /** @class */ (function () {
    function BigInteger(a, b, c) {
        if (a != null) {
            if ("number" == typeof a) {
                this.fromNumber(a, b, c);
            }
            else if (b == null && "string" != typeof a) {
                this.fromString(a, 256);
            }
            else {
                this.fromString(a, b);
            }
        }
    }
    //#region PUBLIC
    // BigInteger.prototype.toString = bnToString;
    // (public) return string representation in given radix
    BigInteger.prototype.toString = function (b) {
        if (this.s < 0) {
            return "-" + this.negate().toString(b);
        }
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            return this.toRadix(b);
        }
        var km = (1 << k) - 1;
        var d;
        var m = false;
        var r = "";
        var i = this.t;
        var p = this.DB - (i * this.DB) % k;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
                m = true;
                r = int2char(d);
            }
            while (i >= 0) {
                if (p < k) {
                    d = (this[i] & ((1 << p) - 1)) << (k - p);
                    d |= this[--i] >> (p += this.DB - k);
                }
                else {
                    d = (this[i] >> (p -= k)) & km;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if (d > 0) {
                    m = true;
                }
                if (m) {
                    r += int2char(d);
                }
            }
        }
        return m ? r : "0";
    };
    // BigInteger.prototype.negate = bnNegate;
    // (public) -this
    BigInteger.prototype.negate = function () {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
    };
    // BigInteger.prototype.abs = bnAbs;
    // (public) |this|
    BigInteger.prototype.abs = function () {
        return (this.s < 0) ? this.negate() : this;
    };
    // BigInteger.prototype.compareTo = bnCompareTo;
    // (public) return + if this > a, - if this < a, 0 if equal
    BigInteger.prototype.compareTo = function (a) {
        var r = this.s - a.s;
        if (r != 0) {
            return r;
        }
        var i = this.t;
        r = i - a.t;
        if (r != 0) {
            return (this.s < 0) ? -r : r;
        }
        while (--i >= 0) {
            if ((r = this[i] - a[i]) != 0) {
                return r;
            }
        }
        return 0;
    };
    // BigInteger.prototype.bitLength = bnBitLength;
    // (public) return the number of bits in "this"
    BigInteger.prototype.bitLength = function () {
        if (this.t <= 0) {
            return 0;
        }
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
    };
    // BigInteger.prototype.mod = bnMod;
    // (public) this mod a
    BigInteger.prototype.mod = function (a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            a.subTo(r, r);
        }
        return r;
    };
    // BigInteger.prototype.modPowInt = bnModPowInt;
    // (public) this^e % m, 0 <= e < 2^32
    BigInteger.prototype.modPowInt = function (e, m) {
        var z;
        if (e < 256 || m.isEven()) {
            z = new Classic(m);
        }
        else {
            z = new Montgomery(m);
        }
        return this.exp(e, z);
    };
    // BigInteger.prototype.clone = bnClone;
    // (public)
    BigInteger.prototype.clone = function () {
        var r = nbi();
        this.copyTo(r);
        return r;
    };
    // BigInteger.prototype.intValue = bnIntValue;
    // (public) return value as integer
    BigInteger.prototype.intValue = function () {
        if (this.s < 0) {
            if (this.t == 1) {
                return this[0] - this.DV;
            }
            else if (this.t == 0) {
                return -1;
            }
        }
        else if (this.t == 1) {
            return this[0];
        }
        else if (this.t == 0) {
            return 0;
        }
        // assumes 16 < DB < 32
        return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    };
    // BigInteger.prototype.byteValue = bnByteValue;
    // (public) return value as byte
    BigInteger.prototype.byteValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
    };
    // BigInteger.prototype.shortValue = bnShortValue;
    // (public) return value as short (assumes DB>=16)
    BigInteger.prototype.shortValue = function () {
        return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
    };
    // BigInteger.prototype.signum = bnSigNum;
    // (public) 0 if this == 0, 1 if this > 0
    BigInteger.prototype.signum = function () {
        if (this.s < 0) {
            return -1;
        }
        else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) {
            return 0;
        }
        else {
            return 1;
        }
    };
    // BigInteger.prototype.toByteArray = bnToByteArray;
    // (public) convert to bigendian byte array
    BigInteger.prototype.toByteArray = function () {
        var i = this.t;
        var r = [];
        r[0] = this.s;
        var p = this.DB - (i * this.DB) % 8;
        var d;
        var k = 0;
        if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) {
                r[k++] = d | (this.s << (this.DB - p));
            }
            while (i >= 0) {
                if (p < 8) {
                    d = (this[i] & ((1 << p) - 1)) << (8 - p);
                    d |= this[--i] >> (p += this.DB - 8);
                }
                else {
                    d = (this[i] >> (p -= 8)) & 0xff;
                    if (p <= 0) {
                        p += this.DB;
                        --i;
                    }
                }
                if ((d & 0x80) != 0) {
                    d |= -256;
                }
                if (k == 0 && (this.s & 0x80) != (d & 0x80)) {
                    ++k;
                }
                if (k > 0 || d != this.s) {
                    r[k++] = d;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.equals = function (a) {
        return (this.compareTo(a) == 0);
    };
    // BigInteger.prototype.min = bnMin;
    BigInteger.prototype.min = function (a) {
        return (this.compareTo(a) < 0) ? this : a;
    };
    // BigInteger.prototype.max = bnMax;
    BigInteger.prototype.max = function (a) {
        return (this.compareTo(a) > 0) ? this : a;
    };
    // BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.and = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
    };
    // BigInteger.prototype.or = bnOr;
    BigInteger.prototype.or = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
    };
    // BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.xor = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
    };
    // BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.andNot = function (a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
    };
    // BigInteger.prototype.not = bnNot;
    // (public) ~this
    BigInteger.prototype.not = function () {
        var r = nbi();
        for (var i = 0; i < this.t; ++i) {
            r[i] = this.DM & ~this[i];
        }
        r.t = this.t;
        r.s = ~this.s;
        return r;
    };
    // BigInteger.prototype.shiftLeft = bnShiftLeft;
    // (public) this << n
    BigInteger.prototype.shiftLeft = function (n) {
        var r = nbi();
        if (n < 0) {
            this.rShiftTo(-n, r);
        }
        else {
            this.lShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.shiftRight = bnShiftRight;
    // (public) this >> n
    BigInteger.prototype.shiftRight = function (n) {
        var r = nbi();
        if (n < 0) {
            this.lShiftTo(-n, r);
        }
        else {
            this.rShiftTo(n, r);
        }
        return r;
    };
    // BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    // (public) returns index of lowest 1-bit (or -1 if none)
    BigInteger.prototype.getLowestSetBit = function () {
        for (var i = 0; i < this.t; ++i) {
            if (this[i] != 0) {
                return i * this.DB + lbit(this[i]);
            }
        }
        if (this.s < 0) {
            return this.t * this.DB;
        }
        return -1;
    };
    // BigInteger.prototype.bitCount = bnBitCount;
    // (public) return number of set bits
    BigInteger.prototype.bitCount = function () {
        var r = 0;
        var x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i) {
            r += cbit(this[i] ^ x);
        }
        return r;
    };
    // BigInteger.prototype.testBit = bnTestBit;
    // (public) true iff nth bit is set
    BigInteger.prototype.testBit = function (n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t) {
            return (this.s != 0);
        }
        return ((this[j] & (1 << (n % this.DB))) != 0);
    };
    // BigInteger.prototype.setBit = bnSetBit;
    // (public) this | (1<<n)
    BigInteger.prototype.setBit = function (n) {
        return this.changeBit(n, op_or);
    };
    // BigInteger.prototype.clearBit = bnClearBit;
    // (public) this & ~(1<<n)
    BigInteger.prototype.clearBit = function (n) {
        return this.changeBit(n, op_andnot);
    };
    // BigInteger.prototype.flipBit = bnFlipBit;
    // (public) this ^ (1<<n)
    BigInteger.prototype.flipBit = function (n) {
        return this.changeBit(n, op_xor);
    };
    // BigInteger.prototype.add = bnAdd;
    // (public) this + a
    BigInteger.prototype.add = function (a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
    };
    // BigInteger.prototype.subtract = bnSubtract;
    // (public) this - a
    BigInteger.prototype.subtract = function (a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
    };
    // BigInteger.prototype.multiply = bnMultiply;
    // (public) this * a
    BigInteger.prototype.multiply = function (a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
    };
    // BigInteger.prototype.divide = bnDivide;
    // (public) this / a
    BigInteger.prototype.divide = function (a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
    };
    // BigInteger.prototype.remainder = bnRemainder;
    // (public) this % a
    BigInteger.prototype.remainder = function (a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
    };
    // BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    // (public) [this/a,this%a]
    BigInteger.prototype.divideAndRemainder = function (a) {
        var q = nbi();
        var r = nbi();
        this.divRemTo(a, q, r);
        return [q, r];
    };
    // BigInteger.prototype.modPow = bnModPow;
    // (public) this^e % m (HAC 14.85)
    BigInteger.prototype.modPow = function (e, m) {
        var i = e.bitLength();
        var k;
        var r = nbv(1);
        var z;
        if (i <= 0) {
            return r;
        }
        else if (i < 18) {
            k = 1;
        }
        else if (i < 48) {
            k = 3;
        }
        else if (i < 144) {
            k = 4;
        }
        else if (i < 768) {
            k = 5;
        }
        else {
            k = 6;
        }
        if (i < 8) {
            z = new Classic(m);
        }
        else if (m.isEven()) {
            z = new Barrett(m);
        }
        else {
            z = new Montgomery(m);
        }
        // precomputation
        var g = [];
        var n = 3;
        var k1 = k - 1;
        var km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
                g[n] = nbi();
                z.mulTo(g2, g[n - 2], g[n]);
                n += 2;
            }
        }
        var j = e.t - 1;
        var w;
        var is1 = true;
        var r2 = nbi();
        var t;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
            if (i >= k1) {
                w = (e[j] >> (i - k1)) & km;
            }
            else {
                w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
                if (j > 0) {
                    w |= e[j - 1] >> (this.DB + i - k1);
                }
            }
            n = k;
            while ((w & 1) == 0) {
                w >>= 1;
                --n;
            }
            if ((i -= n) < 0) {
                i += this.DB;
                --j;
            }
            if (is1) { // ret == 1, don't bother squaring or multiplying it
                g[w].copyTo(r);
                is1 = false;
            }
            else {
                while (n > 1) {
                    z.sqrTo(r, r2);
                    z.sqrTo(r2, r);
                    n -= 2;
                }
                if (n > 0) {
                    z.sqrTo(r, r2);
                }
                else {
                    t = r;
                    r = r2;
                    r2 = t;
                }
                z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
                z.sqrTo(r, r2);
                t = r;
                r = r2;
                r2 = t;
                if (--i < 0) {
                    i = this.DB - 1;
                    --j;
                }
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.modInverse = bnModInverse;
    // (public) 1/this % m (HAC 14.61)
    BigInteger.prototype.modInverse = function (m) {
        var ac = m.isEven();
        if ((this.isEven() && ac) || m.signum() == 0) {
            return BigInteger.ZERO;
        }
        var u = m.clone();
        var v = this.clone();
        var a = nbv(1);
        var b = nbv(0);
        var c = nbv(0);
        var d = nbv(1);
        while (u.signum() != 0) {
            while (u.isEven()) {
                u.rShiftTo(1, u);
                if (ac) {
                    if (!a.isEven() || !b.isEven()) {
                        a.addTo(this, a);
                        b.subTo(m, b);
                    }
                    a.rShiftTo(1, a);
                }
                else if (!b.isEven()) {
                    b.subTo(m, b);
                }
                b.rShiftTo(1, b);
            }
            while (v.isEven()) {
                v.rShiftTo(1, v);
                if (ac) {
                    if (!c.isEven() || !d.isEven()) {
                        c.addTo(this, c);
                        d.subTo(m, d);
                    }
                    c.rShiftTo(1, c);
                }
                else if (!d.isEven()) {
                    d.subTo(m, d);
                }
                d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
                u.subTo(v, u);
                if (ac) {
                    a.subTo(c, a);
                }
                b.subTo(d, b);
            }
            else {
                v.subTo(u, v);
                if (ac) {
                    c.subTo(a, c);
                }
                d.subTo(b, d);
            }
        }
        if (v.compareTo(BigInteger.ONE) != 0) {
            return BigInteger.ZERO;
        }
        if (d.compareTo(m) >= 0) {
            return d.subtract(m);
        }
        if (d.signum() < 0) {
            d.addTo(m, d);
        }
        else {
            return d;
        }
        if (d.signum() < 0) {
            return d.add(m);
        }
        else {
            return d;
        }
    };
    // BigInteger.prototype.pow = bnPow;
    // (public) this^e
    BigInteger.prototype.pow = function (e) {
        return this.exp(e, new NullExp());
    };
    // BigInteger.prototype.gcd = bnGCD;
    // (public) gcd(this,a) (HAC 14.54)
    BigInteger.prototype.gcd = function (a) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            return x;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
        }
        if (g > 0) {
            y.lShiftTo(g, y);
        }
        return y;
    };
    // BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    // (public) test primality with certainty >= 1-.5^t
    BigInteger.prototype.isProbablePrime = function (t) {
        var i;
        var x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i) {
                if (x[0] == lowprimes[i]) {
                    return true;
                }
            }
            return false;
        }
        if (x.isEven()) {
            return false;
        }
        i = 1;
        while (i < lowprimes.length) {
            var m = lowprimes[i];
            var j = i + 1;
            while (j < lowprimes.length && m < lplim) {
                m *= lowprimes[j++];
            }
            m = x.modInt(m);
            while (i < j) {
                if (m % lowprimes[i++] == 0) {
                    return false;
                }
            }
        }
        return x.millerRabin(t);
    };
    //#endregion PUBLIC
    //#region PROTECTED
    // BigInteger.prototype.copyTo = bnpCopyTo;
    // (protected) copy this to r
    BigInteger.prototype.copyTo = function (r) {
        for (var i = this.t - 1; i >= 0; --i) {
            r[i] = this[i];
        }
        r.t = this.t;
        r.s = this.s;
    };
    // BigInteger.prototype.fromInt = bnpFromInt;
    // (protected) set from integer value x, -DV <= x < DV
    BigInteger.prototype.fromInt = function (x) {
        this.t = 1;
        this.s = (x < 0) ? -1 : 0;
        if (x > 0) {
            this[0] = x;
        }
        else if (x < -1) {
            this[0] = x + this.DV;
        }
        else {
            this.t = 0;
        }
    };
    // BigInteger.prototype.fromString = bnpFromString;
    // (protected) set from string and radix
    BigInteger.prototype.fromString = function (s, b) {
        var k;
        if (b == 16) {
            k = 4;
        }
        else if (b == 8) {
            k = 3;
        }
        else if (b == 256) {
            k = 8;
            /* byte array */
        }
        else if (b == 2) {
            k = 1;
        }
        else if (b == 32) {
            k = 5;
        }
        else if (b == 4) {
            k = 2;
        }
        else {
            this.fromRadix(s, b);
            return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length;
        var mi = false;
        var sh = 0;
        while (--i >= 0) {
            var x = (k == 8) ? (+s[i]) & 0xff : intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-") {
                    mi = true;
                }
                continue;
            }
            mi = false;
            if (sh == 0) {
                this[this.t++] = x;
            }
            else if (sh + k > this.DB) {
                this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
                this[this.t++] = (x >> (this.DB - sh));
            }
            else {
                this[this.t - 1] |= x << sh;
            }
            sh += k;
            if (sh >= this.DB) {
                sh -= this.DB;
            }
        }
        if (k == 8 && ((+s[0]) & 0x80) != 0) {
            this.s = -1;
            if (sh > 0) {
                this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
            }
        }
        this.clamp();
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.clamp = bnpClamp;
    // (protected) clamp off excess high words
    BigInteger.prototype.clamp = function () {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c) {
            --this.t;
        }
    };
    // BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    // (protected) r = this << n*DB
    BigInteger.prototype.dlShiftTo = function (n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i) {
            r[i + n] = this[i];
        }
        for (i = n - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r.t = this.t + n;
        r.s = this.s;
    };
    // BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    // (protected) r = this >> n*DB
    BigInteger.prototype.drShiftTo = function (n, r) {
        for (var i = n; i < this.t; ++i) {
            r[i - n] = this[i];
        }
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
    };
    // BigInteger.prototype.lShiftTo = bnpLShiftTo;
    // (protected) r = this << n
    BigInteger.prototype.lShiftTo = function (n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB);
        var c = (this.s << bs) & this.DM;
        for (var i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
        }
        for (var i = ds - 1; i >= 0; --i) {
            r[i] = 0;
        }
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
    };
    // BigInteger.prototype.rShiftTo = bnpRShiftTo;
    // (protected) r = this >> n
    BigInteger.prototype.rShiftTo = function (n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
            r.t = 0;
            return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
        }
        if (bs > 0) {
            r[this.t - ds - 1] |= (this.s & bm) << cbs;
        }
        r.t = this.t - ds;
        r.clamp();
    };
    // BigInteger.prototype.subTo = bnpSubTo;
    // (protected) r = this - a
    BigInteger.prototype.subTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c -= a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c -= a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c < -1) {
            r[i++] = this.DV + c;
        }
        else if (c > 0) {
            r[i++] = c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyTo = function (a, r) {
        var x = this.abs();
        var y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < y.t; ++i) {
            r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        }
        r.s = 0;
        r.clamp();
        if (this.s != a.s) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.squareTo = bnpSquareTo;
    // (protected) r = this^2, r != this (HAC 14.16)
    BigInteger.prototype.squareTo = function (r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
                r[i + x.t] -= x.DV;
                r[i + x.t + 1] = 1;
            }
        }
        if (r.t > 0) {
            r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        }
        r.s = 0;
        r.clamp();
    };
    // BigInteger.prototype.divRemTo = bnpDivRemTo;
    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    BigInteger.prototype.divRemTo = function (m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0) {
            return;
        }
        var pt = this.abs();
        if (pt.t < pm.t) {
            if (q != null) {
                q.fromInt(0);
            }
            if (r != null) {
                this.copyTo(r);
            }
            return;
        }
        if (r == null) {
            r = nbi();
        }
        var y = nbi();
        var ts = this.s;
        var ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
        if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
        }
        else {
            pm.copyTo(y);
            pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0) {
            return;
        }
        var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt;
        var d2 = (1 << this.F1) / yt;
        var e = 1 << this.F2;
        var i = r.t;
        var j = i - ys;
        var t = (q == null) ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y); // "negative" y so we can replace sub with am later
        while (y.t < ys) {
            y[y.t++] = 0;
        }
        while (--j >= 0) {
            // Estimate quotient digit
            var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) { // Try it out
                y.dlShiftTo(j, t);
                r.subTo(t, r);
                while (r[i] < --qd) {
                    r.subTo(t, r);
                }
            }
        }
        if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) {
                BigInteger.ZERO.subTo(q, q);
            }
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0) {
            r.rShiftTo(nsh, r);
        } // Denormalize remainder
        if (ts < 0) {
            BigInteger.ZERO.subTo(r, r);
        }
    };
    // BigInteger.prototype.invDigit = bnpInvDigit;
    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    BigInteger.prototype.invDigit = function () {
        if (this.t < 1) {
            return 0;
        }
        var x = this[0];
        if ((x & 1) == 0) {
            return 0;
        }
        var y = x & 3; // y == 1/x mod 2^2
        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
        // last step - calculate inverse mod DV directly;
        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
        y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
        // we really want the negative inverse, and -DV < y < DV
        return (y > 0) ? this.DV - y : -y;
    };
    // BigInteger.prototype.isEven = bnpIsEven;
    // (protected) true iff this is even
    BigInteger.prototype.isEven = function () {
        return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
    };
    // BigInteger.prototype.exp = bnpExp;
    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    BigInteger.prototype.exp = function (e, z) {
        if (e > 0xffffffff || e < 1) {
            return BigInteger.ONE;
        }
        var r = nbi();
        var r2 = nbi();
        var g = z.convert(this);
        var i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) {
                z.mulTo(r2, g, r);
            }
            else {
                var t = r;
                r = r2;
                r2 = t;
            }
        }
        return z.revert(r);
    };
    // BigInteger.prototype.chunkSize = bnpChunkSize;
    // (protected) return x s.t. r^x < DV
    BigInteger.prototype.chunkSize = function (r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
    };
    // BigInteger.prototype.toRadix = bnpToRadix;
    // (protected) convert to radix string
    BigInteger.prototype.toRadix = function (b) {
        if (b == null) {
            b = 10;
        }
        if (this.signum() == 0 || b < 2 || b > 36) {
            return "0";
        }
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a);
        var y = nbi();
        var z = nbi();
        var r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
    };
    // BigInteger.prototype.fromRadix = bnpFromRadix;
    // (protected) convert from radix string
    BigInteger.prototype.fromRadix = function (s, b) {
        this.fromInt(0);
        if (b == null) {
            b = 10;
        }
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs);
        var mi = false;
        var j = 0;
        var w = 0;
        for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
                if (s.charAt(i) == "-" && this.signum() == 0) {
                    mi = true;
                }
                continue;
            }
            w = b * w + x;
            if (++j >= cs) {
                this.dMultiply(d);
                this.dAddOffset(w, 0);
                j = 0;
                w = 0;
            }
        }
        if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
        }
        if (mi) {
            BigInteger.ZERO.subTo(this, this);
        }
    };
    // BigInteger.prototype.fromNumber = bnpFromNumber;
    // (protected) alternate constructor
    BigInteger.prototype.fromNumber = function (a, b, c) {
        if ("number" == typeof b) {
            // new BigInteger(int,int,RNG)
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    // force MSB set
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                } // force odd
                while (!this.isProbablePrime(b)) {
                    this.dAddOffset(2, 0);
                    if (this.bitLength() > a) {
                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                    }
                }
            }
        }
        else {
            // new BigInteger(int,RNG)
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    // BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    // (protected) r = this op a (bitwise)
    BigInteger.prototype.bitwiseTo = function (a, op, r) {
        var i;
        var f;
        var m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i) {
            r[i] = op(this[i], a[i]);
        }
        if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) {
                r[i] = op(this[i], f);
            }
            r.t = this.t;
        }
        else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) {
                r[i] = op(f, a[i]);
            }
            r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
    };
    // BigInteger.prototype.changeBit = bnpChangeBit;
    // (protected) this op (1<<n)
    BigInteger.prototype.changeBit = function (n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
    };
    // BigInteger.prototype.addTo = bnpAddTo;
    // (protected) r = this + a
    BigInteger.prototype.addTo = function (a, r) {
        var i = 0;
        var c = 0;
        var m = Math.min(a.t, this.t);
        while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
        }
        if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
                c += this[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += this.s;
        }
        else {
            c += this.s;
            while (i < a.t) {
                c += a[i];
                r[i++] = c & this.DM;
                c >>= this.DB;
            }
            c += a.s;
        }
        r.s = (c < 0) ? -1 : 0;
        if (c > 0) {
            r[i++] = c;
        }
        else if (c < -1) {
            r[i++] = this.DV + c;
        }
        r.t = i;
        r.clamp();
    };
    // BigInteger.prototype.dMultiply = bnpDMultiply;
    // (protected) this *= n, this >= 0, 1 < n < DV
    BigInteger.prototype.dMultiply = function (n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
    };
    // BigInteger.prototype.dAddOffset = bnpDAddOffset;
    // (protected) this += n << w words, this >= 0
    BigInteger.prototype.dAddOffset = function (n, w) {
        if (n == 0) {
            return;
        }
        while (this.t <= w) {
            this[this.t++] = 0;
        }
        this[w] += n;
        while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) {
                this[this.t++] = 0;
            }
            ++this[w];
        }
    };
    // BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyLowerTo = function (a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0; // assumes a,this >= 0
        r.t = i;
        while (i > 0) {
            r[--i] = 0;
        }
        for (var j = r.t - this.t; i < j; ++i) {
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        }
        for (var j = Math.min(a.t, n); i < j; ++i) {
            this.am(0, a[i], r, i, 0, n - i);
        }
        r.clamp();
    };
    // BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    BigInteger.prototype.multiplyUpperTo = function (a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0; // assumes a,this >= 0
        while (--i >= 0) {
            r[i] = 0;
        }
        for (i = Math.max(n - this.t, 0); i < a.t; ++i) {
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        }
        r.clamp();
        r.drShiftTo(1, r);
    };
    // BigInteger.prototype.modInt = bnpModInt;
    // (protected) this % n, n < 2^26
    BigInteger.prototype.modInt = function (n) {
        if (n <= 0) {
            return 0;
        }
        var d = this.DV % n;
        var r = (this.s < 0) ? n - 1 : 0;
        if (this.t > 0) {
            if (d == 0) {
                r = this[0] % n;
            }
            else {
                for (var i = this.t - 1; i >= 0; --i) {
                    r = (d * r + this[i]) % n;
                }
            }
        }
        return r;
    };
    // BigInteger.prototype.millerRabin = bnpMillerRabin;
    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    BigInteger.prototype.millerRabin = function (t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0) {
            return false;
        }
        var r = n1.shiftRight(k);
        t = (t + 1) >> 1;
        if (t > lowprimes.length) {
            t = lowprimes.length;
        }
        var a = nbi();
        for (var i = 0; i < t; ++i) {
            // Pick bases at random, instead of starting at 2
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
                var j = 1;
                while (j++ < k && y.compareTo(n1) != 0) {
                    y = y.modPowInt(2, this);
                    if (y.compareTo(BigInteger.ONE) == 0) {
                        return false;
                    }
                }
                if (y.compareTo(n1) != 0) {
                    return false;
                }
            }
        }
        return true;
    };
    // BigInteger.prototype.square = bnSquare;
    // (public) this^2
    BigInteger.prototype.square = function () {
        var r = nbi();
        this.squareTo(r);
        return r;
    };
    //#region ASYNC
    // Public API method
    BigInteger.prototype.gcda = function (a, callback) {
        var x = (this.s < 0) ? this.negate() : this.clone();
        var y = (a.s < 0) ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit();
        var g = y.getLowestSetBit();
        if (g < 0) {
            callback(x);
            return;
        }
        if (i < g) {
            g = i;
        }
        if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        // Workhorse of the algorithm, gets called 200 - 800 times per 512 bit keygen.
        var gcda1 = function () {
            if ((i = x.getLowestSetBit()) > 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) > 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) >= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            }
            else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() > 0)) {
                if (g > 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () { callback(y); }, 0); // escape
            }
            else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    // (protected) alternate constructor
    BigInteger.prototype.fromNumberAsync = function (a, b, c, callback) {
        if ("number" == typeof b) {
            if (a < 2) {
                this.fromInt(1);
            }
            else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp_1 = this;
                var bnpfn1_1 = function () {
                    bnp_1.dAddOffset(2, 0);
                    if (bnp_1.bitLength() > a) {
                        bnp_1.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp_1);
                    }
                    if (bnp_1.isProbablePrime(b)) {
                        setTimeout(function () { callback(); }, 0); // escape
                    }
                    else {
                        setTimeout(bnpfn1_1, 0);
                    }
                };
                setTimeout(bnpfn1_1, 0);
            }
        }
        else {
            var x = [];
            var t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) {
                x[0] &= ((1 << t) - 1);
            }
            else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    return BigInteger;
}());
//#region REDUCERS
//#region NullExp
var NullExp = /** @class */ (function () {
    function NullExp() {
    }
    // NullExp.prototype.convert = nNop;
    NullExp.prototype.convert = function (x) {
        return x;
    };
    // NullExp.prototype.revert = nNop;
    NullExp.prototype.revert = function (x) {
        return x;
    };
    // NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
    };
    // NullExp.prototype.sqrTo = nSqrTo;
    NullExp.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
    };
    return NullExp;
}());
// Modular reduction using "classic" algorithm
var Classic = /** @class */ (function () {
    function Classic(m) {
        this.m = m;
    }
    // Classic.prototype.convert = cConvert;
    Classic.prototype.convert = function (x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0) {
            return x.mod(this.m);
        }
        else {
            return x;
        }
    };
    // Classic.prototype.revert = cRevert;
    Classic.prototype.revert = function (x) {
        return x;
    };
    // Classic.prototype.reduce = cReduce;
    Classic.prototype.reduce = function (x) {
        x.divRemTo(this.m, null, x);
    };
    // Classic.prototype.mulTo = cMulTo;
    Classic.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Classic.prototype.sqrTo = cSqrTo;
    Classic.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Classic;
}());
//#endregion
//#region Montgomery
// Montgomery reduction
var Montgomery = /** @class */ (function () {
    function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 0x7fff;
        this.mph = this.mp >> 15;
        this.um = (1 << (m.DB - 15)) - 1;
        this.mt2 = 2 * m.t;
    }
    // Montgomery.prototype.convert = montConvert;
    // xR mod m
    Montgomery.prototype.convert = function (x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) {
            this.m.subTo(r, r);
        }
        return r;
    };
    // Montgomery.prototype.revert = montRevert;
    // x/R mod m
    Montgomery.prototype.revert = function (x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
    };
    // Montgomery.prototype.reduce = montReduce;
    // x = x/R mod m (HAC 14.32)
    Montgomery.prototype.reduce = function (x) {
        while (x.t <= this.mt2) {
            // pad x so am has enough room later
            x[x.t++] = 0;
        }
        for (var i = 0; i < this.m.t; ++i) {
            // faster way of calculating u0 = x[i]*mp mod DV
            var j = x[i] & 0x7fff;
            var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
            // use am to combine the multiply-shift-add into one call
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            // propagate carry
            while (x[j] >= x.DV) {
                x[j] -= x.DV;
                x[++j]++;
            }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Montgomery.prototype.mulTo = montMulTo;
    // r = "xy/R mod m"; x,y != r
    Montgomery.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Montgomery.prototype.sqrTo = montSqrTo;
    // r = "x^2/R mod m"; x != r
    Montgomery.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Montgomery;
}());
//#endregion Montgomery
//#region Barrett
// Barrett modular reduction
var Barrett = /** @class */ (function () {
    function Barrett(m) {
        this.m = m;
        // setup Barrett
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
    }
    // Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.convert = function (x) {
        if (x.s < 0 || x.t > 2 * this.m.t) {
            return x.mod(this.m);
        }
        else if (x.compareTo(this.m) < 0) {
            return x;
        }
        else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    };
    // Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.revert = function (x) {
        return x;
    };
    // Barrett.prototype.reduce = barrettReduce;
    // x = x mod m (HAC 14.42)
    Barrett.prototype.reduce = function (x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0) {
            x.dAddOffset(1, this.m.t + 1);
        }
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0) {
            x.subTo(this.m, x);
        }
    };
    // Barrett.prototype.mulTo = barrettMulTo;
    // r = x*y mod m; x,y != r
    Barrett.prototype.mulTo = function (x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
    };
    // Barrett.prototype.sqrTo = barrettSqrTo;
    // r = x^2 mod m; x != r
    Barrett.prototype.sqrTo = function (x, r) {
        x.squareTo(r);
        this.reduce(r);
    };
    return Barrett;
}());
//#endregion
//#endregion REDUCERS
// return new, unset BigInteger
function nbi() { return new BigInteger(null); }
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.
var inBrowser = typeof navigator !== "undefined";
if (inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    BigInteger.prototype.am = function am2(i, x, w, j, c, n) {
        var xl = x & 0x7fff;
        var xh = x >> 15;
        while (--n >= 0) {
            var l = this[i] & 0x7fff;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w[j++] = l & 0x3fffffff;
        }
        return c;
    };
    dbits = 30;
}
else if (inBrowser && j_lm && (navigator.appName != "Netscape")) {
    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    BigInteger.prototype.am = function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
            var v = x * this[i++] + w[j] + c;
            c = Math.floor(v / 0x4000000);
            w[j++] = v & 0x3ffffff;
        }
        return c;
    };
    dbits = 26;
}
else { // Mozilla/Netscape seems to prefer am3
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    BigInteger.prototype.am = function am3(i, x, w, j, c, n) {
        var xl = x & 0x3fff;
        var xh = x >> 14;
        while (--n >= 0) {
            var l = this[i] & 0x3fff;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 0xfffffff;
        }
        return c;
    };
    dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
// Digit conversions
var BI_RC = [];
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) {
    BI_RC[rr++] = vv;
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
}
// return bigint initialized to value
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
// returns bit length of the integer x
function nbits(x) {
    var r = 1;
    var t;
    if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

// prng4.js - uses Arcfour as a PRNG
var Arcfour = /** @class */ (function () {
    function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = [];
    }
    // Arcfour.prototype.init = ARC4init;
    // Initialize arcfour context from key, an array of ints, each from [0..255]
    Arcfour.prototype.init = function (key) {
        var i;
        var j;
        var t;
        for (i = 0; i < 256; ++i) {
            this.S[i] = i;
        }
        j = 0;
        for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
        }
        this.i = 0;
        this.j = 0;
    };
    // Arcfour.prototype.next = ARC4next;
    Arcfour.prototype.next = function () {
        var t;
        this.i = (this.i + 1) & 255;
        this.j = (this.j + this.S[this.i]) & 255;
        t = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t;
        return this.S[(t + this.S[this.i]) & 255];
    };
    return Arcfour;
}());
// Plug in your RNG constructor here
function prng_newstate() {
    return new Arcfour();
}
// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator - requires a PRNG backend, e.g. prng4.js
var rng_state;
var rng_pool = null;
var rng_pptr;
// Initialize the pool with junk if needed.
if (rng_pool == null) {
    rng_pool = [];
    rng_pptr = 0;
    var t = void 0;
    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {
        // Extract entropy (2048 bits) from RNG if available
        var z = new Uint32Array(256);
        window.crypto.getRandomValues(z);
        for (t = 0; t < z.length; ++t) {
            rng_pool[rng_pptr++] = z[t] & 255;
        }
    }
    // Use mouse events for entropy, if we do not have enough entropy by the time
    // we need it, entropy will be generated by Math.random.
    var count = 0;
    var onMouseMoveListener_1 = function (ev) {
        count = count || 0;
        if (count >= 256 || rng_pptr >= rng_psize) {
            if (window.removeEventListener) {
                window.removeEventListener("mousemove", onMouseMoveListener_1, false);
            }
            else if (window.detachEvent) {
                window.detachEvent("onmousemove", onMouseMoveListener_1);
            }
            return;
        }
        try {
            var mouseCoordinates = ev.x + ev.y;
            rng_pool[rng_pptr++] = mouseCoordinates & 255;
            count += 1;
        }
        catch (e) {
            // Sometimes Firefox will deny permission to access event properties for some reason. Ignore.
        }
    };
    if (typeof window !== 'undefined') {
        if (window.addEventListener) {
            window.addEventListener("mousemove", onMouseMoveListener_1, false);
        }
        else if (window.attachEvent) {
            window.attachEvent("onmousemove", onMouseMoveListener_1);
        }
    }
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_state = prng_newstate();
        // At this point, we may not have collected enough entropy.  If not, fall back to Math.random
        while (rng_pptr < rng_psize) {
            var random = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = random & 255;
        }
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    // TODO: allow reseeding after first request
    return rng_state.next();
}
var SecureRandom = /** @class */ (function () {
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = function (ba) {
        for (var i = 0; i < ba.length; ++i) {
            ba[i] = rng_get_byte();
        }
    };
    return SecureRandom;
}());

// Depends on jsbn.js and rng.js
// function linebrk(s,n) {
//   var ret = "";
//   var i = 0;
//   while(i + n < s.length) {
//     ret += s.substring(i,i+n) + "\n";
//     i += n;
//   }
//   return ret + s.substring(i,s.length);
// }
// function byte2Hex(b) {
//   if(b < 0x10)
//     return "0" + b.toString(16);
//   else
//     return b.toString(16);
// }
function pkcs1pad1(s, n) {
    if (n < s.length + 22) {
        console.error("Message too long for RSA");
        return null;
    }
    var len = n - s.length - 6;
    var filler = "";
    for (var f = 0; f < len; f += 2) {
        filler += "ff";
    }
    var m = "0001" + filler + "00" + s;
    return parseBigInt(m, 16);
}
// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
    if (n < s.length + 11) { // TODO: fix for utf-8
        console.error("Message too long for RSA");
        return null;
    }
    var ba = [];
    var i = s.length - 1;
    while (i >= 0 && n > 0) {
        var c = s.charCodeAt(i--);
        if (c < 128) { // encode using utf-8
            ba[--n] = c;
        }
        else if ((c > 127) && (c < 2048)) {
            ba[--n] = (c & 63) | 128;
            ba[--n] = (c >> 6) | 192;
        }
        else {
            ba[--n] = (c & 63) | 128;
            ba[--n] = ((c >> 6) & 63) | 128;
            ba[--n] = (c >> 12) | 224;
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = [];
    while (n > 2) { // random non-zero pad
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
// "empty" RSA key constructor
var RSAKey = /** @class */ (function () {
    function RSAKey() {
        this.n = null;
        this.e = 0;
        this.d = null;
        this.p = null;
        this.q = null;
        this.dmp1 = null;
        this.dmq1 = null;
        this.coeff = null;
    }
    //#region PROTECTED
    // protected
    // RSAKey.prototype.doPublic = RSADoPublic;
    // Perform raw public operation on "x": return x^e (mod n)
    RSAKey.prototype.doPublic = function (x) {
        return x.modPowInt(this.e, this.n);
    };
    // RSAKey.prototype.doPrivate = RSADoPrivate;
    // Perform raw private operation on "x": return x^d (mod n)
    RSAKey.prototype.doPrivate = function (x) {
        if (this.p == null || this.q == null) {
            return x.modPow(this.d, this.n);
        }
        // TODO: re-calculate any missing CRT params
        var xp = x.mod(this.p).modPow(this.dmp1, this.p);
        var xq = x.mod(this.q).modPow(this.dmq1, this.q);
        while (xp.compareTo(xq) < 0) {
            xp = xp.add(this.p);
        }
        return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
    };
    //#endregion PROTECTED
    //#region PUBLIC
    // RSAKey.prototype.setPublic = RSASetPublic;
    // Set the public key fields N and e from hex strings
    RSAKey.prototype.setPublic = function (N, E) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
        }
        else {
            console.error("Invalid RSA public key");
        }
    };
    // RSAKey.prototype.encrypt = RSAEncrypt;
    // Return the PKCS#1 RSA encryption of "text" as an even-length hex string
    RSAKey.prototype.encrypt = function (text) {
        var maxLength = (this.n.bitLength() + 7) >> 3;
        var m = pkcs1pad2(text, maxLength);
        if (m == null) {
            return null;
        }
        var c = this.doPublic(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        var length = h.length;
        // fix zero before result
        for (var i = 0; i < maxLength * 2 - length; i++) {
            h = "0" + h;
        }
        return h;
    };
    // RSAKey.prototype.setPrivate = RSASetPrivate;
    // Set the private key fields N, e, and d from hex strings
    RSAKey.prototype.setPrivate = function (N, E, D) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
    // Set the private key fields N, e, d and CRT params from hex strings
    RSAKey.prototype.setPrivateEx = function (N, E, D, P, Q, DP, DQ, C) {
        if (N != null && E != null && N.length > 0 && E.length > 0) {
            this.n = parseBigInt(N, 16);
            this.e = parseInt(E, 16);
            this.d = parseBigInt(D, 16);
            this.p = parseBigInt(P, 16);
            this.q = parseBigInt(Q, 16);
            this.dmp1 = parseBigInt(DP, 16);
            this.dmq1 = parseBigInt(DQ, 16);
            this.coeff = parseBigInt(C, 16);
        }
        else {
            console.error("Invalid RSA private key");
        }
    };
    // RSAKey.prototype.generate = RSAGenerate;
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generate = function (B, E) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        for (;;) {
            for (;;) {
                this.p = new BigInteger(B - qs, 1, rng);
                if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) {
                    break;
                }
            }
            for (;;) {
                this.q = new BigInteger(qs, 1, rng);
                if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) {
                    break;
                }
            }
            if (this.p.compareTo(this.q) <= 0) {
                var t = this.p;
                this.p = this.q;
                this.q = t;
            }
            var p1 = this.p.subtract(BigInteger.ONE);
            var q1 = this.q.subtract(BigInteger.ONE);
            var phi = p1.multiply(q1);
            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                this.n = this.p.multiply(this.q);
                this.d = ee.modInverse(phi);
                this.dmp1 = this.d.mod(p1);
                this.dmq1 = this.d.mod(q1);
                this.coeff = this.q.modInverse(this.p);
                break;
            }
        }
    };
    // RSAKey.prototype.decrypt = RSADecrypt;
    // Return the PKCS#1 RSA decryption of "ctext".
    // "ctext" is an even-length hex string and the output is a plain string.
    RSAKey.prototype.decrypt = function (ctext) {
        var c = parseBigInt(ctext, 16);
        var m = this.doPrivate(c);
        if (m == null) {
            return null;
        }
        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
    };
    // Generate a new random private key B bits long, using public expt E
    RSAKey.prototype.generateAsync = function (B, E, callback) {
        var rng = new SecureRandom();
        var qs = B >> 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        // These functions have non-descript names because they were originally for(;;) loops.
        // I don't know about cryptography to give them better names than loop1-4.
        var loop1 = function () {
            var loop4 = function () {
                if (rsa.p.compareTo(rsa.q) <= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () { callback(); }, 0); // escape
                }
                else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function () {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        }
                        else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function () {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        }
                        else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.sign = function (text, digestMethod, digestName) {
        var header = getDigestHeader(digestName);
        var digest = header + digestMethod(text).toString();
        var m = pkcs1pad1(digest, this.n.bitLength() / 4);
        if (m == null) {
            return null;
        }
        var c = this.doPrivate(m);
        if (c == null) {
            return null;
        }
        var h = c.toString(16);
        if ((h.length & 1) == 0) {
            return h;
        }
        else {
            return "0" + h;
        }
    };
    RSAKey.prototype.verify = function (text, signature, digestMethod) {
        var c = parseBigInt(signature, 16);
        var m = this.doPublic(c);
        if (m == null) {
            return null;
        }
        var unpadded = m.toString(16).replace(/^1f+00/, "");
        var digest = removeDigestHeader(unpadded);
        return digest == digestMethod(text).toString();
    };
    return RSAKey;
}());
// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i < b.length && b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i >= b.length) {
            return null;
        }
    }
    var ret = "";
    while (++i < b.length) {
        var c = b[i] & 255;
        if (c < 128) { // utf-8 decode
            ret += String.fromCharCode(c);
        }
        else if ((c > 191) && (c < 224)) {
            ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
            ++i;
        }
        else {
            ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
            i += 2;
        }
    }
    return ret;
}
// https://tools.ietf.org/html/rfc3447#page-43
var DIGEST_HEADERS = {
    md2: "3020300c06082a864886f70d020205000410",
    md5: "3020300c06082a864886f70d020505000410",
    sha1: "3021300906052b0e03021a05000414",
    sha224: "302d300d06096086480165030402040500041c",
    sha256: "3031300d060960864801650304020105000420",
    sha384: "3041300d060960864801650304020205000430",
    sha512: "3051300d060960864801650304020305000440",
    ripemd160: "3021300906052b2403020105000414"
};
function getDigestHeader(name) {
    return DIGEST_HEADERS[name] || "";
}
function removeDigestHeader(str) {
    for (var name_1 in DIGEST_HEADERS) {
        if (DIGEST_HEADERS.hasOwnProperty(name_1)) {
            var header = DIGEST_HEADERS[name_1];
            var len = header.length;
            if (str.substr(0, len) == header) {
                return str.substr(len);
            }
        }
    }
    return str;
}
// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
// function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
// }
// public
// RSAKey.prototype.encrypt_b64 = RSAEncryptB64;

/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
var YAHOO = {};
YAHOO.lang = {
    /**
     * Utility to set up the prototype, constructor and superclass properties to
     * support an inheritance strategy that can chain constructors and methods.
     * Static members will not be inherited.
     *
     * @method extend
     * @static
     * @param {Function} subc   the object to modify
     * @param {Function} superc the object to inherit
     * @param {Object} overrides  additional properties/methods to add to the
     *                              subclass prototype.  These will override the
     *                              matching items obtained from the superclass
     *                              if present.
     */
    extend: function (subc, superc, overrides) {
        if (!superc || !subc) {
            throw new Error("YAHOO.lang.extend failed, please check that " +
                "all dependencies are included.");
        }
        var F = function () { };
        F.prototype = superc.prototype;
        subc.prototype = new F();
        subc.prototype.constructor = subc;
        subc.superclass = superc.prototype;
        if (superc.prototype.constructor == Object.prototype.constructor) {
            superc.prototype.constructor = superc;
        }
        if (overrides) {
            var i;
            for (i in overrides) {
                subc.prototype[i] = overrides[i];
            }
            /*
             * IE will not enumerate native functions in a derived object even if the
             * function was overridden.  This is a workaround for specific functions
             * we care about on the Object prototype.
             * @property _IEEnumFix
             * @param {Function} r  the object to receive the augmentation
             * @param {Function} s  the object that supplies the properties to augment
             * @static
             * @private
             */
            var _IEEnumFix = function () { }, ADD = ["toString", "valueOf"];
            try {
                if (/MSIE/.test(navigator.userAgent)) {
                    _IEEnumFix = function (r, s) {
                        for (i = 0; i < ADD.length; i = i + 1) {
                            var fname = ADD[i], f = s[fname];
                            if (typeof f === 'function' && f != Object.prototype[fname]) {
                                r[fname] = f;
                            }
                        }
                    };
                }
            }
            catch (ex) { }
            _IEEnumFix(subc.prototype, overrides);
        }
    }
};

/* asn1-1.0.13.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
/**
 * @fileOverview
 * @name asn1-1.0.js
 * @author Kenji Urushima kenji.urushima@gmail.com
 * @version asn1 1.0.13 (2017-Jun-02)
 * @since jsrsasign 2.1
 * @license <a href="https://kjur.github.io/jsrsasign/license/">MIT License</a>
 */
/**
 * kjur's class library name space
 * <p>
 * This name space provides following name spaces:
 * <ul>
 * <li>{@link KJUR.asn1} - ASN.1 primitive hexadecimal encoder</li>
 * <li>{@link KJUR.asn1.x509} - ASN.1 structure for X.509 certificate and CRL</li>
 * <li>{@link KJUR.crypto} - Java Cryptographic Extension(JCE) style MessageDigest/Signature
 * class and utilities</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace. This caused by a bug of jsdoc2.
 * @name KJUR
 * @namespace kjur's class library name space
 */
var KJUR = {};
/**
 * kjur's ASN.1 class library name space
 * <p>
 * This is ITU-T X.690 ASN.1 DER encoder class library and
 * class structure and methods is very similar to
 * org.bouncycastle.asn1 package of
 * well known BouncyCaslte Cryptography Library.
 * <h4>PROVIDING ASN.1 PRIMITIVES</h4>
 * Here are ASN.1 DER primitive classes.
 * <ul>
 * <li>0x01 {@link KJUR.asn1.DERBoolean}</li>
 * <li>0x02 {@link KJUR.asn1.DERInteger}</li>
 * <li>0x03 {@link KJUR.asn1.DERBitString}</li>
 * <li>0x04 {@link KJUR.asn1.DEROctetString}</li>
 * <li>0x05 {@link KJUR.asn1.DERNull}</li>
 * <li>0x06 {@link KJUR.asn1.DERObjectIdentifier}</li>
 * <li>0x0a {@link KJUR.asn1.DEREnumerated}</li>
 * <li>0x0c {@link KJUR.asn1.DERUTF8String}</li>
 * <li>0x12 {@link KJUR.asn1.DERNumericString}</li>
 * <li>0x13 {@link KJUR.asn1.DERPrintableString}</li>
 * <li>0x14 {@link KJUR.asn1.DERTeletexString}</li>
 * <li>0x16 {@link KJUR.asn1.DERIA5String}</li>
 * <li>0x17 {@link KJUR.asn1.DERUTCTime}</li>
 * <li>0x18 {@link KJUR.asn1.DERGeneralizedTime}</li>
 * <li>0x30 {@link KJUR.asn1.DERSequence}</li>
 * <li>0x31 {@link KJUR.asn1.DERSet}</li>
 * </ul>
 * <h4>OTHER ASN.1 CLASSES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.ASN1Object}</li>
 * <li>{@link KJUR.asn1.DERAbstractString}</li>
 * <li>{@link KJUR.asn1.DERAbstractTime}</li>
 * <li>{@link KJUR.asn1.DERAbstractStructured}</li>
 * <li>{@link KJUR.asn1.DERTaggedObject}</li>
 * </ul>
 * <h4>SUB NAME SPACES</h4>
 * <ul>
 * <li>{@link KJUR.asn1.cades} - CAdES long term signature format</li>
 * <li>{@link KJUR.asn1.cms} - Cryptographic Message Syntax</li>
 * <li>{@link KJUR.asn1.csr} - Certificate Signing Request (CSR/PKCS#10)</li>
 * <li>{@link KJUR.asn1.tsp} - RFC 3161 Timestamping Protocol Format</li>
 * <li>{@link KJUR.asn1.x509} - RFC 5280 X.509 certificate and CRL</li>
 * </ul>
 * </p>
 * NOTE: Please ignore method summary and document of this namespace.
 * This caused by a bug of jsdoc2.
 * @name KJUR.asn1
 * @namespace
 */
if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1)
    KJUR.asn1 = {};
/**
 * ASN1 utilities class
 * @name KJUR.asn1.ASN1Util
 * @class ASN1 utilities class
 * @since asn1 1.0.2
 */
KJUR.asn1.ASN1Util = new function () {
    this.integerToByteHex = function (i) {
        var h = i.toString(16);
        if ((h.length % 2) == 1)
            h = '0' + h;
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != '-') {
            if (h.length % 2 == 1) {
                h = '0' + h;
            }
            else {
                if (!h.match(/^[0-7]/)) {
                    h = '00' + h;
                }
            }
        }
        else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            }
            else {
                if (!h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = '';
            for (var i = 0; i < xorLen; i++) {
                hMask += 'f';
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, '');
        }
        return h;
    };
    /**
     * get PEM string from hexadecimal data and header string
     * @name getPEMStringFromHex
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {String} dataHex hexadecimal string of PEM body
     * @param {String} pemHeader PEM header string (ex. 'RSA PRIVATE KEY')
     * @return {String} PEM formatted string of input data
     * @description
     * This method converts a hexadecimal string to a PEM string with
     * a specified header. Its line break will be CRLF("\r\n").
     * @example
     * var pem  = KJUR.asn1.ASN1Util.getPEMStringFromHex('616161', 'RSA PRIVATE KEY');
     * // value of pem will be:
     * -----BEGIN PRIVATE KEY-----
     * YWFh
     * -----END PRIVATE KEY-----
     */
    this.getPEMStringFromHex = function (dataHex, pemHeader) {
        return hextopem(dataHex, pemHeader);
    };
    /**
     * generate ASN1Object specifed by JSON parameters
     * @name newObject
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return {KJUR.asn1.ASN1Object} generated object
     * @since asn1 1.0.3
     * @description
     * generate any ASN1Object specified by JSON param
     * including ASN.1 primitive or structured.
     * Generally 'param' can be described as follows:
     * <blockquote>
     * {TYPE-OF-ASNOBJ: ASN1OBJ-PARAMETER}
     * </blockquote>
     * 'TYPE-OF-ASN1OBJ' can be one of following symbols:
     * <ul>
     * <li>'bool' - DERBoolean</li>
     * <li>'int' - DERInteger</li>
     * <li>'bitstr' - DERBitString</li>
     * <li>'octstr' - DEROctetString</li>
     * <li>'null' - DERNull</li>
     * <li>'oid' - DERObjectIdentifier</li>
     * <li>'enum' - DEREnumerated</li>
     * <li>'utf8str' - DERUTF8String</li>
     * <li>'numstr' - DERNumericString</li>
     * <li>'prnstr' - DERPrintableString</li>
     * <li>'telstr' - DERTeletexString</li>
     * <li>'ia5str' - DERIA5String</li>
     * <li>'utctime' - DERUTCTime</li>
     * <li>'gentime' - DERGeneralizedTime</li>
     * <li>'seq' - DERSequence</li>
     * <li>'set' - DERSet</li>
     * <li>'tag' - DERTaggedObject</li>
     * </ul>
     * @example
     * newObject({'prnstr': 'aaa'});
     * newObject({'seq': [{'int': 3}, {'prnstr': 'aaa'}]})
     * // ASN.1 Tagged Object
     * newObject({'tag': {'tag': 'a1',
     *                    'explicit': true,
     *                    'obj': {'seq': [{'int': 3}, {'prnstr': 'aaa'}]}}});
     * // more simple representation of ASN.1 Tagged Object
     * newObject({'tag': ['a1',
     *                    true,
     *                    {'seq': [
     *                      {'int': 3},
     *                      {'prnstr': 'aaa'}]}
     *                   ]});
     */
    this.newObject = function (param) {
        var _KJUR = KJUR, _KJUR_asn1 = _KJUR.asn1, _DERBoolean = _KJUR_asn1.DERBoolean, _DERInteger = _KJUR_asn1.DERInteger, _DERBitString = _KJUR_asn1.DERBitString, _DEROctetString = _KJUR_asn1.DEROctetString, _DERNull = _KJUR_asn1.DERNull, _DERObjectIdentifier = _KJUR_asn1.DERObjectIdentifier, _DEREnumerated = _KJUR_asn1.DEREnumerated, _DERUTF8String = _KJUR_asn1.DERUTF8String, _DERNumericString = _KJUR_asn1.DERNumericString, _DERPrintableString = _KJUR_asn1.DERPrintableString, _DERTeletexString = _KJUR_asn1.DERTeletexString, _DERIA5String = _KJUR_asn1.DERIA5String, _DERUTCTime = _KJUR_asn1.DERUTCTime, _DERGeneralizedTime = _KJUR_asn1.DERGeneralizedTime, _DERSequence = _KJUR_asn1.DERSequence, _DERSet = _KJUR_asn1.DERSet, _DERTaggedObject = _KJUR_asn1.DERTaggedObject, _newObject = _KJUR_asn1.ASN1Util.newObject;
        var keys = Object.keys(param);
        if (keys.length != 1)
            throw "key of param shall be only one.";
        var key = keys[0];
        if (":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + key + ":") == -1)
            throw "undefined key: " + key;
        if (key == "bool")
            return new _DERBoolean(param[key]);
        if (key == "int")
            return new _DERInteger(param[key]);
        if (key == "bitstr")
            return new _DERBitString(param[key]);
        if (key == "octstr")
            return new _DEROctetString(param[key]);
        if (key == "null")
            return new _DERNull(param[key]);
        if (key == "oid")
            return new _DERObjectIdentifier(param[key]);
        if (key == "enum")
            return new _DEREnumerated(param[key]);
        if (key == "utf8str")
            return new _DERUTF8String(param[key]);
        if (key == "numstr")
            return new _DERNumericString(param[key]);
        if (key == "prnstr")
            return new _DERPrintableString(param[key]);
        if (key == "telstr")
            return new _DERTeletexString(param[key]);
        if (key == "ia5str")
            return new _DERIA5String(param[key]);
        if (key == "utctime")
            return new _DERUTCTime(param[key]);
        if (key == "gentime")
            return new _DERGeneralizedTime(param[key]);
        if (key == "seq") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSequence({ 'array': a });
        }
        if (key == "set") {
            var paramList = param[key];
            var a = [];
            for (var i = 0; i < paramList.length; i++) {
                var asn1Obj = _newObject(paramList[i]);
                a.push(asn1Obj);
            }
            return new _DERSet({ 'array': a });
        }
        if (key == "tag") {
            var tagParam = param[key];
            if (Object.prototype.toString.call(tagParam) === '[object Array]' &&
                tagParam.length == 3) {
                var obj = _newObject(tagParam[2]);
                return new _DERTaggedObject({ tag: tagParam[0],
                    explicit: tagParam[1],
                    obj: obj });
            }
            else {
                var newParam = {};
                if (tagParam.explicit !== undefined)
                    newParam.explicit = tagParam.explicit;
                if (tagParam.tag !== undefined)
                    newParam.tag = tagParam.tag;
                if (tagParam.obj === undefined)
                    throw "obj shall be specified for 'tag'.";
                newParam.obj = _newObject(tagParam.obj);
                return new _DERTaggedObject(newParam);
            }
        }
    };
    /**
     * get encoded hexadecimal string of ASN1Object specifed by JSON parameters
     * @name jsonToASN1HEX
     * @memberOf KJUR.asn1.ASN1Util
     * @function
     * @param {Array} param JSON parameter to generate ASN1Object
     * @return hexadecimal string of ASN1Object
     * @since asn1 1.0.4
     * @description
     * As for ASN.1 object representation of JSON object,
     * please see {@link newObject}.
     * @example
     * jsonToASN1HEX({'prnstr': 'aaa'});
     */
    this.jsonToASN1HEX = function (param) {
        var asn1Obj = this.newObject(param);
        return asn1Obj.getEncodedHex();
    };
};
/**
 * get dot noted oid number string from hexadecimal value of OID
 * @name oidHexToInt
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} hex hexadecimal value of object identifier
 * @return {String} dot noted string of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from hexadecimal string representation of
 * ASN.1 value of object identifier to oid number string.
 * @example
 * KJUR.asn1.ASN1Util.oidHexToInt('550406') &rarr; "2.5.4.6"
 */
KJUR.asn1.ASN1Util.oidHexToInt = function (hex) {
    var s = "";
    var i01 = parseInt(hex.substr(0, 2), 16);
    var i0 = Math.floor(i01 / 40);
    var i1 = i01 % 40;
    var s = i0 + "." + i1;
    var binbuf = "";
    for (var i = 2; i < hex.length; i += 2) {
        var value = parseInt(hex.substr(i, 2), 16);
        var bin = ("00000000" + value.toString(2)).slice(-8);
        binbuf = binbuf + bin.substr(1, 7);
        if (bin.substr(0, 1) == "0") {
            var bi = new BigInteger(binbuf, 2);
            s = s + "." + bi.toString(10);
            binbuf = "";
        }
    }
    return s;
};
/**
 * get hexadecimal value of object identifier from dot noted oid value
 * @name oidIntToHex
 * @memberOf KJUR.asn1.ASN1Util
 * @function
 * @param {String} oidString dot noted string of object identifier
 * @return {String} hexadecimal value of object identifier
 * @since jsrsasign 4.8.3 asn1 1.0.7
 * @description
 * This static method converts from object identifier value string.
 * to hexadecimal string representation of it.
 * @example
 * KJUR.asn1.ASN1Util.oidIntToHex("2.5.4.6") &rarr; "550406"
 */
KJUR.asn1.ASN1Util.oidIntToHex = function (oidString) {
    var itox = function (i) {
        var h = i.toString(16);
        if (h.length == 1)
            h = '0' + h;
        return h;
    };
    var roidtox = function (roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7)
            padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++)
            bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7)
                b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    if (!oidString.match(/^[0-9.]+$/)) {
        throw "malformed oid string: " + oidString;
    }
    var h = '';
    var a = oidString.split('.');
    var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
    h += itox(i0);
    a.splice(0, 2);
    for (var i = 0; i < a.length; i++) {
        h += roidtox(a[i]);
    }
    return h;
};
// ********************************************************************
//  Abstract ASN.1 Classes
// ********************************************************************
// ********************************************************************
/**
 * base class for ASN.1 DER encoder object
 * @name KJUR.asn1.ASN1Object
 * @class base class for ASN.1 DER encoder object
 * @property {Boolean} isModified flag whether internal data was changed
 * @property {String} hTLV hexadecimal string of ASN.1 TLV
 * @property {String} hT hexadecimal string of ASN.1 TLV tag(T)
 * @property {String} hL hexadecimal string of ASN.1 TLV length(L)
 * @property {String} hV hexadecimal string of ASN.1 TLV value(V)
 * @description
 */
KJUR.asn1.ASN1Object = function () {
    var hV = '';
    /**
     * get hexadecimal ASN.1 TLV length(L) bytes from TLV value(V)
     * @name getLengthHexFromValue
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV length(L)
     */
    this.getLengthHexFromValue = function () {
        if (typeof this.hV == "undefined" || this.hV == null) {
            throw "this.hV is null or undefined.";
        }
        if (this.hV.length % 2 == 1) {
            throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = "0" + hN;
        }
        if (n < 128) {
            return hN;
        }
        else {
            var hNlen = hN.length / 2;
            if (hNlen > 15) {
                throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };
    /**
     * get hexadecimal string of ASN.1 TLV bytes
     * @name getEncodedHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV
     */
    this.getEncodedHex = function () {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
            //alert("first time: " + this.hTLV);
        }
        return this.hTLV;
    };
    /**
     * get hexadecimal string of ASN.1 TLV value(V) bytes
     * @name getValueHex
     * @memberOf KJUR.asn1.ASN1Object#
     * @function
     * @return {String} hexadecimal string of ASN.1 TLV value(V) bytes
     */
    this.getValueHex = function () {
        this.getEncodedHex();
        return this.hV;
    };
    this.getFreshValueHex = function () {
        return '';
    };
};
// == BEGIN DERAbstractString ================================================
/**
 * base class for ASN.1 DER string classes
 * @name KJUR.asn1.DERAbstractString
 * @class base class for ASN.1 DER string classes
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @property {String} s internal string of value
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERAbstractString = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @return {String} string value of this string object
     */
    this.getString = function () {
        return this.s;
    };
    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newS value by a string to set
     */
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };
    /**
     * set value by a hexadecimal string
     * @name setStringHex
     * @memberOf KJUR.asn1.DERAbstractString#
     * @function
     * @param {String} newHexString value by a hexadecimal string to set
     */
    this.setStringHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params == "string") {
            this.setString(params);
        }
        else if (typeof params['str'] != "undefined") {
            this.setString(params['str']);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setStringHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
// == END   DERAbstractString ================================================
// == BEGIN DERAbstractTime ==================================================
/**
 * base class for ASN.1 DER Generalized/UTCTime class
 * @name KJUR.asn1.DERAbstractTime
 * @class base class for ASN.1 DER Generalized/UTCTime class
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractTime = function (params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
    // --- PRIVATE METHODS --------------------
    this.localDateToUTC = function (d) {
        utc = d.getTime() + (d.getTimezoneOffset() * 60000);
        var utcDate = new Date(utc);
        return utcDate;
    };
    /*
     * format date string by Data object
     * @name formatDate
     * @memberOf KJUR.asn1.AbstractTime;
     * @param {Date} dateObject
     * @param {string} type 'utc' or 'gen'
     * @param {boolean} withMillis flag for with millisections or not
     * @description
     * 'withMillis' flag is supported from asn1 1.0.6.
     */
    this.formatDate = function (dateObject, type, withMillis) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == 'utc')
            year = year.substr(2, 2);
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        var s = year + month + day + hour + min + sec;
        if (withMillis === true) {
            var millis = d.getMilliseconds();
            if (millis != 0) {
                var sMillis = pad(String(millis), 3);
                sMillis = sMillis.replace(/[0]+$/, "");
                s = s + "." + sMillis;
            }
        }
        return s + "Z";
    };
    this.zeroPadding = function (s, len) {
        if (s.length >= len)
            return s;
        return new Array(len - s.length + 1).join('0') + s;
    };
    // --- PUBLIC METHODS --------------------
    /**
     * get string value of this string object
     * @name getString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @return {String} string value of this time object
     */
    this.getString = function () {
        return this.s;
    };
    /**
     * set value by a string
     * @name setString
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {String} newS value by a string to set such like "130430235959Z"
     */
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(newS);
    };
    /**
     * set value by a Date object
     * @name setByDateValue
     * @memberOf KJUR.asn1.DERAbstractTime#
     * @function
     * @param {Integer} year year of date (ex. 2013)
     * @param {Integer} month month of date between 1 and 12 (ex. 12)
     * @param {Integer} day day of month
     * @param {Integer} hour hours of date
     * @param {Integer} min minutes of date
     * @param {Integer} sec seconds of date
     */
    this.setByDateValue = function (year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
// == END   DERAbstractTime ==================================================
// == BEGIN DERAbstractStructured ============================================
/**
 * base class for ASN.1 DER structured class
 * @name KJUR.asn1.DERAbstractStructured
 * @class base class for ASN.1 DER structured class
 * @property {Array} asn1Array internal array of ASN1Object
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERAbstractStructured = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    /**
     * set value by array of ASN1Object
     * @name setByASN1ObjectArray
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {array} asn1ObjectArray array of ASN1Object to set
     */
    this.setByASN1ObjectArray = function (asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };
    /**
     * append an ASN1Object to internal array
     * @name appendASN1Object
     * @memberOf KJUR.asn1.DERAbstractStructured#
     * @function
     * @param {ASN1Object} asn1Object to add
     */
    this.appendASN1Object = function (asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };
    this.asn1Array = new Array();
    if (typeof params != "undefined") {
        if (typeof params['array'] != "undefined") {
            this.asn1Array = params['array'];
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
// ********************************************************************
//  ASN.1 Object Classes
// ********************************************************************
// ********************************************************************
/**
 * class for ASN.1 DER Boolean
 * @name KJUR.asn1.DERBoolean
 * @class class for ASN.1 DER Boolean
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERBoolean = function () {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = "01";
    this.hTLV = "0101ff";
};
YAHOO.lang.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER Integer
 * @name KJUR.asn1.DERInteger
 * @class class for ASN.1 DER Integer
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>bigint - specify initial ASN.1 value(V) by BigInteger object</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERInteger = function (params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = "02";
    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function (bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };
    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DERInteger
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function (intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };
    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DERInteger#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     * @example
     * new KJUR.asn1.DERInteger(123);
     * new KJUR.asn1.DERInteger({'int': 123});
     * new KJUR.asn1.DERInteger({'hex': '1fad'});
     */
    this.setValueHex = function (newHexString) {
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['bigint'] != "undefined") {
            this.setByBigInteger(params['bigint']);
        }
        else if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        }
        else if (typeof params == "number") {
            this.setByInteger(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER encoded BitString primitive
 * @name KJUR.asn1.DERBitString
 * @class class for ASN.1 DER encoded BitString primitive
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>bin - specify binary string (ex. '10111')</li>
 * <li>array - specify array of boolean (ex. [true,false,true,true])</li>
 * <li>hex - specify hexadecimal string of ASN.1 value(V) including unused bits</li>
 * <li>obj - specify {@link KJUR.asn1.ASN1Util.newObject}
 * argument for "BitString encapsulates" structure.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: 'obj' parameter have been supported since
 * asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).<br/>
 * @example
 * // default constructor
 * o = new KJUR.asn1.DERBitString();
 * // initialize with binary string
 * o = new KJUR.asn1.DERBitString({bin: "1011"});
 * // initialize with boolean array
 * o = new KJUR.asn1.DERBitString({array: [true,false,true,true]});
 * // initialize with hexadecimal string (04 is unused bits)
 * o = new KJUR.asn1.DEROctetString({hex: "04bac0"});
 * // initialize with ASN1Util.newObject argument for encapsulated
 * o = new KJUR.asn1.DERBitString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // BIT STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DERBitString = function (params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = "00" + o.getEncodedHex();
    }
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = "03";
    /**
     * set ASN.1 value(V) by a hexadecimal string including unused bits
     * @name setHexValueIncludingUnusedBits
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} newHexStringIncludingUnusedBits
     */
    this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };
    /**
     * set ASN.1 value(V) by unused bit and hexadecimal string of value
     * @name setUnusedBitsAndHexValue
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {Integer} unusedBits
     * @param {String} hValue
     */
    this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {
        if (unusedBits < 0 || 7 < unusedBits) {
            throw "unused bits shall be from 0 to 7: u = " + unusedBits;
        }
        var hUnusedBits = "0" + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };
    /**
     * set ASN.1 DER BitString by binary string<br/>
     * @name setByBinaryString
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {String} binaryString binary value string (i.e. '10111')
     * @description
     * Its unused bits will be calculated automatically by length of
     * 'binaryValue'. <br/>
     * NOTE: Trailing zeros '0' will be ignored.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray("01011");
     */
    this.setByBinaryString = function (binaryString) {
        binaryString = binaryString.replace(/0+$/, '');
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8)
            unusedBits = 0;
        for (var i = 0; i <= unusedBits; i++) {
            binaryString += '0';
        }
        var h = '';
        for (var i = 0; i < binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1)
                x = '0' + x;
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = '0' + unusedBits + h;
    };
    /**
     * set ASN.1 TLV value(V) by an array of boolean<br/>
     * @name setByBooleanArray
     * @memberOf KJUR.asn1.DERBitString#
     * @function
     * @param {array} booleanArray array of boolean (ex. [true, false, true])
     * @description
     * NOTE: Trailing falses will be ignored in the ASN.1 DER Object.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.setByBooleanArray([false, true, false, true, true]);
     */
    this.setByBooleanArray = function (booleanArray) {
        var s = '';
        for (var i = 0; i < booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += '1';
            }
            else {
                s += '0';
            }
        }
        this.setByBinaryString(s);
    };
    /**
     * generate an array of falses with specified length<br/>
     * @name newFalseArray
     * @memberOf KJUR.asn1.DERBitString
     * @function
     * @param {Integer} nLength length of array to generate
     * @return {array} array of boolean falses
     * @description
     * This static method may be useful to initialize boolean array.
     * @example
     * o = new KJUR.asn1.DERBitString();
     * o.newFalseArray(3) &rarr; [false, false, false]
     */
    this.newFalseArray = function (nLength) {
        var a = new Array(nLength);
        for (var i = 0; i < nLength; i++) {
            a[i] = false;
        }
        return a;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params == "string" && params.toLowerCase().match(/^[0-9a-f]+$/)) {
            this.setHexValueIncludingUnusedBits(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setHexValueIncludingUnusedBits(params['hex']);
        }
        else if (typeof params['bin'] != "undefined") {
            this.setByBinaryString(params['bin']);
        }
        else if (typeof params['array'] != "undefined") {
            this.setByBooleanArray(params['array']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER OctetString<br/>
 * @name KJUR.asn1.DEROctetString
 * @class class for ASN.1 DER OctetString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * This class provides ASN.1 OctetString simple type.<br/>
 * Supported "params" attributes are:
 * <ul>
 * <li>str - to set a string as a value</li>
 * <li>hex - to set a hexadecimal string as a value</li>
 * <li>obj - to set a encapsulated ASN.1 value by JSON object
 * which is defined in {@link KJUR.asn1.ASN1Util.newObject}</li>
 * </ul>
 * NOTE: A parameter 'obj' have been supported
 * for "OCTET STRING, encapsulates" structure.
 * since asn1 1.0.11, jsrsasign 6.1.1 (2016-Sep-25).
 * @see KJUR.asn1.DERAbstractString - superclass
 * @example
 * // default constructor
 * o = new KJUR.asn1.DEROctetString();
 * // initialize with string
 * o = new KJUR.asn1.DEROctetString({str: "aaa"});
 * // initialize with hexadecimal string
 * o = new KJUR.asn1.DEROctetString({hex: "616161"});
 * // initialize with ASN1Util.newObject argument
 * o = new KJUR.asn1.DEROctetString({obj: {seq: [{int: 3}, {prnstr: 'aaa'}]}});
 * // above generates a ASN.1 data like this:
 * // OCTET STRING, encapsulates {
 * //   SEQUENCE {
 * //     INTEGER 3
 * //     PrintableString 'aaa'
 * //     }
 * //   }
 */
KJUR.asn1.DEROctetString = function (params) {
    if (params !== undefined && typeof params.obj !== "undefined") {
        var o = KJUR.asn1.ASN1Util.newObject(params.obj);
        params.hex = o.getEncodedHex();
    }
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = "04";
};
YAHOO.lang.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER Null
 * @name KJUR.asn1.DERNull
 * @class class for ASN.1 DER Null
 * @extends KJUR.asn1.ASN1Object
 * @description
 * @see KJUR.asn1.ASN1Object - superclass
 */
KJUR.asn1.DERNull = function () {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = "05";
    this.hTLV = "0500";
};
YAHOO.lang.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER ObjectIdentifier
 * @name KJUR.asn1.DERObjectIdentifier
 * @class class for ASN.1 DER ObjectIdentifier
 * @param {Array} params associative array of parameters (ex. {'oid': '2.5.4.5'})
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>oid - specify initial ASN.1 value(V) by a oid string (ex. 2.5.4.13)</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERObjectIdentifier = function (params) {
    var itox = function (i) {
        var h = i.toString(16);
        if (h.length == 1)
            h = '0' + h;
        return h;
    };
    var roidtox = function (roid) {
        var h = '';
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7)
            padLen = 0;
        var bPad = '';
        for (var i = 0; i < padLen; i++)
            bPad += '0';
        b = bPad + b;
        for (var i = 0; i < b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7)
                b8 = '1' + b8;
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = "06";
    /**
     * set value by a hexadecimal string
     * @name setValueHex
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} newHexString hexadecimal value of OID bytes
     */
    this.setValueHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    /**
     * set value by a OID string<br/>
     * @name setValueOidString
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidString OID string (ex. 2.5.4.13)
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueOidString("2.5.4.13");
     */
    this.setValueOidString = function (oidString) {
        if (!oidString.match(/^[0-9.]+$/)) {
            throw "malformed oid string: " + oidString;
        }
        var h = '';
        var a = oidString.split('.');
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i < a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };
    /**
     * set value by a OID name
     * @name setValueName
     * @memberOf KJUR.asn1.DERObjectIdentifier#
     * @function
     * @param {String} oidName OID name (ex. 'serverAuth')
     * @since 1.0.1
     * @description
     * OID name shall be defined in 'KJUR.asn1.x509.OID.name2oidList'.
     * Otherwise raise error.
     * @example
     * o = new KJUR.asn1.DERObjectIdentifier();
     * o.setValueName("serverAuth");
     */
    this.setValueName = function (oidName) {
        var oid = KJUR.asn1.x509.OID.name2oid(oidName);
        if (oid !== '') {
            this.setValueOidString(oid);
        }
        else {
            throw "DERObjectIdentifier oidName undefined: " + oidName;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (params !== undefined) {
        if (typeof params === "string") {
            if (params.match(/^[0-2].[0-9.]+$/)) {
                this.setValueOidString(params);
            }
            else {
                this.setValueName(params);
            }
        }
        else if (params.oid !== undefined) {
            this.setValueOidString(params.oid);
        }
        else if (params.hex !== undefined) {
            this.setValueHex(params.hex);
        }
        else if (params.name !== undefined) {
            this.setValueName(params.name);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER Enumerated
 * @name KJUR.asn1.DEREnumerated
 * @class class for ASN.1 DER Enumerated
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>int - specify initial ASN.1 value(V) by integer value</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * @example
 * new KJUR.asn1.DEREnumerated(123);
 * new KJUR.asn1.DEREnumerated({int: 123});
 * new KJUR.asn1.DEREnumerated({hex: '1fad'});
 */
KJUR.asn1.DEREnumerated = function (params) {
    KJUR.asn1.DEREnumerated.superclass.constructor.call(this);
    this.hT = "0a";
    /**
     * set value by Tom Wu's BigInteger object
     * @name setByBigInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {BigInteger} bigIntegerValue to set
     */
    this.setByBigInteger = function (bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };
    /**
     * set value by integer value
     * @name setByInteger
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {Integer} integer value to set
     */
    this.setByInteger = function (intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };
    /**
     * set value by integer value
     * @name setValueHex
     * @memberOf KJUR.asn1.DEREnumerated#
     * @function
     * @param {String} hexadecimal string of integer value
     * @description
     * <br/>
     * NOTE: Value shall be represented by minimum octet length of
     * two's complement representation.
     */
    this.setValueHex = function (newHexString) {
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['int'] != "undefined") {
            this.setByInteger(params['int']);
        }
        else if (typeof params == "number") {
            this.setByInteger(params);
        }
        else if (typeof params['hex'] != "undefined") {
            this.setValueHex(params['hex']);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DEREnumerated, KJUR.asn1.ASN1Object);
// ********************************************************************
/**
 * class for ASN.1 DER UTF8String
 * @name KJUR.asn1.DERUTF8String
 * @class class for ASN.1 DER UTF8String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERUTF8String = function (params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = "0c";
};
YAHOO.lang.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER NumericString
 * @name KJUR.asn1.DERNumericString
 * @class class for ASN.1 DER NumericString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERNumericString = function (params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = "12";
};
YAHOO.lang.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER PrintableString
 * @name KJUR.asn1.DERPrintableString
 * @class class for ASN.1 DER PrintableString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERPrintableString = function (params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = "13";
};
YAHOO.lang.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER TeletexString
 * @name KJUR.asn1.DERTeletexString
 * @class class for ASN.1 DER TeletexString
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERTeletexString = function (params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = "14";
};
YAHOO.lang.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER IA5String
 * @name KJUR.asn1.DERIA5String
 * @class class for ASN.1 DER IA5String
 * @param {Array} params associative array of parameters (ex. {'str': 'aaa'})
 * @extends KJUR.asn1.DERAbstractString
 * @description
 * @see KJUR.asn1.DERAbstractString - superclass
 */
KJUR.asn1.DERIA5String = function (params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = "16";
};
YAHOO.lang.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
// ********************************************************************
/**
 * class for ASN.1 DER UTCTime
 * @name KJUR.asn1.DERUTCTime
 * @class class for ASN.1 DER UTCTime
 * @param {Array} params associative array of parameters (ex. {'str': '130430235959Z'})
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 * <h4>EXAMPLES</h4>
 * @example
 * d1 = new KJUR.asn1.DERUTCTime();
 * d1.setString('130430125959Z');
 *
 * d2 = new KJUR.asn1.DERUTCTime({'str': '130430125959Z'});
 * d3 = new KJUR.asn1.DERUTCTime({'date': new Date(Date.UTC(2015, 0, 31, 0, 0, 0, 0))});
 * d4 = new KJUR.asn1.DERUTCTime('130430125959Z');
 */
KJUR.asn1.DERUTCTime = function (params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = "17";
    /**
     * set value by a Date object<br/>
     * @name setByDate
     * @memberOf KJUR.asn1.DERUTCTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * o = new KJUR.asn1.DERUTCTime();
     * o.setByDate(new Date("2016/12/31"));
     */
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'utc');
        this.hV = stohex(this.s);
    };
    this.getFreshValueHex = function () {
        if (typeof this.date == "undefined" && typeof this.s == "undefined") {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'utc');
            this.hV = stohex(this.s);
        }
        return this.hV;
    };
    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        }
        else if (typeof params == "string" && params.match(/^[0-9]{12}Z$/)) {
            this.setString(params);
        }
        else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        }
        else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
// ********************************************************************
/**
 * class for ASN.1 DER GeneralizedTime
 * @name KJUR.asn1.DERGeneralizedTime
 * @class class for ASN.1 DER GeneralizedTime
 * @param {Array} params associative array of parameters (ex. {'str': '20130430235959Z'})
 * @property {Boolean} withMillis flag to show milliseconds or not
 * @extends KJUR.asn1.DERAbstractTime
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>str - specify initial ASN.1 value(V) by a string (ex.'20130430235959Z')</li>
 * <li>hex - specify initial ASN.1 value(V) by a hexadecimal string</li>
 * <li>date - specify Date object.</li>
 * <li>millis - specify flag to show milliseconds (from 1.0.6)</li>
 * </ul>
 * NOTE1: 'params' can be omitted.
 * NOTE2: 'withMillis' property is supported from asn1 1.0.6.
 */
KJUR.asn1.DERGeneralizedTime = function (params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = "18";
    this.withMillis = false;
    /**
     * set value by a Date object
     * @name setByDate
     * @memberOf KJUR.asn1.DERGeneralizedTime#
     * @function
     * @param {Date} dateObject Date object to set ASN.1 value(V)
     * @example
     * When you specify UTC time, use 'Date.UTC' method like this:<br/>
     * o1 = new DERUTCTime();
     * o1.setByDate(date);
     *
     * date = new Date(Date.UTC(2015, 0, 31, 23, 59, 59, 0)); #2015JAN31 23:59:59
     */
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, 'gen', this.withMillis);
        this.hV = stohex(this.s);
    };
    this.getFreshValueHex = function () {
        if (this.date === undefined && this.s === undefined) {
            this.date = new Date();
            this.s = this.formatDate(this.date, 'gen', this.withMillis);
            this.hV = stohex(this.s);
        }
        return this.hV;
    };
    if (params !== undefined) {
        if (params.str !== undefined) {
            this.setString(params.str);
        }
        else if (typeof params == "string" && params.match(/^[0-9]{14}Z$/)) {
            this.setString(params);
        }
        else if (params.hex !== undefined) {
            this.setStringHex(params.hex);
        }
        else if (params.date !== undefined) {
            this.setByDate(params.date);
        }
        if (params.millis === true) {
            this.withMillis = true;
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
// ********************************************************************
/**
 * class for ASN.1 DER Sequence
 * @name KJUR.asn1.DERSequence
 * @class class for ASN.1 DER Sequence
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * </ul>
 * NOTE: 'params' can be omitted.
 */
KJUR.asn1.DERSequence = function (params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = "30";
    this.getFreshValueHex = function () {
        var h = '';
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
YAHOO.lang.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
// ********************************************************************
/**
 * class for ASN.1 DER Set
 * @name KJUR.asn1.DERSet
 * @class class for ASN.1 DER Set
 * @extends KJUR.asn1.DERAbstractStructured
 * @description
 * <br/>
 * As for argument 'params' for constructor, you can specify one of
 * following properties:
 * <ul>
 * <li>array - specify array of ASN1Object to set elements of content</li>
 * <li>sortflag - flag for sort (default: true). ASN.1 BER is not sorted in 'SET OF'.</li>
 * </ul>
 * NOTE1: 'params' can be omitted.<br/>
 * NOTE2: sortflag is supported since 1.0.5.
 */
KJUR.asn1.DERSet = function (params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = "31";
    this.sortFlag = true; // item shall be sorted only in ASN.1 DER
    this.getFreshValueHex = function () {
        var a = new Array();
        for (var i = 0; i < this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        if (this.sortFlag == true)
            a.sort();
        this.hV = a.join('');
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params.sortflag != "undefined" &&
            params.sortflag == false)
            this.sortFlag = false;
    }
};
YAHOO.lang.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
// ********************************************************************
/**
 * class for ASN.1 DER TaggedObject
 * @name KJUR.asn1.DERTaggedObject
 * @class class for ASN.1 DER TaggedObject
 * @extends KJUR.asn1.ASN1Object
 * @description
 * <br/>
 * Parameter 'tagNoNex' is ASN.1 tag(T) value for this object.
 * For example, if you find '[1]' tag in a ASN.1 dump,
 * 'tagNoHex' will be 'a1'.
 * <br/>
 * As for optional argument 'params' for constructor, you can specify *ANY* of
 * following properties:
 * <ul>
 * <li>explicit - specify true if this is explicit tag otherwise false
 *     (default is 'true').</li>
 * <li>tag - specify tag (default is 'a0' which means [0])</li>
 * <li>obj - specify ASN1Object which is tagged</li>
 * </ul>
 * @example
 * d1 = new KJUR.asn1.DERUTF8String({'str':'a'});
 * d2 = new KJUR.asn1.DERTaggedObject({'obj': d1});
 * hex = d2.getEncodedHex();
 */
KJUR.asn1.DERTaggedObject = function (params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = "a0";
    this.hV = '';
    this.isExplicit = true;
    this.asn1Object = null;
    /**
     * set value by an ASN1Object
     * @name setString
     * @memberOf KJUR.asn1.DERTaggedObject#
     * @function
     * @param {Boolean} isExplicitFlag flag for explicit/implicit tag
     * @param {Integer} tagNoHex hexadecimal string of ASN.1 tag
     * @param {ASN1Object} asn1Object ASN.1 to encapsulate
     */
    this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        }
        else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != "undefined") {
        if (typeof params['tag'] != "undefined") {
            this.hT = params['tag'];
        }
        if (typeof params['explicit'] != "undefined") {
            this.isExplicit = params['explicit'];
        }
        if (typeof params['obj'] != "undefined") {
            this.asn1Object = params['obj'];
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
YAHOO.lang.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Create a new JSEncryptRSAKey that extends Tom Wu's RSA key object.
 * This object is just a decorator for parsing the key parameter
 * @param {string|Object} key - The key in string format, or an object containing
 * the parameters needed to build a RSAKey object.
 * @constructor
 */
var JSEncryptRSAKey = /** @class */ (function (_super) {
    __extends(JSEncryptRSAKey, _super);
    function JSEncryptRSAKey(key) {
        var _this = _super.call(this) || this;
        // Call the super constructor.
        //  RSAKey.call(this);
        // If a key key was provided.
        if (key) {
            // If this is a string...
            if (typeof key === "string") {
                _this.parseKey(key);
            }
            else if (JSEncryptRSAKey.hasPrivateKeyProperty(key) ||
                JSEncryptRSAKey.hasPublicKeyProperty(key)) {
                // Set the values for the key.
                _this.parsePropertiesFrom(key);
            }
        }
        return _this;
    }
    /**
     * Method to parse a pem encoded string containing both a public or private key.
     * The method will translate the pem encoded string in a der encoded string and
     * will parse private key and public key parameters. This method accepts public key
     * in the rsaencryption pkcs #1 format (oid: 1.2.840.113549.1.1.1).
     *
     * @todo Check how many rsa formats use the same format of pkcs #1.
     *
     * The format is defined as:
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * it's possible to examine the structure of the keys obtained from openssl using
     * an asn.1 dumper as the one used here to parse the components: http://lapo.it/asn1js/
     * @argument {string} pem the pem encoded string, can include the BEGIN/END header/footer
     * @private
     */
    JSEncryptRSAKey.prototype.parseKey = function (pem) {
        try {
            var modulus = 0;
            var public_exponent = 0;
            var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
            var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
            var asn1 = ASN1.decode(der);
            // Fixes a bug with OpenSSL 1.0+ private keys
            if (asn1.sub.length === 3) {
                asn1 = asn1.sub[2].sub[0];
            }
            if (asn1.sub.length === 9) {
                // Parse the private key.
                modulus = asn1.sub[1].getHexStringValue(); // bigint
                this.n = parseBigInt(modulus, 16);
                public_exponent = asn1.sub[2].getHexStringValue(); // int
                this.e = parseInt(public_exponent, 16);
                var private_exponent = asn1.sub[3].getHexStringValue(); // bigint
                this.d = parseBigInt(private_exponent, 16);
                var prime1 = asn1.sub[4].getHexStringValue(); // bigint
                this.p = parseBigInt(prime1, 16);
                var prime2 = asn1.sub[5].getHexStringValue(); // bigint
                this.q = parseBigInt(prime2, 16);
                var exponent1 = asn1.sub[6].getHexStringValue(); // bigint
                this.dmp1 = parseBigInt(exponent1, 16);
                var exponent2 = asn1.sub[7].getHexStringValue(); // bigint
                this.dmq1 = parseBigInt(exponent2, 16);
                var coefficient = asn1.sub[8].getHexStringValue(); // bigint
                this.coeff = parseBigInt(coefficient, 16);
            }
            else if (asn1.sub.length === 2) {
                if (asn1.sub[0].sub) {
                    // Parse ASN.1 SubjectPublicKeyInfo type as defined by X.509
                    var bit_string = asn1.sub[1];
                    var sequence = bit_string.sub[0];
                    modulus = sequence.sub[0].getHexStringValue();
                    this.n = parseBigInt(modulus, 16);
                    public_exponent = sequence.sub[1].getHexStringValue();
                    this.e = parseInt(public_exponent, 16);
                }
                else {
                    // Parse ASN.1 RSAPublicKey type as defined by PKCS #1
                    modulus = asn1.sub[0].getHexStringValue();
                    this.n = parseBigInt(modulus, 16);
                    public_exponent = asn1.sub[1].getHexStringValue();
                    this.e = parseInt(public_exponent, 16);
                }
            }
            else {
                return false;
            }
            return true;
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa key.
     *
     * The translation follow the ASN.1 notation :
     * RSAPrivateKey ::= SEQUENCE {
     *   version           Version,
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER,  -- e
     *   privateExponent   INTEGER,  -- d
     *   prime1            INTEGER,  -- p
     *   prime2            INTEGER,  -- q
     *   exponent1         INTEGER,  -- d mod (p1)
     *   exponent2         INTEGER,  -- d mod (q-1)
     *   coefficient       INTEGER,  -- (inverse of q) mod p
     * }
     * @returns {string}  DER Encoded String representing the rsa private key
     * @private
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKey = function () {
        var options = {
            array: [
                new KJUR.asn1.DERInteger({ int: 0 }),
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
                new KJUR.asn1.DERInteger({ bigint: this.d }),
                new KJUR.asn1.DERInteger({ bigint: this.p }),
                new KJUR.asn1.DERInteger({ bigint: this.q }),
                new KJUR.asn1.DERInteger({ bigint: this.dmp1 }),
                new KJUR.asn1.DERInteger({ bigint: this.dmq1 }),
                new KJUR.asn1.DERInteger({ bigint: this.coeff }),
            ],
        };
        var seq = new KJUR.asn1.DERSequence(options);
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateBaseKeyB64 = function () {
        return hex2b64(this.getPrivateBaseKey());
    };
    /**
     * Translate rsa parameters in a hex encoded string representing the rsa public key.
     * The representation follow the ASN.1 notation :
     * PublicKeyInfo ::= SEQUENCE {
     *   algorithm       AlgorithmIdentifier,
     *   PublicKey       BIT STRING
     * }
     * Where AlgorithmIdentifier is:
     * AlgorithmIdentifier ::= SEQUENCE {
     *   algorithm       OBJECT IDENTIFIER,     the OID of the enc algorithm
     *   parameters      ANY DEFINED BY algorithm OPTIONAL (NULL for PKCS #1)
     * }
     * and PublicKey is a SEQUENCE encapsulated in a BIT STRING
     * RSAPublicKey ::= SEQUENCE {
     *   modulus           INTEGER,  -- n
     *   publicExponent    INTEGER   -- e
     * }
     * @returns {string} DER Encoded String representing the rsa public key
     * @private
     */
    JSEncryptRSAKey.prototype.getPublicBaseKey = function () {
        var first_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERObjectIdentifier({ oid: "1.2.840.113549.1.1.1" }),
                new KJUR.asn1.DERNull(),
            ],
        });
        var second_sequence = new KJUR.asn1.DERSequence({
            array: [
                new KJUR.asn1.DERInteger({ bigint: this.n }),
                new KJUR.asn1.DERInteger({ int: this.e }),
            ],
        });
        var bit_string = new KJUR.asn1.DERBitString({
            hex: "00" + second_sequence.getEncodedHex(),
        });
        var seq = new KJUR.asn1.DERSequence({
            array: [first_sequence, bit_string],
        });
        return seq.getEncodedHex();
    };
    /**
     * base64 (pem) encoded version of the DER encoded representation
     * @returns {string} pem encoded representation without header and footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicBaseKeyB64 = function () {
        return hex2b64(this.getPublicBaseKey());
    };
    /**
     * wrap the string in block of width chars. The default value for rsa keys is 64
     * characters.
     * @param {string} str the pem encoded string without header and footer
     * @param {Number} [width=64] - the length the string has to be wrapped at
     * @returns {string}
     * @private
     */
    JSEncryptRSAKey.wordwrap = function (str, width) {
        width = width || 64;
        if (!str) {
            return str;
        }
        var regex = "(.{1," + width + "})( +|$\n?)|(.{1," + width + "})";
        return str.match(RegExp(regex, "g")).join("\n");
    };
    /**
     * Retrieve the pem encoded private key
     * @returns {string} the pem encoded private key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPrivateKey = function () {
        var key = "-----BEGIN RSA PRIVATE KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
        key += "-----END RSA PRIVATE KEY-----";
        return key;
    };
    /**
     * Retrieve the pem encoded public key
     * @returns {string} the pem encoded public key with header/footer
     * @public
     */
    JSEncryptRSAKey.prototype.getPublicKey = function () {
        var key = "-----BEGIN PUBLIC KEY-----\n";
        key += JSEncryptRSAKey.wordwrap(this.getPublicBaseKeyB64()) + "\n";
        key += "-----END PUBLIC KEY-----";
        return key;
    };
    /**
     * Check if the object contains the necessary parameters to populate the rsa modulus
     * and public exponent parameters.
     * @param {Object} [obj={}] - An object that may contain the two public key
     * parameters
     * @returns {boolean} true if the object contains both the modulus and the public exponent
     * properties (n and e)
     * @todo check for types of n and e. N should be a parseable bigInt object, E should
     * be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPublicKeyProperty = function (obj) {
        obj = obj || {};
        return obj.hasOwnProperty("n") && obj.hasOwnProperty("e");
    };
    /**
     * Check if the object contains ALL the parameters of an RSA key.
     * @param {Object} [obj={}] - An object that may contain nine rsa key
     * parameters
     * @returns {boolean} true if the object contains all the parameters needed
     * @todo check for types of the parameters all the parameters but the public exponent
     * should be parseable bigint objects, the public exponent should be a parseable integer number
     * @private
     */
    JSEncryptRSAKey.hasPrivateKeyProperty = function (obj) {
        obj = obj || {};
        return (obj.hasOwnProperty("n") &&
            obj.hasOwnProperty("e") &&
            obj.hasOwnProperty("d") &&
            obj.hasOwnProperty("p") &&
            obj.hasOwnProperty("q") &&
            obj.hasOwnProperty("dmp1") &&
            obj.hasOwnProperty("dmq1") &&
            obj.hasOwnProperty("coeff"));
    };
    /**
     * Parse the properties of obj in the current rsa object. Obj should AT LEAST
     * include the modulus and public exponent (n, e) parameters.
     * @param {Object} obj - the object containing rsa parameters
     * @private
     */
    JSEncryptRSAKey.prototype.parsePropertiesFrom = function (obj) {
        this.n = obj.n;
        this.e = obj.e;
        if (obj.hasOwnProperty("d")) {
            this.d = obj.d;
            this.p = obj.p;
            this.q = obj.q;
            this.dmp1 = obj.dmp1;
            this.dmq1 = obj.dmq1;
            this.coeff = obj.coeff;
        }
    };
    return JSEncryptRSAKey;
}(RSAKey));

var _a;
var version = typeof process !== 'undefined'
    ? (_a = process.env) === null || _a === void 0 ? void 0 : _a.npm_package_version
    : undefined;
/**
 *
 * @param {Object} [options = {}] - An object to customize JSEncrypt behaviour
 * possible parameters are:
 * - default_key_size        {number}  default: 1024 the key size in bit
 * - default_public_exponent {string}  default: '010001' the hexadecimal representation of the public exponent
 * - log                     {boolean} default: false whether log warn/error or not
 * @constructor
 */
var JSEncrypt = /** @class */ (function () {
    function JSEncrypt(options) {
        if (options === void 0) { options = {}; }
        options = options || {};
        this.default_key_size = options.default_key_size
            ? parseInt(options.default_key_size, 10)
            : 1024;
        this.default_public_exponent = options.default_public_exponent || "010001"; // 65537 default openssl public exponent for rsa key type
        this.log = options.log || false;
        // The private and public key.
        this.key = null;
    }
    /**
     * Method to set the rsa key parameter (one method is enough to set both the public
     * and the private key, since the private key contains the public key paramenters)
     * Log a warning if logs are enabled
     * @param {Object|string} key the pem encoded string or an object (with or without header/footer)
     * @public
     */
    JSEncrypt.prototype.setKey = function (key) {
        if (this.log && this.key) {
            console.warn("A key was already set, overriding existing.");
        }
        this.key = new JSEncryptRSAKey(key);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPrivateKey = function (privkey) {
        // Create the key.
        this.setKey(privkey);
    };
    /**
     * Proxy method for setKey, for api compatibility
     * @see setKey
     * @public
     */
    JSEncrypt.prototype.setPublicKey = function (pubkey) {
        // Sets the public key.
        this.setKey(pubkey);
    };
    /**
     * Proxy method for RSAKey object's decrypt, decrypt the string using the private
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str base64 encoded crypted string to decrypt
     * @return {string} the decrypted string
     * @public
     */
    JSEncrypt.prototype.decrypt = function (str) {
        // Return the decrypted string.
        try {
            return this.getKey().decrypt(b64tohex(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's encrypt, encrypt the string using the public
     * components of the rsa key object. Note that if the object was not set will be created
     * on the fly (by the getKey method) using the parameters passed in the JSEncrypt constructor
     * @param {string} str the string to encrypt
     * @return {string} the encrypted string encoded in base64
     * @public
     */
    JSEncrypt.prototype.encrypt = function (str) {
        // Return the encrypted string.
        try {
            return hex2b64(this.getKey().encrypt(str));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's sign.
     * @param {string} str the string to sign
     * @param {function} digestMethod hash method
     * @param {string} digestName the name of the hash algorithm
     * @return {string} the signature encoded in base64
     * @public
     */
    JSEncrypt.prototype.sign = function (str, digestMethod, digestName) {
        // return the RSA signature of 'str' in 'hex' format.
        try {
            return hex2b64(this.getKey().sign(str, digestMethod, digestName));
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Proxy method for RSAKey object's verify.
     * @param {string} str the string to verify
     * @param {string} signature the signature encoded in base64 to compare the string to
     * @param {function} digestMethod hash method
     * @return {boolean} whether the data and signature match
     * @public
     */
    JSEncrypt.prototype.verify = function (str, signature, digestMethod) {
        // Return the decrypted 'digest' of the signature.
        try {
            return this.getKey().verify(str, b64tohex(signature), digestMethod);
        }
        catch (ex) {
            return false;
        }
    };
    /**
     * Getter for the current JSEncryptRSAKey object. If it doesn't exists a new object
     * will be created and returned
     * @param {callback} [cb] the callback to be called if we want the key to be generated
     * in an async fashion
     * @returns {JSEncryptRSAKey} the JSEncryptRSAKey object
     * @public
     */
    JSEncrypt.prototype.getKey = function (cb) {
        // Only create new if it does not exist.
        if (!this.key) {
            // Get a new private key.
            this.key = new JSEncryptRSAKey();
            if (cb && {}.toString.call(cb) === "[object Function]") {
                this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
                return;
            }
            // Generate the key.
            this.key.generate(this.default_key_size, this.default_public_exponent);
        }
        return this.key;
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateKey();
    };
    /**
     * Returns the pem encoded representation of the private key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the private key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPrivateKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPrivateBaseKeyB64();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITH header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKey = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicKey();
    };
    /**
     * Returns the pem encoded representation of the public key
     * If the key doesn't exists a new key will be created
     * @returns {string} pem encoded representation of the public key WITHOUT header and footer
     * @public
     */
    JSEncrypt.prototype.getPublicKeyB64 = function () {
        // Return the private representation of this key.
        return this.getKey().getPublicBaseKeyB64();
    };
    JSEncrypt.version = version;
    return JSEncrypt;
}());

var md5Exports = {};
var md5 = {
  get exports(){ return md5Exports; },
  set exports(v){ md5Exports = v; },
};

var cryptExports = {};
var crypt = {
  get exports(){ return cryptExports; },
  set exports(v){ cryptExports = v; },
};

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt$1 = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt$1.rotl(n, 8) & 0x00FF00FF | crypt$1.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt$1.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  crypt.exports = crypt$1;
})();

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

var charenc_1 = charenc;

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
var isBuffer_1 = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
};

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

(function(){
  var crypt = cryptExports,
      utf8 = charenc_1.utf8,
      isBuffer = isBuffer_1,
      bin = charenc_1.bin,

  // The core
  md5$1 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message) && message.constructor !== Uint8Array)
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5$1._ff,
        GG = md5$1._gg,
        HH = md5$1._hh,
        II = md5$1._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5$1._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5$1._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5$1._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5$1._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5$1._blocksize = 16;
  md5$1._digestsize = 16;

  md5.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5$1(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();

/* eslint-disable */
/**
 * 动态注入
 */
var encryptInfo = {
    serialNums: [],
    key: '',
    verified: true,
};

var _License_verified, _License_verifiedTimer;
class License {
    constructor(viewport) {
        this.viewport = viewport;
        /**
         * 序列号、公钥
         */
        this.encryptInfo = encryptInfo;
        _License_verified.set(this, true
        /**
         * 延迟显示水印
         */
        );
        /**
         * 延迟显示水印
         */
        _License_verifiedTimer.set(this, setTimeout(() => {
            __classPrivateFieldSet(this, _License_verified, false, "f");
            this.viewport.triggerRender();
        }, 1000 * 5));
    }
    verify(str, signature) {
        var _a;
        clearTimeout(__classPrivateFieldGet(this, _License_verifiedTimer, "f"));
        const verifyEncrypt = new JSEncrypt();
        verifyEncrypt.setPublicKey((_a = this.encryptInfo) === null || _a === void 0 ? void 0 : _a.key);
        const verified = verifyEncrypt.verify(str, signature, md5Exports);
        __classPrivateFieldSet(this, _License_verified, verified, "f");
        this.viewport.triggerRender();
        return verified;
    }
    getVerified() {
        if (encryptInfo.verified) {
            return true;
        }
        /**
         * @TEMP 暂时关闭水印
         */
        return __classPrivateFieldGet(this, _License_verified, "f");
    }
}
_License_verified = new WeakMap(), _License_verifiedTimer = new WeakMap();

class Info {
    constructor(scene, signals) {
        this.scene = scene;
        this.signals = signals;
        const container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.left = '12px';
        container.style.bottom = '12px';
        container.style.fontSize = '12px';
        container.style.color = '#fff';
        container.style.pointerEvents = 'none';
        this.container = container;
        this.state = {
            objects: 0,
            vertices: 0,
            triangles: 0,
            frametime: 0,
            lodFrametime: 0,
        };
    }
    addListeners() {
        const { scene, signals, } = this;
        function createTextEl(text, isMarginLeft = true) {
            const el = document.createElement('span');
            if (isMarginLeft)
                el.style.marginLeft = '6px';
            el.innerText = text;
            return el;
        }
        function createBr() {
            return document.createElement('br');
        }
        const objectsText = createTextEl('0');
        const trianglesText = createTextEl('0');
        const verticesText = createTextEl('0');
        const frametimeText = createTextEl('0');
        const lodFrametimeText = createTextEl('0');
        // objects
        this.container.appendChild(createTextEl('objects', false));
        this.container.appendChild(objectsText);
        this.container.appendChild(createBr());
        // triangles
        this.container.appendChild(createTextEl('triangles', false));
        this.container.appendChild(trianglesText);
        this.container.appendChild(createBr());
        // vertices
        this.container.appendChild(createTextEl('vertices', false));
        this.container.appendChild(verticesText);
        this.container.appendChild(createBr());
        // frametime
        this.container.appendChild(createTextEl('frametime', false));
        this.container.appendChild(frametimeText);
        this.container.appendChild(createBr());
        // Lod frametime
        this.container.appendChild(createTextEl('lodFrametime', false));
        this.container.appendChild(lodFrametimeText);
        const update = () => {
            this.state.objects = 0;
            this.state.vertices = 0;
            this.state.triangles = 0;
            for (let i = 0; i < scene.children.length; i++) {
                const object = scene.children[i];
                object.traverseVisible((object) => {
                    var _a, _b, _c, _d;
                    if (object.stype !== 'SceneManager')
                        this.state.objects++;
                    if (object.isMesh) {
                        const geometry = object.geometry;
                        if (geometry.isGeometry) {
                            this.state.vertices += ((_a = geometry.vertices) === null || _a === void 0 ? void 0 : _a.length) || 0;
                            this.state.triangles += ((_b = geometry.faces) === null || _b === void 0 ? void 0 : _b.length) || 0;
                        }
                        else if (geometry.isBufferGeometry) {
                            this.state.vertices += ((_c = geometry.attributes.position) === null || _c === void 0 ? void 0 : _c.count) || 0;
                            if (geometry.index !== null) {
                                this.state.triangles += geometry.index.count / 3;
                            }
                            else {
                                this.state.triangles += ((_d = geometry.attributes.position) === null || _d === void 0 ? void 0 : _d.count) / 3 || 0;
                            }
                        }
                    }
                });
            }
            objectsText.innerText = String(this.state.objects);
            verticesText.innerText = String(this.state.vertices);
            trianglesText.innerText = String(this.state.triangles);
        };
        signals.objectAdded.add(update);
        signals.objectRemoved.add(update);
        signals.geometryChanged.add(update);
        const updateFrametime = (time) => {
            this.state.frametime = time;
            frametimeText.innerText = Number(time).toFixed(2) + ' ms';
        };
        signals.sceneRendered.add(updateFrametime);
        const updateLodFrametime = (time) => {
            this.state.lodFrametime = time;
            lodFrametimeText.innerText = Number(time).toFixed(2) + ' ms';
        };
        signals.loadRendered.add(updateLodFrametime);
    }
}

const vpTemp$1 = new THREE.Vector4();
class ViewHelper extends THREE.Object3D {
    constructor(editorCamera, dom) {
        super();
        const color1 = new THREE.Color('#ff3653');
        const color2 = new THREE.Color('#8adb00');
        const color3 = new THREE.Color('#2c8fff');
        const camera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0, 4);
        camera.position.set(0, 0, 2);
        const geometry = new THREE.BoxGeometry(0.8, 0.05, 0.05).translate(0.4, 0, 0);
        const xAxis = new THREE.Mesh(geometry, getAxisMaterial(color1));
        const yAxis = new THREE.Mesh(geometry, getAxisMaterial(color2));
        const zAxis = new THREE.Mesh(geometry, getAxisMaterial(color3));
        yAxis.rotation.z = Math.PI / 2;
        zAxis.rotation.y = -Math.PI / 2;
        this.add(xAxis);
        this.add(zAxis);
        this.add(yAxis);
        const posXAxisHelper = new THREE.Sprite(getSpriteMaterial(color1, 'X'));
        posXAxisHelper.userData.type = 'posX';
        const posYAxisHelper = new THREE.Sprite(getSpriteMaterial(color2, 'Y'));
        posYAxisHelper.userData.type = 'posY';
        const posZAxisHelper = new THREE.Sprite(getSpriteMaterial(color3, 'Z'));
        posZAxisHelper.userData.type = 'posZ';
        const negXAxisHelper = new THREE.Sprite(getSpriteMaterial(color1));
        negXAxisHelper.userData.type = 'negX';
        const negYAxisHelper = new THREE.Sprite(getSpriteMaterial(color2));
        negYAxisHelper.userData.type = 'negY';
        const negZAxisHelper = new THREE.Sprite(getSpriteMaterial(color3));
        negZAxisHelper.userData.type = 'negZ';
        posXAxisHelper.position.x = 1;
        posYAxisHelper.position.y = 1;
        posZAxisHelper.position.z = 1;
        negXAxisHelper.position.x = -1;
        negXAxisHelper.scale.setScalar(0.8);
        negYAxisHelper.position.y = -1;
        negYAxisHelper.scale.setScalar(0.8);
        negZAxisHelper.position.z = -1;
        negZAxisHelper.scale.setScalar(0.8);
        this.add(posXAxisHelper);
        this.add(posYAxisHelper);
        this.add(posZAxisHelper);
        this.add(negXAxisHelper);
        this.add(negYAxisHelper);
        this.add(negZAxisHelper);
        const point = new THREE.Vector3();
        const dim = 128;
        this.render = function (renderer) {
            this.quaternion.copy(editorCamera.quaternion).invert();
            this.updateMatrixWorld();
            point.set(0, 0, 1);
            point.applyQuaternion(editorCamera.quaternion);
            if (point.x >= 0) {
                posXAxisHelper.material.opacity = 1;
                negXAxisHelper.material.opacity = 0.5;
            }
            else {
                posXAxisHelper.material.opacity = 0.5;
                negXAxisHelper.material.opacity = 1;
            }
            if (point.y >= 0) {
                posYAxisHelper.material.opacity = 1;
                negYAxisHelper.material.opacity = 0.5;
            }
            else {
                posYAxisHelper.material.opacity = 0.5;
                negYAxisHelper.material.opacity = 1;
            }
            if (point.z >= 0) {
                posZAxisHelper.material.opacity = 1;
                negZAxisHelper.material.opacity = 0.5;
            }
            else {
                posZAxisHelper.material.opacity = 0.5;
                negZAxisHelper.material.opacity = 1;
            }
            //
            const x = dom.offsetWidth - dim;
            renderer.clearDepth();
            renderer.getViewport(vpTemp$1);
            renderer.setViewport(x, 0, dim, dim);
            renderer.render(this, camera);
            renderer.setViewport(vpTemp$1.x, vpTemp$1.y, vpTemp$1.z, vpTemp$1.w);
        };
        function getAxisMaterial(color) {
            return new THREE.MeshBasicMaterial({ color: color, toneMapped: false, });
        }
        function getSpriteMaterial(color, text = null) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            if (!context)
                return;
            context.beginPath();
            context.arc(32, 32, 16, 0, 2 * Math.PI);
            context.closePath();
            context.fillStyle = color.getStyle();
            context.fill();
            if (text !== null) {
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillStyle = '#000000';
                context.fillText(text, 32, 41);
            }
            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.SpriteMaterial({ map: texture, toneMapped: false, });
        }
    }
}

const xwLogImg = {
    url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAApCAYAAADDJIzmAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQAAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAASwAAAABAAABLAAAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAZKADAAQAAAABAAAAKQAAAAAaAV+RAAAACXBIWXMAAC4jAAAuIwF4pT92AAACy2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNi4wLjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6T3JpZW50YXRpb24+MTwvdGlmZjpPcmllbnRhdGlvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjIwMDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODI8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4K80N3zgAAElhJREFUeAHtO1lsXNd1d3vbvFnIISmKNm0xXuBWQl24Qly4dQCiTmwYRfrHfLcokPy0AVo0RWt/eAK0dl0Hjuu0H/FP+2391WiDpFbLIq0NFNBPACpwLUuUQ4uSKA5neW/edpeec4dvOENRCuVFFmpdYOa9ueu5Zz/n3qFfeuq1ecYLExESX2kcS8mpbyhyt3xuGKCLv/NX9+LqWhLGREUbmqZ04A823u1lhLT05wbZF3RhYbRDudTxfNKMtmuD0HgmKGqmct/XAkXdlxJXh4NzP/p2DvgxX1Ac3dZtCxIQIgqqz/zXtwpYuQN47y4+8X1fV1SFJroykEV1aflvCxH4g8ZVLzlzxva7rUB+kRYT+zZLCaFm412SQH1CVlb4fPdxP+WywpOkntSS+oNPv5L7eWWwRrZSstqS+8bf/fkJMUDvffblRa8w/fNv/0X3ZnMtL7fEZhEEuS8ruSscmjlGa52xjMUb7/4pEvBu+RQwwOsPf60uNMl3zr8NRvzGZX19VW//4u28c+Hf4/sfezI1GTXUcXyPFOFC+GS6tbV61zu7MfoO3cIO3XOs49qpVo4SNet2u1Y0jo813n39RBj4WASBFcHWELL5iZa+O/ggDHxcglgXeMHOCG7a3fKpYeDjEuRTA+DuRJMYuEuQSXx87r8OiEPuRuSHp4qhJ1a+64z3z6ImPZe01f4YbWXlTX6qzBNCCPFQ0OTluEXov7ob0wkbAu6R5U5Mj9DFJ1719WxIL731rUG5iRs9H3r2dY8leS3muQmVS3PC5frqn0AGghBoq4s8ciLhH3qfVZlS3sz76FlevyY1WfR6I0kSjzlkN++XkJP9S1tnhut5pN32TCP032mfw7BgG+dY9Or1hCQVJolWtOAbQRNjwB58qKDMMQUtwge++jckmE6TgxfGaW5vObHScpMdPzBG+bkqHJ52NHBZNuKyG4Djfdg23fm6R41PBqCQKc9dsvJmH7PYhVbhgHuCZsX1BBn3TcbC3D7hZIqQ/kHLIfEzmThIDMZcI1nOqz3SLWYedo8989ezaSYZCetAKcMqbnUUeMtByoXjG+ZQYwpHy7xWEtughLSVx0NNVC2LghqmRkSskwUnSUoxOgiYz6KuzAaouvK729o1mlLKDAA+3PBh1lxbe6FYmntF5W7uWA40QixubLgbxKRM/p32CM+1lzKthXXdcU7GpGE5oACKUTlVjmGIYK1zyiHPt0bWDgp6qVFZwyhIzjpUq8IwX7D8vf/+TjT/9CtzgglAOh2OKwZkkPfdR37v5ZoqAlpEfaHhyENrQiknRgeXA2hzsE3spj0SAnrtkV4QyJAEfV5MRSRo3LP8vZTUaoNLPkTxp06NA4WbuZ7LcEe3WnbzZUIF/gcs9gArjGa+AUzAB9eYUNGHmJ0amb3azQsjqFM1zWpEqzuh3IAc3YXTrS1CXjBHv/LSrHAct0Rk4fP80o87bTxuePTpV8JtbqYZcCgim/LE7Nu7haH57Ou1lCSuoEIh4RBOyj0rBUBKQUAdQQLEEh0oZkBYvaggPqYIgXITxxo68SqRV1AR9dWe9QCj8t5QNPsnToC6WBCBljrIs2hmMf51TZ55IhFZb7C++gKkWKglxuYleKuNyfch0DXsYujS8j95Orwc0J72JdecyhznNMJzlSpigP9WCWFnpqBGXFBbqkGIIsdL2EDp2ILnOy0auK8xeyRHQmBPQMSOBmYbnv2ASuMkgXHecESmvHFGtJUnT/7QuSo7VfihCUAK6GdOQSM4psgwIevsmLigNBzOsPeNqhKJs1czfEPmMwmh0m3kewQZ67W2BgZsjYBeM72l5e96WnqB4UWQu7Xw2DOvSZp9P5np/zwuZkK6nU8Qe2yW619R5+pi4Bvzol+YQJiYgQljsB8gAonhxWEmiw3wpYQ08sgLuX6mg2sAUeJKtjXL5uuEVKAPmFAlDOtMbaMzYA0q2BOme+8zqvcQExhQbrsl1dLaVfyJxHKJO2or+2zW+g02UlUxc2m1uLDaQaNMUJqClRNJvl2vIqKxClWiiio783kou0eyAGxLrZROT6jCbxzrZNFlupicGJMQHAkFjal/fsEMzz2oWV8lKVTDp9W95+vEl4PZgILCvVx7sMpAC6JTALZnpI/tJPu/Wi320Gl3BgCxdoE5oEIBJahDkbt0khPf9UC+4zRN6gWfEjoTHgdDXrL2/hkP/H3Fje2BW+ZRpbMcQANDmxUUctR41oOFPhRdFino+6E6hIqqY/o03JUCQyX7AUd9UxavyEsJsWoamQr24SGyhzbAAcOc03uWq02Pv8aN6nS7G3VqQAVxx7W2BSgsL0JGfAMmnVtueS5BfEkguKDFQBcf/OQb1qifQwDLhe0TEHfs3cY86kStVWYqeXLJX9tvPwjamzlC/EbgBoU24uK1i9fImTfKTU9MiT9QBYLnM4dcYecuQNDBq3ESCjt3UpkZwH/PiKDpgqGE8xft0o6zLUVaBW/Exc2jkX28fu/Vm3pZ4Ovfv/lBXbtepeRO4zl0noY7WzttD+ysVURotMeBRMPNXdxyDgQRI8nUAKfpJ+1LZ1ooYZYgYLBDwfU0Ogzjc1i1BZK9/q9/fvmR3365FtVJQ2jX2hecX8tqxkRmuCvdTGboCYADWVBPeIXKRS49wxobvWhSZa0dh0Xfh3UEWAnfJ30eLPW/LPWTv4GTJSP7AfYGrGOEHwJEJK03JoAbBxTffX/BdHQHNkuA+1wFx8QDLUKQuk0dkjmxPdWtkky4BUnAqYKNggpv1hQbwBPF85CFomtbW24VHQ0CANxpjS2g8koSg23iXg5mnEmqKZl0e2VVcOAMTgYBYH2vDaU/OBKUEmLBmM1jGlcqkgD7jRMWz4eI7tl4J5kC8oAZ1M7QqGM/HfStGILEjuwIEiWT8AXGgACHZvc30XhOFuyENZYrwd1E31oJFkpWn/nSUy8egXilgWoNu9iRraExtO83+QoJT/Mk6TiMtwsQAzrYDpQTNDtBNCUylAKAeozrHC82jLvXGcCbLGH79qVnvYGh5wNYBqn0QQUWXBbEM4nQcgLBNn5Qaa6pzlCfj8+POMAoerfOzr+22orWwyXgxWGx7jGoXRZk4PC0LP/I2OFIzLIPPnFd/JT4LdsQPpQkJ0nlY9WjwLP7CorReJVFFBAGgQNfQGSS1rrbYg506SyKJgGPY7z/Qe9nvr6pon40CABZ4IM3Ra6nieI2FEMilOplfGyRRRNwjLfd7F2KPWTgXtCzOfeb7eKj089tX3rrz64hYdCdRUTiM2NcXv7Rc9ewLdmOI1RTwzbwvrQHKY0XSoKMlkW1WIBDiP3QI0SEflh5cGjUiaEeR7U3gImGa9SLpHfxx8WVav3hbTTwo4ngBRn0IqjiL88tbaE6nlRZ4z0PeEfilLGBNdAO8e6rdGr6qb8HyUvSyXtdhloPLfQCtso92RBcgaFjkmn0FA+Y/tOoAmRkwDpl2F0hHNQ4qNXRej53eLZrs63LC/EGLGyRVLs34NEuWtFNS9wBjBu6+CVwkMYJtEsqcJdtqBKhn6qbzug+28op8OLAfQQvbiilDsmCJkjetzU52yJqXliHApkFCXnu3/4YDDo1p3YXuCWClEDhE7m61NPU5D5wfXCs95Eyv/tSKjKq0bXNVQCyBbsF2FA3gwmf4I7x+T6V95FLO7QDiPBUgUddFrB3ahU8LAfbUevCtxp5USRpg+4Xe0pDaH9vrO3dYk4F3ECD23Agqi+oQz1ptjoGCdXo9RS6rxNeHOBJ5ckUOANmgIEmyywOkLmN49Cjz/5gNshfYxTuw+Ep7N7qdsFb+yr1NBIH0xv4G6NO8CFqqN5symPMLtza7JO96SHsyYmzZzmmMMZHeiCT5e+Tby3w0hCXsFdBZZXtpbrDNtwT6GcXb3YuLf8jRNiYnGwCKY3gTmhzV/iULIM5g6aumdnuYr2adiRDz66cE5+5Eg54Zi44yhMCgOoObvN4GU0h1kvtmIkO45N83HfciJUE/ktNyy0toYqIbW1tTWx0/wTdep2jVJQxBrYHMh1x+XZtE+KEukW21e+QJ2s3RuoTInjDMoke7hB26x0VGfDVRbtUX2WCo1sMAobr2Er4sgac5TSs0KJTgwugUIfzI2HxKfigYArsjS8ZuA0jhrEG3TClckil1TAQR//2Di2OVzVXE9iQ6zHIoZtAqWz1p2hgWzeEuOH1eAcDnLHSzeojguS1BVaRHQo2BOK2mCWgNo6cn4I8FxRQd3ClBvBRgca9+IyRQi8VRK5Dl8Wleh5d7uy0e54hc7u5FRwLPheszRZ6JCmEH2Z8SCsbx4CLf/H085AnI+Tep16cQWcG00Myy3mdFJ211efhWvUwxsE+dyxBiiykosIRmbEfBPHwOutzN7VBifC5Ze5dJUQhYyW8IwaQzVdgorPkrNw5v9BmbmyiHGIet2JqtU2zAvmn8+d3WASR1/bMmOcLyRbqJAay3paoZ96wtzbHOiAKhwX94HPwgYQsJIMgmkIhA95wy0gf7Jf/DjgUhg9tCGQIduBqqB3dalFwPIb1tqL8AsCP9d4/Mp6aLptu5xM562htqn3mEAdSY3BRODqYK6Pgsn7PzayQYXJvaPDLdtDqIxUyHgdhOxrtgrvWZcbfi8+8Csd81MPgEn+PF/wHwX153P65Gzad3Ugc23F9GzTCe2m/ynEYweM7qvkLXym20Bu8YyWkBBrhhc9NJQP7Qo4ohMQ2JMAcmzbHOixqZGBhCge3e+MtS1aM0iboBencZyQ3pdGnaOQLSLPSAJKgGONAH1zDurARBJwwGlPvpgJqbzBUe3b90pyieRormLnAnJeTOJK0nrfEuQ46uwj8KWFs3OfyOnbn65cSAwCkLnc9n+gsFsoQMTIbQJGPCT54y4EyzC3E7o3OFkgLBJWJK00NcAe2HbM8WAKVMMUbeb9foe5MT8YqNWX6fmL9MbOD45hwTZAxBplua9CxbhLxd4DKQhGX4MzMuGznZz/5ToxAHrIcSpIOOdfn1m2kPy0Ep1Y0kyGYEMhyQhCDdei23S7oUPSRGLheL5+9Vd6+bXB+lvjYp7LgmLP55rUTW1tBprpBBgoZk4u02MtQfhbAYCBlItClcBgEiaEkmH4ALlsMzwgOu96J5X+ors3NJY92L/qqERe8Gzpw+id5L7EheawdiRnkSGOObx7U0EUC6X5LRJm0KWayH/jqy/X52M23IBlZgZgDJfTkN3/odH+xGfBeYHAOPduj0z6ROykRFdlU2A/XGfWH3N7O9E6F9VM4xK8XwpuGY4W+C2vkuB7CoySchzRJhmOyWDMBnhwmLXGv+wgCNZDgWsO0Onwwqwv3jHxFZVAoBw5/wJCBK1kaM5zgVksZMKEnhW4h5nOMSRNGjkJ6//dHx8O3Om/Xy9yl4iMBN1S4jJpSKOZzP86Nwz28EiQ504g4SrJwffUPur/25EvTOx2ZumHu1t1QPvr09yqDpOJueooCUnQvH+ZQ0v/d9EjQ9OKqVD4TNM3rYNsvxPV8IeCqDSe8dSQ47wwkSnac1jY9mXosa4R5kFOwGh3CEiVm+peSbtAMAB5X+JHhSa5zsHuqXi0UHDuU+51UWWXt7hOvBIH/37tw+vmrQve2gYMji0BQZ6VK2zfkpj9xDEqc7cTDRCq2c7H+ztUP/+UvdwBJkLqeTOTddLJ9jU1I6bMoq+MdKkxfpAr2iUe4EH3j/awrwO3IkRUntHFE4dWYP9VzWKbddp/D/Sg4TJ8O04InPO/HXIcpXV7+DwFGTMCxrsL7WV7CtcFn9VccDXPu1BZ0DHk7uHsF3pxhJ09+08H+DO59BRXh4GmjnQ/uhhFykoCUYMDO8E7R2tzxhKs8gztkbqr3BOOmBBnbMxzltlK8cLa+OriKV4cg8EkstwOnl8Q5yN6gXRjapIL6nsjx3tKDRXL1o9N/tI1IOuhGx9i6h379WeN/AG/pVWSijcXFfJ10owXn8eSD34qvOVuYwzX0EfiX8Uz8q/aOVdhxemkHsujVam/jmV7mXwv77/3zH/aPdtZ7c8mFSLevpuvkP4GzF2K83JGqPF5b3hpMAcG7JFPOXNS75E9nuM5j9x+P8Y+y27V7OPYnpJuSzlT63teSGPvjiSghZwi2ITxHH5yxOWXoKHMyE23Uj4/ubI1E5dA7H+8IXtnc1tmgodwgg7y2PUuw+V3YPvr/4Hc7NJHgsKd30iW88S3cae+fjCBju8GrMd0jm4FMKhVrpEWashiPfVvox/+/8IDGtvuZvf4f1azOqNpo8RwAAAAASUVORK5CYII=',
    width: 100,
    height: 41,
};
const vpTemp = new Vector4();
const loader = new TextureLoader();
class WaterMark extends Object3D {
    get size() {
        var _a;
        return (_a = this._size) !== null && _a !== void 0 ? _a : (this.size = new Vector2(100, 100));
    }
    set size(value) {
        this._size = value;
        const { x: width, y: height, } = value;
        const { camera, currViewport, } = this;
        currViewport.set(width * Math.random(), height * Math.random(), width, height);
        camera.left = camera.right = width / 2;
        camera.left = -camera.left;
        camera.top = camera.bottom = height / 2;
        camera.bottom = -camera.bottom;
        camera.updateProjectionMatrix();
    }
    get velocity() {
        var _a;
        return (_a = this._velocity) !== null && _a !== void 0 ? _a : (this._velocity = this.direction.clone().multiplyScalar(this.speed));
    }
    set velocity(value) {
        this._velocity = value;
    }
    constructor(viewport) {
        super();
        this.viewport = viewport;
        this.fontSize = 50;
        this.imageWidth = 200;
        this.camera = new OrthographicCamera(-1.6, 1.6, 0.8, -0.8, 0, 4);
        this.direction = new Vector2().random().normalize();
        this.speed = 2;
        this.currViewport = new Vector4();
        this.lastRenderTime = 0;
        this.autoRender = (time) => {
            if (time - this.lastRenderTime > 30) {
                this.render();
            }
            requestAnimationFrame(this.autoRender);
        };
        this.camera.position.z = 2;
        // this._generateMarkForString()
        this._generateMarkForImage();
        // this.autoRender( performance.now() )
    }
    _generateMark(str = [28145, 22323, 36805, 32500, 25968, 23383, 23402, 29983, 25216, 26415, 26377, 38480, 20844, 21496]) {
    }
    _generateMarkForString(str = [28145, 22323, 36805, 32500, 25968, 23383, 23402, 29983, 25216, 26415, 26377, 38480, 20844, 21496]) {
        const text = Array.isArray(str) ? String.fromCodePoint(...str) : str;
        const length = text.length;
        const { fontSize, } = this;
        const baseLine = fontSize / 4;
        const baseLine2 = baseLine * 2;
        const { x: width, y: height, } = this.size = new Vector2(fontSize * length + baseLine2, fontSize + baseLine2);
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        if (!context)
            return;
        const gradient = context.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#ff3653');
        gradient.addColorStop(0.5, '#8adb00');
        gradient.addColorStop(1, '#2c8fff');
        context.fillStyle = gradient;
        context.font = `bold ${fontSize}px/1 serif`;
        context.fillText(text, baseLine, height - baseLine * 1.5);
        const texture = loader.load(canvas.toDataURL());
        const materil = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true, });
        const mark = new Mesh(new PlaneGeometry(width, height), materil);
        this.add(mark);
    }
    _generateMarkForImage(url = xwLogImg.url, width = xwLogImg.width, height = xwLogImg.height) {
        const imgWidth = this.imageWidth;
        const imgHeight = imgWidth * (height / width);
        this.size = new Vector2(imgWidth, imgHeight);
        const texture = loader.load(url);
        const materil = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true, });
        const mark = new Mesh(new PlaneGeometry(imgWidth, imgHeight), materil);
        this.add(mark);
    }
    render() {
        // this.lastRenderTime = performance.now()
        const { renderer, } = this.viewport;
        renderer.getViewport(vpTemp);
        const { width, height, } = renderer.domElement;
        const area = new Vector2(width, height);
        const { position, velocity, } = getPositionVelocity(this.currViewport, area, this.velocity, this.speed);
        const viewport = this.currViewport;
        viewport.x = position.x;
        viewport.y = position.y;
        this.velocity = velocity;
        renderer.clearDepth();
        renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
        renderer.render(this, this.camera);
        renderer.setViewport(vpTemp.x, vpTemp.y, vpTemp.z, vpTemp.w);
    }
}
function getPositionVelocity(rect, area, velocity, speed) {
    speed = speed !== null && speed !== void 0 ? speed : velocity.length();
    let { x, y, } = rect;
    let { x: velocityX, y: velocityY, } = velocity;
    x += velocityX;
    y += velocityY;
    if ((x + rect.width >= area.x && velocityX > 0) || (x <= 0 && velocityX < 0)) {
        velocityX = (-velocityX) * Math.random();
    }
    if ((y + rect.height >= area.y && velocityY > 0) || (y <= 0 && velocityY < 0)) {
        velocityY = (-velocityY) * Math.random();
    }
    const newVelocity = new Vector2(velocityX, velocityY);
    newVelocity.normalize().multiplyScalar(speed);
    const position = new Vector2(rect.x, rect.y).add(newVelocity);
    return {
        position: position,
        velocity: newVelocity,
    };
}

const innerRenderState = {
    needsUpdate: false,
};
let renderStartTime = 0;
let renderEndTime = 0;
const backgroundDispose = (background) => {
    if (background instanceof Texture) {
        background.dispose();
    }
};
class Viewport {
    constructor(options) {
        this.clock = new Clock();
        this.raycaster = new Raycaster();
        this.sky = null;
        this.options = options;
        this.state = {
            useFreq: 1,
            enabledPostprocessing: true,
            isPausedRender: false,
            isDisposed: false,
        };
        this.signals = Signals();
        this.scener = new Scener(this.signals, this.state);
        this.scene = this.scener.scene;
        this.cameraManager = new CameraManager(this);
        this.camera = this.cameraManager.currentCamera;
        this.rendererManager = new RendererManager(this);
        this.container = this.rendererManager.container;
        this.interactiveContainer = this.rendererManager.interactiveContainer;
        this.renderer = this.rendererManager.renderer;
        this.rendererCSS3D = this.rendererManager.rendererCSS3D;
        this.rendererCSS2D = this.rendererManager.rendererCSS2D;
        this.pmremGenerator = new PMREMGenerator(this.renderer);
        this.pmremGenerator.compileEquirectangularShader();
        this.effectManager = new EffectManager(this.renderer, this.scene, this.camera);
        this.effectComposer = this.effectManager.effectComposer;
        this.bvh = new Bvh(this);
        this.controls = new Controls(this);
        this.info = new Info(this.scene, this.signals);
        this.stats = new Stats();
        this.mixer = new AnimationMixer(this.scene);
        this.clipsSet = new Set();
        this.postUpdate = new Map();
        this.postRender = new Map();
        this.selectModel = null;
        this.selectPoi = null;
        this._loop = 0;
        this.viewHelper = new ViewHelper(this.camera, this.container);
        this.license = new License(this);
        this.waterMark = new WaterMark(this);
        this._initInfo();
        this._initStats();
        this._signalsEventListenr();
        this._containerAddEventListener(this.container);
        this.animate(0);
    }
    _initInfo() {
        if (this.options.showInfo) {
            this.info.addListeners();
            const { container, } = this.info;
            container.style.zIndex = '1';
            this.container.appendChild(container);
        }
    }
    _initStats() {
        if (this.options.showStats) {
            const { dom, } = this.stats;
            dom.style.zIndex = '1';
            this.container.appendChild(dom);
            this.signals.sceneRendered.add(() => {
                this.stats.update();
            });
        }
    }
    /**
     ***************************** post-processing ***************************
     */
    setSSR(options = {}) {
        const { enabled = true, intensity = 1, exponent = 1.75, distance = 20, fade = 0, roughnessFade = 1, thickness = 3.5, ior = 1.75, maxRoughness = 0.1, maxDepthDifference = 20, blend = 0.95, correction = 1, correctionRadius = 1, blur = 1, blurKernel = 1, blurSharpness = 10, jitter = 0, jitterRoughness = 2, steps = 20, refineSteps = 10, missedRays = false, useNormalMap = true, useRoughnessMap = true, resolutionScale = 1, velocityResolutionScale = 1, } = options;
        const { effectManager, } = this;
        /**
         * effect
         */
        const ssrEffect = effectManager.effectsMap.get(EffectManager.CONSTANTS.ssrEffect);
        if (ssrEffect.enabled !== enabled) {
            ssrEffect.enabled = enabled;
            effectManager.effectsNeedsUpddate = true;
        }
        const { effect, } = ssrEffect;
        effect.usingBoxProjectedEnvMap = true;
        effect.intensity = intensity;
        effect.exponent = exponent;
        effect.distance = distance;
        effect.fade = fade;
        effect.roughnessFade = roughnessFade;
        effect.thickness = thickness;
        effect.ior = ior;
        effect.maxRoughness = maxRoughness;
        effect.maxDepthDifference = maxDepthDifference;
        effect.blend = blend;
        effect.correction = correction;
        effect.correctionRadius = correctionRadius;
        effect.blur = blur;
        effect.blurKernel = blurKernel;
        effect.blurSharpness = blurSharpness;
        effect.jitter = jitter;
        effect.jitterRoughness = jitterRoughness;
        effect.steps = steps;
        effect.refineSteps = refineSteps;
        effect.missedRays = missedRays;
        effect.useNormalMap = useNormalMap;
        effect.useRoughnessMap = useRoughnessMap;
        effect.resolutionScale = resolutionScale;
        effect.velocityResolutionScale = velocityResolutionScale;
        this.triggerRender();
    }
    setBloom(options = {}) {
        var _a;
        const { enabled = true, mipmapBlur = true, radius = 0.85, intensity = 3, threshold = 1, smoothing = 0, scalar = 2, opacity = 1, selection = [], } = options;
        const { effectManager, } = this;
        const bloomEffect = effectManager.effectsMap.get(EffectManager.CONSTANTS.bloomEffect);
        if (bloomEffect.enabled !== enabled) {
            bloomEffect.enabled = enabled;
            effectManager.effectsNeedsUpddate = true;
        }
        const { effect, } = bloomEffect;
        effect.intensity = intensity;
        const { mipmapBlurPass, renderTarget, } = effect;
        // mipmap
        mipmapBlurPass.enabled = mipmapBlur;
        mipmapBlurPass.radius = radius;
        const mapUniform = effect.uniforms.get('map');
        if (mapUniform) {
            mapUniform.value = mipmapBlur ? mipmapBlurPass.texture : renderTarget.texture;
        }
        // luminance
        effect.luminanceMaterial.threshold = threshold;
        effect.luminanceMaterial.smoothing = smoothing;
        effect.blendMode.opacity.value = opacity;
        /**
         * selection
         */
        (_a = effect.luminanceMaterial.userData.bloomSelection) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
            if (child instanceof Mesh && child.material.color) {
                child.material.toneMapped = true;
                child.material.color.multiplyScalar(1 / scalar);
            }
        });
        effect.luminanceMaterial.userData.bloomSelection = [];
        if (enabled) {
            selection.forEach((object) => {
                object.traverse((child) => {
                    if (child instanceof Mesh && child.material.color) {
                        child.material.toneMapped = false;
                        child.material.color.multiplyScalar(scalar);
                        effect.luminanceMaterial.userData.bloomSelection.push(child);
                    }
                });
            });
        }
        this.triggerRender();
    }
    setSSAO(options = {}) {
        const { enabled = true, depthAwareUpsampling = true, samples = 32, rings = 7, distanceThreshold = 0.02, // Render up to a distance of ~20 world units
        distanceFalloff = 0.0025, // with an additional ~2.5 units of falloff.
        rangeThreshold = 0.0003, // Occlusion proximity of ~0.3 world units
        rangeFalloff = 0.0001, // with ~0.1 units of falloff.
        luminanceInfluence = 0.7, minRadiusScale = 0.33, radius = 0.1, intensity = 3, bias = 0.004, fade = 0.01, color = null, resolutionScale = 1, } = options;
        const { effectManager, } = this;
        const normalPass = effectManager.passesMap.get(EffectManager.CONSTANTS.normalPass);
        const ssaoEffect = effectManager.effectsMap.get(EffectManager.CONSTANTS.ssaoEffect);
        if (ssaoEffect.enabled !== enabled) {
            normalPass.enabled = enabled;
            ssaoEffect.enabled = enabled;
            effectManager.effectsNeedsUpddate = true;
        }
        const { effect, } = ssaoEffect, { ssaoMaterial: material, } = effect;
        effect.depthAwareUpsampling = depthAwareUpsampling;
        effect.luminanceInfluence = luminanceInfluence;
        effect.resolution.scale = resolutionScale;
        effect.intensity = intensity;
        material.samples = samples;
        material.rings = rings;
        material.distanceThreshold = distanceThreshold;
        material.distanceFalloff = distanceFalloff;
        material.proximityThreshold = rangeThreshold;
        material.proximityFalloff = rangeFalloff;
        material.minRadiusScale = minRadiusScale;
        material.fade = fade;
        material.bias = bias;
        material.radius = radius;
        if (color)
            effect.color = new Color(color);
        this.triggerRender();
    }
    // setSSGI ( options: SSGIOptions = {} ) {
    //   const {
    //     enabled = true,
    //     distance = 2.8,
    //     thickness = 1.2,
    //     autoThickness = false,
    //     maxRoughness = 1,
    //     blend = 0.95,
    //     denoiseIterations = 3,
    //     denoiseKernel = 3,
    //     denoiseDiffuse = 25,
    //     denoiseSpecular = 25.54,
    //     depthPhi = 5,
    //     normalPhi = 28,
    //     roughnessPhi = 18.75,
    //     envBlur = 0.2,
    //     importanceSampling = true,
    //     directLightMultiplier = 0,
    //     maxEnvLuminance = 40,
    //     steps = 50,
    //     refineSteps = 4,
    //     spp = 1,
    //     resolutionScale = 1,
    //     missedRays = false,
    //   } = options
    //   const { effectManager, } = this
    //   const velocityDepthNormalPass = effectManager.passesMap.get(
    //     EffectManager.CONSTANTS.velocityDepthNormalPass
    //   ) as VelocityDepthNormalPass
    //   const ssgiEffect = effectManager.effectsMap.get(
    //     EffectManager.CONSTANTS.ssgiEffect
    //   ) as EffectState<SSGIEffect>
    //   if ( ssgiEffect.enabled !== enabled ) {
    //     velocityDepthNormalPass.enabled = enabled
    //     ssgiEffect.enabled = enabled
    //     effectManager.effectsNeedsUpddate = true
    //   }
    //   const effect = ssgiEffect.effect as any
    //   effect.distance = distance
    //   effect.thickness = thickness
    //   effect.autoThickness = autoThickness
    //   effect.maxRoughness = maxRoughness
    //   effect.blend = blend
    //   effect.denoiseIterations = denoiseIterations
    //   effect.denoiseKernel = denoiseKernel
    //   effect.denoiseDiffuse = denoiseDiffuse
    //   effect.denoiseSpecular = denoiseSpecular
    //   effect.depthPhi = depthPhi
    //   effect.normalPhi = normalPhi
    //   effect.roughnessPhi = roughnessPhi
    //   effect.envBlur = envBlur
    //   effect.importanceSampling = importanceSampling
    //   effect.directLightMultiplier = directLightMultiplier
    //   effect.maxEnvLuminance = maxEnvLuminance
    //   effect.steps = steps
    //   effect.refineSteps = refineSteps
    //   effect.spp = spp
    //   effect.resolutionScale = resolutionScale
    //   effect.missedRays = missedRays
    //   this.triggerRender()
    // }
    /**
     ***************************** renderer ***************************
     */
    setColorSpace(colorSpace) {
        if (colorSpace === 'sRGB') {
            this.renderer.outputEncoding = sRGBEncoding;
        }
        else {
            this.renderer.outputEncoding = LinearEncoding;
        }
        this.signals.sceneChanged.dispatch();
    }
    setToneMapping(options = {}) {
        const { type = 'ACESFilmic', exposure = 0.8, } = options;
        const toneMaps = {
            None: NoToneMapping,
            Linear: LinearToneMapping,
            Reinhard: ReinhardToneMapping,
            Cineon: CineonToneMapping,
            ACESFilmic: ACESFilmicToneMapping,
        };
        this.renderer.toneMapping = toneMaps[type];
        this.renderer.toneMappingExposure = exposure;
        this.signals.sceneChanged.dispatch();
    }
    /**
     ***************************** background ***************************
     */
    async setSphereSkyBackground(imgUrl) {
        const texture = await getTexture({ file: imgUrl, });
        backgroundDispose(this.scene.background);
        this.scene.background = texture;
        this.signals.backgroundChanged.dispatch();
    }
    async setSkyBackground(dirPath, fileNames = ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']) {
        const cubeTexture = await getTexture({ path: dirPath, file: fileNames, });
        backgroundDispose(this.scene.background);
        this.scene.background = cubeTexture;
        this.signals.backgroundChanged.dispatch();
    }
    setBackgroundColor(color) {
        backgroundDispose(this.scene.background);
        this.scene.background = new Color(color);
        this.signals.backgroundChanged.dispatch();
    }
    setBackgroundColorAlpha(color, alpha) {
        backgroundDispose(this.scene.background);
        this.scene.background = null;
        this.renderer.setClearColor(new Color(color), alpha);
        this.signals.backgroundChanged.dispatch();
    }
    async setBackgroundImage(imgUrl) {
        const texture = await getTexture({ file: imgUrl, });
        texture.mapping = UVMapping;
        this.scene.background = texture;
        this.signals.backgroundChanged.dispatch();
    }
    setSky(options = {}) {
        const { enabled = true, position = { x: 0, y: 0, z: 0, }, scalar = 450000, turbidity = 10, rayleigh = 3, elevation = 2, azimuth = 180, exposure = 0.6, } = options;
        if (!enabled) {
            this.closeSky();
            return;
        }
        if (!this.sky) {
            this.sky = new Sky();
            this.scene.add(this.sky);
        }
        this.sky.name = 'sky';
        this.sky.position.set(position.x, position.y, position.z);
        this.sky.scale.setScalar(scalar);
        const uniforms = this.sky.material.uniforms;
        uniforms['turbidity'].value = turbidity;
        uniforms['rayleigh'].value = rayleigh;
        uniforms['mieCoefficient'].value = 0.005;
        uniforms['mieDirectionalG'].value = 0.7;
        const sun = new Vector3();
        const phi = deg2Euler(90 - elevation);
        const theta = deg2Euler(azimuth);
        sun.setFromSphericalCoords(1, phi, theta);
        uniforms['sunPosition'].value.copy(sun);
        this.sky.userData.toneMapping = this.renderer.toneMapping;
        this.sky.userData.toneMappingExposure = this.renderer.toneMappingExposure;
        this.renderer.toneMapping = ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = exposure;
        this.signals.objectAdded.dispatch();
        return this.sky;
    }
    closeSky() {
        if (!this.sky)
            return false;
        const { toneMapping, toneMappingExposure, } = this.sky.userData;
        this.renderer.toneMapping = toneMapping;
        this.renderer.toneMappingExposure = toneMappingExposure;
        this.sky.removeFromParent();
        this.sky = null;
        this.signals.objectRemoved.dispatch();
        return true;
    }
    screenshot() {
        return new Promise((resolve) => {
            this.renderer.domElement.toBlob(blob => {
                resolve(blob);
            });
        });
    }
    /**
     ***************************** environment ***************************
     */
    async setEnvironment(options) {
        if (options) {
            const { path, file, background, } = options;
            const texture = await getTexture({ path, file, });
            this.scene.environment = texture;
            if (background) {
                backgroundDispose(this.scene.background);
                this.scene.background = texture;
            }
        }
        else {
            this.scene.environment = this.pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }
        this.signals.sceneChanged.dispatch();
        return this.scene.environment;
    }
    /**
     ***************************** modelAnimation ***************************
     */
    playModelAnimation(model, animation) {
        let findClip;
        if (animation instanceof AnimationClip)
            findClip = animation;
        else if (isNumber(animation))
            findClip = model.animations[animation];
        else if (isFunction(animation))
            findClip = model.animations.find(animation);
        if (!findClip)
            return;
        const clipAction = this.mixer.clipAction(findClip, model);
        const aniOperate = $e(clipAction);
        aniOperate.play();
        this.clipsSet.add(findClip);
        return aniOperate;
    }
    stopModelAnimation(model, animation) {
        var _a;
        let findClip;
        if (animation instanceof AnimationClip)
            findClip = animation;
        else if (isNumber(animation))
            findClip = model.animations[animation];
        else if (isFunction(animation))
            findClip = model.animations.find(animation);
        if (!findClip)
            return;
        (_a = this.mixer.existingAction(findClip)) === null || _a === void 0 ? void 0 : _a.stop();
        this.mixer.uncacheAction(findClip, model);
        this.clipsSet.delete(findClip);
    }
    /**
     ***************************** render ***************************
     */
    async render(fn) {
        await (fn === null || fn === void 0 ? void 0 : fn());
        return new Promise((resolve) => {
            this.signals.sceneRendered.addOnce(resolve);
            this.triggerRender();
        });
    }
    /**
     * 触发渲染
     * @param count
     */
    triggerRender(count = 1) {
        this.state.useFreq = count;
    }
    /**
     * 暂停渲染
     * @param pause
     */
    async setPauseRender(pause = true) {
        this.state.isPausedRender = pause;
        if (pause === false) {
            return this.render();
        }
    }
    /**
     * effect passes
     */
    _passesObserver() {
        this.effectManager.updateEffectPass();
    }
    /**
     * 每帧都会被执行
     * @param time
     * @returns
     */
    autoRender(time) {
        if (this.state.useFreq <= 0 && !innerRenderState.needsUpdate)
            return;
        if (this.state.useFreq > 0)
            this.state.useFreq--;
        if (innerRenderState.needsUpdate)
            innerRenderState.needsUpdate = false;
        if (this.state.isPausedRender)
            return;
        renderStartTime = performance.now();
        this.signals.beforeRender.dispatch();
        this._passesObserver();
        if (this.state.enabledPostprocessing) {
            this.effectComposer.render();
        }
        else {
            this.renderer.clear();
            this.renderer.render(this.scene, this.camera);
        }
        const beforeAutoUpdate = this.scene.matrixWorldAutoUpdate;
        /**
         * 取消多余计算
         */
        this.scene.matrixWorldAutoUpdate = false;
        // CSS renderer
        if (this.rendererCSS2D &&
            this.rendererManager.internalOptions.enableRenderCss2D) {
            this.rendererCSS2D.render(this.scene, this.camera);
        }
        if (this.rendererCSS3D &&
            this.rendererManager.internalOptions.enableRenderCss3D) {
            this.rendererCSS3D.render(this.scene, this.camera);
        }
        this.scene.matrixWorldAutoUpdate = beforeAutoUpdate;
        if (this.options.showViewHelper && this.camera === this.cameraManager.mainCamera) {
            this.viewHelper.render(this.renderer);
        }
        /**
         * 显示水印
         */
        if (!this.license.getVerified()) {
            this.waterMark.render();
        }
        this.postRender.forEach((fn) => fn(time));
        renderEndTime = performance.now();
        this.signals.sceneRendered.dispatch(renderEndTime - renderStartTime);
    }
    animate(time) {
        this._loop = requestAnimationFrame((time) => {
            this.animate(time);
        });
        const delta = this.clock.getDelta();
        if (this.clipsSet.size > 0) {
            this.mixer.update(delta);
            this.signals.modelAnimation.dispatch();
        }
        if (exports.update())
            this.signals.tweenUpdate.dispatch();
        this.postUpdate.forEach((fn) => fn(time));
        this.autoRender(time);
        this.signals.getSceneInfo.dispatch(this.info.state);
    }
    getOffsetByPosition(position) {
        const vector = new Vector3(position.x, position.y, position.z);
        const vectorProject = vector.project(this.camera);
        const rect = this.renderer.domElement.getBoundingClientRect();
        const left = Math.round(rect.left + (rect.width / 2) * (vectorProject.x + 1));
        const top = Math.round(rect.top + (rect.height / 2) * (-vectorProject.y + 1));
        return {
            left,
            top,
        };
    }
    getPositionByOffset(offset, z = 0.1) {
        const position = new Vector3(0, 0, 0);
        const vector = new Vector3(0, 0, 0);
        const rect = this.renderer.domElement.getBoundingClientRect();
        vector.set((offset.offsetX / rect.width) * 2 - 1, (-offset.offsetY / rect.height) * 2 + 1, z);
        vector.unproject(this.camera);
        vector.sub(this.camera.position).normalize();
        const distance = vector.distanceTo(this.camera.position);
        position.copy(this.camera.position).add(vector.multiplyScalar(distance));
        /**关于屏幕取点的另一个算法 */
        // const plane = new THREE.Plane().applyMatrix4(this.scene.matrixWorld)
        // const pPosition = plane.coplanarPoint(new THREE.Vector3())
        return position;
    }
    getIntersects(event, objects = this.scener.intersectsList.getAll(), options = {}) {
        const { isFilterHideObject = true, } = options;
        const rect = this.container.getBoundingClientRect();
        let offsetPoint = {
            offsetX: 0,
            offsetY: 0,
        };
        if (event instanceof MouseEvent) {
            offsetPoint = {
                offsetX: event.clientX - rect.left,
                offsetY: event.clientY - rect.top,
            };
        }
        else if (event instanceof TouchEvent) {
            const touch = event.changedTouches[0];
            offsetPoint = {
                offsetX: touch.clientX - rect.left,
                offsetY: touch.clientY - rect.top,
            };
        }
        else {
            offsetPoint = event;
        }
        const mouse = new Vector2();
        // normailzed
        mouse.set((offsetPoint.offsetX / rect.width) * 2 - 1, -(offsetPoint.offsetY / rect.height) * 2 + 1);
        this.raycaster.setFromCamera(mouse, this.camera);
        let intersectObjects = [];
        if (isArray(objects)) {
            intersectObjects = this.raycaster.intersectObjects(objects, true);
        }
        else {
            intersectObjects = this.raycaster.intersectObject(objects, true);
        }
        /**
         * 是否过滤隐藏对象
         */
        if (isFilterHideObject) {
            return intersectObjects.filter(({ object, }) => isObjectVisible(object));
        }
        return intersectObjects;
    }
    rayClash(startPoint = this.camera.position, dir = new Vector3(0, -1, 0), objects = this.scener.intersectsList.meshOfModelList) {
        const raycaster = new Raycaster();
        raycaster.set(startPoint, dir);
        if (isArray(objects))
            return raycaster.intersectObjects(objects, true);
        else
            return raycaster.intersectObject(objects, true);
    }
    setHoverEnabled(enabled) {
        this.options.hoverEnabled = enabled;
    }
    clearSignals() {
        for (const i in this.signals)
            this.signals[i].removeAll();
    }
    dispose() {
        cancelAnimationFrame(this._loop);
        // bvh
        this.bvh.dispose();
        // animations
        this.mixer.stopAllAction();
        this.clipsSet.forEach(clip => {
            this.mixer.uncacheAction(clip);
            this.mixer.uncacheClip(clip);
        });
        this.mixer.uncacheRoot(this.scene);
        this.clipsSet.clear();
        // controls
        this.controls.dispose();
        // tween
        exports.removeAll();
        // signals
        this.clearSignals();
        // scene
        this.scene.clear();
        this.pmremGenerator.dispose();
        // composer
        this.effectComposer.dispose();
        // renderer
        this.renderer.dispose();
        this.renderer.forceContextLoss();
        // dom container
        this.container.remove();
        this.state.isDisposed = true;
    }
    _signalsEventListenr() {
        const windowResizeChange = () => {
            const { offsetWidth, offsetHeight, } = this.container;
            // passes
            this.effectManager.updateCamera(this.camera);
            this.camera.aspect = offsetWidth / offsetHeight;
            this.camera.updateProjectionMatrix();
            // this.renderer.setSize( offsetWidth, offsetHeight )
            this.effectComposer.setSize(offsetWidth, offsetHeight);
            if (this.rendererCSS3D) {
                this.rendererCSS3D.setSize(offsetWidth, offsetHeight);
            }
            if (this.rendererCSS2D) {
                this.rendererCSS2D.setSize(offsetWidth, offsetHeight);
            }
            this.triggerRender();
        };
        setTimeout(() => windowResizeChange());
        // window
        this.signals.windowResize.add(windowResizeChange);
        this.signals.cameraObjectChange.add(windowResizeChange);
        // scene
        this.signals.sceneChanged.add(() => this.triggerRender());
        this.signals.backgroundChanged.add(() => this.triggerRender());
        // object
        this.signals.objectAdded.add(() => this.triggerRender());
        this.signals.objectRemoved.add(() => this.triggerRender());
        this.signals.objectChanged.add(() => this.triggerRender());
        // material
        this.signals.materialAdded.add(() => this.triggerRender());
        this.signals.materialRemoved.add(() => this.triggerRender());
        this.signals.materialChanged.add(() => this.triggerRender());
        // geometry
        this.signals.geometryChanged.add(() => this.triggerRender());
        // camera
        this.signals.cameraChange.add(() => this.triggerRender());
        // tween
        this.signals.tweenUpdate.add(() => this.triggerRender());
        // modelAnimation
        this.signals.modelAnimation.add(() => this.triggerRender());
        const outlineChange = (param) => {
            const defaultOption = {
                color: 0xffffff,
                hideColor: 0x999999,
                edgeThickness: 3,
                edgeStrength: 10,
            };
            const { objects, options, } = param;
            const { color, hideColor, edgeThickness, edgeStrength, } = Object.assign(Object.assign({}, defaultOption), options);
            const { effectManager, } = this;
            const outlineEffectState = effectManager.effectsMap.get(EffectManager.CONSTANTS.outlineEffect);
            const enabled = objects.length > 0;
            if (outlineEffectState.enabled !== enabled) {
                outlineEffectState.enabled = enabled;
                effectManager.effectsNeedsUpddate = true;
            }
            const { effect, } = outlineEffectState;
            const { uniforms, } = effect;
            const meshes = [];
            objects.forEach((object) => {
                object.traverse(child => {
                    if (child instanceof Mesh)
                        meshes.push(child);
                });
            });
            effect.selection.set(meshes);
            // blurriness
            effect.blur = (edgeThickness > 0);
            effect.blurPass.kernelSize = edgeThickness;
            // uniforms
            const visibleEdgeColorUniform = uniforms.get('visibleEdgeColor');
            const hiddenEdgeColorUniform = uniforms.get('hiddenEdgeColor');
            const edgeStrengthUniform = uniforms.get('edgeStrength');
            if (visibleEdgeColorUniform)
                visibleEdgeColorUniform.value.set(color);
            if (hiddenEdgeColorUniform)
                hiddenEdgeColorUniform.value.set(hideColor);
            if (edgeStrengthUniform)
                edgeStrengthUniform.value = edgeStrength;
            this.triggerRender();
        };
        // outline
        this.signals.outlineChange.add(outlineChange);
    }
    _containerAddEventListener(container) {
        // 双击时最大间隔时长限制
        const dblClickMaxInterval = 300;
        /**
         * PC
         */
        // 在 pc 端连续俩次 mouseDown 的时间戳
        // 俩次相减时间差 与 dblClickMaxInterval 比较得出是否为双击行为
        const mouseDownTimes = [0, 0];
        // 记录 mouseDown 事件属性, 与 mouseUp 比较鼠标在屏幕上的你偏移量，来区分点击交互还是场景相机交互
        let mouseDownEvent = null;
        const onMouseDown = (event) => {
            mouseDownEvent = event;
            this.signals.mouseDown.dispatch(event);
            // 记录鼠标按下时时间戳, 最多记录俩次
            if (mouseDownTimes[0] === 0)
                mouseDownTimes[0] = performance.now();
            else if (mouseDownTimes[1] === 0)
                mouseDownTimes[1] = performance.now();
            container.addEventListener('mouseup', onMouseUp, false);
        };
        const onMouseMove = (event) => {
            this.signals.mouseMove.dispatch(event);
            if (this.options.hoverEnabled)
                this._triggerSceneEventInAllObject('hover', event);
        };
        const onMouseUp = (event) => {
            var _a, _b;
            this.signals.mouseUp.dispatch(event);
            // 计算鼠标偏移量
            const movementX = event.offsetX - ((_a = mouseDownEvent === null || mouseDownEvent === void 0 ? void 0 : mouseDownEvent.offsetX) !== null && _a !== void 0 ? _a : 0);
            const movementY = event.offsetY - ((_b = mouseDownEvent === null || mouseDownEvent === void 0 ? void 0 : mouseDownEvent.offsetY) !== null && _b !== void 0 ? _b : 0);
            if (Math.abs(movementX) > 2 || Math.abs(movementY) > 2) {
                // 清空 mouseDown 的时间戳，防止鼠标移动后下次点击判断错误。
                mouseDownTimes[0] = 0;
                mouseDownTimes[1] = 0;
                return;
            }
            setTimeout(() => {
                // 只有单次时间戳记录，被判定为单击事件
                if (mouseDownTimes[0] !== 0 && mouseDownTimes[1] === 0) {
                    // 左键单击
                    if (event.button === 0) {
                        this.signals.click.dispatch(event);
                        this._triggerSceneEventInAllObject('click', event);
                    }
                    // 右键单击
                    else if (event.button === 2) {
                        this.signals.rightClick.dispatch(event);
                        this._triggerSceneEventInAllObject('rightClick', event);
                    }
                }
                // 清空 mouseDown 的时间戳，防止鼠标移动后下次点击判断错误。
                mouseDownTimes[0] = 0;
                mouseDownTimes[1] = 0;
            }, dblClickMaxInterval);
            container.removeEventListener('mouseup', onMouseUp, false);
        };
        const onDblclick = (event) => {
            this.signals.dblClick.dispatch(event);
            this._triggerSceneEventInAllObject('dblClick', event);
        };
        const onMouseWheel = (event) => {
            this.signals.mouseWheel.dispatch(event);
        };
        /**
         * Mobile
         */
        // touch 长按时最大间隔时长限制
        const touchLongUpMaxInterval = 800;
        // 在 mobile 端以手指长按替代 pc 端鼠标右键点击
        // 是否 touch 事件长按（ 别名 touch 右键点击 ）
        let isTouchLongPressAsTouchRightClick = false;
        // 长按定时器
        let timer = null;
        let touchStartEvent = null;
        // 在 mobile 端连续俩次 mouseDown 的时间戳，
        // 俩次相减于 dblClickMaxInterval 比较得出是否为双击行为
        const touchstartTimes = [0, 0];
        const onTouchStart = (event) => {
            if (touchstartTimes[0] === 0)
                touchstartTimes[0] = performance.now();
            else if (touchstartTimes[1] === 0)
                touchstartTimes[1] = performance.now();
            touchStartEvent = event;
            timer && clearTimeout(timer);
            timer = setTimeout(() => {
                isTouchLongPressAsTouchRightClick = true;
            }, touchLongUpMaxInterval);
            container.addEventListener('touchend', onTouchEnd, { once: true, });
        };
        const onTouchEnd = (event) => {
            var _a, _b;
            timer && clearTimeout(timer);
            /**
             * 重置状态记录
             */
            const resetTouchesState = () => {
                isTouchLongPressAsTouchRightClick = false;
                touchstartTimes[0] = 0;
                touchstartTimes[1] = 0;
            };
            // 计算偏移量
            const movementX = event.changedTouches[0].clientX -
                ((_a = touchStartEvent === null || touchStartEvent === void 0 ? void 0 : touchStartEvent.changedTouches[0].clientX) !== null && _a !== void 0 ? _a : 0);
            const movementY = event.changedTouches[0].clientY -
                ((_b = touchStartEvent === null || touchStartEvent === void 0 ? void 0 : touchStartEvent.changedTouches[0].clientY) !== null && _b !== void 0 ? _b : 0);
            if (Math.abs(movementX) > 2 || Math.abs(movementY) > 2) {
                resetTouchesState();
                return;
            }
            // 手指长按
            if (isTouchLongPressAsTouchRightClick) {
                resetTouchesState();
                this.signals.rightClick.dispatch(event);
                this._triggerSceneEventInAllObject('rightClick', event);
            }
            else {
                setTimeout(() => {
                    if (touchstartTimes[0] !== 0 && touchstartTimes[1] === 0) {
                        this.signals.click.dispatch(event);
                        this._triggerSceneEventInAllObject('click', event);
                    }
                    else if (touchstartTimes[0] !== 0 &&
                        touchstartTimes[1] !== 0 &&
                        touchstartTimes[1] - touchstartTimes[0] <= dblClickMaxInterval) {
                        this.signals.dblClick.dispatch(event);
                        this._triggerSceneEventInAllObject('dblClick', event);
                    }
                    resetTouchesState();
                }, dblClickMaxInterval);
            }
        };
        /**
         * key event
         */
        const onKeyDown = (event) => {
            this.signals.keyDown.dispatch(event);
        };
        const onKeyUp = (event) => {
            this.signals.keyUp.dispatch(event);
        };
        container.addEventListener('mousedown', onMouseDown, false);
        container.addEventListener('mousemove', onMouseMove, false);
        container.addEventListener('dblclick', onDblclick, false);
        container.addEventListener('wheel', onMouseWheel, { passive: true, });
        container.addEventListener('touchstart', onTouchStart, { passive: true, });
        container.addEventListener('contextmenu', (event) => event.preventDefault(), false);
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
    }
    /**
     * 触发场景交互事件
     * @param {SceneEventType}          eventType 事件类型 hover | click | dblClick | rightClick
     * @param {MouseEvent | TouchEvent} event     鼠标事件对象 或 触摸事件对象
     */
    _triggerSceneEventInAllObject(eventType, event) {
        // 获取到事件所有交叉对象
        const intersects = this.getIntersects(event, this.scener.intersectsList.getAll());
        // 如果射线没有与任何对象相交
        if (intersects.length === 0) {
            // 有上次 modelHover 记录模型
            if (this.selectModel && this.signals.modelHover.numListeners > 0) {
                this.signals.modelUnHover.dispatch(this.selectModel);
            }
            // 有上次 poiHover 记录模型
            if (this.selectPoi && this.signals.poiHover.numListeners > 0) {
                this.signals.poiUnHover.dispatch(this.selectPoi);
            }
            this.selectModel = null;
            this.selectPoi = null;
            this.signals.sceneClick.dispatch({
                type: eventType,
                event,
            });
            return;
        }
        // 第一个交叉对象
        const firstIntersect = {
            object: null,
            type: null,
            point: null,
        };
        // 交叉对象的所有 Poi 对象
        const poiIntersects = [];
        // 交叉对象的所有 Model 对象
        const modelIntersects = [];
        function findModelTarget(object) {
            if (object.parent) {
                if (object.parent.stype === 'Model')
                    return object.parent;
                else
                    return findModelTarget(object.parent);
            }
            else
                return;
        }
        // 开始过滤未隐藏且属于 Poi 和 Model 的对象。
        intersects.forEach((intersect) => {
            // Poi
            if (intersect.object.parent instanceof Poi) {
                const poi = intersect.object.parent;
                if (!firstIntersect.object) {
                    firstIntersect.type = 'Poi';
                    firstIntersect.object = intersect.object;
                    firstIntersect.point = intersect.point;
                }
                const index = poiIntersects.findIndex((fi) => fi.poi.uuid === poi.uuid);
                if (index === -1)
                    poiIntersects.push({ poi, sourceData: intersect, });
            }
            // Model
            else if (intersect.object instanceof Object3D) {
                const model = findModelTarget(intersect.object);
                if (model) {
                    if (!firstIntersect.object) {
                        firstIntersect.type = 'Model';
                        firstIntersect.object = intersect.object;
                        firstIntersect.point = intersect.point;
                    }
                    modelIntersects.push({ model, sourceData: intersect, });
                }
            }
        });
        // 触发 selectPosition
        if (eventType === 'click' && firstIntersect.point)
            this.signals.selectPosition.dispatch(firstIntersect.point);
        // 事件类型值首字母转大写
        const newEventType = eventType.slice(0, 1).toUpperCase() + eventType.slice(1);
        // 触发模型事件
        const triggerModelEvent = (modelIntersects) => {
            var _a;
            const { model: target, } = modelIntersects[0];
            if (target) {
                if (newEventType === 'Hover') {
                    if (((_a = this.selectModel) === null || _a === void 0 ? void 0 : _a.uuid) !== target.uuid) {
                        this.signals.modelHover.dispatch({
                            target,
                            currentTarget: firstIntersect.object,
                            intersects: modelIntersects,
                            event,
                        });
                        // 存储新的选中模型
                        this.selectModel = target;
                    }
                }
                else {
                    // 准备要触发的模型事件
                    let targetEvent = null;
                    // 根据事件类型确定对应模型事件函数
                    if (newEventType === 'Click') {
                        targetEvent = target.onClick;
                        target.dispatchEvent({ type: 'click', });
                    }
                    else if (newEventType === 'RightClick') {
                        targetEvent = target.onRightClick;
                        target.dispatchEvent({ type: 'rightClick', });
                    }
                    else if (newEventType === 'DblClick') {
                        targetEvent = target.onDblClick;
                        target.dispatchEvent({ type: 'dblClick', });
                    }
                    // 模型事件函数存在
                    if (targetEvent)
                        targetEvent(target);
                    // 如果没绑定对应模型事件, 冒泡一次
                    else
                        target.isEventPropagation = true;
                    // 允许冒泡到全局事件
                    if (target.isEventPropagation) {
                        this.signals[`model${newEventType}`].dispatch({
                            target,
                            currentTarget: firstIntersect.object,
                            intersects: modelIntersects,
                            event,
                        });
                        target.isEventPropagation = false;
                    }
                }
            }
        };
        // 触发 Poi 事件
        const triggerPoiEvent = (intersects) => {
            var _a;
            const { poi: target, } = intersects[0];
            if (target) {
                if (newEventType === 'Hover') {
                    if (((_a = this.selectPoi) === null || _a === void 0 ? void 0 : _a.uuid) !== target.uuid) {
                        this.signals.poiHover.dispatch({ target, event, });
                        // 存储新的选中 Poi
                        this.selectPoi = target;
                    }
                }
                else {
                    let targetEvent = null;
                    if (newEventType === 'Click') {
                        targetEvent = target.onClick;
                        target.dispatchEvent({ type: 'click', });
                    }
                    else if (newEventType === 'RightClick') {
                        targetEvent = target.onRightClick;
                        target.dispatchEvent({ type: 'rightClick', });
                    }
                    else if (newEventType === 'DblClick') {
                        targetEvent = target.onDblClick;
                        target.dispatchEvent({ type: 'dblClick', });
                    }
                    // Poi 事件函数存在
                    if (targetEvent)
                        targetEvent(target);
                    // 如果没绑定对应 Poi 事件, 冒泡一次
                    else
                        target.isEventPropagation = true;
                    // 允许冒泡到全局事件
                    if (target.isEventPropagation) {
                        this.signals[`poi${newEventType}`].dispatch({ target, event, });
                        target.isEventPropagation = false;
                    }
                }
            }
        };
        /**
         * 判断 un hover
         */
        if (newEventType === 'Hover') {
            if (modelIntersects.length > 0) {
                const [{ model, }] = modelIntersects;
                if (this.selectModel && this.selectModel.uuid !== model.uuid) {
                    this.signals.modelUnHover.dispatch(this.selectModel);
                    this.selectModel = null;
                }
            }
            if (poiIntersects.length > 0) {
                const [{ poi, }] = poiIntersects;
                if (this.selectPoi && this.selectPoi.uuid !== poi.uuid) {
                    this.signals.poiUnHover.dispatch(this.selectPoi);
                    this.selectPoi = null;
                }
            }
        }
        // 如果第一个交叉对象类型是 Model 就触发模型事件
        if (firstIntersect.type === 'Model') {
            triggerModelEvent(modelIntersects);
        }
        // 如果第一个交叉对象类型是 Poi 就触发 Poi 事件
        else if (firstIntersect.type === 'Poi') {
            triggerPoiEvent(poiIntersects);
        }
    }
}

class BaseMesh extends Mesh {
    constructor(geometry, material, param, type = 'BaseMesh') {
        super(geometry, material);
        const { id, name = '', level = { max: null, min: null, }, visible = true, position = { x: 0, y: 0, z: 0, }, rotation = { x: 0, y: 0, z: 0, }, scale = { x: 1, y: 1, z: 1, }, userData = {}, } = param;
        if (id === undefined)
            throw new Error('In soonspacejs: 空间对象实例化失败，缺少必要字段 \'id\'！');
        this.sid = id;
        this.name = name;
        this.stype = type;
        this.level = level;
        this.visible = visible !== null && visible !== void 0 ? visible : true;
        this.handleHide = !visible;
        this.position.set(position.x, position.y, position.z);
        this.rotation.set(rotation.x, rotation.y, rotation.z);
        this.scale.set(scale.x, scale.y, scale.z);
        this.castShadow = true;
        this.receiveShadow = true;
        this.userData = userData;
        this.isEventPropagation = false;
        this.autoUpdate = false;
    }
    show() {
        this.visible = true;
        this.handleHide = false;
        this.autoUpdate = true;
        innerRenderState.needsUpdate = true;
    }
    hide() {
        this.visible = false;
        this.handleHide = true;
        this.autoUpdate = true;
        innerRenderState.needsUpdate = true;
    }
    setMove(position, options, onUpdate, onStart) {
        return Animation(this.position, IVector3ToVector3(position), options, onUpdate, onStart);
    }
    setRotate(rotation, options, onUpdate, onStart) {
        const euler = IVector3ToEuler(rotation);
        const sourceQuaternion = this.quaternion.clone();
        const targetQuaternion = new Quaternion().setFromEuler(euler);
        return Animation({ t: 0, }, { t: 1, }, options, ({ t, }, tween) => {
            this.quaternion.slerpQuaternions(sourceQuaternion, targetQuaternion, t);
            onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(this.rotation, tween);
        }, onStart);
    }
    setScale(scale, options, onUpdate, onStart) {
        return Animation(this.scale, IVector3ToVector3(scale), options, onUpdate, onStart);
    }
    getBoundingBox() {
        return getBoundingBox(this);
    }
    eventPropagation() {
        this.isEventPropagation = true;
    }
    sClone(recursive) {
        return new BaseMesh(this.geometry, this.material, { id: `clone_${randomString()}`, }).sCopy(this, recursive);
    }
    sCopy(source, recursive = true) {
        this.name = source.name;
        // this.sid = source.sid
        this.stype = source.stype;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.geometry = source.geometry;
        this.material = source.material;
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
            for (let i = 0; i < source.children.length; i++) {
                if (source.children[i] instanceof BaseObject3D ||
                    source.children[i] instanceof BaseMesh) {
                    this.add(source.children[i].sClone());
                }
                else {
                    this.add(source.children[i].clone());
                }
            }
        }
        return this;
    }
}

const defaultParam$1 = {
    onLoad: null,
    onClick: null,
    onDblClick: null,
    onRightClick: null,
};
class BaseObject3D extends Object3D {
    constructor(params, type = 'BaseObject3D') {
        super();
        const { id, name = '', level = { max: null, min: null, }, visible = true, position = { x: 0, y: 0, z: 0, }, rotation = { x: 0, y: 0, z: 0, }, scale = { x: 1, y: 1, z: 1, }, userData = {}, onLoad, onClick, onDblClick, onRightClick, } = Object.assign(Object.assign({}, defaultParam$1), params);
        if (id === undefined)
            throw new Error('In soonspacejs: 空间对象实例化失败，缺少必要字段 \'id\'！');
        this.sid = id;
        this.name = name;
        this.stype = type;
        this.level = level;
        this.visible = visible !== null && visible !== void 0 ? visible : true;
        this.handleHide = !visible;
        this.isEventPropagation = false;
        this.position.set(position.x, position.y, position.z);
        this.rotation.set(rotation.x, rotation.y, rotation.z);
        this.scale.set(scale.x, scale.y, scale.z);
        this.castShadow = true;
        this.receiveShadow = true;
        this.userData = userData;
        this.autoUpdate = false;
        this.onLoad = (onLoad === null || onLoad === void 0 ? void 0 : onLoad.bind(this)) || null;
        this.onClick = (onClick === null || onClick === void 0 ? void 0 : onClick.bind(this)) || null;
        this.onDblClick = (onDblClick === null || onDblClick === void 0 ? void 0 : onDblClick.bind(this)) || null;
        this.onRightClick = (onRightClick === null || onRightClick === void 0 ? void 0 : onRightClick.bind(this)) || null;
    }
    eventPropagation() {
        this.isEventPropagation = true;
    }
    show() {
        this.visible = true;
        this.handleHide = false;
        this.autoUpdate = true;
        innerRenderState.needsUpdate = true;
    }
    hide() {
        this.visible = false;
        this.handleHide = true;
        this.autoUpdate = true;
        innerRenderState.needsUpdate = true;
    }
    setMove(position, options, onUpdate, onStart) {
        return Animation(this.position, IVector3ToVector3(position), options, onUpdate, onStart);
    }
    setRotate(rotation, options, onUpdate, onStart) {
        const euler = IVector3ToEuler(rotation);
        const sourceQuaternion = this.quaternion.clone();
        const targetQuaternion = new Quaternion().setFromEuler(euler);
        return Animation({ t: 0, }, { t: 1, }, options, ({ t, }, tween) => {
            this.quaternion.slerpQuaternions(sourceQuaternion, targetQuaternion, t);
            onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(this.rotation, tween);
        }, onStart);
    }
    setScale(scale, options, onUpdate, onStart) {
        return Animation(this.scale, IVector3ToVector3(scale), options, onUpdate, onStart);
    }
    sClone(recursive) {
        return new BaseObject3D({ id: `clone_${randomString()}`, }).sCopy(this, recursive);
    }
    sCopy(source, recursive = true) {
        this.name = source.name;
        // this.sid = source.sid
        this.stype = source.stype;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.animations = source.animations;
        if (recursive === true) {
            for (let i = 0; i < source.children.length; i++) {
                const child = source.children[i];
                if (child instanceof BaseObject3D ||
                    child instanceof BaseMesh) {
                    this.add(child.sClone());
                }
                else {
                    this.add(child.clone());
                }
            }
        }
        return this;
    }
    getBoundingBox() {
        return getBoundingBox(this);
    }
    getSpaceAttribute(isFromWorld = true) {
        return getSpaceAttributeFromObject(this, isFromWorld);
    }
    syncSpaceAttribute(object, isFromWorld = true) {
        if (object instanceof BaseObject3D) {
            syncSpaceAttributeToObject(this, object, isFromWorld);
        }
        else {
            warn('In soonspacejs: BaseObject3D 对象原型方法 \'syncSpaceAttribute\' 第一个参数对象类型错误!');
        }
    }
}

class Group extends BaseObject3D {
    constructor(param) {
        super(param, 'Group');
    }
    showAllChild() {
        this.children.forEach(child => {
            if (child instanceof BaseObject3D)
                child.show();
        });
    }
    hideAllChild() {
        this.children.forEach(child => {
            if (child instanceof BaseObject3D)
                child.hide();
        });
    }
}

class PluginObject extends BaseObject3D {
    constructor(param) {
        super(param, 'PluginObject');
    }
}

class PoiNode extends BaseObject3D {
    constructor(params) {
        super(params, 'PoiNode');
        const { type, element, elementAutoDisplay = true, occlude = false, onChange, } = params;
        this.elementType = type;
        this.element = element;
        this.elementAutoDisplay = elementAutoDisplay;
        this.occlude = occlude;
        this.onChange = onChange;
        this.create(type);
    }
    create(type) {
        if (type === '2D' || type === '2d') {
            this._create2D();
        }
        else if (type === '2.5D' || type === '2.5d') {
            this._create2DHalf();
        }
        else if (type === '3D' || type === '3d') {
            this._create3D();
        }
    }
    show() {
        this.visible = true;
        this.handleHide = false;
        this.autoUpdate = true;
    }
    hide() {
        this.visible = false;
        this.handleHide = true;
        this.autoUpdate = true;
    }
    getBoundingBox(padding = 50) {
        padding = padding <= 0 ? 50 : padding;
        const min = new Vector3();
        const max = new Vector3();
        const offsetVec = new Vector3(padding, padding, padding);
        min.copy(this.position);
        max.copy(this.position);
        min.sub(offsetVec);
        max.add(offsetVec);
        return new Box3(min, max);
    }
    _create2D() {
        this.add(new CSS2DObject(this.element));
    }
    _create2DHalf() {
        this.add(new CSS3DSprite(this.element));
    }
    _create3D() {
        this.add(new CSS3DObject(this.element));
    }
}

class Model extends BaseObject3D {
    constructor(param) {
        super(param, 'Model');
        const { format, } = param;
        this.formatType = format;
    }
    setEnvMap(dirPath, fileNames = ['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'], options = {}) {
        getTexture({ path: dirPath, file: fileNames, })
            .then((cubeTexture) => {
            this.traverse((child) => {
                if (child instanceof Mesh && child.material instanceof MeshStandardMaterial) {
                    const { reflectivity = 0.5, } = options;
                    child.material.envMap = cubeTexture;
                    child.material.envMapIntensity = reflectivity;
                    innerRenderState.needsUpdate = true;
                }
            });
        });
    }
    sClone(recursive) {
        return new Model({ id: `${this.sid}_clone`, url: '', format: this.formatType, }).sCopy(this, recursive);
    }
}

const defaultParam = {
    position: { x: 0, y: 0, z: 0, },
    scale: { x: 16, y: 16, z: 1, },
    stype: 'Icon',
};
class Icon extends Sprite {
    constructor(material, param) {
        super(material);
        const { position, scale, stype, } = Object.assign(Object.assign({}, defaultParam), param);
        this.stype = stype;
        this.position.set(position.x, position.y, position.z);
        this.scale.set(scale.x, scale.y, scale.z);
        this.renderOrder = 1;
    }
}

class Poi extends BaseObject3D {
    constructor(material, param) {
        super(param, 'Poi');
        const { name, type = '2.5d', nameScale = { x: 16, y: 16, z: 1, }, } = param;
        this.iconType = type;
        this.icon = this._createIcon(material);
        const textParam = {
            position: { x: 0, y: 10, z: 0, },
            name,
            scale: nameScale,
        };
        this.text = this.name ? this._createText(textParam) : null;
        this.renderOrder = 11;
    }
    getBoundingBox(padding = 50) {
        padding = padding <= 0 ? 50 : padding;
        const min = new Vector3();
        const max = new Vector3();
        const offsetVec = new Vector3(padding, padding, padding);
        min.copy(this.position);
        max.copy(this.position);
        min.sub(offsetVec);
        max.add(offsetVec);
        return new Box3(min, max);
    }
    sClone(recursive, type) {
        return new Poi(this.icon.material, { id: `${this.sid}_clone`, url: '', type: type !== null && type !== void 0 ? type : this.iconType, name: this.name, }).sCopy(this, recursive);
    }
    _createIcon(material) {
        const icon = new Icon(this._computeMaterialSizeAttenuation(material));
        this.add(icon);
        return icon;
    }
    _createText(info) {
        const material = this._createTextMaterial(info);
        const text = new Icon(this._computeMaterialSizeAttenuation(material), info);
        this.add(text);
        return text;
    }
    _createTextMaterial(info) {
        const canvas = this._createTextCanvas(info.name || '');
        const texture = new Texture(canvas);
        texture.flipY = true;
        texture.version += 1;
        const material = new SpriteMaterial({
            map: texture,
            depthTest: true,
        });
        return material;
    }
    _createTextCanvas(text, info) {
        const defaultParam = {
            fontFamily: 'Microsoft YaHei',
            fontSize: 32,
            color: '#fff',
            textAlign: 'center',
            textBaseline: 'bottom',
        };
        const width = 256;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = width;
        const context = canvas.getContext('2d');
        const { fontFamily, fontSize, color, textAlign, textBaseline, } = Object.assign(Object.assign({}, defaultParam), info);
        const halfWidth = width * 0.5;
        const halfHeight = width * 0.5;
        if (context) {
            context.save();
            context.font = fontSize + 'px ' + fontFamily;
            context.textAlign = textAlign;
            context.textBaseline = textBaseline;
            context.shadowColor = 'black';
            context.strokeStyle = 'black';
            context.lineWidth = 3;
            context.fillStyle = color;
            context.strokeText(text, halfWidth, halfHeight);
            context.fillText(text, halfWidth, halfHeight);
            context.restore();
        }
        return canvas;
    }
    _computeMaterialSizeAttenuation(material) {
        if (this.iconType === '2D' || this.iconType === '2d') {
            material.sizeAttenuation = false;
        }
        else if (this.iconType === '2.5D' || this.iconType === '2.5d') {
            material.sizeAttenuation = true;
        }
        return material;
    }
}

function createGeometry$4(radius) {
    return new SphereGeometry(radius, 32, 32);
}
function createMaterial$4(color, opacity, gradient) {
    return new MeshBasicMaterial({
        color, opacity, transparent: opacity < 1, map: gradientTexture(gradient),
    });
}
class Point extends BaseMesh {
    constructor(param, type = 'Point') {
        const { radius = 10, color = 0xffffff, opacity = 1, gradient, } = param;
        super(createGeometry$4(radius), createMaterial$4(color, opacity, gradient), param, type);
    }
    setOptions(param) {
        const { color, opacity, radius, position, gradient, } = param;
        const material = this.material;
        if (color)
            material.color = new Color(color);
        if (opacity)
            material.opacity = opacity;
        if (radius)
            this.geometry = new SphereGeometry(radius, 32, 32);
        if (position)
            this.position.copy(IVector3ToVector3(position));
        if (gradient)
            material.map = gradientTexture(gradient);
        material.needsUpdate = true;
        innerRenderState.needsUpdate = true;
    }
}

class Node extends Point {
    constructor(param) {
        super(param, 'Node');
        this.graphs = param.graphs;
    }
}

function createGeometry$3(radius) {
    return new CircleGeometry(radius, 64);
}
function createMaterial$3(color, opacity, gradient) {
    return new MeshBasicMaterial({
        color, opacity, transparent: opacity < 1, side: DoubleSide, map: gradientTexture(gradient),
    });
}
class Circle extends BaseMesh {
    constructor(param) {
        const { radius = 50, color = 0xffffff, opacity = 1, gradient, } = param;
        super(createGeometry$3(radius), createMaterial$3(color, opacity, gradient), param, 'Circle');
        this.rotation.set(Math.PI / 2, 0, 0);
    }
    setOptions(params) {
        const { color, opacity, radius, position, gradient, } = params;
        const material = this.material;
        if (color)
            material.color = new Color(color);
        if (opacity)
            material.opacity = opacity;
        if (radius)
            this.geometry = new CircleGeometry(radius, 64);
        if (position)
            this.position.copy(IVector3ToVector3(position));
        if (gradient)
            material.map = gradientTexture(gradient);
        material.needsUpdate = true;
        innerRenderState.needsUpdate = true;
    }
}

function createGeometry$2(start, end, width, up = new Vector3(0, 1, 0)) {
    const widthHalf = width / 2;
    const v2 = new Vector3();
    const v3 = new Vector3();
    v2.subVectors(end, start);
    v2.normalize();
    v3.crossVectors(v2, up);
    if (v3.length() === 0) {
        v3.crossVectors(v2, new Vector3(0, 0, -1));
    }
    const direct1 = new Vector3(v3.x * widthHalf, v3.y * widthHalf, v3.z * widthHalf);
    const direct2 = new Vector3(-v3.x * widthHalf, -v3.y * widthHalf, -v3.z * widthHalf);
    const new1 = new Vector3();
    new1.addVectors(start, direct1);
    const new2 = new Vector3();
    new2.addVectors(start, direct2);
    const new3 = new Vector3();
    new3.addVectors(end, direct2);
    const new4 = new Vector3();
    new4.addVectors(end, direct1);
    const geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute([
        new1.x, new1.y, new1.z,
        new2.x, new2.y, new2.z,
        new3.x, new3.y, new3.z,
        new3.x, new3.y, new3.z,
        new4.x, new4.y, new4.z,
        new1.x, new1.y, new1.z
    ], 3));
    geometry.setAttribute('uv', new Float32BufferAttribute([
        0, 0,
        1, 0,
        1, 1,
        1, 1,
        0, 1,
        0, 0
    ], 2));
    return geometry;
}
function createMaterial$2(pointDist, width, color, opacity, imgUrl, animation) {
    const transparent = typeof opacity !== 'undefined' ? opacity < 1 : false;
    const material = new MeshBasicMaterial({
        color,
        side: DoubleSide,
        transparent,
        opacity,
    });
    let texture;
    if (imgUrl) {
        texture = new TextureLoader().load(imgUrl, map => {
            texture.repeat.set(1, pointDist / (width * (map.image.height / map.image.width)) * 0.63 * (map.image.height / map.image.height));
            material.color.set(0xffffff);
        });
        texture.wrapS = RepeatWrapping;
        texture.wrapT = RepeatWrapping;
        texture.flipY = true;
        texture.matrixAutoUpdate = true;
        if (isBoolean(animation) && animation) {
            Animation(texture.offset, { y: -1, x: 0, }, { repeat: true, duration: 500, });
        }
        else if (isObject(animation)) {
            Animation(texture.offset, { y: -1, x: 0, }, Object.assign(Object.assign({}, animation), { repeat: true }));
        }
        material.map = texture;
    }
    return material;
}
class Link extends BaseMesh {
    constructor(param) {
        const { start, end, imgUrl, width = 20, color = 0x00ff00, opacity = 1, animation = false, passable = 0, restrict = 0, } = param;
        const startPos = IVector3ToVector3(start);
        const endPos = IVector3ToVector3(end);
        const pointDist = startPos.distanceTo(endPos);
        super(createGeometry$2(startPos, endPos, width), createMaterial$2(pointDist, width, color, opacity, imgUrl, animation), param, 'Link');
        this.passable = passable;
        this.restrict = restrict;
    }
}

class Topology extends BaseObject3D {
    constructor(param) {
        super(param, 'Topology');
        const { type = 'line', } = param;
        this.topologyType = type;
        this.nodes = [];
        this.links = [];
        this.info = param;
        this.create();
    }
    create() {
        var _a, _b;
        const { 
        // 
        nodes, 
        // 
        renderLink = true, linkWidth = 20, linkColor = 0x00ff00, 
        // 
        renderNode = true, nodeColor = 0x0000ff, nodeRadius = linkWidth / 2, 
        // 
        imgUrl, animation = false, } = this.info;
        const linksId = [];
        for (const nodeItem of nodes) {
            // Node
            const node = this.createNode(Object.assign(Object.assign({}, nodeItem), { radius: nodeRadius, color: nodeColor }));
            if (renderNode === false)
                node.hide();
            this.nodes.push(node);
            // Circle
            if (!imgUrl && renderLink) {
                const color = isArray(linkColor) ?
                    linkColor[(_a = nodeItem.graphs[0]) === null || _a === void 0 ? void 0 : _a.passable] ?
                        linkColor[(_b = nodeItem.graphs[0]) === null || _b === void 0 ? void 0 : _b.passable] :
                        linkColor[0] :
                    linkColor;
                !renderNode && this.createCircle({
                    id: `${nodeItem.id}_circle`,
                    name: `${nodeItem.name || nodeItem.id}_circle`,
                    position: nodeItem.position,
                    radius: linkWidth / 2,
                    color,
                });
            }
            // Link
            if (renderLink) {
                for (let j = 0; j < nodeItem.graphs.length; j++) {
                    const { linkInfo, targetNodeId, passable, restrict, } = nodeItem.graphs[j];
                    const { id, name, } = linkInfo;
                    const targetNode = this.info.nodes.find(i => i.id === targetNodeId);
                    if (!linksId.includes(id) && targetNode) {
                        linksId.push(id);
                        const color = isArray(linkColor) ?
                            linkColor[passable] ?
                                linkColor[passable] :
                                linkColor[0] :
                            linkColor;
                        const link = this.createLink({
                            id,
                            name,
                            start: nodeItem.position,
                            end: targetNode.position,
                            width: linkWidth,
                            color,
                            imgUrl,
                            opacity: imgUrl ? 0.99 : 1,
                            animation,
                            passable,
                            restrict,
                            userData: {
                                startNodeId: nodeItem.id,
                                endNodeId: targetNode.id,
                            },
                        });
                        this.links.push(link);
                    }
                }
            }
        }
    }
    createNode(param) {
        const node = new Node(Object.assign({}, param));
        this.add(node);
        return node;
    }
    createCircle(param) {
        const circle = new Circle(Object.assign(Object.assign({}, param), { rotation: {
                x: Math.PI / 2,
                y: 0,
                z: 0,
            } }));
        this.add(circle);
        return circle;
    }
    createLink(param) {
        const link = new Link(Object.assign({}, param));
        this.add(link);
        return link;
    }
    resetNodes(newNodes) {
        // const {
        //   // 
        //   linkWidth = 20,
        //   linkColor = 0x00ff00,
        //   // 
        //   nodeColor = 0x0000ff,
        //   // 
        //   imgUrl,
        //   animation = false,
        // } = this.info
        const { 
        // 
        renderLink = true, linkWidth = 20, linkColor = 0x00ff00, 
        // 
        renderNode = true, nodeColor = 0x0000ff, nodeRadius = linkWidth / 2, 
        // 
        imgUrl, animation = false, } = this.info;
        const linksId = [];
        const oldNodes = [...this.info.nodes];
        this.info.nodes = [...newNodes];
        /**
         * del old node
         */
        const deletedNodes = [];
        for (let i = 0; i < oldNodes.length; i++) {
            const node = newNodes.find(n => n.id === oldNodes[i].id);
            if (!node ||
                !IVector3ToVector3(node.position).equals(IVector3ToVector3(oldNodes[i].position))) {
                deletedNodes.push(oldNodes[i]);
            }
        }
        for (let i = 0; i < deletedNodes.length; i++) {
            const index = this.nodes.findIndex(n => deletedNodes[i].id === n.sid);
            this.remove(this.nodes[index]);
            this.nodes.splice(index, 1);
        }
        /**
         * add new node
         */
        const addedNodes = [];
        for (let i = 0; i < newNodes.length; i++) {
            const node = oldNodes.find(n => n.id === newNodes[i].id);
            if (!node ||
                !IVector3ToVector3(node.position).equals(IVector3ToVector3(newNodes[i].position))) {
                addedNodes.push(newNodes[i]);
            }
        }
        for (let i = 0; i < addedNodes.length; i++) {
            const node = this.createNode(Object.assign(Object.assign({}, addedNodes[i]), { radius: nodeRadius, color: nodeColor }));
            this.nodes.push(node);
        }
        // clean link
        this.remove(...this.links);
        this.links.length = 0;
        // 临时代码
        for (const nodeItem of newNodes) {
            // Link
            if (renderLink) {
                for (let j = 0; j < nodeItem.graphs.length; j++) {
                    const { linkInfo, targetNodeId, passable, restrict, } = nodeItem.graphs[j];
                    const { id, name, } = linkInfo;
                    const targetNode = this.info.nodes.find(i => i.id === targetNodeId);
                    if (!linksId.includes(id) && targetNode) {
                        linksId.push(id);
                        const color = isArray(linkColor) ?
                            linkColor[passable] ?
                                linkColor[passable] :
                                linkColor[0] :
                            linkColor;
                        const link = this.createLink({
                            id,
                            name,
                            start: nodeItem.position,
                            end: targetNode.position,
                            width: linkWidth,
                            color,
                            imgUrl,
                            opacity: imgUrl ? 0.99 : 1,
                            animation,
                            passable,
                            restrict,
                        });
                        this.links.push(link);
                    }
                }
            }
        }
    }
    getLength() {
        let dist = 0;
        for (let i = 1; i < this.nodes.length; i++) {
            dist += this.nodes[i].position.distanceTo(this.nodes[i - 1].position);
        }
        return dist;
    }
}

function createGeometry$1(points, width, up = new Vector3(0, 1, 0)) {
    const widthHalf = width / 2;
    const geometry = new BufferGeometry();
    let positionArray = [];
    let uvArray = [];
    if (points.length < 2)
        return geometry;
    for (let i = 0; i < points.length - 1; i++) {
        const start = IVector3ToVector3(points[i]);
        const end = IVector3ToVector3(points[i + 1]);
        const v2 = new Vector3();
        const v3 = new Vector3();
        v2.subVectors(end, start);
        v2.normalize();
        v3.crossVectors(v2, up);
        const direct1 = new Vector3(v3.x * widthHalf, v3.y * widthHalf, v3.z * widthHalf);
        const direct2 = new Vector3(-v3.x * widthHalf, -v3.y * widthHalf, -v3.z * widthHalf);
        const new1 = new Vector3();
        new1.addVectors(start, direct1);
        const new2 = new Vector3();
        new2.addVectors(start, direct2);
        const new3 = new Vector3();
        new3.addVectors(end, direct2);
        const new4 = new Vector3();
        new4.addVectors(end, direct1);
        positionArray = [
            ...positionArray,
            ...[
                new1.x, new1.y, new1.z,
                new2.x, new2.y, new2.z,
                new3.x, new3.y, new3.z,
                new3.x, new3.y, new3.z,
                new4.x, new4.y, new4.z,
                new1.x, new1.y, new1.z
            ]
        ];
        uvArray = [
            ...uvArray,
            ...[
                0, 0,
                1, 0,
                1, 1,
                1, 1,
                0, 1,
                0, 0
            ]
        ];
    }
    geometry.setAttribute('position', new Float32BufferAttribute(positionArray, 3));
    geometry.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
    return geometry;
}
function createMaterial$1(color, opacity, gradient) {
    return new MeshBasicMaterial({
        color,
        side: DoubleSide,
        transparent: opacity < 1,
        opacity,
        map: gradientTexture(gradient),
    });
}
class Line extends BaseMesh {
    constructor(params, type = 'Line') {
        const { points, width = 20, color = 0xffffff, opacity = 1, gradient, } = params;
        super(createGeometry$1(points, width), createMaterial$1(color, opacity, gradient), params, type);
        this.params = params;
        this.points = points;
        this.frustumCulled = false;
    }
    setOptions(params) {
        var _a;
        const { color, opacity, points, width, gradient, } = params;
        this.points = points;
        const material = this.material;
        if (color)
            material.color = new Color(color);
        if (opacity)
            material.opacity = opacity;
        if (gradient)
            material.map = gradientTexture(gradient);
        if (points && width)
            this.geometry = createGeometry$1(points, width);
        else if (points)
            this.geometry = createGeometry$1(points, (_a = this.params.width) !== null && _a !== void 0 ? _a : 20);
        else if (width)
            this.geometry = createGeometry$1(this.points, width);
        material.needsUpdate = true;
        innerRenderState.needsUpdate = true;
    }
}

function createGeometry(points) {
    const list = [];
    for (let i = 0; i < points.length; i++) {
        list.push(new Vector2(points[i].x, points[i].z));
    }
    return list.length > 2 ?
        new ShapeGeometry(new Shape(list)) :
        new BufferGeometry();
}
function createMaterial(color, opacity, gradient) {
    return new MeshBasicMaterial({
        color, opacity, transparent: opacity < 1, side: DoubleSide, map: gradientTexture(gradient),
    });
}
class Polygon extends BaseMesh {
    constructor(param, type = 'Polygon') {
        const { yHeight, points, color = 0xffffff, opacity = 1, gradient, } = param;
        super(createGeometry(points), createMaterial(color, opacity, gradient), param, type);
        this.points = points;
        this.position.set(0, yHeight, 0);
        this.rotation.set(Math.PI / 2, 0, 0);
    }
    setOptions(param) {
        const { color, opacity, yHeight, points, gradient, } = param;
        const material = this.material;
        if (color)
            material.color = new Color(color);
        if (opacity)
            material.opacity = opacity;
        if (yHeight)
            this.position.set(0, yHeight, 0);
        if (points)
            this.geometry = createGeometry(points);
        if (gradient)
            material.map = gradientTexture(gradient);
        material.needsUpdate = true;
        innerRenderState.needsUpdate = true;
    }
}

class Canvas3D extends BaseObject3D {
    constructor(param) {
        super(param, 'Canvas3D');
        this.create(param);
    }
    create(param) {
        const { points = [], lines = [], polygons = [], circles = [], } = param;
        for (let i = 0; i < points.length; i++)
            this.createPoint(points[i]);
        for (let i = 0; i < lines.length; i++)
            this.createLine(lines[i]);
        for (let i = 0; i < polygons.length; i++)
            this.createPolygon(polygons[i]);
        for (let i = 0; i < circles.length; i++)
            this.createCircle(circles[i]);
    }
    createPoint(param) {
        const point = new Point(param);
        this.add(point);
        innerRenderState.needsUpdate = true;
        return point;
    }
    getPoint(id) {
        return this.getChildForType('Point', id);
    }
    removePoint(id) {
        const point = this.getPoint(id);
        point && this.remove(point);
        innerRenderState.needsUpdate = true;
    }
    createLine(param) {
        const line = new Line(param);
        this.add(line);
        innerRenderState.needsUpdate = true;
        return line;
    }
    getLine(id) {
        return this.getChildForType('Line', id);
    }
    removeLine(id) {
        const line = this.getLine(id);
        line && this.remove(line);
        innerRenderState.needsUpdate = true;
    }
    createPolygon(param) {
        const face = new Polygon(param);
        this.add(face);
        innerRenderState.needsUpdate = true;
        return face;
    }
    getPolygon(id) {
        return this.getChildForType('Polygon', id);
    }
    removePolygon(id) {
        const polygon = this.getPolygon(id);
        polygon && this.remove(polygon);
        innerRenderState.needsUpdate = true;
    }
    createCircle(param) {
        const circle = new Circle(param);
        this.add(circle);
        innerRenderState.needsUpdate = true;
        return circle;
    }
    getCircle(id) {
        return this.getChildForType('Circle', id);
    }
    removeCircle(id) {
        const circle = this.getCircle(id);
        circle && this.remove(circle);
        innerRenderState.needsUpdate = true;
    }
    getChildForType(type, id) {
        for (let i = 0; i < this.children.length; i++) {
            if (this.children[i].stype === type &&
                this.children[i].sid === id)
                return this.children[i];
        }
        return null;
    }
}

class Ground extends BaseMesh {
    constructor(geometry, material, param) {
        super(geometry, material, param, 'Ground');
    }
}

var library = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BaseMesh: BaseMesh,
  BaseObject3D: BaseObject3D,
  Canvas3D: Canvas3D,
  Circle: Circle,
  Ground: Ground,
  Group: Group,
  Icon: Icon,
  Line: Line,
  Link: Link,
  Model: Model,
  Node: Node,
  PluginObject: PluginObject,
  Poi: Poi,
  PoiNode: PoiNode,
  Point: Point,
  Polygon: Polygon,
  Topology: Topology
});

function O(n) {
  var t = typeof n;
  return n == null || t !== "object" && t !== "function";
}
function $(n) {
  return n && typeof n[Symbol.iterator] == "function";
}

var y = /* @__PURE__ */ ((n) => (n[n.x = 0] = "x", n[n.y = 1] = "y", n[n.z = 2] = "z", n))(y || {});
((n) => {
  function r(e) {
    return n[e];
  }
  n.toKey = r;
  function c(e) {
    return n[e];
  }
  n.toIndex = c;
})(y || (y = {}));
function V(n) {
  return n.w != null ? new Vector4().copy(n) : n.z != null ? new Vector3().copy(n) : new Vector2().copy(n);
}
function f(n, r, c) {
  c = c ?? 0;
  const e = c + 1;
  if (O(n))
    return n;
  if (n.x != null && n.y != null)
    return V(n);
  if (Array.isArray(n))
    return n.map((o) => f(o, r, e));
  if (n instanceof Map) {
    const o = /* @__PURE__ */ new Map();
    for (const u of n.keys()) {
      const t = n.get(u), m = f(t, r, e);
      o.set(u, m);
    }
    return o;
  }
  if ($(n)) {
    const o = [];
    for (const u of n) {
      const t = f(u, r, e);
      o.push(t);
    }
    return o;
  }
  if ((r || c === 0) && typeof n == "object") {
    const o = {};
    for (const u of Object.keys(n))
      o[u] = f(n[u], r, e);
    return o;
  }
  return n;
}

/**
 * 格式化动画路径信息
 * @param path
 * @returns
 */
function formatAnimationPath(path) {
    const pathInfo = {};
    if (Array.isArray(path)) {
        const points = path.map((point) => new Vector3().copy(point));
        pathInfo.points = points;
    }
    else if (path instanceof Topology) {
        const points = path.nodes.map((node) => {
            return node.getWorldPosition(new Vector3());
        });
        pathInfo.points = points;
    }
    else {
        pathInfo.curve = path;
    }
    return pathInfo;
}
function createPathAnimation(target, path, ssp, options) {
    const vecOpts = options ? f(options, false) : null;
    const pathInfo = formatAnimationPath(path);
    const clip = on(Object.assign(Object.assign(Object.assign({}, vecOpts), pathInfo), { target }));
    // @ts-ignore
    return ssp.playModelAnimation(target, clip);
}
function createPathAnimationActionForCamera(camera, path, ssp, options) {
    let { eyeHeight, anchor, front, enableUp, } = options !== null && options !== void 0 ? options : {};
    eyeHeight = eyeHeight !== null && eyeHeight !== void 0 ? eyeHeight : 100;
    enableUp = enableUp !== null && enableUp !== void 0 ? enableUp : false;
    anchor = anchor !== null && anchor !== void 0 ? anchor : new Vector3(0, -eyeHeight, 0);
    front = front !== null && front !== void 0 ? front : new Vector3(0, 0, enableUp ? 1 : -1);
    return createPathAnimation(camera, path, ssp, Object.assign(Object.assign({}, options), { anchor, front, enableUp }));
}
/**
  * 创建骨骼路径动画
  * @param options
  * @returns
  */
function createBonePathAnimation(model, path, ssp, options) {
    const vecOpts = options ? f(options, false) : null;
    const pathInfo = formatAnimationPath(path);
    // @ts-ignore
    const animationInfo = rn(Object.assign(Object.assign(Object.assign({}, vecOpts), pathInfo), { model }));
    const { model: skinnedModel, clip, } = animationInfo;
    // @ts-ignore
    const action = ssp.playModelAnimation(skinnedModel, clip);
    return Object.assign(Object.assign({}, animationInfo), { action });
}

class DefaultManage {
    constructor(type, viewport, scene) {
        this.type = type;
        this.scene = scene;
        this.viewport = viewport;
    }
    /***
     * group
     */
    createGroup(groupInfo, parent) {
        const group = new Group(groupInfo);
        if (parent !== null)
            this.viewport.scener.addObject(group, parent !== null && parent !== void 0 ? parent : this.scene);
        return group;
    }
    clear() {
        this.getAll().forEach(item => {
            this.viewport.scener.removeObject(item);
        });
    }
    getAll() {
        const objects = [];
        this.scene.traverse(object => {
            // BaseObject3D BaseMesh
            if ((object instanceof BaseObject3D ||
                object instanceof BaseMesh) &&
                isObject(object) &&
                object.stype === this.type) {
                objects.push(object);
            }
            // Object3D for light and helper
            else if (isObject(object) &&
                object.userData.stype === this.type) {
                objects.push(object);
            }
        });
        return objects;
    }
    hideAll() {
        this.getAll().forEach(item => {
            if (item.hide) {
                item.hide();
            }
            else {
                item.visible = false;
            }
        });
        this.viewport.signals.objectChanged.dispatch();
    }
    showAll() {
        this.getAll().forEach(item => {
            if (item.show) {
                item.show();
            }
            else {
                item.visible = true;
            }
        });
        this.viewport.signals.objectChanged.dispatch();
    }
}

class LightManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.LIGHT_MANAGE_TYPE, viewport, scene);
        RectAreaLightUniformsLib.init();
    }
    createAmbientLight(options) {
        const { id, name = '', color = 0x9a9a9a, intensity = 1, } = options;
        const light = new AmbientLight(color, intensity);
        light.name = name;
        light.userData.sid = id;
        light.userData.stype = 'Light';
        this.viewport.scener.addObject(light, this.scene);
        return light;
    }
    setAmbientLight(light, options) {
        const { name = '', color = 0x9a9a9a, intensity = 1, } = options;
        if (!light)
            return false;
        light.name = name;
        light.color = new Color(color);
        light.intensity = intensity;
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    createDirectionalLight(options) {
        const { id, name = '', color = 0x9a9a9a, intensity = 1, position = { x: 1000, y: 1000, z: 1000, }, target = { x: -1000, y: -1000, z: -1000, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        const light = new DirectionalLight(color, intensity);
        light.name = name;
        light.userData.sid = id;
        light.userData.stype = 'Light';
        light.position.set(position.x, position.y, position.z);
        light.target.name = `${name}-target`;
        light.target.position.set(target.x, target.y, target.z);
        light.castShadow = openShadow;
        if (openShadow) {
            const depth = light.position.distanceTo(light.target.position);
            light.shadow.bias = -0.005;
            light.shadow.camera.left = -depth;
            light.shadow.camera.right = depth;
            light.shadow.camera.top = depth;
            light.shadow.camera.bottom = -depth;
            light.shadow.camera.far = depth;
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.scener.addObject(light, this.scene);
        this.viewport.scener.addObject(light.target, this.scene);
        return light;
    }
    setDirectionalLight(light, options) {
        const { name = '', color = 0x9a9a9a, intensity = 1, position = { x: 1000, y: 1000, z: 1000, }, target = { x: -1000, y: -1000, z: -1000, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        if (!light)
            return false;
        light.name = name;
        light.color = new Color(color);
        light.intensity = intensity;
        light.position.set(position.x, position.y, position.z);
        light.target.position.set(target.x, target.y, target.z);
        light.castShadow = openShadow;
        if (openShadow) {
            const depth = light.position.distanceTo(light.target.position);
            light.shadow.bias = -0.005;
            light.shadow.camera.left = -depth;
            light.shadow.camera.right = depth;
            light.shadow.camera.top = depth;
            light.shadow.camera.bottom = -depth;
            light.shadow.camera.far = depth;
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    createHemisphereLight(options) {
        const { id, name = '', skyColor = 0xffffff, groundColor = 0xdddddd, intensity = 1, position = { x: 0, y: 0, z: 0, }, } = options;
        const light = new HemisphereLight(skyColor, groundColor, intensity);
        light.name = name;
        light.position.set(position.x, position.y, position.z);
        light.userData.sid = id;
        light.userData.stype = 'Light';
        this.viewport.scener.addObject(light, this.scene);
        return light;
    }
    setHemisphereLight(light, options) {
        const { name = '', skyColor = 0xffffff, groundColor = 0xdddddd, intensity = 1, position = { x: 0, y: 0, z: 0, }, } = options;
        if (!light)
            return false;
        light.name = name;
        light.color = new Color(skyColor);
        light.groundColor = new Color(groundColor);
        light.intensity = intensity;
        light.position.set(position.x, position.y, position.z);
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    createSpotLight(options) {
        const { id, name = '', color = 0xffffff, intensity = 1, angle = 45, position = { x: 0, y: 500, z: 0, }, target = { x: 0, y: 0, z: 0, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        const distance = IVector3ToVector3(position).distanceTo(IVector3ToVector3(target));
        const light = new SpotLight(color, intensity, distance, Math.PI / 360 * angle, 0, 0);
        light.name = name;
        light.position.set(position.x, position.y, position.z);
        light.userData.sid = id;
        light.userData.stype = 'Light';
        light.castShadow = openShadow;
        light.target.position.set(target.x, target.y, target.z);
        light.target.castShadow = openShadow;
        light.target.receiveShadow = true;
        light.target.updateMatrixWorld();
        if (openShadow) {
            const far = light.position.distanceTo(light.target.position);
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.bias = -0.005;
            light.shadow.focus = 0.6;
            light.shadow.camera.far = far;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.scener.addObject(light, this.scene);
        return light;
    }
    setSpotLight(light, options) {
        const { name = '', color = 0xffffff, intensity = 1, angle = 45, position = { x: 0, y: 500, z: 0, }, target = { x: 0, y: 0, z: 0, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        if (!light)
            return false;
        const distance = IVector3ToVector3(position).distanceTo(IVector3ToVector3(target));
        light.name = name;
        light.color = new Color(color);
        light.intensity = intensity;
        light.distance = distance;
        light.angle = Math.PI / 360 * angle;
        light.position.set(position.x, position.y, position.z);
        light.castShadow = openShadow;
        light.target.position.set(target.x, target.y, target.z);
        light.target.castShadow = openShadow;
        light.target.updateMatrixWorld();
        if (openShadow) {
            const far = light.position.distanceTo(light.target.position);
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.bias = -0.005;
            light.shadow.focus = 0.6;
            light.shadow.camera.far = far;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    createPointLight(options) {
        const { id, name = '', color = 0xffffff, intensity = 1, distance = 5000, position = { x: 0, y: 500, z: 0, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        const light = new PointLight(color, intensity, distance);
        light.name = name;
        light.userData.sid = id;
        light.userData.stype = 'Light';
        light.position.set(position.x, position.y, position.z);
        light.castShadow = openShadow;
        if (openShadow) {
            light.shadow.bias = -0.005;
            light.shadow.camera.far = distance;
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.scener.addObject(light, this.scene);
        return light;
    }
    setPointLight(light, options) {
        const { name = '', color = 0xffffff, intensity = 1, distance = 5000, position = { x: 0, y: 500, z: 0, }, openShadow = false, shadowAutoUpdate = false, mapSize = 4096, } = options;
        if (!light)
            return false;
        light.name = name;
        light.color = new Color(color);
        light.intensity = intensity;
        light.distance = distance;
        light.position.set(position.x, position.y, position.z);
        light.castShadow = openShadow;
        if (openShadow) {
            light.shadow.bias = -0.005;
            light.shadow.camera.far = distance;
            light.shadow.autoUpdate = shadowAutoUpdate;
            light.shadow.needsUpdate = !shadowAutoUpdate;
            light.shadow.mapSize.width = mapSize;
            light.shadow.mapSize.height = mapSize;
            light.shadow.camera.updateProjectionMatrix();
        }
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    createRectAreaLight(options) {
        const { id, name = '', color = 0xffffff, intensity = 1, width = 10, height = 10, position = { x: 0, y: 0, z: 0, }, } = options;
        const light = new RectAreaLight(color, intensity, width, height);
        light.name = name;
        light.userData.sid = id;
        light.userData.stype = 'Light';
        light.position.set(position.x, position.y, position.z);
        this.viewport.scener.addObject(light, this.scene);
        return light;
    }
    setRectAreaLight(light, options) {
        const { name = '', color = 0xffffff, intensity = 1, width = 10, height = 10, position = { x: 0, y: 0, z: 0, }, } = options;
        if (!light)
            return false;
        light.name = name;
        light.color = new Color(color);
        light.intensity = intensity;
        light.width = width;
        light.height = height;
        light.position.set(position.x, position.y, position.z);
        this.viewport.signals.objectChanged.dispatch();
        return true;
    }
    // 更新所有阴影
    updateAllShadow() {
        const light = this.getAll();
        light.forEach((light) => {
            var _a;
            if (((_a = light.shadow) === null || _a === void 0 ? void 0 : _a.autoUpdate) === false) {
                light.shadow.needsUpdate = true;
            }
        });
        this.viewport.signals.objectChanged.dispatch();
    }
}

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var localforageExports = {};
var localforage = {
  get exports(){ return localforageExports; },
  set exports(v){ localforageExports = v; },
};

/*!
    localForage -- Offline Storage, Improved
    Version 1.9.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/

(function (module, exports) {
	(function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	(function (global){
	var Mutation = global.MutationObserver || global.WebKitMutationObserver;

	var scheduleDrain;

	{
	  if (Mutation) {
	    var called = 0;
	    var observer = new Mutation(nextTick);
	    var element = global.document.createTextNode('');
	    observer.observe(element, {
	      characterData: true
	    });
	    scheduleDrain = function () {
	      element.data = (called = ++called % 2);
	    };
	  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
	    var channel = new global.MessageChannel();
	    channel.port1.onmessage = nextTick;
	    scheduleDrain = function () {
	      channel.port2.postMessage(0);
	    };
	  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
	    scheduleDrain = function () {

	      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	      var scriptEl = global.document.createElement('script');
	      scriptEl.onreadystatechange = function () {
	        nextTick();

	        scriptEl.onreadystatechange = null;
	        scriptEl.parentNode.removeChild(scriptEl);
	        scriptEl = null;
	      };
	      global.document.documentElement.appendChild(scriptEl);
	    };
	  } else {
	    scheduleDrain = function () {
	      setTimeout(nextTick, 0);
	    };
	  }
	}

	var draining;
	var queue = [];
	//named nextTick for less confusing stack traces
	function nextTick() {
	  draining = true;
	  var i, oldQueue;
	  var len = queue.length;
	  while (len) {
	    oldQueue = queue;
	    queue = [];
	    i = -1;
	    while (++i < len) {
	      oldQueue[i]();
	    }
	    len = queue.length;
	  }
	  draining = false;
	}

	module.exports = immediate;
	function immediate(task) {
	  if (queue.push(task) === 1 && !draining) {
	    scheduleDrain();
	  }
	}

	}).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
	},{}],2:[function(_dereq_,module,exports){
	var immediate = _dereq_(1);

	/* istanbul ignore next */
	function INTERNAL() {}

	var handlers = {};

	var REJECTED = ['REJECTED'];
	var FULFILLED = ['FULFILLED'];
	var PENDING = ['PENDING'];

	module.exports = Promise;

	function Promise(resolver) {
	  if (typeof resolver !== 'function') {
	    throw new TypeError('resolver must be a function');
	  }
	  this.state = PENDING;
	  this.queue = [];
	  this.outcome = void 0;
	  if (resolver !== INTERNAL) {
	    safelyResolveThenable(this, resolver);
	  }
	}

	Promise.prototype["catch"] = function (onRejected) {
	  return this.then(null, onRejected);
	};
	Promise.prototype.then = function (onFulfilled, onRejected) {
	  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
	    typeof onRejected !== 'function' && this.state === REJECTED) {
	    return this;
	  }
	  var promise = new this.constructor(INTERNAL);
	  if (this.state !== PENDING) {
	    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
	    unwrap(promise, resolver, this.outcome);
	  } else {
	    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
	  }

	  return promise;
	};
	function QueueItem(promise, onFulfilled, onRejected) {
	  this.promise = promise;
	  if (typeof onFulfilled === 'function') {
	    this.onFulfilled = onFulfilled;
	    this.callFulfilled = this.otherCallFulfilled;
	  }
	  if (typeof onRejected === 'function') {
	    this.onRejected = onRejected;
	    this.callRejected = this.otherCallRejected;
	  }
	}
	QueueItem.prototype.callFulfilled = function (value) {
	  handlers.resolve(this.promise, value);
	};
	QueueItem.prototype.otherCallFulfilled = function (value) {
	  unwrap(this.promise, this.onFulfilled, value);
	};
	QueueItem.prototype.callRejected = function (value) {
	  handlers.reject(this.promise, value);
	};
	QueueItem.prototype.otherCallRejected = function (value) {
	  unwrap(this.promise, this.onRejected, value);
	};

	function unwrap(promise, func, value) {
	  immediate(function () {
	    var returnValue;
	    try {
	      returnValue = func(value);
	    } catch (e) {
	      return handlers.reject(promise, e);
	    }
	    if (returnValue === promise) {
	      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
	    } else {
	      handlers.resolve(promise, returnValue);
	    }
	  });
	}

	handlers.resolve = function (self, value) {
	  var result = tryCatch(getThen, value);
	  if (result.status === 'error') {
	    return handlers.reject(self, result.value);
	  }
	  var thenable = result.value;

	  if (thenable) {
	    safelyResolveThenable(self, thenable);
	  } else {
	    self.state = FULFILLED;
	    self.outcome = value;
	    var i = -1;
	    var len = self.queue.length;
	    while (++i < len) {
	      self.queue[i].callFulfilled(value);
	    }
	  }
	  return self;
	};
	handlers.reject = function (self, error) {
	  self.state = REJECTED;
	  self.outcome = error;
	  var i = -1;
	  var len = self.queue.length;
	  while (++i < len) {
	    self.queue[i].callRejected(error);
	  }
	  return self;
	};

	function getThen(obj) {
	  // Make sure we only access the accessor once as required by the spec
	  var then = obj && obj.then;
	  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
	    return function appyThen() {
	      then.apply(obj, arguments);
	    };
	  }
	}

	function safelyResolveThenable(self, thenable) {
	  // Either fulfill, reject or reject with error
	  var called = false;
	  function onError(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.reject(self, value);
	  }

	  function onSuccess(value) {
	    if (called) {
	      return;
	    }
	    called = true;
	    handlers.resolve(self, value);
	  }

	  function tryToUnwrap() {
	    thenable(onSuccess, onError);
	  }

	  var result = tryCatch(tryToUnwrap);
	  if (result.status === 'error') {
	    onError(result.value);
	  }
	}

	function tryCatch(func, value) {
	  var out = {};
	  try {
	    out.value = func(value);
	    out.status = 'success';
	  } catch (e) {
	    out.status = 'error';
	    out.value = e;
	  }
	  return out;
	}

	Promise.resolve = resolve;
	function resolve(value) {
	  if (value instanceof this) {
	    return value;
	  }
	  return handlers.resolve(new this(INTERNAL), value);
	}

	Promise.reject = reject;
	function reject(reason) {
	  var promise = new this(INTERNAL);
	  return handlers.reject(promise, reason);
	}

	Promise.all = all;
	function all(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var values = new Array(len);
	  var resolved = 0;
	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    allResolver(iterable[i], i);
	  }
	  return promise;
	  function allResolver(value, i) {
	    self.resolve(value).then(resolveFromAll, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	    function resolveFromAll(outValue) {
	      values[i] = outValue;
	      if (++resolved === len && !called) {
	        called = true;
	        handlers.resolve(promise, values);
	      }
	    }
	  }
	}

	Promise.race = race;
	function race(iterable) {
	  var self = this;
	  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
	    return this.reject(new TypeError('must be an array'));
	  }

	  var len = iterable.length;
	  var called = false;
	  if (!len) {
	    return this.resolve([]);
	  }

	  var i = -1;
	  var promise = new this(INTERNAL);

	  while (++i < len) {
	    resolver(iterable[i]);
	  }
	  return promise;
	  function resolver(value) {
	    self.resolve(value).then(function (response) {
	      if (!called) {
	        called = true;
	        handlers.resolve(promise, response);
	      }
	    }, function (error) {
	      if (!called) {
	        called = true;
	        handlers.reject(promise, error);
	      }
	    });
	  }
	}

	},{"1":1}],3:[function(_dereq_,module,exports){
	(function (global){
	if (typeof global.Promise !== 'function') {
	  global.Promise = _dereq_(2);
	}

	}).call(this,typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
	},{"2":2}],4:[function(_dereq_,module,exports){

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function getIDB() {
	    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */
	    try {
	        if (typeof indexedDB !== 'undefined') {
	            return indexedDB;
	        }
	        if (typeof webkitIndexedDB !== 'undefined') {
	            return webkitIndexedDB;
	        }
	        if (typeof mozIndexedDB !== 'undefined') {
	            return mozIndexedDB;
	        }
	        if (typeof OIndexedDB !== 'undefined') {
	            return OIndexedDB;
	        }
	        if (typeof msIndexedDB !== 'undefined') {
	            return msIndexedDB;
	        }
	    } catch (e) {
	        return;
	    }
	}

	var idb = getIDB();

	function isIndexedDBValid() {
	    try {
	        // Initialize IndexedDB; fall back to vendor-prefixed versions
	        // if needed.
	        if (!idb || !idb.open) {
	            return false;
	        }
	        // We mimic PouchDB here;
	        //
	        // We test for openDatabase because IE Mobile identifies itself
	        // as Safari. Oh the lulz...
	        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);

	        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;

	        // Safari <10.1 does not meet our requirements for IDB support
	        // (see: https://github.com/pouchdb/pouchdb/issues/5572).
	        // Safari 10.1 shipped with fetch, we can use that to detect it.
	        // Note: this creates issues with `window.fetch` polyfills and
	        // overrides; see:
	        // https://github.com/localForage/localForage/issues/856
	        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&
	        // some outdated implementations of IDB that appear on Samsung
	        // and HTC Android devices <4.4 are missing IDBKeyRange
	        // See: https://github.com/mozilla/localForage/issues/128
	        // See: https://github.com/mozilla/localForage/issues/272
	        typeof IDBKeyRange !== 'undefined';
	    } catch (e) {
	        return false;
	    }
	}

	// Abstracts constructing a Blob object, so it also works in older
	// browsers that don't support the native Blob constructor. (i.e.
	// old QtWebKit versions, at least).
	// Abstracts constructing a Blob object, so it also works in older
	// browsers that don't support the native Blob constructor. (i.e.
	// old QtWebKit versions, at least).
	function createBlob(parts, properties) {
	    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */
	    parts = parts || [];
	    properties = properties || {};
	    try {
	        return new Blob(parts, properties);
	    } catch (e) {
	        if (e.name !== 'TypeError') {
	            throw e;
	        }
	        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;
	        var builder = new Builder();
	        for (var i = 0; i < parts.length; i += 1) {
	            builder.append(parts[i]);
	        }
	        return builder.getBlob(properties.type);
	    }
	}

	// This is CommonJS because lie is an external dependency, so Rollup
	// can just ignore it.
	if (typeof Promise === 'undefined') {
	    // In the "nopromises" build this will just throw if you don't have
	    // a global promise object, but it would throw anyway later.
	    _dereq_(3);
	}
	var Promise$1 = Promise;

	function executeCallback(promise, callback) {
	    if (callback) {
	        promise.then(function (result) {
	            callback(null, result);
	        }, function (error) {
	            callback(error);
	        });
	    }
	}

	function executeTwoCallbacks(promise, callback, errorCallback) {
	    if (typeof callback === 'function') {
	        promise.then(callback);
	    }

	    if (typeof errorCallback === 'function') {
	        promise["catch"](errorCallback);
	    }
	}

	function normalizeKey(key) {
	    // Cast the key to a string, as that's all we can set as a key.
	    if (typeof key !== 'string') {
	        console.warn(key + ' used as a key, but it is not a string.');
	        key = String(key);
	    }

	    return key;
	}

	function getCallback() {
	    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {
	        return arguments[arguments.length - 1];
	    }
	}

	// Some code originally from async_storage.js in
	// [Gaia](https://github.com/mozilla-b2g/gaia).

	var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';
	var supportsBlobs = void 0;
	var dbContexts = {};
	var toString = Object.prototype.toString;

	// Transaction Modes
	var READ_ONLY = 'readonly';
	var READ_WRITE = 'readwrite';

	// Transform a binary string to an array buffer, because otherwise
	// weird stuff happens when you try to work with the binary string directly.
	// It is known.
	// From http://stackoverflow.com/questions/14967647/ (continues on next line)
	// encode-decode-image-with-base64-breaks-image (2013-04-21)
	function _binStringToArrayBuffer(bin) {
	    var length = bin.length;
	    var buf = new ArrayBuffer(length);
	    var arr = new Uint8Array(buf);
	    for (var i = 0; i < length; i++) {
	        arr[i] = bin.charCodeAt(i);
	    }
	    return buf;
	}

	//
	// Blobs are not supported in all versions of IndexedDB, notably
	// Chrome <37 and Android <5. In those versions, storing a blob will throw.
	//
	// Various other blob bugs exist in Chrome v37-42 (inclusive).
	// Detecting them is expensive and confusing to users, and Chrome 37-42
	// is at very low usage worldwide, so we do a hacky userAgent check instead.
	//
	// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120
	// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916
	// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836
	//
	// Code borrowed from PouchDB. See:
	// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js
	//
	function _checkBlobSupportWithoutCaching(idb) {
	    return new Promise$1(function (resolve) {
	        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
	        var blob = createBlob(['']);
	        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');

	        txn.onabort = function (e) {
	            // If the transaction aborts now its due to not being able to
	            // write to the database, likely due to the disk being full
	            e.preventDefault();
	            e.stopPropagation();
	            resolve(false);
	        };

	        txn.oncomplete = function () {
	            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
	            var matchedEdge = navigator.userAgent.match(/Edge\//);
	            // MS Edge pretends to be Chrome 42:
	            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx
	            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
	        };
	    })["catch"](function () {
	        return false; // error, so assume unsupported
	    });
	}

	function _checkBlobSupport(idb) {
	    if (typeof supportsBlobs === 'boolean') {
	        return Promise$1.resolve(supportsBlobs);
	    }
	    return _checkBlobSupportWithoutCaching(idb).then(function (value) {
	        supportsBlobs = value;
	        return supportsBlobs;
	    });
	}

	function _deferReadiness(dbInfo) {
	    var dbContext = dbContexts[dbInfo.name];

	    // Create a deferred object representing the current database operation.
	    var deferredOperation = {};

	    deferredOperation.promise = new Promise$1(function (resolve, reject) {
	        deferredOperation.resolve = resolve;
	        deferredOperation.reject = reject;
	    });

	    // Enqueue the deferred operation.
	    dbContext.deferredOperations.push(deferredOperation);

	    // Chain its promise to the database readiness.
	    if (!dbContext.dbReady) {
	        dbContext.dbReady = deferredOperation.promise;
	    } else {
	        dbContext.dbReady = dbContext.dbReady.then(function () {
	            return deferredOperation.promise;
	        });
	    }
	}

	function _advanceReadiness(dbInfo) {
	    var dbContext = dbContexts[dbInfo.name];

	    // Dequeue a deferred operation.
	    var deferredOperation = dbContext.deferredOperations.pop();

	    // Resolve its promise (which is part of the database readiness
	    // chain of promises).
	    if (deferredOperation) {
	        deferredOperation.resolve();
	        return deferredOperation.promise;
	    }
	}

	function _rejectReadiness(dbInfo, err) {
	    var dbContext = dbContexts[dbInfo.name];

	    // Dequeue a deferred operation.
	    var deferredOperation = dbContext.deferredOperations.pop();

	    // Reject its promise (which is part of the database readiness
	    // chain of promises).
	    if (deferredOperation) {
	        deferredOperation.reject(err);
	        return deferredOperation.promise;
	    }
	}

	function _getConnection(dbInfo, upgradeNeeded) {
	    return new Promise$1(function (resolve, reject) {
	        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();

	        if (dbInfo.db) {
	            if (upgradeNeeded) {
	                _deferReadiness(dbInfo);
	                dbInfo.db.close();
	            } else {
	                return resolve(dbInfo.db);
	            }
	        }

	        var dbArgs = [dbInfo.name];

	        if (upgradeNeeded) {
	            dbArgs.push(dbInfo.version);
	        }

	        var openreq = idb.open.apply(idb, dbArgs);

	        if (upgradeNeeded) {
	            openreq.onupgradeneeded = function (e) {
	                var db = openreq.result;
	                try {
	                    db.createObjectStore(dbInfo.storeName);
	                    if (e.oldVersion <= 1) {
	                        // Added when support for blob shims was added
	                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
	                    }
	                } catch (ex) {
	                    if (ex.name === 'ConstraintError') {
	                        console.warn('The database "' + dbInfo.name + '"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
	                    } else {
	                        throw ex;
	                    }
	                }
	            };
	        }

	        openreq.onerror = function (e) {
	            e.preventDefault();
	            reject(openreq.error);
	        };

	        openreq.onsuccess = function () {
	            resolve(openreq.result);
	            _advanceReadiness(dbInfo);
	        };
	    });
	}

	function _getOriginalConnection(dbInfo) {
	    return _getConnection(dbInfo, false);
	}

	function _getUpgradedConnection(dbInfo) {
	    return _getConnection(dbInfo, true);
	}

	function _isUpgradeNeeded(dbInfo, defaultVersion) {
	    if (!dbInfo.db) {
	        return true;
	    }

	    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
	    var isDowngrade = dbInfo.version < dbInfo.db.version;
	    var isUpgrade = dbInfo.version > dbInfo.db.version;

	    if (isDowngrade) {
	        // If the version is not the default one
	        // then warn for impossible downgrade.
	        if (dbInfo.version !== defaultVersion) {
	            console.warn('The database "' + dbInfo.name + '"' + " can't be downgraded from version " + dbInfo.db.version + ' to version ' + dbInfo.version + '.');
	        }
	        // Align the versions to prevent errors.
	        dbInfo.version = dbInfo.db.version;
	    }

	    if (isUpgrade || isNewStore) {
	        // If the store is new then increment the version (if needed).
	        // This will trigger an "upgradeneeded" event which is required
	        // for creating a store.
	        if (isNewStore) {
	            var incVersion = dbInfo.db.version + 1;
	            if (incVersion > dbInfo.version) {
	                dbInfo.version = incVersion;
	            }
	        }

	        return true;
	    }

	    return false;
	}

	// encode a blob for indexeddb engines that don't support blobs
	function _encodeBlob(blob) {
	    return new Promise$1(function (resolve, reject) {
	        var reader = new FileReader();
	        reader.onerror = reject;
	        reader.onloadend = function (e) {
	            var base64 = btoa(e.target.result || '');
	            resolve({
	                __local_forage_encoded_blob: true,
	                data: base64,
	                type: blob.type
	            });
	        };
	        reader.readAsBinaryString(blob);
	    });
	}

	// decode an encoded blob
	function _decodeBlob(encodedBlob) {
	    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
	    return createBlob([arrayBuff], { type: encodedBlob.type });
	}

	// is this one of our fancy encoded blobs?
	function _isEncodedBlob(value) {
	    return value && value.__local_forage_encoded_blob;
	}

	// Specialize the default `ready()` function by making it dependent
	// on the current database operations. Thus, the driver will be actually
	// ready when it's been initialized (default) *and* there are no pending
	// operations on the database (initiated by some other instances).
	function _fullyReady(callback) {
	    var self = this;

	    var promise = self._initReady().then(function () {
	        var dbContext = dbContexts[self._dbInfo.name];

	        if (dbContext && dbContext.dbReady) {
	            return dbContext.dbReady;
	        }
	    });

	    executeTwoCallbacks(promise, callback, callback);
	    return promise;
	}

	// Try to establish a new db connection to replace the
	// current one which is broken (i.e. experiencing
	// InvalidStateError while creating a transaction).
	function _tryReconnect(dbInfo) {
	    _deferReadiness(dbInfo);

	    var dbContext = dbContexts[dbInfo.name];
	    var forages = dbContext.forages;

	    for (var i = 0; i < forages.length; i++) {
	        var forage = forages[i];
	        if (forage._dbInfo.db) {
	            forage._dbInfo.db.close();
	            forage._dbInfo.db = null;
	        }
	    }
	    dbInfo.db = null;

	    return _getOriginalConnection(dbInfo).then(function (db) {
	        dbInfo.db = db;
	        if (_isUpgradeNeeded(dbInfo)) {
	            // Reopen the database for upgrading.
	            return _getUpgradedConnection(dbInfo);
	        }
	        return db;
	    }).then(function (db) {
	        // store the latest db reference
	        // in case the db was upgraded
	        dbInfo.db = dbContext.db = db;
	        for (var i = 0; i < forages.length; i++) {
	            forages[i]._dbInfo.db = db;
	        }
	    })["catch"](function (err) {
	        _rejectReadiness(dbInfo, err);
	        throw err;
	    });
	}

	// FF doesn't like Promises (micro-tasks) and IDDB store operations,
	// so we have to do it with callbacks
	function createTransaction(dbInfo, mode, callback, retries) {
	    if (retries === undefined) {
	        retries = 1;
	    }

	    try {
	        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
	        callback(null, tx);
	    } catch (err) {
	        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {
	            return Promise$1.resolve().then(function () {
	                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
	                    // increase the db version, to create the new ObjectStore
	                    if (dbInfo.db) {
	                        dbInfo.version = dbInfo.db.version + 1;
	                    }
	                    // Reopen the database for upgrading.
	                    return _getUpgradedConnection(dbInfo);
	                }
	            }).then(function () {
	                return _tryReconnect(dbInfo).then(function () {
	                    createTransaction(dbInfo, mode, callback, retries - 1);
	                });
	            })["catch"](callback);
	        }

	        callback(err);
	    }
	}

	function createDbContext() {
	    return {
	        // Running localForages sharing a database.
	        forages: [],
	        // Shared database.
	        db: null,
	        // Database readiness (promise).
	        dbReady: null,
	        // Deferred operations on the database.
	        deferredOperations: []
	    };
	}

	// Open the IndexedDB database (automatically creates one if one didn't
	// previously exist), using any options set in the config.
	function _initStorage(options) {
	    var self = this;
	    var dbInfo = {
	        db: null
	    };

	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = options[i];
	        }
	    }

	    // Get the current context of the database;
	    var dbContext = dbContexts[dbInfo.name];

	    // ...or create a new context.
	    if (!dbContext) {
	        dbContext = createDbContext();
	        // Register the new context in the global container.
	        dbContexts[dbInfo.name] = dbContext;
	    }

	    // Register itself as a running localForage in the current context.
	    dbContext.forages.push(self);

	    // Replace the default `ready()` function with the specialized one.
	    if (!self._initReady) {
	        self._initReady = self.ready;
	        self.ready = _fullyReady;
	    }

	    // Create an array of initialization states of the related localForages.
	    var initPromises = [];

	    function ignoreErrors() {
	        // Don't handle errors here,
	        // just makes sure related localForages aren't pending.
	        return Promise$1.resolve();
	    }

	    for (var j = 0; j < dbContext.forages.length; j++) {
	        var forage = dbContext.forages[j];
	        if (forage !== self) {
	            // Don't wait for itself...
	            initPromises.push(forage._initReady()["catch"](ignoreErrors));
	        }
	    }

	    // Take a snapshot of the related localForages.
	    var forages = dbContext.forages.slice(0);

	    // Initialize the connection process only when
	    // all the related localForages aren't pending.
	    return Promise$1.all(initPromises).then(function () {
	        dbInfo.db = dbContext.db;
	        // Get the connection or open a new one without upgrade.
	        return _getOriginalConnection(dbInfo);
	    }).then(function (db) {
	        dbInfo.db = db;
	        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {
	            // Reopen the database for upgrading.
	            return _getUpgradedConnection(dbInfo);
	        }
	        return db;
	    }).then(function (db) {
	        dbInfo.db = dbContext.db = db;
	        self._dbInfo = dbInfo;
	        // Share the final connection amongst related localForages.
	        for (var k = 0; k < forages.length; k++) {
	            var forage = forages[k];
	            if (forage !== self) {
	                // Self is already up-to-date.
	                forage._dbInfo.db = dbInfo.db;
	                forage._dbInfo.version = dbInfo.version;
	            }
	        }
	    });
	}

	function getItem(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var req = store.get(key);

	                    req.onsuccess = function () {
	                        var value = req.result;
	                        if (value === undefined) {
	                            value = null;
	                        }
	                        if (_isEncodedBlob(value)) {
	                            value = _decodeBlob(value);
	                        }
	                        resolve(value);
	                    };

	                    req.onerror = function () {
	                        reject(req.error);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Iterate over all items stored in database.
	function iterate(iterator, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var req = store.openCursor();
	                    var iterationNumber = 1;

	                    req.onsuccess = function () {
	                        var cursor = req.result;

	                        if (cursor) {
	                            var value = cursor.value;
	                            if (_isEncodedBlob(value)) {
	                                value = _decodeBlob(value);
	                            }
	                            var result = iterator(value, cursor.key, iterationNumber++);

	                            // when the iterator callback returns any
	                            // (non-`undefined`) value, then we stop
	                            // the iteration immediately
	                            if (result !== void 0) {
	                                resolve(result);
	                            } else {
	                                cursor["continue"]();
	                            }
	                        } else {
	                            resolve();
	                        }
	                    };

	                    req.onerror = function () {
	                        reject(req.error);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);

	    return promise;
	}

	function setItem(key, value, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        var dbInfo;
	        self.ready().then(function () {
	            dbInfo = self._dbInfo;
	            if (toString.call(value) === '[object Blob]') {
	                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {
	                    if (blobSupport) {
	                        return value;
	                    }
	                    return _encodeBlob(value);
	                });
	            }
	            return value;
	        }).then(function (value) {
	            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);

	                    // The reason we don't _save_ null is because IE 10 does
	                    // not support saving the `null` type in IndexedDB. How
	                    // ironic, given the bug below!
	                    // See: https://github.com/mozilla/localForage/issues/161
	                    if (value === null) {
	                        value = undefined;
	                    }

	                    var req = store.put(value, key);

	                    transaction.oncomplete = function () {
	                        // Cast to undefined so the value passed to
	                        // callback/promise is the same as what one would get out
	                        // of `getItem()` later. This leads to some weirdness
	                        // (setItem('foo', undefined) will return `null`), but
	                        // it's not my fault localStorage is our baseline and that
	                        // it's weird.
	                        if (value === undefined) {
	                            value = null;
	                        }

	                        resolve(value);
	                    };
	                    transaction.onabort = transaction.onerror = function () {
	                        var err = req.error ? req.error : req.transaction.error;
	                        reject(err);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function removeItem(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    // We use a Grunt task to make this safe for IE and some
	                    // versions of Android (including those used by Cordova).
	                    // Normally IE won't like `.delete()` and will insist on
	                    // using `['delete']()`, but we have a build step that
	                    // fixes this for us now.
	                    var req = store["delete"](key);
	                    transaction.oncomplete = function () {
	                        resolve();
	                    };

	                    transaction.onerror = function () {
	                        reject(req.error);
	                    };

	                    // The request will be also be aborted if we've exceeded our storage
	                    // space.
	                    transaction.onabort = function () {
	                        var err = req.error ? req.error : req.transaction.error;
	                        reject(err);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function clear(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var req = store.clear();

	                    transaction.oncomplete = function () {
	                        resolve();
	                    };

	                    transaction.onabort = transaction.onerror = function () {
	                        var err = req.error ? req.error : req.transaction.error;
	                        reject(err);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function length(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var req = store.count();

	                    req.onsuccess = function () {
	                        resolve(req.result);
	                    };

	                    req.onerror = function () {
	                        reject(req.error);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function key(n, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        if (n < 0) {
	            resolve(null);

	            return;
	        }

	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var advanced = false;
	                    var req = store.openKeyCursor();

	                    req.onsuccess = function () {
	                        var cursor = req.result;
	                        if (!cursor) {
	                            // this means there weren't enough keys
	                            resolve(null);

	                            return;
	                        }

	                        if (n === 0) {
	                            // We have the first key, return it if that's what they
	                            // wanted.
	                            resolve(cursor.key);
	                        } else {
	                            if (!advanced) {
	                                // Otherwise, ask the cursor to skip ahead n
	                                // records.
	                                advanced = true;
	                                cursor.advance(n);
	                            } else {
	                                // When we get here, we've got the nth key.
	                                resolve(cursor.key);
	                            }
	                        }
	                    };

	                    req.onerror = function () {
	                        reject(req.error);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {
	                if (err) {
	                    return reject(err);
	                }

	                try {
	                    var store = transaction.objectStore(self._dbInfo.storeName);
	                    var req = store.openKeyCursor();
	                    var keys = [];

	                    req.onsuccess = function () {
	                        var cursor = req.result;

	                        if (!cursor) {
	                            resolve(keys);
	                            return;
	                        }

	                        keys.push(cursor.key);
	                        cursor["continue"]();
	                    };

	                    req.onerror = function () {
	                        reject(req.error);
	                    };
	                } catch (e) {
	                    reject(e);
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function dropInstance(options, callback) {
	    callback = getCallback.apply(this, arguments);

	    var currentConfig = this.config();
	    options = typeof options !== 'function' && options || {};
	    if (!options.name) {
	        options.name = options.name || currentConfig.name;
	        options.storeName = options.storeName || currentConfig.storeName;
	    }

	    var self = this;
	    var promise;
	    if (!options.name) {
	        promise = Promise$1.reject('Invalid arguments');
	    } else {
	        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;

	        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {
	            var dbContext = dbContexts[options.name];
	            var forages = dbContext.forages;
	            dbContext.db = db;
	            for (var i = 0; i < forages.length; i++) {
	                forages[i]._dbInfo.db = db;
	            }
	            return db;
	        });

	        if (!options.storeName) {
	            promise = dbPromise.then(function (db) {
	                _deferReadiness(options);

	                var dbContext = dbContexts[options.name];
	                var forages = dbContext.forages;

	                db.close();
	                for (var i = 0; i < forages.length; i++) {
	                    var forage = forages[i];
	                    forage._dbInfo.db = null;
	                }

	                var dropDBPromise = new Promise$1(function (resolve, reject) {
	                    var req = idb.deleteDatabase(options.name);

	                    req.onerror = req.onblocked = function (err) {
	                        var db = req.result;
	                        if (db) {
	                            db.close();
	                        }
	                        reject(err);
	                    };

	                    req.onsuccess = function () {
	                        var db = req.result;
	                        if (db) {
	                            db.close();
	                        }
	                        resolve(db);
	                    };
	                });

	                return dropDBPromise.then(function (db) {
	                    dbContext.db = db;
	                    for (var i = 0; i < forages.length; i++) {
	                        var _forage = forages[i];
	                        _advanceReadiness(_forage._dbInfo);
	                    }
	                })["catch"](function (err) {
	                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
	                    throw err;
	                });
	            });
	        } else {
	            promise = dbPromise.then(function (db) {
	                if (!db.objectStoreNames.contains(options.storeName)) {
	                    return;
	                }

	                var newVersion = db.version + 1;

	                _deferReadiness(options);

	                var dbContext = dbContexts[options.name];
	                var forages = dbContext.forages;

	                db.close();
	                for (var i = 0; i < forages.length; i++) {
	                    var forage = forages[i];
	                    forage._dbInfo.db = null;
	                    forage._dbInfo.version = newVersion;
	                }

	                var dropObjectPromise = new Promise$1(function (resolve, reject) {
	                    var req = idb.open(options.name, newVersion);

	                    req.onerror = function (err) {
	                        var db = req.result;
	                        db.close();
	                        reject(err);
	                    };

	                    req.onupgradeneeded = function () {
	                        var db = req.result;
	                        db.deleteObjectStore(options.storeName);
	                    };

	                    req.onsuccess = function () {
	                        var db = req.result;
	                        db.close();
	                        resolve(db);
	                    };
	                });

	                return dropObjectPromise.then(function (db) {
	                    dbContext.db = db;
	                    for (var j = 0; j < forages.length; j++) {
	                        var _forage2 = forages[j];
	                        _forage2._dbInfo.db = db;
	                        _advanceReadiness(_forage2._dbInfo);
	                    }
	                })["catch"](function (err) {
	                    (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function () {});
	                    throw err;
	                });
	            });
	        }
	    }

	    executeCallback(promise, callback);
	    return promise;
	}

	var asyncStorage = {
	    _driver: 'asyncStorage',
	    _initStorage: _initStorage,
	    _support: isIndexedDBValid(),
	    iterate: iterate,
	    getItem: getItem,
	    setItem: setItem,
	    removeItem: removeItem,
	    clear: clear,
	    length: length,
	    key: key,
	    keys: keys,
	    dropInstance: dropInstance
	};

	function isWebSQLValid() {
	    return typeof openDatabase === 'function';
	}

	// Sadly, the best way to save binary data in WebSQL/localStorage is serializing
	// it to Base64, so this is how we store it to prevent very strange errors with less
	// verbose ways of binary <-> string data storage.
	var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	var BLOB_TYPE_PREFIX = '~~local_forage_type~';
	var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;

	var SERIALIZED_MARKER = '__lfsc__:';
	var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;

	// OMG the serializations!
	var TYPE_ARRAYBUFFER = 'arbf';
	var TYPE_BLOB = 'blob';
	var TYPE_INT8ARRAY = 'si08';
	var TYPE_UINT8ARRAY = 'ui08';
	var TYPE_UINT8CLAMPEDARRAY = 'uic8';
	var TYPE_INT16ARRAY = 'si16';
	var TYPE_INT32ARRAY = 'si32';
	var TYPE_UINT16ARRAY = 'ur16';
	var TYPE_UINT32ARRAY = 'ui32';
	var TYPE_FLOAT32ARRAY = 'fl32';
	var TYPE_FLOAT64ARRAY = 'fl64';
	var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;

	var toString$1 = Object.prototype.toString;

	function stringToBuffer(serializedString) {
	    // Fill the string into a ArrayBuffer.
	    var bufferLength = serializedString.length * 0.75;
	    var len = serializedString.length;
	    var i;
	    var p = 0;
	    var encoded1, encoded2, encoded3, encoded4;

	    if (serializedString[serializedString.length - 1] === '=') {
	        bufferLength--;
	        if (serializedString[serializedString.length - 2] === '=') {
	            bufferLength--;
	        }
	    }

	    var buffer = new ArrayBuffer(bufferLength);
	    var bytes = new Uint8Array(buffer);

	    for (i = 0; i < len; i += 4) {
	        encoded1 = BASE_CHARS.indexOf(serializedString[i]);
	        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
	        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
	        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);

	        /*jslint bitwise: true */
	        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
	        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
	        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
	    }
	    return buffer;
	}

	// Converts a buffer to a string to store, serialized, in the backend
	// storage library.
	function bufferToString(buffer) {
	    // base64-arraybuffer
	    var bytes = new Uint8Array(buffer);
	    var base64String = '';
	    var i;

	    for (i = 0; i < bytes.length; i += 3) {
	        /*jslint bitwise: true */
	        base64String += BASE_CHARS[bytes[i] >> 2];
	        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
	        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
	        base64String += BASE_CHARS[bytes[i + 2] & 63];
	    }

	    if (bytes.length % 3 === 2) {
	        base64String = base64String.substring(0, base64String.length - 1) + '=';
	    } else if (bytes.length % 3 === 1) {
	        base64String = base64String.substring(0, base64String.length - 2) + '==';
	    }

	    return base64String;
	}

	// Serialize a value, afterwards executing a callback (which usually
	// instructs the `setItem()` callback/promise to be executed). This is how
	// we store binary data with localStorage.
	function serialize(value, callback) {
	    var valueType = '';
	    if (value) {
	        valueType = toString$1.call(value);
	    }

	    // Cannot use `value instanceof ArrayBuffer` or such here, as these
	    // checks fail when running the tests using casper.js...
	    //
	    // TODO: See why those tests fail and use a better solution.
	    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {
	        // Convert binary arrays to a string and prefix the string with
	        // a special marker.
	        var buffer;
	        var marker = SERIALIZED_MARKER;

	        if (value instanceof ArrayBuffer) {
	            buffer = value;
	            marker += TYPE_ARRAYBUFFER;
	        } else {
	            buffer = value.buffer;

	            if (valueType === '[object Int8Array]') {
	                marker += TYPE_INT8ARRAY;
	            } else if (valueType === '[object Uint8Array]') {
	                marker += TYPE_UINT8ARRAY;
	            } else if (valueType === '[object Uint8ClampedArray]') {
	                marker += TYPE_UINT8CLAMPEDARRAY;
	            } else if (valueType === '[object Int16Array]') {
	                marker += TYPE_INT16ARRAY;
	            } else if (valueType === '[object Uint16Array]') {
	                marker += TYPE_UINT16ARRAY;
	            } else if (valueType === '[object Int32Array]') {
	                marker += TYPE_INT32ARRAY;
	            } else if (valueType === '[object Uint32Array]') {
	                marker += TYPE_UINT32ARRAY;
	            } else if (valueType === '[object Float32Array]') {
	                marker += TYPE_FLOAT32ARRAY;
	            } else if (valueType === '[object Float64Array]') {
	                marker += TYPE_FLOAT64ARRAY;
	            } else {
	                callback(new Error('Failed to get type for BinaryArray'));
	            }
	        }

	        callback(marker + bufferToString(buffer));
	    } else if (valueType === '[object Blob]') {
	        // Conver the blob to a binaryArray and then to a string.
	        var fileReader = new FileReader();

	        fileReader.onload = function () {
	            // Backwards-compatible prefix for the blob type.
	            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);

	            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
	        };

	        fileReader.readAsArrayBuffer(value);
	    } else {
	        try {
	            callback(JSON.stringify(value));
	        } catch (e) {
	            console.error("Couldn't convert value into a JSON string: ", value);

	            callback(null, e);
	        }
	    }
	}

	// Deserialize data we've inserted into a value column/field. We place
	// special markers into our strings to mark them as encoded; this isn't
	// as nice as a meta field, but it's the only sane thing we can do whilst
	// keeping localStorage support intact.
	//
	// Oftentimes this will just deserialize JSON content, but if we have a
	// special marker (SERIALIZED_MARKER, defined above), we will extract
	// some kind of arraybuffer/binary data/typed array out of the string.
	function deserialize(value) {
	    // If we haven't marked this string as being specially serialized (i.e.
	    // something other than serialized JSON), we can just return it and be
	    // done with it.
	    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
	        return JSON.parse(value);
	    }

	    // The following code deals with deserializing some kind of Blob or
	    // TypedArray. First we separate out the type of data we're dealing
	    // with from the data itself.
	    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
	    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);

	    var blobType;
	    // Backwards-compatible blob type serialization strategy.
	    // DBs created with older versions of localForage will simply not have the blob type.
	    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
	        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
	        blobType = matcher[1];
	        serializedString = serializedString.substring(matcher[0].length);
	    }
	    var buffer = stringToBuffer(serializedString);

	    // Return the right type based on the code/type set during
	    // serialization.
	    switch (type) {
	        case TYPE_ARRAYBUFFER:
	            return buffer;
	        case TYPE_BLOB:
	            return createBlob([buffer], { type: blobType });
	        case TYPE_INT8ARRAY:
	            return new Int8Array(buffer);
	        case TYPE_UINT8ARRAY:
	            return new Uint8Array(buffer);
	        case TYPE_UINT8CLAMPEDARRAY:
	            return new Uint8ClampedArray(buffer);
	        case TYPE_INT16ARRAY:
	            return new Int16Array(buffer);
	        case TYPE_UINT16ARRAY:
	            return new Uint16Array(buffer);
	        case TYPE_INT32ARRAY:
	            return new Int32Array(buffer);
	        case TYPE_UINT32ARRAY:
	            return new Uint32Array(buffer);
	        case TYPE_FLOAT32ARRAY:
	            return new Float32Array(buffer);
	        case TYPE_FLOAT64ARRAY:
	            return new Float64Array(buffer);
	        default:
	            throw new Error('Unkown type: ' + type);
	    }
	}

	var localforageSerializer = {
	    serialize: serialize,
	    deserialize: deserialize,
	    stringToBuffer: stringToBuffer,
	    bufferToString: bufferToString
	};

	/*
	 * Includes code from:
	 *
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */

	function createDbTable(t, dbInfo, callback, errorCallback) {
	    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);
	}

	// Open the WebSQL database (automatically creates one if one didn't
	// previously exist), using any options set in the config.
	function _initStorage$1(options) {
	    var self = this;
	    var dbInfo = {
	        db: null
	    };

	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];
	        }
	    }

	    var dbInfoPromise = new Promise$1(function (resolve, reject) {
	        // Open the database; the openDatabase API will automatically
	        // create it for us if it doesn't exist.
	        try {
	            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
	        } catch (e) {
	            return reject(e);
	        }

	        // Create our key/value table if it doesn't exist.
	        dbInfo.db.transaction(function (t) {
	            createDbTable(t, dbInfo, function () {
	                self._dbInfo = dbInfo;
	                resolve();
	            }, function (t, error) {
	                reject(error);
	            });
	        }, reject);
	    });

	    dbInfo.serializer = localforageSerializer;
	    return dbInfoPromise;
	}

	function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
	    t.executeSql(sqlStatement, args, callback, function (t, error) {
	        if (error.code === error.SYNTAX_ERR) {
	            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name = ?", [dbInfo.storeName], function (t, results) {
	                if (!results.rows.length) {
	                    // if the table is missing (was deleted)
	                    // re-create it table and retry
	                    createDbTable(t, dbInfo, function () {
	                        t.executeSql(sqlStatement, args, callback, errorCallback);
	                    }, errorCallback);
	                } else {
	                    errorCallback(t, error);
	                }
	            }, errorCallback);
	        } else {
	            errorCallback(t, error);
	        }
	    }, errorCallback);
	}

	function getItem$1(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {
	                    var result = results.rows.length ? results.rows.item(0).value : null;

	                    // Check to see if this is serialized content we need to
	                    // unpack.
	                    if (result) {
	                        result = dbInfo.serializer.deserialize(result);
	                    }

	                    resolve(result);
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function iterate$1(iterator, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;

	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var rows = results.rows;
	                    var length = rows.length;

	                    for (var i = 0; i < length; i++) {
	                        var item = rows.item(i);
	                        var result = item.value;

	                        // Check to see if this is serialized content
	                        // we need to unpack.
	                        if (result) {
	                            result = dbInfo.serializer.deserialize(result);
	                        }

	                        result = iterator(result, item.key, i + 1);

	                        // void(0) prevents problems with redefinition
	                        // of `undefined`.
	                        if (result !== void 0) {
	                            resolve(result);
	                            return;
	                        }
	                    }

	                    resolve();
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function _setItem(key, value, callback, retriesLeft) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            // The localStorage API doesn't return undefined values in an
	            // "expected" way, so undefined is always cast to null in all
	            // drivers. See: https://github.com/mozilla/localForage/pull/42
	            if (value === undefined) {
	                value = null;
	            }

	            // Save the original value to pass to the callback.
	            var originalValue = value;

	            var dbInfo = self._dbInfo;
	            dbInfo.serializer.serialize(value, function (value, error) {
	                if (error) {
	                    reject(error);
	                } else {
	                    dbInfo.db.transaction(function (t) {
	                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {
	                            resolve(originalValue);
	                        }, function (t, error) {
	                            reject(error);
	                        });
	                    }, function (sqlError) {
	                        // The transaction failed; check
	                        // to see if it's a quota error.
	                        if (sqlError.code === sqlError.QUOTA_ERR) {
	                            // We reject the callback outright for now, but
	                            // it's worth trying to re-run the transaction.
	                            // Even if the user accepts the prompt to use
	                            // more storage on Safari, this error will
	                            // be called.
	                            //
	                            // Try to re-run the transaction.
	                            if (retriesLeft > 0) {
	                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));
	                                return;
	                            }
	                            reject(sqlError);
	                        }
	                    });
	                }
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function setItem$1(key, value, callback) {
	    return _setItem.apply(this, [key, value, callback, 1]);
	}

	function removeItem$1(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {
	                    resolve();
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Deletes every item in the table.
	// TODO: Find out if this resets the AUTO_INCREMENT number.
	function clear$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {
	                    resolve();
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Does a simple `COUNT(key)` to get the number of items stored in
	// localForage.
	function length$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                // Ahhh, SQL makes this one soooooo easy.
	                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var result = results.rows.item(0).c;
	                    resolve(result);
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Return the key located at key index X; essentially gets the key from a
	// `WHERE id = ?`. This is the most efficient way I can think to implement
	// this rarely-used (in my experience) part of the API, but it can seem
	// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so
	// the ID of each key will change every time it's updated. Perhaps a stored
	// procedure for the `setItem()` SQL would solve this problem?
	// TODO: Don't change ID on `setItem()`.
	function key$1(n, callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {
	                    var result = results.rows.length ? results.rows.item(0).key : null;
	                    resolve(result);
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys$1(callback) {
	    var self = this;

	    var promise = new Promise$1(function (resolve, reject) {
	        self.ready().then(function () {
	            var dbInfo = self._dbInfo;
	            dbInfo.db.transaction(function (t) {
	                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {
	                    var keys = [];

	                    for (var i = 0; i < results.rows.length; i++) {
	                        keys.push(results.rows.item(i).key);
	                    }

	                    resolve(keys);
	                }, function (t, error) {
	                    reject(error);
	                });
	            });
	        })["catch"](reject);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// https://www.w3.org/TR/webdatabase/#databases
	// > There is no way to enumerate or delete the databases available for an origin from this API.
	function getAllStoreNames(db) {
	    return new Promise$1(function (resolve, reject) {
	        db.transaction(function (t) {
	            t.executeSql('SELECT name FROM sqlite_master ' + "WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (t, results) {
	                var storeNames = [];

	                for (var i = 0; i < results.rows.length; i++) {
	                    storeNames.push(results.rows.item(i).name);
	                }

	                resolve({
	                    db: db,
	                    storeNames: storeNames
	                });
	            }, function (t, error) {
	                reject(error);
	            });
	        }, function (sqlError) {
	            reject(sqlError);
	        });
	    });
	}

	function dropInstance$1(options, callback) {
	    callback = getCallback.apply(this, arguments);

	    var currentConfig = this.config();
	    options = typeof options !== 'function' && options || {};
	    if (!options.name) {
	        options.name = options.name || currentConfig.name;
	        options.storeName = options.storeName || currentConfig.storeName;
	    }

	    var self = this;
	    var promise;
	    if (!options.name) {
	        promise = Promise$1.reject('Invalid arguments');
	    } else {
	        promise = new Promise$1(function (resolve) {
	            var db;
	            if (options.name === currentConfig.name) {
	                // use the db reference of the current instance
	                db = self._dbInfo.db;
	            } else {
	                db = openDatabase(options.name, '', '', 0);
	            }

	            if (!options.storeName) {
	                // drop all database tables
	                resolve(getAllStoreNames(db));
	            } else {
	                resolve({
	                    db: db,
	                    storeNames: [options.storeName]
	                });
	            }
	        }).then(function (operationInfo) {
	            return new Promise$1(function (resolve, reject) {
	                operationInfo.db.transaction(function (t) {
	                    function dropTable(storeName) {
	                        return new Promise$1(function (resolve, reject) {
	                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {
	                                resolve();
	                            }, function (t, error) {
	                                reject(error);
	                            });
	                        });
	                    }

	                    var operations = [];
	                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
	                        operations.push(dropTable(operationInfo.storeNames[i]));
	                    }

	                    Promise$1.all(operations).then(function () {
	                        resolve();
	                    })["catch"](function (e) {
	                        reject(e);
	                    });
	                }, function (sqlError) {
	                    reject(sqlError);
	                });
	            });
	        });
	    }

	    executeCallback(promise, callback);
	    return promise;
	}

	var webSQLStorage = {
	    _driver: 'webSQLStorage',
	    _initStorage: _initStorage$1,
	    _support: isWebSQLValid(),
	    iterate: iterate$1,
	    getItem: getItem$1,
	    setItem: setItem$1,
	    removeItem: removeItem$1,
	    clear: clear$1,
	    length: length$1,
	    key: key$1,
	    keys: keys$1,
	    dropInstance: dropInstance$1
	};

	function isLocalStorageValid() {
	    try {
	        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&
	        // in IE8 typeof localStorage.setItem === 'object'
	        !!localStorage.setItem;
	    } catch (e) {
	        return false;
	    }
	}

	function _getKeyPrefix(options, defaultConfig) {
	    var keyPrefix = options.name + '/';

	    if (options.storeName !== defaultConfig.storeName) {
	        keyPrefix += options.storeName + '/';
	    }
	    return keyPrefix;
	}

	// Check if localStorage throws when saving an item
	function checkIfLocalStorageThrows() {
	    var localStorageTestKey = '_localforage_support_test';

	    try {
	        localStorage.setItem(localStorageTestKey, true);
	        localStorage.removeItem(localStorageTestKey);

	        return false;
	    } catch (e) {
	        return true;
	    }
	}

	// Check if localStorage is usable and allows to save an item
	// This method checks if localStorage is usable in Safari Private Browsing
	// mode, or in any other case where the available quota for localStorage
	// is 0 and there wasn't any saved items yet.
	function _isLocalStorageUsable() {
	    return !checkIfLocalStorageThrows() || localStorage.length > 0;
	}

	// Config the localStorage backend, using options set in the config.
	function _initStorage$2(options) {
	    var self = this;
	    var dbInfo = {};
	    if (options) {
	        for (var i in options) {
	            dbInfo[i] = options[i];
	        }
	    }

	    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);

	    if (!_isLocalStorageUsable()) {
	        return Promise$1.reject();
	    }

	    self._dbInfo = dbInfo;
	    dbInfo.serializer = localforageSerializer;

	    return Promise$1.resolve();
	}

	// Remove all keys from the datastore, effectively destroying all data in
	// the app's key/value store!
	function clear$2(callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var keyPrefix = self._dbInfo.keyPrefix;

	        for (var i = localStorage.length - 1; i >= 0; i--) {
	            var key = localStorage.key(i);

	            if (key.indexOf(keyPrefix) === 0) {
	                localStorage.removeItem(key);
	            }
	        }
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Retrieve an item from the store. Unlike the original async_storage
	// library in Gaia, we don't modify return values at all. If a key's value
	// is `undefined`, we pass that value to the callback function.
	function getItem$2(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var result = localStorage.getItem(dbInfo.keyPrefix + key);

	        // If a result was found, parse it from the serialized
	        // string into a JS object. If result isn't truthy, the key
	        // is likely undefined and we'll pass it straight to the
	        // callback.
	        if (result) {
	            result = dbInfo.serializer.deserialize(result);
	        }

	        return result;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Iterate over all items in the store.
	function iterate$2(iterator, callback) {
	    var self = this;

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var keyPrefix = dbInfo.keyPrefix;
	        var keyPrefixLength = keyPrefix.length;
	        var length = localStorage.length;

	        // We use a dedicated iterator instead of the `i` variable below
	        // so other keys we fetch in localStorage aren't counted in
	        // the `iterationNumber` argument passed to the `iterate()`
	        // callback.
	        //
	        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530
	        var iterationNumber = 1;

	        for (var i = 0; i < length; i++) {
	            var key = localStorage.key(i);
	            if (key.indexOf(keyPrefix) !== 0) {
	                continue;
	            }
	            var value = localStorage.getItem(key);

	            // If a result was found, parse it from the serialized
	            // string into a JS object. If result isn't truthy, the
	            // key is likely undefined and we'll pass it straight
	            // to the iterator.
	            if (value) {
	                value = dbInfo.serializer.deserialize(value);
	            }

	            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);

	            if (value !== void 0) {
	                return value;
	            }
	        }
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Same as localStorage's key() method, except takes a callback.
	function key$2(n, callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var result;
	        try {
	            result = localStorage.key(n);
	        } catch (error) {
	            result = null;
	        }

	        // Remove the prefix from the key, if a key is found.
	        if (result) {
	            result = result.substring(dbInfo.keyPrefix.length);
	        }

	        return result;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function keys$2(callback) {
	    var self = this;
	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        var length = localStorage.length;
	        var keys = [];

	        for (var i = 0; i < length; i++) {
	            var itemKey = localStorage.key(i);
	            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
	                keys.push(itemKey.substring(dbInfo.keyPrefix.length));
	            }
	        }

	        return keys;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Supply the number of keys in the datastore to the callback function.
	function length$2(callback) {
	    var self = this;
	    var promise = self.keys().then(function (keys) {
	        return keys.length;
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Remove an item from the store, nice and simple.
	function removeItem$2(key, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = self.ready().then(function () {
	        var dbInfo = self._dbInfo;
	        localStorage.removeItem(dbInfo.keyPrefix + key);
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	// Set a key's value and run an optional callback once the value is set.
	// Unlike Gaia's implementation, the callback function is passed the value,
	// in case you want to operate on that value only after you're sure it
	// saved, or something like that.
	function setItem$2(key, value, callback) {
	    var self = this;

	    key = normalizeKey(key);

	    var promise = self.ready().then(function () {
	        // Convert undefined values to null.
	        // https://github.com/mozilla/localForage/pull/42
	        if (value === undefined) {
	            value = null;
	        }

	        // Save the original value to pass to the callback.
	        var originalValue = value;

	        return new Promise$1(function (resolve, reject) {
	            var dbInfo = self._dbInfo;
	            dbInfo.serializer.serialize(value, function (value, error) {
	                if (error) {
	                    reject(error);
	                } else {
	                    try {
	                        localStorage.setItem(dbInfo.keyPrefix + key, value);
	                        resolve(originalValue);
	                    } catch (e) {
	                        // localStorage capacity exceeded.
	                        // TODO: Make this a specific error/event.
	                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
	                            reject(e);
	                        }
	                        reject(e);
	                    }
	                }
	            });
	        });
	    });

	    executeCallback(promise, callback);
	    return promise;
	}

	function dropInstance$2(options, callback) {
	    callback = getCallback.apply(this, arguments);

	    options = typeof options !== 'function' && options || {};
	    if (!options.name) {
	        var currentConfig = this.config();
	        options.name = options.name || currentConfig.name;
	        options.storeName = options.storeName || currentConfig.storeName;
	    }

	    var self = this;
	    var promise;
	    if (!options.name) {
	        promise = Promise$1.reject('Invalid arguments');
	    } else {
	        promise = new Promise$1(function (resolve) {
	            if (!options.storeName) {
	                resolve(options.name + '/');
	            } else {
	                resolve(_getKeyPrefix(options, self._defaultConfig));
	            }
	        }).then(function (keyPrefix) {
	            for (var i = localStorage.length - 1; i >= 0; i--) {
	                var key = localStorage.key(i);

	                if (key.indexOf(keyPrefix) === 0) {
	                    localStorage.removeItem(key);
	                }
	            }
	        });
	    }

	    executeCallback(promise, callback);
	    return promise;
	}

	var localStorageWrapper = {
	    _driver: 'localStorageWrapper',
	    _initStorage: _initStorage$2,
	    _support: isLocalStorageValid(),
	    iterate: iterate$2,
	    getItem: getItem$2,
	    setItem: setItem$2,
	    removeItem: removeItem$2,
	    clear: clear$2,
	    length: length$2,
	    key: key$2,
	    keys: keys$2,
	    dropInstance: dropInstance$2
	};

	var sameValue = function sameValue(x, y) {
	    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);
	};

	var includes = function includes(array, searchElement) {
	    var len = array.length;
	    var i = 0;
	    while (i < len) {
	        if (sameValue(array[i], searchElement)) {
	            return true;
	        }
	        i++;
	    }

	    return false;
	};

	var isArray = Array.isArray || function (arg) {
	    return Object.prototype.toString.call(arg) === '[object Array]';
	};

	// Drivers are stored here when `defineDriver()` is called.
	// They are shared across all instances of localForage.
	var DefinedDrivers = {};

	var DriverSupport = {};

	var DefaultDrivers = {
	    INDEXEDDB: asyncStorage,
	    WEBSQL: webSQLStorage,
	    LOCALSTORAGE: localStorageWrapper
	};

	var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];

	var OptionalDriverMethods = ['dropInstance'];

	var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);

	var DefaultConfig = {
	    description: '',
	    driver: DefaultDriverOrder.slice(),
	    name: 'localforage',
	    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
	    // we can use without a prompt.
	    size: 4980736,
	    storeName: 'keyvaluepairs',
	    version: 1.0
	};

	function callWhenReady(localForageInstance, libraryMethod) {
	    localForageInstance[libraryMethod] = function () {
	        var _args = arguments;
	        return localForageInstance.ready().then(function () {
	            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
	        });
	    };
	}

	function extend() {
	    for (var i = 1; i < arguments.length; i++) {
	        var arg = arguments[i];

	        if (arg) {
	            for (var _key in arg) {
	                if (arg.hasOwnProperty(_key)) {
	                    if (isArray(arg[_key])) {
	                        arguments[0][_key] = arg[_key].slice();
	                    } else {
	                        arguments[0][_key] = arg[_key];
	                    }
	                }
	            }
	        }
	    }

	    return arguments[0];
	}

	var LocalForage = function () {
	    function LocalForage(options) {
	        _classCallCheck(this, LocalForage);

	        for (var driverTypeKey in DefaultDrivers) {
	            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
	                var driver = DefaultDrivers[driverTypeKey];
	                var driverName = driver._driver;
	                this[driverTypeKey] = driverName;

	                if (!DefinedDrivers[driverName]) {
	                    // we don't need to wait for the promise,
	                    // since the default drivers can be defined
	                    // in a blocking manner
	                    this.defineDriver(driver);
	                }
	            }
	        }

	        this._defaultConfig = extend({}, DefaultConfig);
	        this._config = extend({}, this._defaultConfig, options);
	        this._driverSet = null;
	        this._initDriver = null;
	        this._ready = false;
	        this._dbInfo = null;

	        this._wrapLibraryMethodsWithReady();
	        this.setDriver(this._config.driver)["catch"](function () {});
	    }

	    // Set any config values for localForage; can be called anytime before
	    // the first API call (e.g. `getItem`, `setItem`).
	    // We loop through options so we don't overwrite existing config
	    // values.


	    LocalForage.prototype.config = function config(options) {
	        // If the options argument is an object, we use it to set values.
	        // Otherwise, we return either a specified config value or all
	        // config values.
	        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
	            // If localforage is ready and fully initialized, we can't set
	            // any new configuration values. Instead, we return an error.
	            if (this._ready) {
	                return new Error("Can't call config() after localforage " + 'has been used.');
	            }

	            for (var i in options) {
	                if (i === 'storeName') {
	                    options[i] = options[i].replace(/\W/g, '_');
	                }

	                if (i === 'version' && typeof options[i] !== 'number') {
	                    return new Error('Database version must be a number.');
	                }

	                this._config[i] = options[i];
	            }

	            // after all config options are set and
	            // the driver option is used, try setting it
	            if ('driver' in options && options.driver) {
	                return this.setDriver(this._config.driver);
	            }

	            return true;
	        } else if (typeof options === 'string') {
	            return this._config[options];
	        } else {
	            return this._config;
	        }
	    };

	    // Used to define a custom driver, shared across all instances of
	    // localForage.


	    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
	        var promise = new Promise$1(function (resolve, reject) {
	            try {
	                var driverName = driverObject._driver;
	                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');

	                // A driver name should be defined and not overlap with the
	                // library-defined, default drivers.
	                if (!driverObject._driver) {
	                    reject(complianceError);
	                    return;
	                }

	                var driverMethods = LibraryMethods.concat('_initStorage');
	                for (var i = 0, len = driverMethods.length; i < len; i++) {
	                    var driverMethodName = driverMethods[i];

	                    // when the property is there,
	                    // it should be a method even when optional
	                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);
	                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {
	                        reject(complianceError);
	                        return;
	                    }
	                }

	                var configureMissingMethods = function configureMissingMethods() {
	                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {
	                        return function () {
	                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');
	                            var promise = Promise$1.reject(error);
	                            executeCallback(promise, arguments[arguments.length - 1]);
	                            return promise;
	                        };
	                    };

	                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
	                        var optionalDriverMethod = OptionalDriverMethods[_i];
	                        if (!driverObject[optionalDriverMethod]) {
	                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
	                        }
	                    }
	                };

	                configureMissingMethods();

	                var setDriverSupport = function setDriverSupport(support) {
	                    if (DefinedDrivers[driverName]) {
	                        console.info('Redefining LocalForage driver: ' + driverName);
	                    }
	                    DefinedDrivers[driverName] = driverObject;
	                    DriverSupport[driverName] = support;
	                    // don't use a then, so that we can define
	                    // drivers that have simple _support methods
	                    // in a blocking manner
	                    resolve();
	                };

	                if ('_support' in driverObject) {
	                    if (driverObject._support && typeof driverObject._support === 'function') {
	                        driverObject._support().then(setDriverSupport, reject);
	                    } else {
	                        setDriverSupport(!!driverObject._support);
	                    }
	                } else {
	                    setDriverSupport(true);
	                }
	            } catch (e) {
	                reject(e);
	            }
	        });

	        executeTwoCallbacks(promise, callback, errorCallback);
	        return promise;
	    };

	    LocalForage.prototype.driver = function driver() {
	        return this._driver || null;
	    };

	    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
	        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));

	        executeTwoCallbacks(getDriverPromise, callback, errorCallback);
	        return getDriverPromise;
	    };

	    LocalForage.prototype.getSerializer = function getSerializer(callback) {
	        var serializerPromise = Promise$1.resolve(localforageSerializer);
	        executeTwoCallbacks(serializerPromise, callback);
	        return serializerPromise;
	    };

	    LocalForage.prototype.ready = function ready(callback) {
	        var self = this;

	        var promise = self._driverSet.then(function () {
	            if (self._ready === null) {
	                self._ready = self._initDriver();
	            }

	            return self._ready;
	        });

	        executeTwoCallbacks(promise, callback, callback);
	        return promise;
	    };

	    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
	        var self = this;

	        if (!isArray(drivers)) {
	            drivers = [drivers];
	        }

	        var supportedDrivers = this._getSupportedDrivers(drivers);

	        function setDriverToConfig() {
	            self._config.driver = self.driver();
	        }

	        function extendSelfWithDriver(driver) {
	            self._extend(driver);
	            setDriverToConfig();

	            self._ready = self._initStorage(self._config);
	            return self._ready;
	        }

	        function initDriver(supportedDrivers) {
	            return function () {
	                var currentDriverIndex = 0;

	                function driverPromiseLoop() {
	                    while (currentDriverIndex < supportedDrivers.length) {
	                        var driverName = supportedDrivers[currentDriverIndex];
	                        currentDriverIndex++;

	                        self._dbInfo = null;
	                        self._ready = null;

	                        return self.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
	                    }

	                    setDriverToConfig();
	                    var error = new Error('No available storage method found.');
	                    self._driverSet = Promise$1.reject(error);
	                    return self._driverSet;
	                }

	                return driverPromiseLoop();
	            };
	        }

	        // There might be a driver initialization in progress
	        // so wait for it to finish in order to avoid a possible
	        // race condition to set _dbInfo
	        var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function () {
	            return Promise$1.resolve();
	        }) : Promise$1.resolve();

	        this._driverSet = oldDriverSetDone.then(function () {
	            var driverName = supportedDrivers[0];
	            self._dbInfo = null;
	            self._ready = null;

	            return self.getDriver(driverName).then(function (driver) {
	                self._driver = driver._driver;
	                setDriverToConfig();
	                self._wrapLibraryMethodsWithReady();
	                self._initDriver = initDriver(supportedDrivers);
	            });
	        })["catch"](function () {
	            setDriverToConfig();
	            var error = new Error('No available storage method found.');
	            self._driverSet = Promise$1.reject(error);
	            return self._driverSet;
	        });

	        executeTwoCallbacks(this._driverSet, callback, errorCallback);
	        return this._driverSet;
	    };

	    LocalForage.prototype.supports = function supports(driverName) {
	        return !!DriverSupport[driverName];
	    };

	    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {
	        extend(this, libraryMethodsAndProperties);
	    };

	    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
	        var supportedDrivers = [];
	        for (var i = 0, len = drivers.length; i < len; i++) {
	            var driverName = drivers[i];
	            if (this.supports(driverName)) {
	                supportedDrivers.push(driverName);
	            }
	        }
	        return supportedDrivers;
	    };

	    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
	        // Add a stub for each driver API method that delays the call to the
	        // corresponding driver method until localForage is ready. These stubs
	        // will be replaced by the driver methods as soon as the driver is
	        // loaded, so there is no performance impact.
	        for (var i = 0, len = LibraryMethods.length; i < len; i++) {
	            callWhenReady(this, LibraryMethods[i]);
	        }
	    };

	    LocalForage.prototype.createInstance = function createInstance(options) {
	        return new LocalForage(options);
	    };

	    return LocalForage;
	}();

	// The actual localForage object that we expose as a module or via a
	// global. It's extended by pulling in one of our other libraries.


	var localforage_js = new LocalForage();

	module.exports = localforage_js;

	},{"3":3}]},{},[4])(4)
	});
} (localforage));

/* eslint-disable no-case-declarations */

/**
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *
 * FBX format references:
 * 	https://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 * Binary format specification:
 *	https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */


let fbxTree;
let connections;
let sceneGraph;

class FBXLoader extends Loader {

  constructor ( manager ) {

    super( manager );

  }

  load ( url, onLoad, onProgress, onError ) {

    const scope = this;

    const path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;

    const loader = new FileLoader( this.manager );

    loader.setPath( scope.path );
    loader.setResponseType( 'arraybuffer' );
    loader.setRequestHeader( scope.requestHeader );
    loader.setWithCredentials( scope.withCredentials );

    loader.load( url, function ( buffer ) {

      try {

        onLoad( scope.parse( buffer, path ) );

      } catch ( e ) {

        if ( onError ) {

          onError( e );

        } else {

          console.error( e );

        }

        scope.manager.itemError( url );

      }

    }, onProgress, onError );

  }

  parse ( FBXBuffer, path ) {

    if ( isFbxFormatBinary( FBXBuffer ) ) {

      fbxTree = new BinaryParser().parse( FBXBuffer );

    } else {

      const FBXText = convertArrayBufferToString( FBXBuffer );

      if ( !isFbxFormatASCII( FBXText ) ) {

        throw new Error( 'THREE.FBXLoader: Unknown format.' )

      }

      if ( getFbxVersion( FBXText ) < 7000 ) {

        throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion( FBXText ) )

      }

      fbxTree = new TextParser().parse( FBXText );

    }

    // console.log( fbxTree );

    const textureLoader = new TextureLoader( this.manager ).setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );

    return new FBXTreeParser( textureLoader, this.manager ).parse( fbxTree )

  }

}

// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group
class FBXTreeParser {

  constructor ( textureLoader, manager ) {

    this.textureLoader = textureLoader;
    this.manager = manager;

  }

  parse () {

    connections = this.parseConnections();

    const images = this.parseImages();
    const textures = this.parseTextures( images );
    const materials = this.parseMaterials( textures );
    const deformers = this.parseDeformers();
    const geometryMap = new GeometryParser().parse( deformers );

    this.parseScene( deformers, geometryMap, materials );

    return sceneGraph

  }

  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections () {

    const connectionMap = new Map();

    if ( 'Connections' in fbxTree ) {

      const rawConnections = fbxTree.Connections.connections;

      rawConnections.forEach( function ( rawConnection ) {

        const fromID = rawConnection[ 0 ];
        const toID = rawConnection[ 1 ];
        const relationship = rawConnection[ 2 ];

        if ( !connectionMap.has( fromID ) ) {

          connectionMap.set( fromID, {
            parents: [],
            children: [],
          } );

        }

        const parentRelationship = { ID: toID, relationship: relationship, };

        connectionMap.get( fromID ).parents.push( parentRelationship );

        if ( !connectionMap.has( toID ) ) {

          connectionMap.set( toID, {
            parents: [],
            children: [],
          } );

        }

        const childRelationship = { ID: fromID, relationship: relationship, };

        connectionMap.get( toID ).children.push( childRelationship );

      } );

    }

    return connectionMap

  }

  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages () {

    const images = {};
    const blobs = {};

    if ( 'Video' in fbxTree.Objects ) {

      const videoNodes = fbxTree.Objects.Video;

      for ( const nodeID in videoNodes ) {

        const videoNode = videoNodes[ nodeID ];

        const id = parseInt( nodeID );

        images[ id ] = videoNode.RelativeFilename || videoNode.Filename;

        // raw image data is in videoNode.Content
        if ( 'Content' in videoNode ) {

          const arrayBufferContent = ( videoNode.Content instanceof ArrayBuffer ) && ( videoNode.Content.byteLength > 0 );
          const base64Content = ( typeof videoNode.Content === 'string' ) && ( videoNode.Content !== '' );

          if ( arrayBufferContent || base64Content ) {

            const image = this.parseImage( videoNodes[ nodeID ] );

            blobs[ videoNode.RelativeFilename || videoNode.Filename ] = image;

          }

        }

      }

    }

    for ( const id in images ) {

      const filename = images[ id ];

      if ( blobs[ filename ] !== undefined ) images[ id ] = blobs[ filename ];
      else images[ id ] = images[ id ].split( '\\' ).pop();

    }

    return images

  }

  // Parse embedded image data in FBXTree.Video.Content
  parseImage ( videoNode ) {

    const content = videoNode.Content;
    const fileName = videoNode.RelativeFilename || videoNode.Filename;
    const extension = fileName.slice( fileName.lastIndexOf( '.' ) + 1 ).toLowerCase();

    let type;

    switch ( extension ) {

    case 'bmp':

      type = 'image/bmp';
      break

    case 'jpg':
    case 'jpeg':

      type = 'image/jpeg';
      break

    case 'png':

      type = 'image/png';
      break

    case 'tif':

      type = 'image/tiff';
      break

    case 'tga':

      if ( this.manager.getHandler( '.tga' ) === null ) {

        console.warn( 'FBXLoader: TGA loader not found, skipping ', fileName );

      }

      type = 'image/tga';
      break

    default:

      console.warn( 'FBXLoader: Image type "' + extension + '" is not supported.' );
      return

    }

    if ( typeof content === 'string' ) { // ASCII format

      return 'data:' + type + ';base64,' + content

    } else { // Binary Format

      const array = new Uint8Array( content );

      return window.URL.createObjectURL( new Blob( [ array ], { type: type, } ) )

    }

  }

  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures ( images ) {

    const textureMap = new Map();

    if ( 'Texture' in fbxTree.Objects ) {

      const textureNodes = fbxTree.Objects.Texture;

      for ( const nodeID in textureNodes ) {

        const texture = this.parseTexture( textureNodes[ nodeID ], images );

        textureMap.set( parseInt( nodeID ), texture );

      }

    }

    return textureMap

  }

  // Parse individual node in FBXTree.Objects.Texture
  parseTexture ( textureNode, images ) {

    const texture = this.loadTexture( textureNode, images );

    texture.ID = textureNode.id;

    texture.name = textureNode.attrName;

    const wrapModeU = textureNode.WrapModeU;
    const wrapModeV = textureNode.WrapModeV;

    const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
    const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;

    // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
    // 0: repeat(default), 1: clamp

    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;
    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;

    if ( 'Scaling' in textureNode ) {

      const values = textureNode.Scaling.value;

      texture.repeat.x = values[ 0 ];
      texture.repeat.y = values[ 1 ];

    }

    if ( 'Translation' in textureNode ) {

      const values = textureNode.Translation.value;

      texture.offset.x = values[ 0 ];
      texture.offset.y = values[ 1 ];

    }

    return texture

  }

  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture ( textureNode, images ) {

    let fileName;

    const currentPath = this.textureLoader.path;

    const children = connections.get( textureNode.id ).children;

    if ( children !== undefined && children.length > 0 && images[ children[ 0 ].ID ] !== undefined ) {

      fileName = images[ children[ 0 ].ID ];

      if ( fileName.indexOf( 'blob:' ) === 0 || fileName.indexOf( 'data:' ) === 0 ) {

        this.textureLoader.setPath( undefined );

      }

    }

    let texture;

    const extension = textureNode.FileName.slice( -3 ).toLowerCase();

    if ( extension === 'tga' ) {

      const loader = this.manager.getHandler( '.tga' );

      if ( loader === null ) {

        console.warn( 'FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename );
        texture = new Texture();

      } else {

        loader.setPath( this.textureLoader.path );
        texture = loader.load( fileName );

      }

    } else if ( extension === 'psd' ) {

      console.warn( 'FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename );
      texture = new Texture();

    } else {

      texture = this.textureLoader.load( fileName );

    }

    this.textureLoader.setPath( currentPath );

    return texture

  }

  // Parse nodes in FBXTree.Objects.Material
  parseMaterials ( textureMap ) {

    const materialMap = new Map();

    if ( 'Material' in fbxTree.Objects ) {

      const materialNodes = fbxTree.Objects.Material;

      for ( const nodeID in materialNodes ) {

        const material = this.parseMaterial( materialNodes[ nodeID ], textureMap );

        if ( material !== null ) materialMap.set( parseInt( nodeID ), material );

      }

    }

    return materialMap

  }

  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial ( materialNode, textureMap ) {

    const ID = materialNode.id;
    const name = materialNode.attrName;
    let type = materialNode.ShadingModel;

    // Case where FBX wraps shading model in property object.
    if ( typeof type === 'object' ) {

      type = type.value;

    }

    // Ignore unused materials which don't have any connections.
    if ( !connections.has( ID ) ) return null

    const parameters = this.parseParameters( materialNode, textureMap, ID );

    let material;

    switch ( type.toLowerCase() ) {

    case 'phong':
    case 'lambert':
      material = new MeshStandardMaterial();
      break
    default:
      // console.warn( 'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshStandardMaterial.', type )
      material = new MeshStandardMaterial();
      break

    }

    material.setValues( parameters );
    material.name = name;

    return material

  }

  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters ( materialNode, textureMap, ID ) {

    const parameters = {};

    if ( materialNode.BumpFactor ) {

      parameters.bumpScale = materialNode.BumpFactor.value;

    }

    if ( materialNode.Diffuse ) {

      parameters.color = new Color().fromArray( materialNode.Diffuse.value ).convertSRGBToLinear();

    } else if ( materialNode.DiffuseColor && ( materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB' ) ) {

      // The blender exporter exports diffuse here instead of in materialNode.Diffuse
      parameters.color = new Color().fromArray( materialNode.DiffuseColor.value ).convertSRGBToLinear();

    }

    if ( materialNode.DisplacementFactor ) {

      parameters.displacementScale = materialNode.DisplacementFactor.value;

    }

    if ( materialNode.Emissive ) {

      parameters.emissive = new Color().fromArray( materialNode.Emissive.value ).convertSRGBToLinear();

    } else if ( materialNode.EmissiveColor && ( materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB' ) ) {

      // The blender exporter exports emissive color here instead of in materialNode.Emissive
      parameters.emissive = new Color().fromArray( materialNode.EmissiveColor.value ).convertSRGBToLinear();

    }

    if ( materialNode.EmissiveFactor ) {

      parameters.emissiveIntensity = parseFloat( materialNode.EmissiveFactor.value );

    }

    if ( materialNode.Opacity ) {

      parameters.opacity = parseFloat( materialNode.Opacity.value );

    }

    if ( parameters.opacity < 1.0 ) {

      parameters.transparent = true;
      parameters.depthWrite = false;

    }

    // if ( materialNode.ReflectionFactor ) {

    //   parameters.reflectivity = materialNode.ReflectionFactor.value

    // }

    // if ( materialNode.Shininess ) {

    //   parameters.shininess = materialNode.Shininess.value

    // }

    // if ( materialNode.Specular ) {

    //   parameters.specular = new Color().fromArray( materialNode.Specular.value ).convertSRGBToLinear()

    // } else if ( materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color' ) {

    //   // The blender exporter exports specular color here instead of in materialNode.Specular
    //   parameters.specular = new Color().fromArray( materialNode.SpecularColor.value ).convertSRGBToLinear()

    // }

    const scope = this;

    connections.get( ID ).children.forEach( function ( child ) {

      const type = child.relationship;

      switch ( type ) {

      case 'Bump':
        parameters.bumpMap = scope.getTexture( textureMap, child.ID );
        break

      case 'Maya|TEX_ao_map':
        parameters.aoMap = scope.getTexture( textureMap, child.ID );
        break

      case 'DiffuseColor':
      case 'Maya|TEX_color_map':
        parameters.map = scope.getTexture( textureMap, child.ID );
        if ( parameters.map !== undefined ) {

          parameters.map.encoding = sRGBEncoding;

        }

        break

      case 'DisplacementColor':
        parameters.displacementMap = scope.getTexture( textureMap, child.ID );
        break

      case 'EmissiveColor':
        parameters.emissiveMap = scope.getTexture( textureMap, child.ID );
        if ( parameters.emissiveMap !== undefined ) {

          parameters.emissiveMap.encoding = sRGBEncoding;

        }

        break

      case 'NormalMap':
      case 'Maya|TEX_normal_map':
        parameters.normalMap = scope.getTexture( textureMap, child.ID );
        break

      case 'ReflectionColor':
        parameters.envMap = scope.getTexture( textureMap, child.ID );
        if ( parameters.envMap !== undefined ) {

          parameters.envMap.mapping = EquirectangularReflectionMapping;
          parameters.envMap.encoding = sRGBEncoding;

        }

        break

      case 'SpecularColor':
        parameters.specularMap = scope.getTexture( textureMap, child.ID );
        if ( parameters.specularMap !== undefined ) {

          parameters.specularMap.encoding = sRGBEncoding;

        }

        break

      case 'TransparentColor':
      case 'TransparencyFactor':
        parameters.alphaMap = scope.getTexture( textureMap, child.ID );
        parameters.transparent = true;
        break

      case 'AmbientColor':
      case 'ShininessExponent': // AKA glossiness map
      case 'SpecularFactor': // AKA specularLevel
      case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor
      default:
        console.warn( 'THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type );
        break

      }

    } );

    return parameters

  }

  // get a texture from the textureMap for use by a material.
  getTexture ( textureMap, id ) {

    // if the texture is a layered texture, just use the first layer and issue a warning
    if ( 'LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture ) {

      console.warn( 'THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.' );
      id = connections.get( id ).children[ 0 ].ID;

    }

    return textureMap.get( id )

  }

  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers () {

    const skeletons = {};
    const morphTargets = {};

    if ( 'Deformer' in fbxTree.Objects ) {

      const DeformerNodes = fbxTree.Objects.Deformer;

      for ( const nodeID in DeformerNodes ) {

        const deformerNode = DeformerNodes[ nodeID ];

        const relationships = connections.get( parseInt( nodeID ) );

        if ( deformerNode.attrType === 'Skin' ) {

          const skeleton = this.parseSkeleton( relationships, DeformerNodes );

          skeleton.ID = nodeID;

          if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: skeleton attached to more than one geometry is not supported.' );
          skeleton.geometryID = relationships.parents[ 0 ].ID;

          skeletons[ nodeID ] = skeleton;

        } else if ( deformerNode.attrType === 'BlendShape' ) {

          const morphTarget = {
            id: nodeID,
          };

          morphTarget.rawTargets = this.parseMorphTargets( relationships, DeformerNodes );
          morphTarget.id = nodeID;

          if ( relationships.parents.length > 1 ) console.warn( 'THREE.FBXLoader: morph target attached to more than one geometry is not supported.' );

          morphTargets[ nodeID ] = morphTarget;

        }

      }

    }

    return {

      skeletons: skeletons,
      morphTargets: morphTargets,

    }

  }

  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton ( relationships, deformerNodes ) {

    const rawBones = [];

    relationships.children.forEach( function ( child ) {

      const boneNode = deformerNodes[ child.ID ];

      if ( boneNode.attrType !== 'Cluster' ) return

      const rawBone = {

        ID: child.ID,
        indices: [],
        weights: [],
        transformLink: new Matrix4().fromArray( boneNode.TransformLink.a ),
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,

      };

      if ( 'Indexes' in boneNode ) {

        rawBone.indices = boneNode.Indexes.a;
        rawBone.weights = boneNode.Weights.a;

      }

      rawBones.push( rawBone );

    } );

    return {

      rawBones: rawBones,
      bones: [],

    }

  }

  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets ( relationships, deformerNodes ) {

    const rawMorphTargets = [];

    for ( let i = 0; i < relationships.children.length; i++ ) {

      const child = relationships.children[ i ];

      const morphTargetNode = deformerNodes[ child.ID ];

      const rawMorphTarget = {

        name: morphTargetNode.attrName,
        initialWeight: morphTargetNode.DeformPercent,
        id: morphTargetNode.id,
        fullWeights: morphTargetNode.FullWeights.a,

      };

      if ( morphTargetNode.attrType !== 'BlendShapeChannel' ) return

      rawMorphTarget.geoID = connections.get( parseInt( child.ID ) ).children.filter( function ( child ) {

        return child.relationship === undefined

      } )[ 0 ].ID;

      rawMorphTargets.push( rawMorphTarget );

    }

    return rawMorphTargets

  }

  // create the main Group() to be returned by the loader
  parseScene ( deformers, geometryMap, materialMap ) {

    sceneGraph = new Group$2();

    const modelMap = this.parseModels( deformers.skeletons, geometryMap, materialMap );

    const modelNodes = fbxTree.Objects.Model;

    const scope = this;

    modelMap.forEach( function ( model ) {

      const modelNode = modelNodes[ model.ID ];

      scope.setLookAtProperties( model, modelNode );

      const parentConnections = connections.get( model.ID ).parents;

      parentConnections.forEach( function ( connection ) {

        const parent = modelMap.get( connection.ID );

        if ( parent !== undefined ) parent.add( model );

      } );

      if ( model.parent === null ) {

        sceneGraph.add( model );

      }


    } );

    this.bindSkeleton( deformers.skeletons, geometryMap, modelMap );

    this.createAmbientLight();

    sceneGraph.traverse( function ( node ) {

      if ( node.userData.transformData ) {

        if ( node.parent ) {

          node.userData.transformData.parentMatrix = node.parent.matrix;
          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;

        }

        const transform = generateTransform( node.userData.transformData );

        node.applyMatrix4( transform );
        node.updateWorldMatrix();

      }

    } );

    const animations = new AnimationParser().parse();

    // if all the models where already combined in a single group, just return that
    if ( sceneGraph.children.length === 1 && sceneGraph.children[ 0 ].isGroup ) {

      sceneGraph.children[ 0 ].animations = animations;
      sceneGraph = sceneGraph.children[ 0 ];

    }

    sceneGraph.animations = animations;

  }

  // parse nodes in FBXTree.Objects.Model
  parseModels ( skeletons, geometryMap, materialMap ) {

    const modelMap = new Map();
    const modelNodes = fbxTree.Objects.Model;

    for ( const nodeID in modelNodes ) {

      const id = parseInt( nodeID );
      const node = modelNodes[ nodeID ];
      const relationships = connections.get( id );

      let model = this.buildSkeleton( relationships, skeletons, id, node.attrName );

      if ( !model ) {

        switch ( node.attrType ) {

        case 'Camera':
          // model = this.createCamera( relationships )
          break
        case 'Light':
          // model = this.createLight( relationships )
          break
        case 'Mesh':
          model = this.createMesh( relationships, geometryMap, materialMap );
          break
        case 'NurbsCurve':
          model = this.createCurve( relationships, geometryMap );
          break
        case 'LimbNode':
        case 'Root':
          model = new Bone();
          break
        case 'Null':
        default:
          model = new Group$2();
          break

        }

        model.name = node.attrName ? PropertyBinding.sanitizeNodeName( node.attrName ) : '';

        model.ID = id;

      }

      this.getTransformData( model, node );
      modelMap.set( id, model );

    }

    return modelMap

  }

  buildSkeleton ( relationships, skeletons, id, name ) {

    let bone = null;

    relationships.parents.forEach( function ( parent ) {

      for ( const ID in skeletons ) {

        const skeleton = skeletons[ ID ];

        skeleton.rawBones.forEach( function ( rawBone, i ) {

          if ( rawBone.ID === parent.ID ) {

            const subBone = bone;

            bone = new Bone();

            bone.matrixWorld.copy( rawBone.transformLink );

            // set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

            bone.name = name ? PropertyBinding.sanitizeNodeName( name ) : '';
            bone.ID = id;

            skeleton.bones[ i ] = bone;

            // In cases where a bone is shared between multiple meshes
            // duplicate the bone here and and it as a child of the first bone
            if ( subBone !== null ) {

              bone.add( subBone );

            }

          }

        } );

      }

    } );

    return bone

  }

  // create a PerspectiveCamera or OrthographicCamera
  createCamera ( relationships ) {

    let model;
    let cameraAttribute;

    relationships.children.forEach( function ( child ) {

      const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

      if ( attr !== undefined ) {

        cameraAttribute = attr;

      }

    } );

    if ( cameraAttribute === undefined ) {

      model = new Object3D();

    } else {

      let type = 0;

      if ( cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1 ) {

        type = 1;

      }

      let nearClippingPlane = 1;

      if ( cameraAttribute.NearPlane !== undefined ) {

        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;

      }

      let farClippingPlane = 1000;

      if ( cameraAttribute.FarPlane !== undefined ) {

        farClippingPlane = cameraAttribute.FarPlane.value / 1000;

      }


      let width = window.innerWidth;
      let height = window.innerHeight;

      if ( cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined ) {

        width = cameraAttribute.AspectWidth.value;
        height = cameraAttribute.AspectHeight.value;

      }

      const aspect = width / height;

      let fov = 45;

      if ( cameraAttribute.FieldOfView !== undefined ) {

        fov = cameraAttribute.FieldOfView.value;

      }

      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

      switch ( type ) {

      case 0: // Perspective
        model = new PerspectiveCamera( fov, aspect, nearClippingPlane, farClippingPlane );
        if ( focalLength !== null ) model.setFocalLength( focalLength );
        break

      case 1: // Orthographic
        model = new OrthographicCamera( -width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane );
        break

      default:
        console.warn( 'THREE.FBXLoader: Unknown camera type ' + type + '.' );
        model = new Object3D();
        break

      }

    }

    return model

  }

  // Create a DirectionalLight, PointLight or SpotLight
  createLight ( relationships ) {

    let model;
    let lightAttribute;

    relationships.children.forEach( function ( child ) {

      const attr = fbxTree.Objects.NodeAttribute[ child.ID ];

      if ( attr !== undefined ) {

        lightAttribute = attr;

      }

    } );

    if ( lightAttribute === undefined ) {

      model = new Object3D();

    } else {

      let type;

      // LightType can be undefined for Point lights
      if ( lightAttribute.LightType === undefined ) {

        type = 0;

      } else {

        type = lightAttribute.LightType.value;

      }

      let color = 0xffffff;

      if ( lightAttribute.Color !== undefined ) {

        color = new Color().fromArray( lightAttribute.Color.value ).convertSRGBToLinear();

      }

      let intensity = ( lightAttribute.Intensity === undefined ) ? 1 : lightAttribute.Intensity.value / 100;

      // light disabled
      if ( lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0 ) {

        intensity = 0;

      }

      let distance = 0;

      if ( lightAttribute.FarAttenuationEnd !== undefined ) {

        if ( lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0 ) {

          distance = 0;

        } else {

          distance = lightAttribute.FarAttenuationEnd.value;

        }

      }

      // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?
      const decay = 1;

      switch ( type ) {

      case 0: // Point
        model = new PointLight( color, intensity, distance, decay );
        break

      case 1: // Directional
        model = new DirectionalLight( color, intensity );
        break

      case 2: // Spot
        let angle = Math.PI / 3;

        if ( lightAttribute.InnerAngle !== undefined ) {

          angle = MathUtils.degToRad( lightAttribute.InnerAngle.value );

        }

        let penumbra = 0;

        if ( lightAttribute.OuterAngle !== undefined ) {

          // TODO: this is not correct - FBX calculates outer and inner angle in degrees
          // with OuterAngle > InnerAngle && OuterAngle <= Math.PI
          // while three.js uses a penumbra between (0, 1) to attenuate the inner angle
          penumbra = MathUtils.degToRad( lightAttribute.OuterAngle.value );
          penumbra = Math.max( penumbra, 1 );

        }

        model = new SpotLight( color, intensity, distance, angle, penumbra, decay );
        break

      default:
        console.warn( 'THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.' );
        model = new PointLight( color, intensity );
        break

      }

      if ( lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1 ) {

        model.castShadow = true;

      }

    }

    return model

  }

  createMesh ( relationships, geometryMap, materialMap ) {

    let model;
    let geometry = null;
    let material = null;
    const materials = [];

    // get geometry and materials(s) from connections
    relationships.children.forEach( function ( child ) {

      if ( geometryMap.has( child.ID ) ) {

        geometry = geometryMap.get( child.ID );

      }

      if ( materialMap.has( child.ID ) ) {

        materials.push( materialMap.get( child.ID ) );

      }

    } );

    if ( materials.length > 1 ) {

      material = materials;

    } else if ( materials.length > 0 ) {

      material = materials[ 0 ];

    } else {

      material = new MeshStandardMaterial( { color: 0xcccccc, } );
      materials.push( material );

    }

    if ( 'color' in geometry.attributes ) {

      materials.forEach( function ( material ) {

        material.vertexColors = true;

      } );

    }

    if ( geometry.FBX_Deformer ) {

      model = new SkinnedMesh( geometry, material );
      model.normalizeSkinWeights();

    } else {

      model = new Mesh( geometry, material );

    }

    model.castShadow = true;
    model.receiveShadow = true;

    return model

  }

  createCurve ( relationships, geometryMap ) {

    const geometry = relationships.children.reduce( function ( geo, child ) {

      if ( geometryMap.has( child.ID ) ) geo = geometryMap.get( child.ID );

      return geo

    }, null );

    // FBX does not list materials for Nurbs lines, so we'll just put our own in here.
    const material = new LineBasicMaterial( { color: 0x3300ff, linewidth: 1, } );

    return new Line$1( geometry, material )

  }

  // parse the model node for transform data
  getTransformData ( model, modelNode ) {

    const transformData = {};

    if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

    if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
    else transformData.eulerOrder = 'ZYX';

    if ( 'Lcl_Translation' in modelNode ) transformData.translation = modelNode.Lcl_Translation.value;

    if ( 'PreRotation' in modelNode ) transformData.preRotation = modelNode.PreRotation.value;
    if ( 'Lcl_Rotation' in modelNode ) transformData.rotation = modelNode.Lcl_Rotation.value;
    if ( 'PostRotation' in modelNode ) transformData.postRotation = modelNode.PostRotation.value;

    if ( 'Lcl_Scaling' in modelNode ) transformData.scale = modelNode.Lcl_Scaling.value;

    if ( 'ScalingOffset' in modelNode ) transformData.scalingOffset = modelNode.ScalingOffset.value;
    if ( 'ScalingPivot' in modelNode ) transformData.scalingPivot = modelNode.ScalingPivot.value;

    if ( 'RotationOffset' in modelNode ) transformData.rotationOffset = modelNode.RotationOffset.value;
    if ( 'RotationPivot' in modelNode ) transformData.rotationPivot = modelNode.RotationPivot.value;

    model.userData.transformData = transformData;

  }

  setLookAtProperties ( model, modelNode ) {

    if ( 'LookAtProperty' in modelNode ) {

      const children = connections.get( model.ID ).children;

      children.forEach( function ( child ) {

        if ( child.relationship === 'LookAtProperty' ) {

          const lookAtTarget = fbxTree.Objects.Model[ child.ID ];

          if ( 'Lcl_Translation' in lookAtTarget ) {

            const pos = lookAtTarget.Lcl_Translation.value;

            // DirectionalLight, SpotLight
            if ( model.target !== undefined ) {

              model.target.position.fromArray( pos );
              sceneGraph.add( model.target );

            } else { // Cameras and other Object3Ds

              model.lookAt( new Vector3().fromArray( pos ) );

            }

          }

        }

      } );

    }

  }

  bindSkeleton ( skeletons, geometryMap, modelMap ) {

    const bindMatrices = this.parsePoseNodes();

    for ( const ID in skeletons ) {

      const skeleton = skeletons[ ID ];

      const parents = connections.get( parseInt( skeleton.ID ) ).parents;

      parents.forEach( function ( parent ) {

        if ( geometryMap.has( parent.ID ) ) {

          const geoID = parent.ID;
          const geoRelationships = connections.get( geoID );

          geoRelationships.parents.forEach( function ( geoConnParent ) {

            if ( modelMap.has( geoConnParent.ID ) ) {

              const model = modelMap.get( geoConnParent.ID );

              model.bind( new Skeleton( skeleton.bones ), bindMatrices[ geoConnParent.ID ] );

            }

          } );

        }

      } );

    }

  }

  parsePoseNodes () {

    const bindMatrices = {};

    if ( 'Pose' in fbxTree.Objects ) {

      const BindPoseNode = fbxTree.Objects.Pose;

      for ( const nodeID in BindPoseNode ) {

        if ( BindPoseNode[ nodeID ].attrType === 'BindPose' && BindPoseNode[ nodeID ].NbPoseNodes > 0 ) {

          const poseNodes = BindPoseNode[ nodeID ].PoseNode;

          if ( Array.isArray( poseNodes ) ) {

            poseNodes.forEach( function ( poseNode ) {

              bindMatrices[ poseNode.Node ] = new Matrix4().fromArray( poseNode.Matrix.a );

            } );

          } else {

            bindMatrices[ poseNodes.Node ] = new Matrix4().fromArray( poseNodes.Matrix.a );

          }

        }

      }

    }

    return bindMatrices

  }

  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight () {

    if ( 'GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings ) {

      const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
      const r = ambientColor[ 0 ];
      const g = ambientColor[ 1 ];
      const b = ambientColor[ 2 ];

      if ( r !== 0 || g !== 0 || b !== 0 ) {

        const color = new Color( r, g, b ).convertSRGBToLinear();

        sceneGraph.add( new AmbientLight( color, 1 ) );

      }

    }

  }

}

// parse Geometry data from FBXTree and return map of BufferGeometries
class GeometryParser {

  constructor () {

    this.negativeMaterialIndices = false;

  }

  // Parse nodes in FBXTree.Objects.Geometry
  parse ( deformers ) {

    const geometryMap = new Map();

    if ( 'Geometry' in fbxTree.Objects ) {

      const geoNodes = fbxTree.Objects.Geometry;

      for ( const nodeID in geoNodes ) {

        const relationships = connections.get( parseInt( nodeID ) );
        const geo = this.parseGeometry( relationships, geoNodes[ nodeID ], deformers );

        geometryMap.set( parseInt( nodeID ), geo );

      }

    }

    // report warnings

    if ( this.negativeMaterialIndices === true ) {

      console.warn( 'THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.' );

    }

    return geometryMap

  }

  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry ( relationships, geoNode, deformers ) {

    switch ( geoNode.attrType ) {

    case 'Mesh':
      return this.parseMeshGeometry( relationships, geoNode, deformers )

    case 'NurbsCurve':
      return this.parseNurbsGeometry( geoNode )

    }

  }

  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry ( relationships, geoNode, deformers ) {

    const skeletons = deformers.skeletons;
    const morphTargets = [];

    const modelNodes = relationships.parents.map( function ( parent ) {

      return fbxTree.Objects.Model[ parent.ID ]

    } );

    // don't create geometry if it is not associated with any models
    if ( modelNodes.length === 0 ) return

    const skeleton = relationships.children.reduce( function ( skeleton, child ) {

      if ( skeletons[ child.ID ] !== undefined ) skeleton = skeletons[ child.ID ];

      return skeleton

    }, null );

    relationships.children.forEach( function ( child ) {

      if ( deformers.morphTargets[ child.ID ] !== undefined ) {

        morphTargets.push( deformers.morphTargets[ child.ID ] );

      }

    } );

    // Assume one model and get the preRotation from that
    // if there is more than one model associated with the geometry this may cause problems
    const modelNode = modelNodes[ 0 ];

    const transformData = {};

    if ( 'RotationOrder' in modelNode ) transformData.eulerOrder = getEulerOrder( modelNode.RotationOrder.value );
    if ( 'InheritType' in modelNode ) transformData.inheritType = parseInt( modelNode.InheritType.value );

    if ( 'GeometricTranslation' in modelNode ) transformData.translation = modelNode.GeometricTranslation.value;
    if ( 'GeometricRotation' in modelNode ) transformData.rotation = modelNode.GeometricRotation.value;
    if ( 'GeometricScaling' in modelNode ) transformData.scale = modelNode.GeometricScaling.value;

    const transform = generateTransform( transformData );

    return this.genGeometry( geoNode, skeleton, morphTargets, transform )

  }

  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry ( geoNode, skeleton, morphTargets, preTransform ) {

    const geo = new BufferGeometry();

    if ( geoNode.attrName ) geo.name = geoNode.attrName;

    const geoInfo = this.parseGeoNode( geoNode, skeleton );
    const buffers = this.genBuffers( geoInfo );

    const positionAttribute = new Float32BufferAttribute( buffers.vertex, 3 );

    positionAttribute.applyMatrix4( preTransform );

    geo.setAttribute( 'position', positionAttribute );

    if ( buffers.colors.length > 0 ) {

      geo.setAttribute( 'color', new Float32BufferAttribute( buffers.colors, 3 ) );

    }

    if ( skeleton ) {

      geo.setAttribute( 'skinIndex', new Uint16BufferAttribute( buffers.weightsIndices, 4 ) );

      geo.setAttribute( 'skinWeight', new Float32BufferAttribute( buffers.vertexWeights, 4 ) );

      // used later to bind the skeleton to the model
      geo.FBX_Deformer = skeleton;

    }

    if ( buffers.normal.length > 0 ) {

      const normalMatrix = new Matrix3().getNormalMatrix( preTransform );

      const normalAttribute = new Float32BufferAttribute( buffers.normal, 3 );

      normalAttribute.applyNormalMatrix( normalMatrix );

      geo.setAttribute( 'normal', normalAttribute );

    }

    buffers.uvs.forEach( function ( uvBuffer, i ) {

      // subsequent uv buffers are called 'uv1', 'uv2', ...
      let name = 'uv' + ( i + 1 ).toString();

      // the first uv buffer is just called 'uv'
      if ( i === 0 ) {

        name = 'uv';

      }

      geo.setAttribute( name, new Float32BufferAttribute( buffers.uvs[ i ], 2 ) );

    } );

    if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

      // Convert the material indices of each vertex into rendering groups on the geometry.
      let prevMaterialIndex = buffers.materialIndex[ 0 ];
      let startIndex = 0;

      buffers.materialIndex.forEach( function ( currentIndex, i ) {

        if ( currentIndex !== prevMaterialIndex ) {

          geo.addGroup( startIndex, i - startIndex, prevMaterialIndex );

          prevMaterialIndex = currentIndex;
          startIndex = i;

        }

      } );

      // the loop above doesn't add the last group, do that here.
      if ( geo.groups.length > 0 ) {

        const lastGroup = geo.groups[ geo.groups.length - 1 ];
        const lastIndex = lastGroup.start + lastGroup.count;

        if ( lastIndex !== buffers.materialIndex.length ) {

          geo.addGroup( lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex );

        }

      }

      // case where there are multiple materials but the whole geometry is only
      // using one of them
      if ( geo.groups.length === 0 ) {

        geo.addGroup( 0, buffers.materialIndex.length, buffers.materialIndex[ 0 ] );

      }

    }

    this.addMorphTargets( geo, geoNode, morphTargets, preTransform );

    return geo

  }

  parseGeoNode ( geoNode, skeleton ) {

    const geoInfo = {};

    geoInfo.vertexPositions = ( geoNode.Vertices !== undefined ) ? geoNode.Vertices.a : [];
    geoInfo.vertexIndices = ( geoNode.PolygonVertexIndex !== undefined ) ? geoNode.PolygonVertexIndex.a : [];

    if ( geoNode.LayerElementColor ) {

      geoInfo.color = this.parseVertexColors( geoNode.LayerElementColor[ 0 ] );

    }

    if ( geoNode.LayerElementMaterial ) {

      geoInfo.material = this.parseMaterialIndices( geoNode.LayerElementMaterial[ 0 ] );

    }

    if ( geoNode.LayerElementNormal ) {

      geoInfo.normal = this.parseNormals( geoNode.LayerElementNormal[ 0 ] );

    }

    if ( geoNode.LayerElementUV ) {

      geoInfo.uv = [];

      let i = 0;

      while ( geoNode.LayerElementUV[ i ] ) {

        if ( geoNode.LayerElementUV[ i ].UV ) {

          geoInfo.uv.push( this.parseUVs( geoNode.LayerElementUV[ i ] ) );

        }

        i++;

      }

    }

    geoInfo.weightTable = {};

    if ( skeleton !== null ) {

      geoInfo.skeleton = skeleton;

      skeleton.rawBones.forEach( function ( rawBone, i ) {

        // loop over the bone's vertex indices and weights
        rawBone.indices.forEach( function ( index, j ) {

          if ( geoInfo.weightTable[ index ] === undefined ) geoInfo.weightTable[ index ] = [];

          geoInfo.weightTable[ index ].push( {

            id: i,
            weight: rawBone.weights[ j ],

          } );

        } );

      } );

    }

    return geoInfo

  }

  genBuffers ( geoInfo ) {

    const buffers = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: [],
    };

    let polygonIndex = 0;
    let faceLength = 0;
    let displayedWeightsWarning = false;

    // these will hold data for a single face
    let facePositionIndexes = [];
    let faceNormals = [];
    let faceColors = [];
    let faceUVs = [];
    let faceWeights = [];
    let faceWeightIndices = [];

    const scope = this;

    geoInfo.vertexIndices.forEach( function ( vertexIndex, polygonVertexIndex ) {

      let materialIndex;
      let endOfFace = false;

      // Face index and vertex index arrays are combined in a single array
      // A cube with quad faces looks like this:
      // PolygonVertexIndex: *24 {
      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
      //  }
      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
      // to find index of last vertex bit shift the index: ^ - 1
      if ( vertexIndex < 0 ) {

        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1
        endOfFace = true;

      }

      let weightIndices = [];
      let weights = [];

      facePositionIndexes.push( vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2 );

      if ( geoInfo.color ) {

        const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color );

        faceColors.push( data[ 0 ], data[ 1 ], data[ 2 ] );

      }

      if ( geoInfo.skeleton ) {

        if ( geoInfo.weightTable[ vertexIndex ] !== undefined ) {

          geoInfo.weightTable[ vertexIndex ].forEach( function ( wt ) {

            weights.push( wt.weight );
            weightIndices.push( wt.id );

          } );


        }

        if ( weights.length > 4 ) {

          if ( !displayedWeightsWarning ) {

            console.warn( 'THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.' );
            displayedWeightsWarning = true;

          }

          const wIndex = [ 0, 0, 0, 0 ];
          const Weight = [ 0, 0, 0, 0 ];

          weights.forEach( function ( weight, weightIndex ) {

            let currentWeight = weight;
            let currentIndex = weightIndices[ weightIndex ];

            Weight.forEach( function ( comparedWeight, comparedWeightIndex, comparedWeightArray ) {

              if ( currentWeight > comparedWeight ) {

                comparedWeightArray[ comparedWeightIndex ] = currentWeight;
                currentWeight = comparedWeight;

                const tmp = wIndex[ comparedWeightIndex ];

                wIndex[ comparedWeightIndex ] = currentIndex;
                currentIndex = tmp;

              }

            } );

          } );

          weightIndices = wIndex;
          weights = Weight;

        }

        // if the weight array is shorter than 4 pad with 0s
        while ( weights.length < 4 ) {

          weights.push( 0 );
          weightIndices.push( 0 );

        }

        for ( let i = 0; i < 4; ++i ) {

          faceWeights.push( weights[ i ] );
          faceWeightIndices.push( weightIndices[ i ] );

        }

      }

      if ( geoInfo.normal ) {

        const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal );

        faceNormals.push( data[ 0 ], data[ 1 ], data[ 2 ] );

      }

      if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

        materialIndex = getData( polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material )[ 0 ];

        if ( materialIndex < 0 ) {

          scope.negativeMaterialIndices = true;
          materialIndex = 0; // fallback

        }

      }

      if ( geoInfo.uv ) {

        geoInfo.uv.forEach( function ( uv, i ) {

          const data = getData( polygonVertexIndex, polygonIndex, vertexIndex, uv );

          if ( faceUVs[ i ] === undefined ) {

            faceUVs[ i ] = [];

          }

          faceUVs[ i ].push( data[ 0 ] );
          faceUVs[ i ].push( data[ 1 ] );

        } );

      }

      faceLength++;

      if ( endOfFace ) {

        if ( faceLength > 4 ) console.warn( 'THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export.' );

        scope.genFace( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength );

        polygonIndex++;
        faceLength = 0;

        // reset arrays for the next face
        facePositionIndexes = [];
        faceNormals = [];
        faceColors = [];
        faceUVs = [];
        faceWeights = [];
        faceWeightIndices = [];

      }

    } );

    return buffers

  }

  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace ( buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength ) {

    for ( let i = 2; i < faceLength; i++ ) {

      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 0 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 1 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ 2 ] ] );

      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 1 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ ( i - 1 ) * 3 + 2 ] ] );

      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 1 ] ] );
      buffers.vertex.push( geoInfo.vertexPositions[ facePositionIndexes[ i * 3 + 2 ] ] );

      if ( geoInfo.skeleton ) {

        buffers.vertexWeights.push( faceWeights[ 0 ] );
        buffers.vertexWeights.push( faceWeights[ 1 ] );
        buffers.vertexWeights.push( faceWeights[ 2 ] );
        buffers.vertexWeights.push( faceWeights[ 3 ] );

        buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 ] );
        buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 1 ] );
        buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 2 ] );
        buffers.vertexWeights.push( faceWeights[ ( i - 1 ) * 4 + 3 ] );

        buffers.vertexWeights.push( faceWeights[ i * 4 ] );
        buffers.vertexWeights.push( faceWeights[ i * 4 + 1 ] );
        buffers.vertexWeights.push( faceWeights[ i * 4 + 2 ] );
        buffers.vertexWeights.push( faceWeights[ i * 4 + 3 ] );

        buffers.weightsIndices.push( faceWeightIndices[ 0 ] );
        buffers.weightsIndices.push( faceWeightIndices[ 1 ] );
        buffers.weightsIndices.push( faceWeightIndices[ 2 ] );
        buffers.weightsIndices.push( faceWeightIndices[ 3 ] );

        buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 ] );
        buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 1 ] );
        buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 2 ] );
        buffers.weightsIndices.push( faceWeightIndices[ ( i - 1 ) * 4 + 3 ] );

        buffers.weightsIndices.push( faceWeightIndices[ i * 4 ] );
        buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 1 ] );
        buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 2 ] );
        buffers.weightsIndices.push( faceWeightIndices[ i * 4 + 3 ] );

      }

      if ( geoInfo.color ) {

        buffers.colors.push( faceColors[ 0 ] );
        buffers.colors.push( faceColors[ 1 ] );
        buffers.colors.push( faceColors[ 2 ] );

        buffers.colors.push( faceColors[ ( i - 1 ) * 3 ] );
        buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 1 ] );
        buffers.colors.push( faceColors[ ( i - 1 ) * 3 + 2 ] );

        buffers.colors.push( faceColors[ i * 3 ] );
        buffers.colors.push( faceColors[ i * 3 + 1 ] );
        buffers.colors.push( faceColors[ i * 3 + 2 ] );

      }

      if ( geoInfo.material && geoInfo.material.mappingType !== 'AllSame' ) {

        buffers.materialIndex.push( materialIndex );
        buffers.materialIndex.push( materialIndex );
        buffers.materialIndex.push( materialIndex );

      }

      if ( geoInfo.normal ) {

        buffers.normal.push( faceNormals[ 0 ] );
        buffers.normal.push( faceNormals[ 1 ] );
        buffers.normal.push( faceNormals[ 2 ] );

        buffers.normal.push( faceNormals[ ( i - 1 ) * 3 ] );
        buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 1 ] );
        buffers.normal.push( faceNormals[ ( i - 1 ) * 3 + 2 ] );

        buffers.normal.push( faceNormals[ i * 3 ] );
        buffers.normal.push( faceNormals[ i * 3 + 1 ] );
        buffers.normal.push( faceNormals[ i * 3 + 2 ] );

      }

      if ( geoInfo.uv ) {

        geoInfo.uv.forEach( function ( uv, j ) {

          if ( buffers.uvs[ j ] === undefined ) buffers.uvs[ j ] = [];

          buffers.uvs[ j ].push( faceUVs[ j ][ 0 ] );
          buffers.uvs[ j ].push( faceUVs[ j ][ 1 ] );

          buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 ] );
          buffers.uvs[ j ].push( faceUVs[ j ][ ( i - 1 ) * 2 + 1 ] );

          buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 ] );
          buffers.uvs[ j ].push( faceUVs[ j ][ i * 2 + 1 ] );

        } );

      }

    }

  }

  addMorphTargets ( parentGeo, parentGeoNode, morphTargets, preTransform ) {

    if ( morphTargets.length === 0 ) return

    parentGeo.morphTargetsRelative = true;

    parentGeo.morphAttributes.position = [];
    // parentGeo.morphAttributes.normal = []; // not implemented

    const scope = this;

    morphTargets.forEach( function ( morphTarget ) {

      morphTarget.rawTargets.forEach( function ( rawTarget ) {

        const morphGeoNode = fbxTree.Objects.Geometry[ rawTarget.geoID ];

        if ( morphGeoNode !== undefined ) {

          scope.genMorphGeometry( parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name );

        }

      } );

    } );

  }

  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry ( parentGeo, parentGeoNode, morphGeoNode, preTransform, name ) {

    const vertexIndices = ( parentGeoNode.PolygonVertexIndex !== undefined ) ? parentGeoNode.PolygonVertexIndex.a : [];

    const morphPositionsSparse = ( morphGeoNode.Vertices !== undefined ) ? morphGeoNode.Vertices.a : [];
    const indices = ( morphGeoNode.Indexes !== undefined ) ? morphGeoNode.Indexes.a : [];

    const length = parentGeo.attributes.position.count * 3;
    const morphPositions = new Float32Array( length );

    for ( let i = 0; i < indices.length; i++ ) {

      const morphIndex = indices[ i ] * 3;

      morphPositions[ morphIndex ] = morphPositionsSparse[ i * 3 ];
      morphPositions[ morphIndex + 1 ] = morphPositionsSparse[ i * 3 + 1 ];
      morphPositions[ morphIndex + 2 ] = morphPositionsSparse[ i * 3 + 2 ];

    }

    // TODO: add morph normal support
    const morphGeoInfo = {
      vertexIndices: vertexIndices,
      vertexPositions: morphPositions,

    };

    const morphBuffers = this.genBuffers( morphGeoInfo );

    const positionAttribute = new Float32BufferAttribute( morphBuffers.vertex, 3 );

    positionAttribute.name = name || morphGeoNode.attrName;

    positionAttribute.applyMatrix4( preTransform );

    parentGeo.morphAttributes.position.push( positionAttribute );

  }

  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals ( NormalNode ) {

    const mappingType = NormalNode.MappingInformationType;
    const referenceType = NormalNode.ReferenceInformationType;
    const buffer = NormalNode.Normals.a;
    let indexBuffer = [];

    if ( referenceType === 'IndexToDirect' ) {

      if ( 'NormalIndex' in NormalNode ) {

        indexBuffer = NormalNode.NormalIndex.a;

      } else if ( 'NormalsIndex' in NormalNode ) {

        indexBuffer = NormalNode.NormalsIndex.a;

      }

    }

    return {
      dataSize: 3,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType,
    }

  }

  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs ( UVNode ) {

    const mappingType = UVNode.MappingInformationType;
    const referenceType = UVNode.ReferenceInformationType;
    const buffer = UVNode.UV.a;
    let indexBuffer = [];

    if ( referenceType === 'IndexToDirect' ) {

      indexBuffer = UVNode.UVIndex.a;

    }

    return {
      dataSize: 2,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType,
    }

  }

  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors ( ColorNode ) {

    const mappingType = ColorNode.MappingInformationType;
    const referenceType = ColorNode.ReferenceInformationType;
    const buffer = ColorNode.Colors.a;
    let indexBuffer = [];

    if ( referenceType === 'IndexToDirect' ) {

      indexBuffer = ColorNode.ColorIndex.a;

    }

    for ( let i = 0, c = new Color(); i < buffer.length; i += 4 ) {

      c.fromArray( buffer, i ).convertSRGBToLinear().toArray( buffer, i );

    }

    return {
      dataSize: 4,
      buffer: buffer,
      indices: indexBuffer,
      mappingType: mappingType,
      referenceType: referenceType,
    }

  }

  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices ( MaterialNode ) {

    const mappingType = MaterialNode.MappingInformationType;
    const referenceType = MaterialNode.ReferenceInformationType;

    if ( mappingType === 'NoMappingInformation' ) {

      return {
        dataSize: 1,
        buffer: [ 0 ],
        indices: [ 0 ],
        mappingType: 'AllSame',
        referenceType: referenceType,
      }

    }

    const materialIndexBuffer = MaterialNode.Materials.a;

    // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
    // we expect.So we create an intermediate buffer that points to the index in the buffer,
    // for conforming with the other functions we've written for other data.
    const materialIndices = [];

    for ( let i = 0; i < materialIndexBuffer.length; ++i ) {

      materialIndices.push( i );

    }

    return {
      dataSize: 1,
      buffer: materialIndexBuffer,
      indices: materialIndices,
      mappingType: mappingType,
      referenceType: referenceType,
    }

  }

  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry ( geoNode ) {

    const order = parseInt( geoNode.Order );

    if ( isNaN( order ) ) {

      console.error( 'THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id );
      return new BufferGeometry()

    }

    const degree = order - 1;

    const knots = geoNode.KnotVector.a;
    const controlPoints = [];
    const pointsValues = geoNode.Points.a;

    for ( let i = 0, l = pointsValues.length; i < l; i += 4 ) {

      controlPoints.push( new Vector4().fromArray( pointsValues, i ) );

    }

    let startKnot, endKnot;

    if ( geoNode.Form === 'Closed' ) {

      controlPoints.push( controlPoints[ 0 ] );

    } else if ( geoNode.Form === 'Periodic' ) {

      startKnot = degree;
      endKnot = knots.length - 1 - startKnot;

      for ( let i = 0; i < degree; ++i ) {

        controlPoints.push( controlPoints[ i ] );

      }

    }

    const curve = new NURBSCurve( degree, knots, controlPoints, startKnot, endKnot );
    const points = curve.getPoints( controlPoints.length * 12 );

    return new BufferGeometry().setFromPoints( points )

  }

}

// parse animation data from FBXTree
class AnimationParser {

  // take raw animation clips and turn them into three.js animation clips
  parse () {

    const animationClips = [];

    const rawClips = this.parseClips();

    if ( rawClips !== undefined ) {

      for ( const key in rawClips ) {

        const rawClip = rawClips[ key ];

        const clip = this.addClip( rawClip );

        animationClips.push( clip );

      }

    }

    return animationClips

  }

  parseClips () {

    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
    // if this is undefined we can safely assume there are no animations
    if ( fbxTree.Objects.AnimationCurve === undefined ) return undefined

    const curveNodesMap = this.parseAnimationCurveNodes();

    this.parseAnimationCurves( curveNodesMap );

    const layersMap = this.parseAnimationLayers( curveNodesMap );
    const rawClips = this.parseAnimStacks( layersMap );

    return rawClips

  }

  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes () {

    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;

    const curveNodesMap = new Map();

    for ( const nodeID in rawCurveNodes ) {

      const rawCurveNode = rawCurveNodes[ nodeID ];

      if ( rawCurveNode.attrName.match( /S|R|T|DeformPercent/ ) !== null ) {

        const curveNode = {

          id: rawCurveNode.id,
          attr: rawCurveNode.attrName,
          curves: {},

        };

        curveNodesMap.set( curveNode.id, curveNode );

      }

    }

    return curveNodesMap

  }

  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves ( curveNodesMap ) {

    const rawCurves = fbxTree.Objects.AnimationCurve;

    // TODO: Many values are identical up to roundoff error, but won't be optimised
    // e.g. position times: [0, 0.4, 0. 8]
    // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
    // clearly, this should be optimised to
    // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
    // this shows up in nearly every FBX file, and generally time array is length > 100

    for ( const nodeID in rawCurves ) {

      const animationCurve = {

        id: rawCurves[ nodeID ].id,
        times: rawCurves[ nodeID ].KeyTime.a.map( convertFBXTimeToSeconds ),
        values: rawCurves[ nodeID ].KeyValueFloat.a,

      };

      const relationships = connections.get( animationCurve.id );

      if ( relationships !== undefined ) {

        const animationCurveID = relationships.parents[ 0 ].ID;
        const animationCurveRelationship = relationships.parents[ 0 ].relationship;

        if ( animationCurveRelationship.match( /X/ ) ) {

          curveNodesMap.get( animationCurveID ).curves[ 'x' ] = animationCurve;

        } else if ( animationCurveRelationship.match( /Y/ ) ) {

          curveNodesMap.get( animationCurveID ).curves[ 'y' ] = animationCurve;

        } else if ( animationCurveRelationship.match( /Z/ ) ) {

          curveNodesMap.get( animationCurveID ).curves[ 'z' ] = animationCurve;

        } else if ( animationCurveRelationship.match( /d|DeformPercent/ ) && curveNodesMap.has( animationCurveID ) ) {

          curveNodesMap.get( animationCurveID ).curves[ 'morph' ] = animationCurve;

        }

      }

    }

  }

  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers ( curveNodesMap ) {

    const rawLayers = fbxTree.Objects.AnimationLayer;

    const layersMap = new Map();

    for ( const nodeID in rawLayers ) {

      const layerCurveNodes = [];

      const connection = connections.get( parseInt( nodeID ) );

      if ( connection !== undefined ) {

        // all the animationCurveNodes used in the layer
        const children = connection.children;

        children.forEach( function ( child, i ) {

          if ( curveNodesMap.has( child.ID ) ) {

            const curveNode = curveNodesMap.get( child.ID );

            // check that the curves are defined for at least one axis, otherwise ignore the curveNode
            if ( curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined ) {

              if ( layerCurveNodes[ i ] === undefined ) {

                const modelID = connections.get( child.ID ).parents.filter( function ( parent ) {

                  return parent.relationship !== undefined

                } )[ 0 ].ID;

                if ( modelID !== undefined ) {

                  const rawModel = fbxTree.Objects.Model[ modelID.toString() ];

                  if ( rawModel === undefined ) {

                    console.warn( 'THREE.FBXLoader: Encountered a unused curve.', child );
                    return

                  }

                  const node = {

                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
                    ID: rawModel.id,
                    initialPosition: [ 0, 0, 0 ],
                    initialRotation: [ 0, 0, 0 ],
                    initialScale: [ 1, 1, 1 ],

                  };

                  sceneGraph.traverse( function ( child ) {

                    if ( child.ID === rawModel.id ) {

                      node.transform = child.matrix;

                      if ( child.userData.transformData ) node.eulerOrder = child.userData.transformData.eulerOrder;

                    }

                  } );

                  if ( !node.transform ) node.transform = new Matrix4();

                  // if the animated model is pre rotated, we'll have to apply the pre rotations to every
                  // animation value as well
                  if ( 'PreRotation' in rawModel ) node.preRotation = rawModel.PreRotation.value;
                  if ( 'PostRotation' in rawModel ) node.postRotation = rawModel.PostRotation.value;

                  layerCurveNodes[ i ] = node;

                }

              }

              if ( layerCurveNodes[ i ] ) layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

            } else if ( curveNode.curves.morph !== undefined ) {

              if ( layerCurveNodes[ i ] === undefined ) {

                const deformerID = connections.get( child.ID ).parents.filter( function ( parent ) {

                  return parent.relationship !== undefined

                } )[ 0 ].ID;

                const morpherID = connections.get( deformerID ).parents[ 0 ].ID;
                const geoID = connections.get( morpherID ).parents[ 0 ].ID;

                // assuming geometry is not used in more than one model
                const modelID = connections.get( geoID ).parents[ 0 ].ID;

                const rawModel = fbxTree.Objects.Model[ modelID ];

                const node = {

                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName( rawModel.attrName ) : '',
                  morphName: fbxTree.Objects.Deformer[ deformerID ].attrName,

                };

                layerCurveNodes[ i ] = node;

              }

              layerCurveNodes[ i ][ curveNode.attr ] = curveNode;

            }

          }

        } );

        layersMap.set( parseInt( nodeID ), layerCurveNodes );

      }

    }

    return layersMap

  }

  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks ( layersMap ) {

    const rawStacks = fbxTree.Objects.AnimationStack;

    // connect the stacks (clips) up to the layers
    const rawClips = {};

    for ( const nodeID in rawStacks ) {

      const children = connections.get( parseInt( nodeID ) ).children;

      if ( children.length > 1 ) {

        // it seems like stacks will always be associated with a single layer. But just in case there are files
        // where there are multiple layers per stack, we'll display a warning
        console.warn( 'THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.' );

      }

      const layer = layersMap.get( children[ 0 ].ID );

      rawClips[ nodeID ] = {

        name: rawStacks[ nodeID ].attrName,
        layer: layer,

      };

    }

    return rawClips

  }

  addClip ( rawClip ) {

    let tracks = [];

    const scope = this;

    rawClip.layer.forEach( function ( rawTracks ) {

      tracks = tracks.concat( scope.generateTracks( rawTracks ) );

    } );

    return new AnimationClip( rawClip.name, -1, tracks )

  }

  generateTracks ( rawTracks ) {

    const tracks = [];

    let initialPosition = new Vector3();
    let initialRotation = new Quaternion();
    let initialScale = new Vector3();

    if ( rawTracks.transform ) rawTracks.transform.decompose( initialPosition, initialRotation, initialScale );

    initialPosition = initialPosition.toArray();
    initialRotation = new Euler().setFromQuaternion( initialRotation, rawTracks.eulerOrder ).toArray();
    initialScale = initialScale.toArray();

    if ( rawTracks.T !== undefined && Object.keys( rawTracks.T.curves ).length > 0 ) {

      const positionTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position' );

      if ( positionTrack !== undefined ) tracks.push( positionTrack );

    }

    if ( rawTracks.R !== undefined && Object.keys( rawTracks.R.curves ).length > 0 ) {

      const rotationTrack = this.generateRotationTrack( rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder );

      if ( rotationTrack !== undefined ) tracks.push( rotationTrack );

    }

    if ( rawTracks.S !== undefined && Object.keys( rawTracks.S.curves ).length > 0 ) {

      const scaleTrack = this.generateVectorTrack( rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale' );

      if ( scaleTrack !== undefined ) tracks.push( scaleTrack );

    }

    if ( rawTracks.DeformPercent !== undefined ) {

      const morphTrack = this.generateMorphTrack( rawTracks );

      if ( morphTrack !== undefined ) tracks.push( morphTrack );

    }

    return tracks

  }

  generateVectorTrack ( modelName, curves, initialValue, type ) {

    const times = this.getTimesForAllAxes( curves );
    const values = this.getKeyframeTrackValues( times, curves, initialValue );

    return new VectorKeyframeTrack( modelName + '.' + type, times, values )

  }

  generateRotationTrack ( modelName, curves, initialValue, preRotation, postRotation, eulerOrder ) {

    if ( curves.x !== undefined ) {

      this.interpolateRotations( curves.x );
      curves.x.values = curves.x.values.map( MathUtils.degToRad );

    }

    if ( curves.y !== undefined ) {

      this.interpolateRotations( curves.y );
      curves.y.values = curves.y.values.map( MathUtils.degToRad );

    }

    if ( curves.z !== undefined ) {

      this.interpolateRotations( curves.z );
      curves.z.values = curves.z.values.map( MathUtils.degToRad );

    }

    const times = this.getTimesForAllAxes( curves );
    const values = this.getKeyframeTrackValues( times, curves, initialValue );

    if ( preRotation !== undefined ) {

      preRotation = preRotation.map( MathUtils.degToRad );
      preRotation.push( eulerOrder );

      preRotation = new Euler().fromArray( preRotation );
      preRotation = new Quaternion().setFromEuler( preRotation );

    }

    if ( postRotation !== undefined ) {

      postRotation = postRotation.map( MathUtils.degToRad );
      postRotation.push( eulerOrder );

      postRotation = new Euler().fromArray( postRotation );
      postRotation = new Quaternion().setFromEuler( postRotation ).invert();

    }

    const quaternion = new Quaternion();
    const euler = new Euler();

    const quaternionValues = [];

    for ( let i = 0; i < values.length; i += 3 ) {

      euler.set( values[ i ], values[ i + 1 ], values[ i + 2 ], eulerOrder );

      quaternion.setFromEuler( euler );

      if ( preRotation !== undefined ) quaternion.premultiply( preRotation );
      if ( postRotation !== undefined ) quaternion.multiply( postRotation );

      quaternion.toArray( quaternionValues, ( i / 3 ) * 4 );

    }

    return new QuaternionKeyframeTrack( modelName + '.quaternion', times, quaternionValues )

  }

  generateMorphTrack ( rawTracks ) {

    const curves = rawTracks.DeformPercent.curves.morph;
    const values = curves.values.map( function ( val ) {

      return val / 100

    } );

    const morphNum = sceneGraph.getObjectByName( rawTracks.modelName ).morphTargetDictionary[ rawTracks.morphName ];

    return new NumberKeyframeTrack( rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values )

  }

  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes ( curves ) {

    let times = [];

    // first join together the times for each axis, if defined
    if ( curves.x !== undefined ) times = times.concat( curves.x.times );
    if ( curves.y !== undefined ) times = times.concat( curves.y.times );
    if ( curves.z !== undefined ) times = times.concat( curves.z.times );

    // then sort them
    times = times.sort( function ( a, b ) {

      return a - b

    } );

    // and remove duplicates
    if ( times.length > 1 ) {

      let targetIndex = 1;
      let lastValue = times[ 0 ];

      for ( let i = 1; i < times.length; i++ ) {

        const currentValue = times[ i ];

        if ( currentValue !== lastValue ) {

          times[ targetIndex ] = currentValue;
          lastValue = currentValue;
          targetIndex++;

        }

      }

      times = times.slice( 0, targetIndex );

    }

    return times

  }

  getKeyframeTrackValues ( times, curves, initialValue ) {

    const prevValue = initialValue;

    const values = [];

    let xIndex = -1;
    let yIndex = -1;
    let zIndex = -1;

    times.forEach( function ( time ) {

      if ( curves.x ) xIndex = curves.x.times.indexOf( time );
      if ( curves.y ) yIndex = curves.y.times.indexOf( time );
      if ( curves.z ) zIndex = curves.z.times.indexOf( time );

      // if there is an x value defined for this frame, use that
      if ( xIndex !== -1 ) {

        const xValue = curves.x.values[ xIndex ];

        values.push( xValue );
        prevValue[ 0 ] = xValue;

      } else {

        // otherwise use the x value from the previous frame
        values.push( prevValue[ 0 ] );

      }

      if ( yIndex !== -1 ) {

        const yValue = curves.y.values[ yIndex ];

        values.push( yValue );
        prevValue[ 1 ] = yValue;

      } else {

        values.push( prevValue[ 1 ] );

      }

      if ( zIndex !== -1 ) {

        const zValue = curves.z.values[ zIndex ];

        values.push( zValue );
        prevValue[ 2 ] = zValue;

      } else {

        values.push( prevValue[ 2 ] );

      }

    } );

    return values

  }

  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations ( curve ) {

    for ( let i = 1; i < curve.values.length; i++ ) {

      const initialValue = curve.values[ i - 1 ];
      const valuesSpan = curve.values[ i ] - initialValue;

      const absoluteSpan = Math.abs( valuesSpan );

      if ( absoluteSpan >= 180 ) {

        const numSubIntervals = absoluteSpan / 180;

        const step = valuesSpan / numSubIntervals;
        let nextValue = initialValue + step;

        const initialTime = curve.times[ i - 1 ];
        const timeSpan = curve.times[ i ] - initialTime;
        const interval = timeSpan / numSubIntervals;
        let nextTime = initialTime + interval;

        const interpolatedTimes = [];
        const interpolatedValues = [];

        while ( nextTime < curve.times[ i ] ) {

          interpolatedTimes.push( nextTime );
          nextTime += interval;

          interpolatedValues.push( nextValue );
          nextValue += step;

        }

        curve.times = inject( curve.times, i, interpolatedTimes );
        curve.values = inject( curve.values, i, interpolatedValues );

      }

    }

  }

}

// parse an FBX file in ASCII format
class TextParser {

  getPrevNode () {

    return this.nodeStack[ this.currentIndent - 2 ]

  }

  getCurrentNode () {

    return this.nodeStack[ this.currentIndent - 1 ]

  }

  getCurrentProp () {

    return this.currentProp

  }

  pushStack ( node ) {

    this.nodeStack.push( node );
    this.currentIndent += 1;

  }

  popStack () {

    this.nodeStack.pop();
    this.currentIndent -= 1;

  }

  setCurrentProp ( val, name ) {

    this.currentProp = val;
    this.currentPropName = name;

  }

  parse ( text ) {

    this.currentIndent = 0;

    this.allNodes = new FBXTree();
    this.nodeStack = [];
    this.currentProp = [];
    this.currentPropName = '';

    const scope = this;

    const split = text.split( /[\r\n]+/ );

    split.forEach( function ( line, i ) {

      const matchComment = line.match( /^[\s\t]*;/ );
      const matchEmpty = line.match( /^[\s\t]*$/ );

      if ( matchComment || matchEmpty ) return

      const matchBeginning = line.match( '^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '' );
      const matchProperty = line.match( '^\\t{' + ( scope.currentIndent ) + '}(\\w+):[\\s\\t\\r\\n](.*)' );
      const matchEnd = line.match( '^\\t{' + ( scope.currentIndent - 1 ) + '}}' );

      if ( matchBeginning ) {

        scope.parseNodeBegin( line, matchBeginning );

      } else if ( matchProperty ) {

        scope.parseNodeProperty( line, matchProperty, split[ ++i ] );

      } else if ( matchEnd ) {

        scope.popStack();

      } else if ( line.match( /^[^\s\t}]/ ) ) {

        // large arrays are split over multiple lines terminated with a ',' character
        // if this is encountered the line needs to be joined to the previous line
        scope.parseNodePropertyContinued( line );

      }

    } );

    return this.allNodes

  }

  parseNodeBegin ( line, property ) {

    const nodeName = property[ 1 ].trim().replace( /^"/, '' ).replace( /"$/, '' );

    const nodeAttrs = property[ 2 ].split( ',' ).map( function ( attr ) {

      return attr.trim().replace( /^"/, '' ).replace( /"$/, '' )

    } );

    const node = { name: nodeName, };
    const attrs = this.parseNodeAttr( nodeAttrs );

    const currentNode = this.getCurrentNode();

    // a top node
    if ( this.currentIndent === 0 ) {

      this.allNodes.add( nodeName, node );

    } else { // a subnode

      // if the subnode already exists, append it
      if ( nodeName in currentNode ) {

        // special case Pose needs PoseNodes as an array
        if ( nodeName === 'PoseNode' ) {

          currentNode.PoseNode.push( node );

        } else if ( currentNode[ nodeName ].id !== undefined ) {

          currentNode[ nodeName ] = {};
          currentNode[ nodeName ][ currentNode[ nodeName ].id ] = currentNode[ nodeName ];

        }

        if ( attrs.id !== '' ) currentNode[ nodeName ][ attrs.id ] = node;

      } else if ( typeof attrs.id === 'number' ) {

        currentNode[ nodeName ] = {};
        currentNode[ nodeName ][ attrs.id ] = node;

      } else if ( nodeName !== 'Properties70' ) {

        if ( nodeName === 'PoseNode' )	currentNode[ nodeName ] = [ node ];
        else currentNode[ nodeName ] = node;

      }

    }

    if ( typeof attrs.id === 'number' ) node.id = attrs.id;
    if ( attrs.name !== '' ) node.attrName = attrs.name;
    if ( attrs.type !== '' ) node.attrType = attrs.type;

    this.pushStack( node );

  }

  parseNodeAttr ( attrs ) {

    let id = attrs[ 0 ];

    if ( attrs[ 0 ] !== '' ) {

      id = parseInt( attrs[ 0 ] );

      if ( isNaN( id ) ) {

        id = attrs[ 0 ];

      }

    }

    let name = '', type = '';

    if ( attrs.length > 1 ) {

      name = attrs[ 1 ].replace( /^(\w+)::/, '' );
      type = attrs[ 2 ];

    }

    return { id: id, name: name, type: type, }

  }

  parseNodeProperty ( line, property, contentLine ) {

    let propName = property[ 1 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();
    let propValue = property[ 2 ].replace( /^"/, '' ).replace( /"$/, '' ).trim();

    // for special case: base64 image data follows "Content: ," line
    //	Content: ,
    //	 "/9j/4RDaRXhpZgAATU0A..."
    if ( propName === 'Content' && propValue === ',' ) {

      propValue = contentLine.replace( /"/g, '' ).replace( /,$/, '' ).trim();

    }

    const currentNode = this.getCurrentNode();
    const parentName = currentNode.name;

    if ( parentName === 'Properties70' ) {

      this.parseNodeSpecialProperty( line, propName, propValue );
      return

    }

    // Connections
    if ( propName === 'C' ) {

      const connProps = propValue.split( ',' ).slice( 1 );
      const from = parseInt( connProps[ 0 ] );
      const to = parseInt( connProps[ 1 ] );

      let rest = propValue.split( ',' ).slice( 3 );

      rest = rest.map( function ( elem ) {

        return elem.trim().replace( /^"/, '' )

      } );

      propName = 'connections';
      propValue = [ from, to ];
      append( propValue, rest );

      if ( currentNode[ propName ] === undefined ) {

        currentNode[ propName ] = [];

      }

    }

    // Node
    if ( propName === 'Node' ) currentNode.id = propValue;

    // connections
    if ( propName in currentNode && Array.isArray( currentNode[ propName ] ) ) {

      currentNode[ propName ].push( propValue );

    } else {

      if ( propName !== 'a' ) currentNode[ propName ] = propValue;
      else currentNode.a = propValue;

    }

    this.setCurrentProp( currentNode, propName );

    // convert string to array, unless it ends in ',' in which case more will be added to it
    if ( propName === 'a' && propValue.slice( -1 ) !== ',' ) {

      currentNode.a = parseNumberArray( propValue );

    }

  }

  parseNodePropertyContinued ( line ) {

    const currentNode = this.getCurrentNode();

    currentNode.a += line;

    // if the line doesn't end in ',' we have reached the end of the property value
    // so convert the string to an array
    if ( line.slice( -1 ) !== ',' ) {

      currentNode.a = parseNumberArray( currentNode.a );

    }

  }

  // parse "Property70"
  parseNodeSpecialProperty ( line, propName, propValue ) {

    // split this
    // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
    // into array like below
    // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
    const props = propValue.split( '",' ).map( function ( prop ) {

      return prop.trim().replace( /^"/, '' ).replace( /\s/, '_' )

    } );

    const innerPropName = props[ 0 ];
    const innerPropType1 = props[ 1 ];
    const innerPropType2 = props[ 2 ];
    const innerPropFlag = props[ 3 ];
    let innerPropValue = props[ 4 ];

    // cast values where needed, otherwise leave as strings
    switch ( innerPropType1 ) {

    case 'int':
    case 'enum':
    case 'bool':
    case 'ULongLong':
    case 'double':
    case 'Number':
    case 'FieldOfView':
      innerPropValue = parseFloat( innerPropValue );
      break

    case 'Color':
    case 'ColorRGB':
    case 'Vector3D':
    case 'Lcl_Translation':
    case 'Lcl_Rotation':
    case 'Lcl_Scaling':
      innerPropValue = parseNumberArray( innerPropValue );
      break

    }

    // CAUTION: these props must append to parent's parent
    this.getPrevNode()[ innerPropName ] = {

      'type': innerPropType1,
      'type2': innerPropType2,
      'flag': innerPropFlag,
      'value': innerPropValue,

    };

    this.setCurrentProp( this.getPrevNode(), innerPropName );

  }

}

// Parse an FBX file in Binary format
class BinaryParser {

  parse ( buffer ) {

    const reader = new BinaryReader( buffer );

    reader.skip( 23 ); // skip magic 23 bytes

    const version = reader.getUint32();

    if ( version < 6400 ) {

      throw new Error( 'THREE.FBXLoader: FBX version not supported, FileVersion: ' + version )

    }

    const allNodes = new FBXTree();

    while ( !this.endOfContent( reader ) ) {

      const node = this.parseNode( reader, version );

      if ( node !== null ) allNodes.add( node.name, node );

    }

    return allNodes

  }

  // Check if reader has reached the end of content.
  endOfContent ( reader ) {

    // footer size: 160bytes + 16-byte alignment padding
    // - 16bytes: magic
    // - padding til 16-byte alignment (at least 1byte?)
    //	(seems like some exporters embed fixed 15 or 16bytes?)
    // - 4bytes: magic
    // - 4bytes: version
    // - 120bytes: zero
    // - 16bytes: magic
    if ( reader.size() % 16 === 0 ) {

      return ( ( reader.getOffset() + 160 + 16 ) & ~0xf ) >= reader.size()

    } else {

      return reader.getOffset() + 160 + 16 >= reader.size()

    }

  }

  // recursively parse nodes until the end of the file is reached
  parseNode ( reader, version ) {

    const node = {};

    // The first three data sizes depends on version.
    const endOffset = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();
    const numProperties = ( version >= 7500 ) ? reader.getUint64() : reader.getUint32();

    ( version >= 7500 ) ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

    const nameLen = reader.getUint8();
    const name = reader.getString( nameLen );

    // Regards this node as NULL-record if endOffset is zero
    if ( endOffset === 0 ) return null

    const propertyList = [];

    for ( let i = 0; i < numProperties; i++ ) {

      propertyList.push( this.parseProperty( reader ) );

    }

    // Regards the first three elements in propertyList as id, attrName, and attrType
    const id = propertyList.length > 0 ? propertyList[ 0 ] : '';
    const attrName = propertyList.length > 1 ? propertyList[ 1 ] : '';
    const attrType = propertyList.length > 2 ? propertyList[ 2 ] : '';

    // check if this node represents just a single property
    // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}
    node.singleProperty = ( numProperties === 1 && reader.getOffset() === endOffset ) ? true : false;

    while ( endOffset > reader.getOffset() ) {

      const subNode = this.parseNode( reader, version );

      if ( subNode !== null ) this.parseSubNode( name, node, subNode );

    }

    node.propertyList = propertyList; // raw property list used by parent

    if ( typeof id === 'number' ) node.id = id;
    if ( attrName !== '' ) node.attrName = attrName;
    if ( attrType !== '' ) node.attrType = attrType;
    if ( name !== '' ) node.name = name;

    return node

  }

  parseSubNode ( name, node, subNode ) {

    // special case: child node is single property
    if ( subNode.singleProperty === true ) {

      const value = subNode.propertyList[ 0 ];

      if ( Array.isArray( value ) ) {

        node[ subNode.name ] = subNode;

        subNode.a = value;

      } else {

        node[ subNode.name ] = value;

      }

    } else if ( name === 'Connections' && subNode.name === 'C' ) {

      const array = [];

      subNode.propertyList.forEach( function ( property, i ) {

        // first Connection is FBX type (OO, OP, etc.). We'll discard these
        if ( i !== 0 ) array.push( property );

      } );

      if ( node.connections === undefined ) {

        node.connections = [];

      }

      node.connections.push( array );

    } else if ( subNode.name === 'Properties70' ) {

      const keys = Object.keys( subNode );

      keys.forEach( function ( key ) {

        node[ key ] = subNode[ key ];

      } );

    } else if ( name === 'Properties70' && subNode.name === 'P' ) {

      let innerPropName = subNode.propertyList[ 0 ];
      let innerPropType1 = subNode.propertyList[ 1 ];
      const innerPropType2 = subNode.propertyList[ 2 ];
      const innerPropFlag = subNode.propertyList[ 3 ];
      let innerPropValue;

      if ( innerPropName.indexOf( 'Lcl ' ) === 0 ) innerPropName = innerPropName.replace( 'Lcl ', 'Lcl_' );
      if ( innerPropType1.indexOf( 'Lcl ' ) === 0 ) innerPropType1 = innerPropType1.replace( 'Lcl ', 'Lcl_' );

      if ( innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf( 'Lcl_' ) === 0 ) {

        innerPropValue = [
          subNode.propertyList[ 4 ],
          subNode.propertyList[ 5 ],
          subNode.propertyList[ 6 ]
        ];

      } else {

        innerPropValue = subNode.propertyList[ 4 ];

      }

      // this will be copied to parent, see above
      node[ innerPropName ] = {

        'type': innerPropType1,
        'type2': innerPropType2,
        'flag': innerPropFlag,
        'value': innerPropValue,

      };

    } else if ( node[ subNode.name ] === undefined ) {

      if ( typeof subNode.id === 'number' ) {

        node[ subNode.name ] = {};
        node[ subNode.name ][ subNode.id ] = subNode;

      } else {

        node[ subNode.name ] = subNode;

      }

    } else {

      if ( subNode.name === 'PoseNode' ) {

        if ( !Array.isArray( node[ subNode.name ] ) ) {

          node[ subNode.name ] = [ node[ subNode.name ] ];

        }

        node[ subNode.name ].push( subNode );

      } else if ( node[ subNode.name ][ subNode.id ] === undefined ) {

        node[ subNode.name ][ subNode.id ] = subNode;

      }

    }

  }

  parseProperty ( reader ) {

    const type = reader.getString( 1 );
    let length;

    switch ( type ) {

    case 'C':
      return reader.getBoolean()

    case 'D':
      return reader.getFloat64()

    case 'F':
      return reader.getFloat32()

    case 'I':
      return reader.getInt32()

    case 'L':
      return reader.getInt64()

    case 'R':
      length = reader.getUint32();
      return reader.getArrayBuffer( length )

    case 'S':
      length = reader.getUint32();
      return reader.getString( length )

    case 'Y':
      return reader.getInt16()

    case 'b':
    case 'c':
    case 'd':
    case 'f':
    case 'i':
    case 'l':

      const arrayLength = reader.getUint32();
      const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed
      const compressedLength = reader.getUint32();

      if ( encoding === 0 ) {

        switch ( type ) {

        case 'b':
        case 'c':
          return reader.getBooleanArray( arrayLength )

        case 'd':
          return reader.getFloat64Array( arrayLength )

        case 'f':
          return reader.getFloat32Array( arrayLength )

        case 'i':
          return reader.getInt32Array( arrayLength )

        case 'l':
          return reader.getInt64Array( arrayLength )

        }

      }

      const data = fflate.unzlibSync( new Uint8Array( reader.getArrayBuffer( compressedLength ) ) );
      const reader2 = new BinaryReader( data.buffer );

      switch ( type ) {

      case 'b':
      case 'c':
        return reader2.getBooleanArray( arrayLength )

      case 'd':
        return reader2.getFloat64Array( arrayLength )

      case 'f':
        return reader2.getFloat32Array( arrayLength )

      case 'i':
        return reader2.getInt32Array( arrayLength )

      case 'l':
        return reader2.getInt64Array( arrayLength )

      }

      break // cannot happen but is required by the DeepScan

    default:
      throw new Error( 'THREE.FBXLoader: Unknown property type ' + type )

    }

  }

}

class BinaryReader {

  constructor ( buffer, littleEndian ) {

    this.dv = new DataView( buffer );
    this.offset = 0;
    this.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;
    this._textDecoder = new TextDecoder();

  }

  getOffset () {

    return this.offset

  }

  size () {

    return this.dv.buffer.byteLength

  }

  skip ( length ) {

    this.offset += length;

  }

  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean () {

    return ( this.getUint8() & 1 ) === 1

  }

  getBooleanArray ( size ) {

    const a = [];

    for ( let i = 0; i < size; i++ ) {

      a.push( this.getBoolean() );

    }

    return a

  }

  getUint8 () {

    const value = this.dv.getUint8( this.offset );

    this.offset += 1;
    return value

  }

  getInt16 () {

    const value = this.dv.getInt16( this.offset, this.littleEndian );

    this.offset += 2;
    return value

  }

  getInt32 () {

    const value = this.dv.getInt32( this.offset, this.littleEndian );

    this.offset += 4;
    return value

  }

  getInt32Array ( size ) {

    const a = [];

    for ( let i = 0; i < size; i++ ) {

      a.push( this.getInt32() );

    }

    return a

  }

  getUint32 () {

    const value = this.dv.getUint32( this.offset, this.littleEndian );

    this.offset += 4;
    return value

  }

  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64 () {

    let low, high;

    if ( this.littleEndian ) {

      low = this.getUint32();
      high = this.getUint32();

    } else {

      high = this.getUint32();
      low = this.getUint32();

    }

    // calculate negative value
    if ( high & 0x80000000 ) {

      high = ~high & 0xFFFFFFFF;
      low = ~low & 0xFFFFFFFF;

      if ( low === 0xFFFFFFFF ) high = ( high + 1 ) & 0xFFFFFFFF;

      low = ( low + 1 ) & 0xFFFFFFFF;

      return -( high * 0x100000000 + low )

    }

    return high * 0x100000000 + low

  }

  getInt64Array ( size ) {

    const a = [];

    for ( let i = 0; i < size; i++ ) {

      a.push( this.getInt64() );

    }

    return a

  }

  // Note: see getInt64() comment
  getUint64 () {

    let low, high;

    if ( this.littleEndian ) {

      low = this.getUint32();
      high = this.getUint32();

    } else {

      high = this.getUint32();
      low = this.getUint32();

    }

    return high * 0x100000000 + low

  }

  getFloat32 () {

    const value = this.dv.getFloat32( this.offset, this.littleEndian );

    this.offset += 4;
    return value

  }

  getFloat32Array ( size ) {

    const a = [];

    for ( let i = 0; i < size; i++ ) {

      a.push( this.getFloat32() );

    }

    return a

  }

  getFloat64 () {

    const value = this.dv.getFloat64( this.offset, this.littleEndian );

    this.offset += 8;
    return value

  }

  getFloat64Array ( size ) {

    const a = [];

    for ( let i = 0; i < size; i++ ) {

      a.push( this.getFloat64() );

    }

    return a

  }

  getArrayBuffer ( size ) {

    const value = this.dv.buffer.slice( this.offset, this.offset + size );

    this.offset += size;
    return value

  }

  getString ( size ) {

    const start = this.offset;
    let a = new Uint8Array( this.dv.buffer, start, size );

    this.skip( size );

    const nullByte = a.indexOf( 0 );

    if ( nullByte >= 0 ) a = new Uint8Array( this.dv.buffer, start, nullByte );

    return this._textDecoder.decode( a )

  }

}

// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
// and BinaryParser( FBX Binary format)
class FBXTree {

  add ( key, val ) {

    this[ key ] = val;

  }

}

// ************** UTILITY FUNCTIONS **************

function isFbxFormatBinary ( buffer ) {

  const CORRECT = 'Kaydara\u0020FBX\u0020Binary\u0020\u0020\0';

  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString( buffer, 0, CORRECT.length )

}

function isFbxFormatASCII ( text ) {

  const CORRECT = [ 'K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\' ];

  let cursor = 0;

  function read ( offset ) {

    const result = text[ offset - 1 ];

    text = text.slice( cursor + offset );
    cursor++;
    return result

  }

  for ( let i = 0; i < CORRECT.length; ++i ) {

    const num = read( 1 );

    if ( num === CORRECT[ i ] ) {

      return false

    }

  }

  return true

}

function getFbxVersion ( text ) {

  const versionRegExp = /FBXVersion: (\d+)/;
  const match = text.match( versionRegExp );

  if ( match ) {

    const version = parseInt( match[ 1 ] );

    return version

  }

  throw new Error( 'THREE.FBXLoader: Cannot find the version number for the file given.' )

}

// Converts FBX ticks into real time seconds.
function convertFBXTimeToSeconds ( time ) {

  return time / 46186158000

}

const dataArray = [];

// extracts the data from the correct position in the FBX array based on indexing type
function getData ( polygonVertexIndex, polygonIndex, vertexIndex, infoObject ) {

  let index;

  switch ( infoObject.mappingType ) {

  case 'ByPolygonVertex' :
    index = polygonVertexIndex;
    break
  case 'ByPolygon' :
    index = polygonIndex;
    break
  case 'ByVertice' :
    index = vertexIndex;
    break
  case 'AllSame' :
    index = infoObject.indices[ 0 ];
    break
  default :
    console.warn( 'THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType );

  }

  if ( infoObject.referenceType === 'IndexToDirect' ) index = infoObject.indices[ index ];

  const from = index * infoObject.dataSize;
  const to = from + infoObject.dataSize;

  return slice( dataArray, infoObject.buffer, from, to )

}

const tempEuler = new Euler();
const tempVec = new Vector3();

// generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e
function generateTransform ( transformData ) {

  const lTranslationM = new Matrix4();
  const lPreRotationM = new Matrix4();
  const lRotationM = new Matrix4();
  const lPostRotationM = new Matrix4();

  const lScalingM = new Matrix4();
  const lScalingPivotM = new Matrix4();
  const lScalingOffsetM = new Matrix4();
  const lRotationOffsetM = new Matrix4();
  const lRotationPivotM = new Matrix4();

  const lParentGX = new Matrix4();
  const lParentLX = new Matrix4();
  const lGlobalT = new Matrix4();

  const inheritType = ( transformData.inheritType ) ? transformData.inheritType : 0;

  if ( transformData.translation ) lTranslationM.setPosition( tempVec.fromArray( transformData.translation ) );

  if ( transformData.preRotation ) {

    const array = transformData.preRotation.map( MathUtils.degToRad );

    array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
    lPreRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  }

  if ( transformData.rotation ) {

    const array = transformData.rotation.map( MathUtils.degToRad );

    array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
    lRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );

  }

  if ( transformData.postRotation ) {

    const array = transformData.postRotation.map( MathUtils.degToRad );

    array.push( transformData.eulerOrder || Euler.DEFAULT_ORDER );
    lPostRotationM.makeRotationFromEuler( tempEuler.fromArray( array ) );
    lPostRotationM.invert();

  }

  if ( transformData.scale ) lScalingM.scale( tempVec.fromArray( transformData.scale ) );

  // Pivots and offsets
  if ( transformData.scalingOffset ) lScalingOffsetM.setPosition( tempVec.fromArray( transformData.scalingOffset ) );
  if ( transformData.scalingPivot ) lScalingPivotM.setPosition( tempVec.fromArray( transformData.scalingPivot ) );
  if ( transformData.rotationOffset ) lRotationOffsetM.setPosition( tempVec.fromArray( transformData.rotationOffset ) );
  if ( transformData.rotationPivot ) lRotationPivotM.setPosition( tempVec.fromArray( transformData.rotationPivot ) );

  // parent transform
  if ( transformData.parentMatrixWorld ) {

    lParentLX.copy( transformData.parentMatrix );
    lParentGX.copy( transformData.parentMatrixWorld );

  }

  const lLRM = lPreRotationM.clone().multiply( lRotationM ).multiply( lPostRotationM );
  // Global Rotation
  const lParentGRM = new Matrix4();

  lParentGRM.extractRotation( lParentGX );

  // Global Shear*Scaling
  const lParentTM = new Matrix4();

  lParentTM.copyPosition( lParentGX );

  const lParentGRSM = lParentTM.clone().invert().multiply( lParentGX );
  const lParentGSM = lParentGRM.clone().invert().multiply( lParentGRSM );
  const lLSM = lScalingM;

  const lGlobalRS = new Matrix4();

  if ( inheritType === 0 ) {

    lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM ).multiply( lLSM );

  } else if ( inheritType === 1 ) {

    lGlobalRS.copy( lParentGRM ).multiply( lParentGSM ).multiply( lLRM ).multiply( lLSM );

  } else {

    const lParentLSM = new Matrix4().scale( new Vector3().setFromMatrixScale( lParentLX ) );
    const lParentLSM_inv = lParentLSM.clone().invert();
    const lParentGSM_noLocal = lParentGSM.clone().multiply( lParentLSM_inv );

    lGlobalRS.copy( lParentGRM ).multiply( lLRM ).multiply( lParentGSM_noLocal ).multiply( lLSM );

  }

  const lRotationPivotM_inv = lRotationPivotM.clone().invert();
  const lScalingPivotM_inv = lScalingPivotM.clone().invert();
  // Calculate the local transform matrix
  let lTransform = lTranslationM.clone().multiply( lRotationOffsetM ).multiply( lRotationPivotM ).multiply( lPreRotationM ).multiply( lRotationM ).multiply( lPostRotationM ).multiply( lRotationPivotM_inv ).multiply( lScalingOffsetM ).multiply( lScalingPivotM ).multiply( lScalingM ).multiply( lScalingPivotM_inv );

  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition( lTransform );

  const lGlobalTranslation = lParentGX.clone().multiply( lLocalTWithAllPivotAndOffsetInfo );

  lGlobalT.copyPosition( lGlobalTranslation );

  lTransform = lGlobalT.clone().multiply( lGlobalRS );

  // from global to local
  lTransform.premultiply( lParentGX.invert() );

  return lTransform

}

// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html
function getEulerOrder ( order ) {

  order = order || 0;

  const enums = [
    'ZYX', // -> XYZ extrinsic
    'YZX', // -> XZY extrinsic
    'XZY', // -> YZX extrinsic
    'ZXY', // -> YXZ extrinsic
    'YXZ', // -> ZXY extrinsic
    'XYZ' // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];

  if ( order === 6 ) {

    console.warn( 'THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.' );
    return enums[ 0 ]

  }

  return enums[ order ]

}

// Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser
function parseNumberArray ( value ) {

  const array = value.split( ',' ).map( function ( val ) {

    return parseFloat( val )

  } );

  return array

}

function convertArrayBufferToString ( buffer, from, to ) {

  if ( from === undefined ) from = 0;
  if ( to === undefined ) to = buffer.byteLength;

  return new TextDecoder().decode( new Uint8Array( buffer, from, to ) )

}

function append ( a, b ) {

  for ( let i = 0, j = a.length, l = b.length; i < l; i++, j++ ) {

    a[ j ] = b[ i ];

  }

}

function slice ( a, b, from, to ) {

  for ( let i = from, j = 0; i < to; i++, j++ ) {

    a[ j ] = b[ i ];

  }

  return a

}

// inject array a2 into array a1 at index
function inject ( a1, index, a2 ) {

  return a1.slice( 0, index ).concat( a2 ).concat( a1.slice( index ) )

}

/* WEB WORKER */
const noCompressWorker = () => {
    self.noCompressWorker = function (arrayBuffer, nPos) {
        const [vertex_size] = new Uint32Array(arrayBuffer, nPos, 1);
        nPos += 4; //顶点数量
        // const position: TypedInfo = new Float32Array( arrayBuffer, nPos, vertex_size * 3 )
        const position = { byteOffset: nPos, length: vertex_size * 3, };
        nPos += vertex_size * 3 * 4;
        // const uvs_array = new Float32Array( arrayBuffer, nPos, vertex_size * 2 )
        const texcoord = { byteOffset: nPos, length: vertex_size * 2, };
        nPos += vertex_size * 2 * 4;
        // const color_array = new Uint8Array( arrayBuffer, nPos, vertex_size * 4 )
        const color = { byteOffset: nPos, length: vertex_size * 4, };
        nPos += vertex_size * 4 * 1;
        // const normal_array = new Int8Array( arrayBuffer, nPos, vertex_size * 3 )
        const normal = { byteOffset: nPos, length: vertex_size * 3, };
        nPos += vertex_size * 3 * 1;
        const nTotal = color.length + normal.length;
        let panding = nTotal % 4;
        if (panding > 0) {
            panding = 4 - panding;
            nPos += panding;
        }
        const indices_buffer = new Uint32Array(arrayBuffer, nPos, 1);
        nPos += 4;
        const [indices_len] = indices_buffer;
        // const indices_array = new Uint32Array( arrayBuffer, nPos, indices_len )
        const indice = { byteOffset: nPos, length: indices_len, };
        nPos += indices_len * 4;
        const sub_buffer = new Uint32Array(arrayBuffer, nPos, 1);
        nPos += 4;
        const [sub_buffer_len] = sub_buffer;
        const sub_mesh = [];
        if (sub_buffer_len > 0) {
            for (let i = 0; i < sub_buffer_len; i++) {
                const [start] = new Uint32Array(arrayBuffer, nPos, 1);
                nPos += 4;
                const [count] = new Uint32Array(arrayBuffer, nPos, 1);
                nPos += 4;
                const [alphaMode] = new Uint32Array(arrayBuffer, nPos, 1);
                nPos += 4;
                const [uuid_length] = new Uint32Array(arrayBuffer, nPos, 1);
                nPos += 4;
                const uuid_array = new Uint8Array(arrayBuffer, nPos, uuid_length);
                nPos += uuid_length;
                const uuid = new TextDecoder().decode(uuid_array);
                sub_mesh.push({ start: start, count: count, uuid: uuid, alphaMode: alphaMode, });
            }
        }
        return {
            buffer: arrayBuffer,
            position,
            normal,
            color,
            texcoord,
            indice,
            sub_mesh,
        };
    };
};

/* WEB WORKER */
const gzipCompressWorker = () => {
    self.gzipCompressWorker = function (compressBuffer) {
        // const [ chunkSize ] = new Uint32Array( compressBuffer, 0, 1 )
        const content = new Uint8Array(compressBuffer, 4, compressBuffer.byteLength - 4);
        // @ts-ignore
        const inflator = new pako.Inflate();
        inflator.push(content, true);
        const { result, } = inflator;
        if (result instanceof Uint8Array) {
            const { buffer: arrayBuffer, } = result;
            let nPos = 0;
            const [vertex_size] = new Uint32Array(arrayBuffer, nPos, 1);
            nPos += 4; //顶点数量
            // const position_array = new Float32Array( arrayBuffer, nPos, vertex_size * 3 )
            const position = { byteOffset: nPos, length: vertex_size * 3, };
            nPos += vertex_size * 3 * 4;
            // const uvs_array = new Float32Array( arrayBuffer, nPos, vertex_size * 2 )
            const texcoord = { byteOffset: nPos, length: vertex_size * 2, };
            nPos += vertex_size * 2 * 4;
            // const color_array = new Uint8Array( arrayBuffer, nPos, vertex_size * 4 )
            const color = { byteOffset: nPos, length: vertex_size * 4, };
            nPos += vertex_size * 4 * 1;
            // const normal_array = new Int8Array( arrayBuffer, nPos, vertex_size * 3 )
            const normal = { byteOffset: nPos, length: vertex_size * 3, };
            nPos += vertex_size * 3 * 1;
            const nTotal = color.length + normal.length;
            let panding = nTotal % 4;
            if (panding > 0) {
                panding = 4 - panding;
                nPos += panding;
            }
            const indices_buffer = new Uint32Array(arrayBuffer, nPos, 1);
            nPos += 4;
            const [indices_len] = indices_buffer;
            // const indices_array = new Uint32Array( arrayBuffer, nPos, indices_len )
            const indice = { byteOffset: nPos, length: indices_len, };
            nPos += indices_len * 4;
            const sub_buffer = new Uint32Array(arrayBuffer, nPos, 1);
            nPos += 4;
            const [sub_buffer_len] = sub_buffer;
            const sub_mesh = [];
            if (sub_buffer_len > 0) {
                for (let i = 0; i < sub_buffer_len; i++) {
                    const [start] = new Uint32Array(arrayBuffer, nPos, 1);
                    nPos += 4;
                    const [count] = new Uint32Array(arrayBuffer, nPos, 1);
                    nPos += 4;
                    const [alphaMode] = new Uint32Array(arrayBuffer, nPos, 1);
                    nPos += 4;
                    const [uuid_length] = new Uint32Array(arrayBuffer, nPos, 1);
                    nPos += 4;
                    const uuid_array = new Uint8Array(arrayBuffer, nPos, uuid_length);
                    nPos += uuid_length;
                    const uuid = new TextDecoder().decode(uuid_array);
                    sub_mesh.push({ start: start, count: count, uuid: uuid, alphaMode: alphaMode, });
                }
            }
            return {
                buffer: arrayBuffer,
                position,
                normal,
                color,
                texcoord,
                indice,
                sub_mesh,
            };
        }
    };
};

/* WEB WORKER */
const parseChunkWorker = () => {
    self.parseChunkWorker = function (buffer) {
        let nPos = 0;
        //头部 
        const header = new Int8Array(buffer, nPos, 128);
        nPos += 128;
        // version
        new TextDecoder().decode(header.slice(0, 4));
        //压缩模式  0--没有压缩   1--gzip压缩    2--draco 压缩
        const [compressMode] = header.slice(4, 8);
        if (compressMode === 0) {
            return self.noCompressWorker(buffer, nPos);
        }
        else if (compressMode === 1) {
            const compressBuffer = buffer.slice(128);
            return self.gzipCompressWorker(compressBuffer);
        }
        else ;
        throw new Error('unknown compress mode [ .sbmx model ]');
    };
};

/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const pakoString = `

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));
}(this, (function (exports) { 'use strict';

  // Note: adler32 takes 12% for level 0 and 2% for level 6.
  // It isn't worth it to make additional optimizations as in original.
  // Small size is preferable.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express ofr implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const adler32 = (adler, buf, len, pos) => {
    let s1 = (adler & 0xffff) |0,
        s2 = ((adler >>> 16) & 0xffff) |0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = (s1 + buf[pos++]) |0;
        s2 = (s2 + s1) |0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return (s1 | (s2 << 16)) |0;
  };


  var adler32_1 = adler32;

  // Note: we can't get significant speed boost here.
  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // Use ordinary array, since untyped makes no boost here
  const makeTable = () => {
    let c, table = [];

    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }

    return table;
  };

  // Create table on load. Just 255 signed longs. Not a problem.
  const crcTable = new Uint32Array(makeTable());


  const crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;

    crc ^= -1;

    for (let i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
  };


  var crc32_1 = crc32;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // See state defs from inflate.js
  const BAD$1 = 30;       /* got a data error -- remain here until reset */
  const TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8

     On return, state.mode is one of:

          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data

     Notes:

      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.

      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
  var inffast = function inflate_fast(strm, start) {
    let _in;                    /* local strm.input */
    let last;                   /* have enough input while in < last */
    let _out;                   /* local strm.output */
    let beg;                    /* inflate()'s initial strm.output */
    let end;                    /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
    let dmax;                   /* maximum distance from zlib header */
  //#endif
    let wsize;                  /* window size or zero if not using window */
    let whave;                  /* valid bytes in the window */
    let wnext;                  /* window write index */
    // Use \`s_window\` instead \`window\`, avoid conflict with instrumentation tools
    let s_window;               /* allocated sliding window, if wsize != 0 */
    let hold;                   /* local strm.hold */
    let bits;                   /* local strm.bits */
    let lcode;                  /* local strm.lencode */
    let dcode;                  /* local strm.distcode */
    let lmask;                  /* mask for first level of length codes */
    let dmask;                  /* mask for first level of distance codes */
    let here;                   /* retrieved table entry */
    let op;                     /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    let len;                    /* match length, unused bytes */
    let dist;                   /* match distance */
    let from;                   /* where to copy match from */
    let from_source;


    let input, output; // JS specific, because we have no pointers

    /* copy state to local variables */
    const state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
    dmax = state.dmax;
  //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;


    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen:
      for (;;) { // Goto emulation
        op = here >>> 24/*here.bits*/;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff/*here.op*/;
        if (op === 0) {                          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'" :
          //        "inflate:         literal 0x%02x", here.val));
          output[_out++] = here & 0xffff/*here.val*/;
        }
        else if (op & 16) {                     /* length base */
          len = here & 0xffff/*here.val*/;
          op &= 15;                           /* number of extra bits */
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          //Tracevv((stderr, "inflate:         length %u", len));
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];

          dodist:
          for (;;) { // goto emulation
            op = here >>> 24/*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff/*here.op*/;

            if (op & 16) {                      /* distance base */
              dist = here & 0xffff/*here.val*/;
              op &= 15;                       /* number of extra bits */
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
  //#ifdef INFLATE_STRICT
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD$1;
                break top;
              }
  //#endif
              hold >>>= op;
              bits -= op;
              //Tracevv((stderr, "inflate:         distance %u", dist));
              op = _out - beg;                /* max distance in output */
              if (dist > op) {                /* see if copy from window */
                op = dist - op;               /* distance back in window */
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD$1;
                    break top;
                  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //                if (len <= op - whave) {
  //                  do {
  //                    output[_out++] = 0;
  //                  } while (--len);
  //                  continue top;
  //                }
  //                len -= op - whave;
  //                do {
  //                  output[_out++] = 0;
  //                } while (--op > whave);
  //                if (op === 0) {
  //                  from = _out - dist;
  //                  do {
  //                    output[_out++] = output[from++];
  //                  } while (--len);
  //                  continue top;
  //                }
  //#endif
                }
                from = 0; // window index
                from_source = s_window;
                if (wnext === 0) {           /* very common case */
                  from += wsize - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                else if (wnext < op) {      /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {         /* some from end of window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {  /* some from start of window */
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;      /* rest from output */
                      from_source = output;
                    }
                  }
                }
                else {                      /* contiguous in window */
                  from += wnext - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              }
              else {
                from = _out - dist;          /* copy direct from output */
                do {                        /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            }
            else if ((op & 64) === 0) {          /* 2nd level distance code */
              here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
              continue dodist;
            }
            else {
              strm.msg = 'invalid distance code';
              state.mode = BAD$1;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        }
        else if ((op & 64) === 0) {              /* 2nd level length code */
          here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
          continue dolen;
        }
        else if (op & 32) {                     /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block"));
          state.mode = TYPE$1;
          break top;
        }
        else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;

    /* update state and return */
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const MAXBITS = 15;
  const ENOUGH_LENS$1 = 852;
  const ENOUGH_DISTS$1 = 592;
  //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

  const CODES$1 = 0;
  const LENS$1 = 1;
  const DISTS$1 = 2;

  const lbase = new Uint16Array([ /* Length codes 257..285 base */
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ]);

  const lext = new Uint8Array([ /* Length codes 257..285 extra */
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
    19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
  ]);

  const dbase = new Uint16Array([ /* Distance codes 0..29 base */
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577, 0, 0
  ]);

  const dext = new Uint8Array([ /* Distance codes 0..29 extra */
    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
    23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
    28, 28, 29, 29, 64, 64
  ]);

  const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
  {
    const bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

    let len = 0;               /* a code's length in bits */
    let sym = 0;               /* index of code symbols */
    let min = 0, max = 0;          /* minimum and maximum code lengths */
    let root = 0;              /* number of index bits for root table */
    let curr = 0;              /* number of index bits for current table */
    let drop = 0;              /* code bits to drop for sub-table */
    let left = 0;                   /* number of prefix codes available */
    let used = 0;              /* code entries in table used */
    let huff = 0;              /* Huffman code */
    let incr;              /* for incrementing code, index */
    let fill;              /* index for replicating entries */
    let low;               /* low bits for current root entry */
    let mask;              /* mask for low root bits */
    let next;             /* next available space in table */
    let base = null;     /* base value table to use */
    let base_index = 0;
  //  let shoextra;    /* extra bits table to use */
    let end;                    /* use base and extra for symbol > end */
    const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
    const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
    let extra = null;
    let extra_index = 0;

    let here_bits, here_op, here_val;

    /*
     Process a set of code lengths to create a canonical Huffman code.  The
     code lengths are lens[0..codes-1].  Each length corresponds to the
     symbols 0..codes-1.  The Huffman code is generated by first sorting the
     symbols by length from short to long, and retaining the symbol order
     for codes with equal lengths.  Then the code starts with all zero bits
     for the first code of the shortest length, and the codes are integer
     increments for the same length, and zeros are appended as the length
     increases.  For the deflate format, these bits are stored backwards
     from their more natural integer increment ordering, and so when the
     decoding tables are built in the large loop below, the integer codes
     are incremented backwards.

     This routine assumes, but does not check, that all of the entries in
     lens[] are in the range 0..MAXBITS.  The caller must assure this.
     1..MAXBITS is interpreted as that code length.  zero means that that
     symbol does not occur in this code.

     The codes are sorted by computing a count of codes for each length,
     creating from that a table of starting indices for each length in the
     sorted table, and then entering the symbols in order in the sorted
     table.  The sorted table is work[], with that space being provided by
     the caller.

     The length counts are used for other purposes as well, i.e. finding
     the minimum and maximum length codes, determining if there are any
     codes at all, checking for a valid set of lengths, and looking ahead
     at length counts to determine sub-table sizes when building the
     decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }

    /* bound code lengths, force root to be within code lengths */
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) { break; }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {                     /* no symbols to code at all */
      //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
      //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
      //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;


      //table.op[opts.table_index] = 64;
      //table.bits[opts.table_index] = 1;
      //table.val[opts.table_index++] = 0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;

      opts.bits = 1;
      return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) { break; }
    }
    if (root < min) {
      root = min;
    }

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }        /* over-subscribed */
    }
    if (left > 0 && (type === CODES$1 || max !== 1)) {
      return -1;                      /* incomplete set */
    }

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }

    /*
     Create and fill in decoding tables.  In this loop, the table being
     filled is at next and has curr index bits.  The code being used is huff
     with length len.  That code is converted to an index by dropping drop
     bits off of the bottom.  For codes where len is less than drop + curr,
     those top drop + curr - len bits are incremented through all values to
     fill the table with replicated entries.

     root is the number of index bits for the root table.  When len exceeds
     root, sub-tables are created pointed to by the root entry with an index
     of the low root bits of huff.  This is saved in low to check for when a
     new sub-table should be started.  drop is zero when the root table is
     being filled, and drop is root when sub-tables are being filled.

     When a new sub-table is needed, it is necessary to look ahead in the
     code lengths to determine what size sub-table is needed.  The length
     counts are used for this, and so count[] is decremented as codes are
     entered in the tables.

     used keeps track of how many table entries have been allocated from the
     provided *table space.  It is checked for LENS and DIST tables against
     the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
     the initial root table size constants.  See the comments in inftrees.h
     for more information.

     sym increments through all symbols, and the loop terminates when
     all codes of length max, i.e. all codes, have been processed.  This
     routine permits incomplete codes, so another loop after this one fills
     in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    // poor man optimization - use if-else instead of switch,
    // to avoid deopts in old v8
    if (type === CODES$1) {
      base = extra = work;    /* dummy value--not used */
      end = 19;

    } else if (type === LENS$1) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;

    } else {                    /* DISTS */
      base = dbase;
      extra = dext;
      end = -1;
    }

    /* initialize opts for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = table_index;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = -1;                   /* trigger new sub-table when len > root */
    used = 1 << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
      (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
      return 1;
    }

    /* process all codes and make table entries */
    for (;;) {
      /* create table entry */
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      }
      else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      }
      else {
        here_op = 32 + 64;         /* end of block */
        here_val = 0;
      }

      /* replicate for those indices with low len bits equal to huff */
      incr = 1 << (len - drop);
      fill = 1 << curr;
      min = fill;                 /* save offset to next table */
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
      } while (fill !== 0);

      /* backwards increment the len-bit code huff */
      incr = 1 << (len - 1);
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }

      /* go to next symbol, update count, len */
      sym++;
      if (--count[len] === 0) {
        if (len === max) { break; }
        len = lens[lens_index + work[sym]];
      }

      /* create new sub-table if needed */
      if (len > root && (huff & mask) !== low) {
        /* if first time, transition to sub-tables */
        if (drop === 0) {
          drop = root;
        }

        /* increment past last table */
        next += min;            /* here min is 1 << curr */

        /* determine length of next table */
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) { break; }
          curr++;
          left <<= 1;
        }

        /* check for enough space */
        used += 1 << curr;
        if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
          (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
          return 1;
        }

        /* point entry in root table to sub-table */
        low = huff & mask;
        /*table.op[low] = curr;
        table.bits[low] = root;
        table.val[low] = next - opts.table_index;*/
        table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
      }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
     at most one remaining entry, since if the code is incomplete, the
     maximum code length that was allowed to get this far is one bit) */
    if (huff !== 0) {
      //table.op[next + huff] = 64;            /* invalid code marker */
      //table.bits[next + huff] = len - drop;
      //table.val[next + huff] = 0;
      table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
    }

    /* set return parameters */
    //opts.table_index += used;
    opts.bits = root;
    return 0;
  };


  var inftrees = inflate_table;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var constants$1 = {

    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH:         0,
    Z_PARTIAL_FLUSH:    1,
    Z_SYNC_FLUSH:       2,
    Z_FULL_FLUSH:       3,
    Z_FINISH:           4,
    Z_BLOCK:            5,
    Z_TREES:            6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK:               0,
    Z_STREAM_END:       1,
    Z_NEED_DICT:        2,
    Z_ERRNO:           -1,
    Z_STREAM_ERROR:    -2,
    Z_DATA_ERROR:      -3,
    Z_MEM_ERROR:       -4,
    Z_BUF_ERROR:       -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION:         0,
    Z_BEST_SPEED:             1,
    Z_BEST_COMPRESSION:       9,
    Z_DEFAULT_COMPRESSION:   -1,


    Z_FILTERED:               1,
    Z_HUFFMAN_ONLY:           2,
    Z_RLE:                    3,
    Z_FIXED:                  4,
    Z_DEFAULT_STRATEGY:       0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY:                 0,
    Z_TEXT:                   1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN:                2,

    /* The deflate compression method */
    Z_DEFLATED:               8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.






  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$1;


  /* STATES ====================================================================*/
  /* ===========================================================================*/


  const    HEAD = 1;       /* i: waiting for magic header */
  const    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
  const    TIME = 3;       /* i: waiting for modification time (gzip) */
  const    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
  const    EXLEN = 5;      /* i: waiting for extra length (gzip) */
  const    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
  const    NAME = 7;       /* i: waiting for end of file name (gzip) */
  const    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
  const    HCRC = 9;       /* i: waiting for header crc (gzip) */
  const    DICTID = 10;    /* i: waiting for dictionary check value */
  const    DICT = 11;      /* waiting for inflateSetDictionary() call */
  const        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
  const        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
  const        STORED = 14;    /* i: waiting for stored size (length and complement) */
  const        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
  const        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
  const        TABLE = 17;     /* i: waiting for dynamic block table lengths */
  const        LENLENS = 18;   /* i: waiting for code length code lengths */
  const        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
  const            LEN_ = 20;      /* i: same as LEN below, but only first time in */
  const            LEN = 21;       /* i: waiting for length/lit/eob code */
  const            LENEXT = 22;    /* i: waiting for length extra bits */
  const            DIST = 23;      /* i: waiting for distance code */
  const            DISTEXT = 24;   /* i: waiting for distance extra bits */
  const            MATCH = 25;     /* o: waiting for output space to copy string */
  const            LIT = 26;       /* o: waiting for output space to write literal */
  const    CHECK = 27;     /* i: waiting for 32-bit check value */
  const    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
  const    DONE = 29;      /* finished check, done -- remain here until reset */
  const    BAD = 30;       /* got a data error -- remain here until reset */
  const    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
  const    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

  /* ===========================================================================*/



  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

  const MAX_WBITS = 15;
  /* 32K LZ77 window */
  const DEF_WBITS = MAX_WBITS;


  const zswap32 = (q) => {

    return  (((q >>> 24) & 0xff) +
            ((q >>> 8) & 0xff00) +
            ((q & 0xff00) << 8) +
            ((q & 0xff) << 24));
  };


  function InflateState() {
    this.mode = 0;             /* current inflate mode */
    this.last = false;          /* true if processing last block */
    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
    this.havedict = false;      /* true if dictionary provided */
    this.flags = 0;             /* gzip header method and flags (0 if zlib) */
    this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
    this.check = 0;             /* protected copy of check value */
    this.total = 0;             /* protected copy of output count */
    // TODO: may be {}
    this.head = null;           /* where to save gzip header information */

    /* sliding window */
    this.wbits = 0;             /* log base 2 of requested window size */
    this.wsize = 0;             /* window size or zero if not using window */
    this.whave = 0;             /* valid bytes in the window */
    this.wnext = 0;             /* window write index */
    this.window = null;         /* allocated sliding window, if needed */

    /* bit accumulator */
    this.hold = 0;              /* input bit accumulator */
    this.bits = 0;              /* number of bits in "in" */

    /* for string and stored block copying */
    this.length = 0;            /* literal or length of data to copy */
    this.offset = 0;            /* distance back to copy string from */

    /* for table and code decoding */
    this.extra = 0;             /* extra bits needed */

    /* fixed and dynamic code tables */
    this.lencode = null;          /* starting table for length/literal codes */
    this.distcode = null;         /* starting table for distance codes */
    this.lenbits = 0;           /* index bits for lencode */
    this.distbits = 0;          /* index bits for distcode */

    /* dynamic table building */
    this.ncode = 0;             /* number of code length code lengths */
    this.nlen = 0;              /* number of length code lengths */
    this.ndist = 0;             /* number of distance code lengths */
    this.have = 0;              /* number of code lengths in lens[] */
    this.next = null;              /* next available space in codes[] */

    this.lens = new Uint16Array(320); /* temporary storage for code lengths */
    this.work = new Uint16Array(288); /* work area for code table building */

    /*
     because we don't have pointers in js, we use lencode and distcode directly
     as buffers so we don't need codes
    */
    //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
    this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
    this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
    this.sane = 0;                   /* if false, allow invalid distance too far */
    this.back = 0;                   /* bits back of last unprocessed length/lit */
    this.was = 0;                    /* initial length of match */
  }


  const inflateResetKeep = (strm) => {

    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = ''; /*Z_NULL*/
    if (state.wrap) {       /* to support ill-conceived Java test suite */
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.dmax = 32768;
    state.head = null/*Z_NULL*/;
    state.hold = 0;
    state.bits = 0;
    //state.lencode = state.distcode = state.next = state.codes;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

    state.sane = 1;
    state.back = -1;
    //Tracev((stderr, "inflate: reset"));
    return Z_OK$1;
  };


  const inflateReset = (strm) => {

    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);

  };


  const inflateReset2 = (strm, windowBits) => {
    let wrap;

    /* get the state */
    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    }
    else {
      wrap = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }

    /* update state and reset the rest of it */
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };


  const inflateInit2 = (strm, windowBits) => {

    if (!strm) { return Z_STREAM_ERROR$1; }
    //strm.msg = Z_NULL;                 /* in case we return an error */

    const state = new InflateState();

    //if (state === Z_NULL) return Z_MEM_ERROR;
    //Tracev((stderr, "inflate: allocated"));
    strm.state = state;
    state.window = null/*Z_NULL*/;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null/*Z_NULL*/;
    }
    return ret;
  };


  const inflateInit = (strm) => {

    return inflateInit2(strm, DEF_WBITS);
  };


  /*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
   */
  let virgin = true;

  let lenfix, distfix; // We have no pointers in JS, so keep tables separate


  const fixedtables = (state) => {

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);

      /* literal/length table */
      let sym = 0;
      while (sym < 144) { state.lens[sym++] = 8; }
      while (sym < 256) { state.lens[sym++] = 9; }
      while (sym < 280) { state.lens[sym++] = 7; }
      while (sym < 288) { state.lens[sym++] = 8; }

      inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

      /* distance table */
      sym = 0;
      while (sym < 32) { state.lens[sym++] = 5; }

      inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

      /* do this just once */
      virgin = false;
    }

    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };


  /*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
   */
  const updatewindow = (strm, src, end, copy) => {

    let dist;
    const state = strm.state;

    /* if it hasn't been done already, allocate space for the window */
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;

      state.window = new Uint8Array(state.wsize);
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    }
    else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      //zmemcpy(state->window + state->wnext, end - copy, dist);
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        //zmemcpy(state->window, end - copy, copy);
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      }
      else {
        state.wnext += dist;
        if (state.wnext === state.wsize) { state.wnext = 0; }
        if (state.whave < state.wsize) { state.whave += dist; }
      }
    }
    return 0;
  };


  const inflate$1 = (strm, flush) => {

    let state;
    let input, output;          // input/output buffers
    let next;                   /* next input INDEX */
    let put;                    /* next output INDEX */
    let have, left;             /* available input and output */
    let hold;                   /* bit buffer */
    let bits;                   /* bits in bit buffer */
    let _in, _out;              /* save starting available input and output */
    let copy;                   /* number of stored or match bytes to copy */
    let from;                   /* where to copy match bytes from */
    let from_source;
    let here = 0;               /* current decoding table entry */
    let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
    //let last;                   /* parent table entry */
    let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
    let len;                    /* length to copy for repeats, bits to drop */
    let ret;                    /* return code */
    const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
    let opts;

    let n; // temporary variable for NEED_BITS

    const order = /* permutation of code lengths */
      new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


    if (!strm || !strm.state || !strm.output ||
        (!strm.input && strm.avail_in !== 0)) {
      return Z_STREAM_ERROR$1;
    }

    state = strm.state;
    if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


    //--- LOAD() ---
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    //---

    _in = have;
    _out = left;
    ret = Z_OK$1;

    inf_leave: // goto emulation
    for (;;) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          //=== NEEDBITS(16);
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
            state.check = 0/*crc32(0L, Z_NULL, 0)*/;
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//

            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;           /* expect zlib header */
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) ||   /* check if zlib header allowed */
            (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
            strm.msg = 'incorrect header check';
            state.mode = BAD;
            break;
          }
          if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
          len = (hold & 0x0f)/*BITS(4)*/ + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          else if (len > state.wbits) {
            strm.msg = 'invalid window size';
            state.mode = BAD;
            break;
          }

          // !!! pako patch. Force use \`options.windowBits\` if passed.
          // Required to always use max window size by default.
          state.dmax = 1 << state.wbits;
          //state.dmax = 1 << len;

          //Tracev((stderr, "inflate:   zlib header ok"));
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = hold & 0x200 ? DICTID : TYPE;
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          break;
        case FLAGS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.flags = hold;
          if ((state.flags & 0xff) !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          if (state.flags & 0xe000) {
            strm.msg = 'unknown header flags set';
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = ((hold >> 8) & 1);
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = TIME;
          /* falls through */
        case TIME:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC4(state.check, hold)
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            hbuf[2] = (hold >>> 16) & 0xff;
            hbuf[3] = (hold >>> 24) & 0xff;
            state.check = crc32_1(state.check, hbuf, 4, 0);
            //===
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = OS;
          /* falls through */
        case OS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.xflags = (hold & 0xff);
            state.head.os = (hold >> 8);
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = EXLEN;
          /* falls through */
        case EXLEN:
          if (state.flags & 0x0400) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          else if (state.head) {
            state.head.extra = null/*Z_NULL*/;
          }
          state.mode = EXTRA;
          /* falls through */
        case EXTRA:
          if (state.flags & 0x0400) {
            copy = state.length;
            if (copy > have) { copy = have; }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  // Use untyped array for more convenient processing later
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
                //zmemcpy(state.head.extra + len, next,
                //        len + copy > state.head.extra_max ?
                //        state.head.extra_max - len : copy);
              }
              if (state.flags & 0x0200) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) { break inf_leave; }
          }
          state.length = 0;
          state.mode = NAME;
          /* falls through */
        case NAME:
          if (state.flags & 0x0800) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              // TODO: 2 or 1 bytes?
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.name_max*/)) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
          /* falls through */
        case COMMENT:
          if (state.flags & 0x1000) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.comm_max*/)) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 0x0200) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
          /* falls through */
        case HCRC:
          if (state.flags & 0x0200) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (hold !== (state.check & 0xffff)) {
              strm.msg = 'header crc mismatch';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          if (state.head) {
            state.head.hcrc = ((state.flags >> 9) & 1);
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          strm.adler = state.check = zswap32(hold);
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = DICT;
          /* falls through */
        case DICT:
          if (state.havedict === 0) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = TYPE;
          /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case TYPEDO:
          if (state.last) {
            //--- BYTEBITS() ---//
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            state.mode = CHECK;
            break;
          }
          //=== NEEDBITS(3); */
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.last = (hold & 0x01)/*BITS(1)*/;
          //--- DROPBITS(1) ---//
          hold >>>= 1;
          bits -= 1;
          //---//

          switch ((hold & 0x03)/*BITS(2)*/) {
            case 0:                             /* stored block */
              //Tracev((stderr, "inflate:     stored block%s",
              //        state.last ? " (last)" : ""));
              state.mode = STORED;
              break;
            case 1:                             /* fixed block */
              fixedtables(state);
              //Tracev((stderr, "inflate:     fixed codes block%s",
              //        state.last ? " (last)" : ""));
              state.mode = LEN_;             /* decode codes */
              if (flush === Z_TREES) {
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
                break inf_leave;
              }
              break;
            case 2:                             /* dynamic block */
              //Tracev((stderr, "inflate:     dynamic codes block%s",
              //        state.last ? " (last)" : ""));
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = 'invalid block type';
              state.mode = BAD;
          }
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break;
        case STORED:
          //--- BYTEBITS() ---// /* go to byte boundary */
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
            strm.msg = 'invalid stored block lengths';
            state.mode = BAD;
            break;
          }
          state.length = hold & 0xffff;
          //Tracev((stderr, "inflate:       stored length %u",
          //        state.length));
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = COPY_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case COPY_:
          state.mode = COPY;
          /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) { copy = have; }
            if (copy > left) { copy = left; }
            if (copy === 0) { break inf_leave; }
            //--- zmemcpy(put, next, copy); ---
            output.set(input.subarray(next, next + copy), put);
            //---//
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          //Tracev((stderr, "inflate:       stored end"));
          state.mode = TYPE;
          break;
        case TABLE:
          //=== NEEDBITS(14); */
          while (bits < 14) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
  //#ifndef PKZIP_BUG_WORKAROUND
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = 'too many length or distance symbols';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracev((stderr, "inflate:       table sizes ok"));
          state.have = 0;
          state.mode = LENLENS;
          /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            //=== NEEDBITS(3);
            while (bits < 3) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          // We have separate tables & no pointers. 2 commented lines below not needed.
          //state.next = state.codes;
          //state.lencode = state.next;
          // Switch to use dynamic table
          state.lencode = state.lendyn;
          state.lenbits = 7;

          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid code lengths set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, "inflate:       code lengths ok"));
          state.have = 0;
          state.mode = CODELENS;
          /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if (here_val < 16) {
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              state.lens[state.have++] = here_val;
            }
            else {
              if (here_val === 16) {
                //=== NEEDBITS(here.bits + 2);
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                if (state.have === 0) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 0x03);//BITS(2);
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
              }
              else if (here_val === 17) {
                //=== NEEDBITS(here.bits + 3);
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 3 + (hold & 0x07);//BITS(3);
                //--- DROPBITS(3) ---//
                hold >>>= 3;
                bits -= 3;
                //---//
              }
              else {
                //=== NEEDBITS(here.bits + 7);
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 11 + (hold & 0x7f);//BITS(7);
                //--- DROPBITS(7) ---//
                hold >>>= 7;
                bits -= 7;
                //---//
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }

          /* handle error breaks in while */
          if (state.mode === BAD) { break; }

          /* check for end-of-block code (better have one) */
          if (state.lens[256] === 0) {
            strm.msg = 'invalid code -- missing end-of-block';
            state.mode = BAD;
            break;
          }

          /* build code tables -- note: do not change the lenbits or distbits
             values here (9 and 6) without reading the comments in inftrees.h
             concerning the ENOUGH constants, which depend on those values */
          state.lenbits = 9;

          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.lenbits = opts.bits;
          // state.lencode = state.next;

          if (ret) {
            strm.msg = 'invalid literal/lengths set';
            state.mode = BAD;
            break;
          }

          state.distbits = 6;
          //state.distcode.copy(state.codes);
          // Switch to use dynamic table
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.distbits = opts.bits;
          // state.distcode = state.next;

          if (ret) {
            strm.msg = 'invalid distances set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, 'inflate:       codes ok'));
          state.mode = LEN_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case LEN_:
          state.mode = LEN;
          /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            inffast(strm, _out);
            //--- LOAD() ---
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            //---

            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_op && (here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.lencode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'" :
            //        "inflate:         literal 0x%02x", here.val));
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            //Tracevv((stderr, "inflate:         end of block"));
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
          /* falls through */
        case LENEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
          //Tracevv((stderr, "inflate:         length %u", state.length));
          state.was = state.length;
          state.mode = DIST;
          /* falls through */
        case DIST:
          for (;;) {
            here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if ((here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.distcode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = (here_op) & 15;
          state.mode = DISTEXT;
          /* falls through */
        case DISTEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
  //#ifdef INFLATE_STRICT
          if (state.offset > state.dmax) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracevv((stderr, "inflate:         distance %u", state.offset));
          state.mode = MATCH;
          /* falls through */
        case MATCH:
          if (left === 0) { break inf_leave; }
          copy = _out - left;
          if (state.offset > copy) {         /* copy from window */
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //          Trace((stderr, "inflate.c too far"));
  //          copy -= state.whave;
  //          if (copy > state.length) { copy = state.length; }
  //          if (copy > left) { copy = left; }
  //          left -= copy;
  //          state.length -= copy;
  //          do {
  //            output[put++] = 0;
  //          } while (--copy);
  //          if (state.length === 0) { state.mode = LEN; }
  //          break;
  //#endif
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            }
            else {
              from = state.wnext - copy;
            }
            if (copy > state.length) { copy = state.length; }
            from_source = state.window;
          }
          else {                              /* copy from output */
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) { copy = left; }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) { state.mode = LEN; }
          break;
        case LIT:
          if (left === 0) { break inf_leave; }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              // Use '|' instead of '+' to make sure that result is signed
              hold |= input[next++] << bits;
              bits += 8;
            }
            //===//
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check =
                  /*UPDATE(state.check, put - _out, _out);*/
                  (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

            }
            _out = left;
            // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = 'incorrect data check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   check matches trailer"));
          }
          state.mode = LENGTH;
          /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (hold !== (state.total & 0xffffffff)) {
              strm.msg = 'incorrect length check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   length matches trailer"));
          }
          state.mode = DONE;
          /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
          /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }

    // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */

    //--- RESTORE() ---
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    //---

    if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                        (state.mode < CHECK || flush !== Z_FINISH$1))) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap && _out) {
      strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) +
                      (state.mode === TYPE ? 128 : 0) +
                      (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };


  const inflateEnd = (strm) => {

    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
      return Z_STREAM_ERROR$1;
    }

    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };


  const inflateGetHeader = (strm, head) => {

    /* check state */
    if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

    /* save header structure */
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };


  const inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;

    let state;
    let dictid;
    let ret;

    /* check state */
    if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }
    state = strm.state;

    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }

    /* check for correct dictionary identifier */
    if (state.mode === DICT) {
      dictid = 1; /* adler32(0, null, 0)*/
      /* dictid = adler32(dictid, dictionary, dictLength); */
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    /* copy dictionary to window using updatewindow(), which will amend the
     existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    // Tracev((stderr, "inflate:   dictionary set"));
    return Z_OK$1;
  };


  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$1;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = 'pako inflate (from Nodeca project)';

  /* Not implemented
  module.exports.inflateCopy = inflateCopy;
  module.exports.inflateGetDictionary = inflateGetDictionary;
  module.exports.inflateMark = inflateMark;
  module.exports.inflatePrime = inflatePrime;
  module.exports.inflateSync = inflateSync;
  module.exports.inflateSyncPoint = inflateSyncPoint;
  module.exports.inflateUndermine = inflateUndermine;
  */

  var inflate_1$1 = {
  	inflateReset: inflateReset_1,
  	inflateReset2: inflateReset2_1,
  	inflateResetKeep: inflateResetKeep_1,
  	inflateInit: inflateInit_1,
  	inflateInit2: inflateInit2_1,
  	inflate: inflate_2$1,
  	inflateEnd: inflateEnd_1,
  	inflateGetHeader: inflateGetHeader_1,
  	inflateSetDictionary: inflateSetDictionary_1,
  	inflateInfo: inflateInfo
  };

  const _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  var assign = function (obj /*from1, from2, from3, ...*/) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) { continue; }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };


  // Join array of chunks to single array.
  var flattenChunks = (chunks) => {
    // calculate data length
    let len = 0;

    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    const result = new Uint8Array(len);

    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  };

  var common = {
  	assign: assign,
  	flattenChunks: flattenChunks
  };

  // String encode/decode helpers


  // Quick check if we can use fast array to bin string conversion
  //
  // - apply(Array) can fail on Android 2.2
  // - apply(Uint8Array) can fail on iOS 5.1 Safari
  //
  let STR_APPLY_UIA_OK = true;

  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


  // Table with utf8 lengths (calculated by first byte of sequence)
  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
  // because max possible codepoint is 0x10ffff
  const _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
  }
  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


  // convert string to array (typed, when possible)
  var string2buf = (str) => {
    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }

    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    buf = new Uint8Array(buf_len);

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      if (c < 0x80) {
        /* one byte */
        buf[i++] = c;
      } else if (c < 0x800) {
        /* two bytes */
        buf[i++] = 0xC0 | (c >>> 6);
        buf[i++] = 0x80 | (c & 0x3f);
      } else if (c < 0x10000) {
        /* three bytes */
        buf[i++] = 0xE0 | (c >>> 12);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      } else {
        /* four bytes */
        buf[i++] = 0xf0 | (c >>> 18);
        buf[i++] = 0x80 | (c >>> 12 & 0x3f);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      }
    }

    return buf;
  };

  // Helper
  const buf2binstring = (buf, len) => {
    // On Chrome, the arguments in a function call that are allowed is \`65534\`.
    // If the length of the buffer is smaller than that, we can use this optimization,
    // otherwise we will take a slower path.
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }

    let result = '';
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };


  // convert array to string
  var buf2string = (buf, max) => {
    const len = max || buf.length;

    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }

    let i, out;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    const utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
      let c = buf[i++];
      // quick process ascii
      if (c < 0x80) { utf16buf[out++] = c; continue; }

      let c_len = _utf8len[c];
      // skip 5 & 6 byte codes
      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

      // apply mask on first byte
      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
      // join the rest
      while (c_len > 1 && i < len) {
        c = (c << 6) | (buf[i++] & 0x3f);
        c_len--;
      }

      // terminated by end of string?
      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

      if (c < 0x10000) {
        utf16buf[out++] = c;
      } else {
        c -= 0x10000;
        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
        utf16buf[out++] = 0xdc00 | (c & 0x3ff);
      }
    }

    return buf2binstring(utf16buf, out);
  };


  // Calculate max possible position in utf8 buffer,
  // that will not break sequence. If that's not possible
  // - (very small limits) return max size as is.
  //
  // buf[] - utf8 bytes array
  // max   - length limit (mandatory);
  var utf8border = (buf, max) => {

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means buffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
  };

  var strings = {
  	string2buf: string2buf,
  	buf2string: buf2string,
  	utf8border: utf8border
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var messages = {
    2:      'need dictionary',     /* Z_NEED_DICT       2  */
    1:      'stream end',          /* Z_STREAM_END      1  */
    0:      '',                    /* Z_OK              0  */
    '-1':   'file error',          /* Z_ERRNO         (-1) */
    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */
    this.avail_in = 0;
    /* total number of input bytes read so far */
    this.total_in = 0;
    /* next output byte should be put there */
    this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */
    this.avail_out = 0;
    /* total number of bytes output so far */
    this.total_out = 0;
    /* last error message, NULL if no error */
    this.msg = ''/*Z_NULL*/;
    /* not visible by applications */
    this.state = null;
    /* best guess about the data type: binary or text */
    this.data_type = 2/*Z_UNKNOWN*/;
    /* adler32 value of the uncompressed data */
    this.adler = 0;
  }

  var zstream = ZStream;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function GZheader() {
    /* true if compressed data believed to be text */
    this.text       = 0;
    /* modification time */
    this.time       = 0;
    /* extra flags (not used when writing a gzip file) */
    this.xflags     = 0;
    /* operating system */
    this.os         = 0;
    /* pointer to extra field or Z_NULL if none */
    this.extra      = null;
    /* extra field length (valid if extra != Z_NULL) */
    this.extra_len  = 0; // Actually, we don't need it in JS,
                         // but leave for few code modifications

    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //

    /* space at extra (only when reading header) */
    // this.extra_max  = 0;
    /* pointer to zero-terminated file name or Z_NULL */
    this.name       = '';
    /* space at name (only when reading header) */
    // this.name_max   = 0;
    /* pointer to zero-terminated comment or Z_NULL */
    this.comment    = '';
    /* space at comment (only when reading header) */
    // this.comm_max   = 0;
    /* true if there was or will be a header crc */
    this.hcrc       = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */
    this.done       = false;
  }

  var gzheader = GZheader;

  const toString = Object.prototype.toString;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_NO_FLUSH, Z_FINISH,
    Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
  } = constants$1;

  /* ===========================================================================*/


  /**
   * class Inflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[inflate]]
   * and [[inflateRaw]].
   **/

  /* internal
   * inflate.chunks -> Array
   *
   * Chunks of output data, if [[Inflate#onData]] not overridden.
   **/

  /**
   * Inflate.result -> Uint8Array|String
   *
   * Uncompressed result, generated by default [[Inflate#onData]]
   * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Inflate#push]] with \`Z_FINISH\` / \`true\` param).
   **/

  /**
   * Inflate.err -> Number
   *
   * Error code after inflate finished. 0 (Z_OK) on success.
   * Should be checked if broken data possible.
   **/

  /**
   * Inflate.msg -> String
   *
   * Error message, if [[Inflate.err]] != 0
   **/


  /**
   * new Inflate(options)
   * - options (Object): zlib inflate options.
   *
   * Creates new inflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - \`windowBits\`
   * - \`dictionary\`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - \`chunkSize\` - size of generated data chunks (16K by default)
   * - \`raw\` (Boolean) - do raw inflate
   * - \`to\` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from \`chunkSize\`, depending on content.
   *
   * By default, when no options set, autodetect deflate/gzip data format via
   * wrapper header.
   *
   * ##### Example:
   *
   * \`\`\`javascript
   * const pako = require('pako')
   * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const inflate = new pako.Inflate({ level: 3});
   *
   * inflate.push(chunk1, false);
   * inflate.push(chunk2, true);  // true -> last chunk
   *
   * if (inflate.err) { throw new Error(inflate.err); }
   *
   * console.log(inflate.result);
   * \`\`\`
   **/
  function Inflate(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ''
    }, options || {});

    const opt = this.options;

    // Force window size for \`raw\` data, if not set directly,
    // because we have no header for autodetect.
    if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) { opt.windowBits = -15; }
    }

    // If \`windowBits\` not defined (and mode not raw) - set autodetect flag for gzip/deflate
    if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
        !(options && options.windowBits)) {
      opt.windowBits += 32;
    }

    // Gzip header has no info about windows size, we can do autodetect only
    // for deflate. So, if window size not set, force it to max when gzip possible
    if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
      // bit 3 (16) -> gzipped data
      // bit 4 (32) -> autodetect gzip/deflate
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }

    this.err    = 0;      // error code, if happens (0 = Z_OK)
    this.msg    = '';     // error message
    this.ended  = false;  // used to avoid multiple onEnd() calls
    this.chunks = [];     // chunks of compressed data

    this.strm   = new zstream();
    this.strm.avail_out = 0;

    let status  = inflate_1$1.inflateInit2(
      this.strm,
      opt.windowBits
    );

    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }

    this.header = new gzheader();

    inflate_1$1.inflateGetHeader(this.strm, this.header);

    // Setup dictionary
    if (opt.dictionary) {
      // Convert data if needed
      if (typeof opt.dictionary === 'string') {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) { //In raw mode we need to set the dictionary early
        status = inflate_1$1.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }

  /**
   * Inflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer): input data
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
   *   flush modes. See constants. Skipped or \`false\` means Z_NO_FLUSH,
   *   \`true\` means Z_FINISH.
   *
   * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
   * new output chunks. Returns \`true\` on success. If end of stream detected,
   * [[Inflate#onEnd]] will be called.
   *
   * \`flush_mode\` is not needed for normal operation, because end of stream
   * detected automatically. You may try to use it for advanced things, but
   * this functionality was not tested.
   *
   * On fail call [[Inflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * \`\`\`javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * \`\`\`
   **/
  Inflate.prototype.push = function (data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;

    if (this.ended) return false;

    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

    // Convert data if needed
    if (toString.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = inflate_1$1.inflate(strm, _flush_mode);

      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$1.inflateSetDictionary(strm, dictionary);

        if (status === Z_OK) {
          status = inflate_1$1.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          // Replace code with more verbose
          status = Z_NEED_DICT;
        }
      }

      // Skip snyc markers if more data follows and not raw mode
      while (strm.avail_in > 0 &&
             status === Z_STREAM_END &&
             strm.state.wrap > 0 &&
             data[strm.next_in] !== 0)
      {
        inflate_1$1.inflateReset(strm);
        status = inflate_1$1.inflate(strm, _flush_mode);
      }

      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }

      // Remember real \`avail_out\` value, because we may patch out buffer content
      // to align utf8 strings boundaries.
      last_avail_out = strm.avail_out;

      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {

          if (this.options.to === 'string') {

            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);

            // move tail & realign counters
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

            this.onData(utf8str);

          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }

      // Must repeat iteration if out buffer is full
      if (status === Z_OK && last_avail_out === 0) continue;

      // Finalize if end of stream reached.
      if (status === Z_STREAM_END) {
        status = inflate_1$1.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };


  /**
   * Inflate#onData(chunk) -> Void
   * - chunk (Uint8Array|String): output data. When string output requested,
   *   each chunk will be string.
   *
   * By default, stores data blocks in \`chunks[]\` property and glue
   * those in \`onEnd\`. Override this handler, if you need another behaviour.
   **/
  Inflate.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };


  /**
   * Inflate#onEnd(status) -> Void
   * - status (Number): inflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called either after you tell inflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill \`results\` / \`err\` properties.
   **/
  Inflate.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };


  /**
   * inflate(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Decompress \`data\` with inflate/ungzip and \`options\`. Autodetect
   * format via wrapper header by default. That's why we don't provide
   * separate \`ungzip\` method.
   *
   * Supported options are:
   *
   * - windowBits
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information.
   *
   * Sugar (options):
   *
   * - \`raw\` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   * - \`to\` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from \`chunkSize\`, depending on content.
   *
   *
   * ##### Example:
   *
   * \`\`\`javascript
   * const pako = require('pako');
   * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
   * let output;
   *
   * try {
   *   output = pako.inflate(input);
   * } catch (err) {
   *   console.log(err);
   * }
   * \`\`\`
   **/
  function inflate(input, options) {
    const inflator = new Inflate(options);

    inflator.push(input);

    // That will never happens, if you don't cheat with options :)
    if (inflator.err) throw inflator.msg || messages[inflator.err];

    return inflator.result;
  }


  /**
   * inflateRaw(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * The same as [[inflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate(input, options);
  }


  /**
   * ungzip(data[, options]) -> Uint8Array|String
   * - data (Uint8Array): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Just shortcut to [[inflate]], because it autodetects format
   * by header.content. Done for convenience.
   **/


  var Inflate_1 = Inflate;
  var inflate_2 = inflate;
  var inflateRaw_1 = inflateRaw;
  var ungzip = inflate;
  var constants = constants$1;

  var inflate_1 = {
  	Inflate: Inflate_1,
  	inflate: inflate_2,
  	inflateRaw: inflateRaw_1,
  	ungzip: ungzip,
  	constants: constants
  };

  exports.Inflate = Inflate_1;
  exports.constants = constants;
  exports['default'] = inflate_1;
  exports.inflate = inflate_2;
  exports.inflateRaw = inflateRaw_1;
  exports.ungzip = ungzip;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

`;

/* WEB WORKER */
const DatWorker = `
  onmessage = function ( e ) {
    
    const message = e.data

    switch ( message.type ) {

    case 'decode': {

        const chunkInfo = self.parseChunkWorker( message.data )

        if ( chunkInfo ) { 

          self.postMessage( 
            { type: 'decode', data: chunkInfo, }, 
            [ chunkInfo.buffer ]
          )

        } else {

          self.postMessage( { type: 'decode', data: {}, } )

        }

        break
    
      }
    
    }

  }

`;
const TEXTURES_FILE_NAME = 'textureIndex.json';
class DatLoader extends Loader {
    constructor(store) {
        super();
        this.store = store;
        // loaded texture url
        this.loadedTextures = new Map();
        // loaded material
        this.loadedMaterialsMap = new Map();
        this.defaultMaterial = new MeshStandardMaterial({
            name: 'defaultDatMaterial',
            color: 0x000000,
        });
        this.loadedMaterials = [this.defaultMaterial];
        // draco path
        this.dracoDecoderPath = null;
        // worker pool
        this.workerPool = new WorkerPool(4);
        this.workerSourceURL = '';
        // worker creator
        const workerCreator = this._initWorkerCreator();
        this.workerPool.setWorkerCreator(workerCreator);
    }
    /**
     *
     * @param buffer
     * @param url
     */
    async parseAsync(buffer, url) {
        const [result] = await Promise.allSettled([
            this._decodeBuffer(buffer, url),
            this._createMaterial(url)
        ]);
        if (result.status === 'fulfilled' && result.value) {
            const path = parseFilePath(url);
            const mesh = this._createMesh(result.value, path);
            const group = new Group$2();
            group.add(mesh);
            return group;
        }
    }
    async _decodeBuffer(buffer, url) {
        const chunkInfoCache = await this.store.getItem(`${url}_object`);
        if (chunkInfoCache) {
            return chunkInfoCache;
        }
        const [{ data: workerData, }] = await Promise.all([
            this.workerPool.postMessage({
                type: 'decode',
                data: buffer,
            }, [buffer])
        ]);
        if (workerData) {
            const { type, data, } = workerData !== null && workerData !== void 0 ? workerData : {};
            if (type === 'decode' && data) {
                const { buffer: { byteLength, }, } = data;
                /**
                 * TEMP: 大于 500mb 的文件，不做缓存
                 */
                if (isNumber(byteLength) && byteLength / 1024 / 1024 <= 500) {
                    idleTask(() => {
                        this.store.setItem(`${url}_object`, data);
                    });
                }
                return data;
            }
        }
    }
    _initWorkerCreator() {
        if (!this.workerSourceURL) {
            const noCompressWorkerString = noCompressWorker.toString(), gzipCompressWorkerString = gzipCompressWorker.toString(), parseChunkWorkerString = parseChunkWorker.toString();
            const jsContent = [
                '/* pako */',
                `${pakoString}`,
                '/* noCompress */',
                noCompressWorkerString.substring(noCompressWorkerString.indexOf('{') + 1, noCompressWorkerString.lastIndexOf('}')),
                '/* gzipCompress */',
                gzipCompressWorkerString.substring(gzipCompressWorkerString.indexOf('{') + 1, gzipCompressWorkerString.lastIndexOf('}')),
                '/* parseChunk */',
                parseChunkWorkerString.substring(parseChunkWorkerString.indexOf('{') + 1, parseChunkWorkerString.lastIndexOf('}'))
            ].join('\n');
            const body = [
                '/* dat decoder */',
                jsContent,
                '',
                '/* worker */',
                DatWorker
            ].join('\n');
            this.workerSourceURL = URL.createObjectURL(new Blob([body]));
        }
        return () => {
            return new Worker(this.workerSourceURL);
        };
    }
    _createMesh(chunk, path) {
        const { buffer, position, normal, texcoord, indice, sub_mesh, } = chunk;
        const indexArray = new Uint32Array(buffer, indice.byteOffset, indice.length);
        const positionArray = new Float32Array(buffer, position.byteOffset, position.length);
        const normalArray = new Int8Array(buffer, normal.byteOffset, normal.length);
        const uvArray = new Float32Array(buffer, texcoord.byteOffset, texcoord.length);
        /**
         * TEMP: 兼容 GLTFExport.js
         */
        // const normalArray_float = new Float32Array( normalArray ).map( normal => normal / 255 )
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indexArray, 1));
        geometry.setAttribute('position', new BufferAttribute(positionArray, 3));
        geometry.setAttribute('normal', new BufferAttribute(normalArray, 3, true));
        geometry.setAttribute('uv', new BufferAttribute(uvArray, 2));
        for (let i = 0; i < sub_mesh.length; i++) {
            const { uuid, start, count, } = sub_mesh[i];
            const materialValue = this.loadedMaterialsMap.get(uuid);
            if (materialValue) {
                const { materialIndex, } = materialValue;
                geometry.addGroup(start, count, materialIndex);
            }
            else {
                /**
                 * default group
                 */
                geometry.addGroup(start, count, 0);
                warn(`sbmx material: not found uuid: ${uuid} in file: ${path + TEXTURES_FILE_NAME}`);
            }
        }
        const mesh = new Mesh(geometry, this.loadedMaterials);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        return mesh;
    }
    /**
     * 创建 material
     * @param path
     * @returns
     */
    async _createMaterial(url) {
        const path = parseFilePath(url);
        const texturePath = path + TEXTURES_FILE_NAME;
        // 如果已经加载过，则直接返回
        const texturePromise = this.loadedTextures.get(texturePath);
        if (texturePromise) {
            return texturePromise;
        }
        // 检查缓存
        const textureIndexCache = await this.store.getItem(`${url}_texture`);
        let obj;
        if (textureIndexCache) {
            obj = textureIndexCache;
            this.loadedTextures.set(texturePath, Promise.resolve(obj));
        }
        else {
            /**
             * 发出请求前再检查一次，防止多同时发出请求
             */
            const texturePromise = this.loadedTextures.get(texturePath);
            if (texturePromise) {
                return texturePromise;
            }
            const fetchTexturePromise = fetchFile(texturePath).then(res => res.json());
            this.loadedTextures.set(texturePath, fetchTexturePromise);
            obj = await fetchTexturePromise;
            idleTask(() => {
                this.store.setItem(`${url}_texture`, obj);
            });
        }
        Object.entries(obj).forEach(([uuid, value]) => {
            // 如果已经创建过材质，则直接返回
            if (this.loadedMaterialsMap.has(uuid))
                return;
            const { name, base_map, nor_map, alphamode, color = { r: 1, g: 1, b: 1, a: 1, }, metallic = 0.5, roughness = 0.5, } = value;
            const { r, g, b, a, } = color;
            const transparent = alphamode !== 0;
            const material = new MeshStandardMaterial({
                name,
                color: new Color(r, g, b),
                side: FrontSide,
                metalness: metallic,
                roughness: roughness,
                opacity: a,
                transparent,
                depthWrite: !transparent,
            });
            if (base_map) {
                const path1 = path + base_map;
                new TextureLoader()
                    .load(path1, (texture) => {
                    texture.flipY = true;
                    texture.encoding = sRGBEncoding;
                    texture.wrapS = RepeatWrapping;
                    texture.wrapT = RepeatWrapping;
                    texture.minFilter = LinearMipMapLinearFilter;
                    texture.magFilter = LinearFilter;
                    texture.needsUpdate = true;
                    material.map = texture;
                    material.needsUpdate = true;
                    innerRenderState.needsUpdate = true;
                });
            }
            if (nor_map) {
                const path1 = path + nor_map;
                new TextureLoader()
                    .load(path1, (texture) => {
                    texture.flipY = true;
                    texture.encoding = sRGBEncoding;
                    texture.wrapS = RepeatWrapping;
                    texture.wrapT = RepeatWrapping;
                    texture.needsUpdate = true;
                    material.normalMap = texture;
                    material.needsUpdate = true;
                    innerRenderState.needsUpdate = true;
                });
            }
            const materialIndex = this.loadedMaterials.push(material) - 1;
            this.loadedMaterialsMap.set(uuid, { material, materialIndex, });
        });
    }
    dispose() {
        this.workerPool.dispose();
        URL.revokeObjectURL(this.workerSourceURL);
    }
}

/** temp textures cache */
const _textureCaches = new Map();
/**
 * 贴图是否 png 格式
 * @param textureUrl
 * @returns
 */
const isPNG = (textureUrl) => {
    var _a;
    return (_a = textureUrl === null || textureUrl === void 0 ? void 0 : textureUrl.toLowerCase().endsWith('.png')) !== null && _a !== void 0 ? _a : false;
};
/**
 * 生成 sbm 纹理
 * @param url
 */
const generateSbmTexture = (textureUrl) => {
    if (_textureCaches.has(textureUrl)) {
        return _textureCaches.get(textureUrl);
    }
    const texture = new Texture();
    _textureCaches.set(textureUrl, texture);
    new ImageLoader().load(textureUrl, (image) => {
        texture.image = image;
        texture.needsUpdate = true;
        innerRenderState.needsUpdate = true;
    });
    texture.encoding = sRGBEncoding;
    texture.wrapS = RepeatWrapping;
    texture.wrapT = RepeatWrapping;
    texture.flipY = false;
    texture.anisotropy = 16;
    texture.mipmaps = [];
    texture.generateMipmaps = true;
    return texture;
};
/**
 * 生成 sbm 材质
 * @param materialId
 * @param arr
 * @param texture
 */
const generateSbmMaterial = (materialId, arr, texture, transprent) => {
    const [d0, d1, d2, d3, side] = arr;
    const trans = transprent || d3 < 1;
    const material = new MeshStandardMaterial({
        name: materialId,
        color: new Color(d0, d1, d2),
        opacity: d3,
        transparent: trans,
        depthWrite: !trans,
        alphaTest: 0.01,
        map: texture,
        side: side,
    });
    return material;
};

// https://developer.mozilla.org/en-US/docs/Web/API/DataView
class SDataView extends DataView {
    constructor(buffer, appKeys) {
        super(buffer);
        this.isLE = true;
        this.appKeys = appKeys;
    }
    byteRevers(byte, offset) {
        const keyIndex = offset % this.appKeys.length;
        const appKey = this.appKeys[keyIndex];
        return byte ^ appKey;
    }
    getSoonUint8(byteOffset) {
        return this.byteRevers(this.getUint8(byteOffset), byteOffset);
    }
    getSoonUint16(byteOffset) {
        const view = new DataView(new Uint8Array(2).buffer);
        for (let i = 0; i < 2; i++) {
            view.setUint8(i, this.getSoonUint8(byteOffset + i));
        }
        return view.getUint16(0, this.isLE);
    }
    getSoonUint32(byteOffset) {
        const view = new DataView(new Uint8Array(4).buffer);
        for (let i = 0; i < 4; i++) {
            view.setUint8(i, this.getSoonUint8(byteOffset + i));
        }
        return view.getUint32(0, this.isLE);
    }
    getSoonFloat32(byteOffset) {
        const view = new DataView(new Uint8Array(4).buffer);
        for (let i = 0; i < 4; i++) {
            view.setUint8(i, this.getSoonUint8(byteOffset + i));
        }
        return view.getFloat32(0, this.isLE);
    }
}

const textDecoder = new TextDecoder();
class SbkLoader {
    constructor() {
        this.materials = new Map;
        this.sbmInfo = null;
    }
    /**
     * 解析模型
     * @param buffer 模型二进制原数据
     * @param sbmInfo 模型信息
     * @param onProgress 模型加载进度回填函数
     */
    async parseBuffer(buffer, sbmInfo, onProgress) {
        this.sbmInfo = sbmInfo;
        const dataView = new DataView(buffer);
        // 数据读取索引标记
        let offset = 0;
        // 文件格式字节长度
        const formatNameLength = 8;
        // 文件格式字字节集合
        const formatNameStrArr = [];
        for (let i = 0; i < formatNameLength; i++) {
            formatNameStrArr.push(dataView.getUint8(offset));
            offset += 1;
        }
        // 文件格式
        const formatName = String.fromCharCode(...formatNameStrArr);
        if (formatName !== 'SBK-----')
            return Promise.reject(`In soonspacejs: sbm 资源模型（${this.sbmInfo.url}）格式或数据错误!`);
        const KRlLength = 32;
        const KRPLength = 32;
        const KRMLength = 64;
        const KRl = [];
        const KRP = [];
        const KRM = [];
        // KRL
        for (let i = 0; i < KRlLength; i++) {
            KRl.push(dataView.getUint8(offset));
            offset += 1;
        }
        // 
        const keyVersion = dataView.getUint8(offset);
        offset += 1;
        // 版本号
        const version = dataView.getUint8(offset);
        offset += 1;
        // KRP
        for (let i = 0; i < KRPLength; i++) {
            KRP.push(dataView.getUint8(offset));
            offset += 1;
        }
        // KRM
        for (let i = 0; i < KRMLength; i++) {
            KRM.push(dataView.getUint8(offset));
            offset += 1;
        }
        // KRA = KRP + KRM + KRL
        const KRA = [...KRP, ...KRM, ...KRl];
        const appKeys = [];
        for (let i = 0; i < KRA.length; i++) {
            if ((i <= 7) || (i > 23 && i <= 31) || (i > 39 && i <= 55) ||
                (i > 63 && i <= 87) || (i > 95 && i <= 103)) {
                appKeys.push(KRA[i]);
            }
        }
        // 判断密钥
        if (appKeys.length !== 64)
            return Promise.reject(`In soonspacejs: sbm 资源模型（${this.sbmInfo.url} 数据错误!`);
        if (keyVersion === 1) {
            const buffer = dataView.buffer.slice(offset, dataView.buffer.byteLength);
            const newDataView = new SDataView(buffer, appKeys);
            if (version === 1)
                return this._parseV2(newDataView, onProgress);
            else if (version === 2)
                return this._parseV2(newDataView, onProgress);
            else if (version === 3)
                return this._parseV3(newDataView, onProgress);
            else
                return Promise.reject(`In soonspacejs: sbm 资源模型（${this.sbmInfo.url}）版本错误!`);
        }
        else {
            return Promise.reject(`In soonspacejs: sbm 资源模型（${this.sbmInfo.url}）key 错误!`);
        }
    }
    /**
     * @param dataView
     * @param offset
     * @param onProgress
     */
    _parseV2(dataView, onProgress) {
        let offset = 0;
        // 开始计时
        const startTIme = performance.now();
        const WaterMarkLength = 2;
        const AppIDLength = 32;
        const UserKeyLength = 32;
        // const WaterMark = []
        // const AppID = []
        // const UserKey = []
        // for (let i = 0; i < WaterMarkLength; i++) {
        //   WaterMark.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        // for (let i = 0; i < AppIDLength; i++) {
        //   AppID.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        // for (let i = 0; i < UserKeyLength; i++) {
        //   UserKey.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        offset += WaterMarkLength + AppIDLength + UserKeyLength;
        // 模型解析进度数据
        const progress = {
            total: 0,
            loaded: 0,
            timeStamp: 0,
        };
        if (!this.sbmInfo)
            return Promise.reject('In soonspacejs: sbm 模型资源解析时 \'sbmInfo\' 缺失!');
        const model = new Model(Object.assign(Object.assign({}, this.sbmInfo), { format: 'sbm' }));
        const group = new Group({ id: randomString(), });
        model.add(group);
        // 材质数量
        const materialCount = dataView.getSoonUint16(offset);
        offset += 2;
        // Mesh 数量
        const meshCount = dataView.getSoonUint16(offset);
        offset += 2;
        progress.total = meshCount;
        // 本地缓存 material
        const materialsCache = {};
        // 准备材质
        for (let i = 0; i < materialCount; ++i) {
            // 材质ID
            const materialId = dataView.getSoonUint16(offset).toString();
            offset += 2;
            materialsCache[materialId] = {
                materialInfo: [],
            };
            // a
            // const a0 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a1 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a2 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a3 = dataView.getSoonFloat32(offset)
            offset += 4;
            //d
            const d0 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d1 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d2 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d3 = dataView.getSoonFloat32(offset);
            offset += 4;
            // s
            // const s0 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s1 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s2 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s3 = dataView.getSoonFloat32(offset)
            offset += 4;
            // side
            let side = dataView.getSoonUint8(offset);
            offset += 1;
            // sync threejs side
            if (side === 0)
                side = FrontSide;
            else if (side === 1)
                side = BackSide;
            else if (side === 2)
                side = DoubleSide;
            // 纹理名称长度
            const textureNameLength = dataView.getSoonUint16(offset);
            offset += 2;
            let texture = null;
            if (textureNameLength > 0) {
                // 纹理名称
                let textureName = '';
                // 上次保存的字符串
                let prveStr = '';
                for (let i = 0; i < textureNameLength; i++) {
                    const byte = dataView.getSoonUint8(offset);
                    // 字节大于 127s
                    if (byte > 127) {
                        prveStr = prveStr + '%' + byte.toString(16).toUpperCase();
                    }
                    // 上次字节大于 127
                    else if (prveStr.length > 0) {
                        textureName += decodeURIComponent(prveStr) + String.fromCharCode(byte);
                        prveStr = '';
                    }
                    // 字节小于 127 并且上次字节也小于 127
                    else {
                        textureName += String.fromCharCode(byte);
                    }
                    offset += 1;
                }
                textureName = textureName.replace('\\', '/');
                const { url, isPlatform, } = this.sbmInfo;
                const textureUrl = this.getTextureUrl(url, textureName, isPlatform);
                // 图片地址
                materialsCache[materialId]['textureUrl'] = textureUrl;
                texture = generateSbmTexture(textureUrl);
            }
            if (!this.materials.has(materialId)) {
                const materialInfo = [d0, d1, d2, d3, side];
                const material = generateSbmMaterial(materialId, materialInfo, texture, isPNG(materialsCache[materialId]['textureUrl']));
                this.materials.set(materialId, material);
                materialsCache[materialId]['materialInfo'] = materialInfo;
            }
        }
        // Mesh 缓存
        const meshsCache = {};
        // 准备结构
        for (let i = 0; i < meshCount; ++i) {
            // 网格ID
            const meshId = dataView.getSoonUint16(offset);
            offset += 2;
            // 对应材质ID
            const materialId = dataView.getSoonUint16(offset).toString();
            offset += 2;
            meshsCache[meshId] = {
                materialId,
                position: new ArrayBuffer(0),
                uv: new ArrayBuffer(0),
            };
            const vertices = [];
            const texcoords = [];
            const faces = [];
            const faceVertexUvs = [];
            // verticesCount
            const verticesCount = dataView.getSoonUint16(offset);
            offset += 2;
            if (verticesCount > 0) {
                for (let i = 0; i < verticesCount; i++) {
                    const vector3 = new Vector3();
                    // x
                    vector3.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    vector3.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // z
                    vector3.setZ(dataView.getSoonFloat32(offset));
                    offset += 4;
                    vertices.push(vector3);
                }
            }
            // normalsCount
            const normalsCount = dataView.getSoonUint16(offset);
            offset += 2;
            if (normalsCount > 0) {
                for (let i = 0; i < normalsCount; i++) {
                    const normal = new Vector3();
                    // x
                    normal.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    normal.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // z
                    normal.setZ(dataView.getSoonFloat32(offset));
                    offset += 4;
                }
            }
            // texcoordCount
            const texcoordCount = dataView.getSoonUint16(offset);
            offset += 2;
            if (texcoordCount > 0) {
                for (let i = 0; i < texcoordCount; i++) {
                    const texcoord = new Vector2();
                    // x
                    texcoord.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    texcoord.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    texcoords.push(texcoord);
                }
            }
            // idxCount
            const idxCount = dataView.getSoonUint16(offset);
            offset += 2;
            if (idxCount > 0) {
                for (let i = 0; i < idxCount; i++) {
                    // a
                    const a = dataView.getSoonUint16(offset);
                    offset += 2;
                    // b
                    const b = dataView.getSoonUint16(offset);
                    offset += 2;
                    // c
                    const c = dataView.getSoonUint16(offset);
                    offset += 2;
                    const face = [a, b, c];
                    faces.push(face);
                    if (texcoords.length > 0) {
                        faceVertexUvs.push([
                            texcoords[face[0]],
                            texcoords[face[1]],
                            texcoords[face[2]]
                        ]);
                    }
                }
            }
            const positions = [], uvs = [];
            for (let i = 0; i < faces.length; i++) {
                const face = faces[i];
                // 顶点
                const vertex = vertices[face[0]], vertex2 = vertices[face[1]], vertex3 = vertices[face[2]];
                // 缓存顶点
                positions.push(...vertex.toArray(), ...vertex2.toArray(), ...vertex3.toArray());
                let uv = new Vector2(), uv2 = new Vector2(), uv3 = new Vector2();
                const vertexUvs = faceVertexUvs[i];
                if (vertexUvs !== undefined) {
                    uv = vertexUvs[0];
                    uv2 = vertexUvs[1];
                    uv3 = vertexUvs[2];
                }
                // 缓存 uv
                uvs.push(...uv.toArray(), ...uv2.toArray(), ...uv3.toArray());
            }
            const positionsBuffer = new Float32Array(positions), uvsBuffer = new Float32Array(uvs);
            meshsCache[meshId]['position'] = positionsBuffer.buffer;
            meshsCache[meshId]['uv'] = uvsBuffer.buffer;
            // 准备几何体
            const bufferGeometry = new BufferGeometry();
            // position
            if (positionsBuffer.length > 0) {
                bufferGeometry.setAttribute('position', new BufferAttribute(positionsBuffer, 3));
            }
            // uv
            if (uvsBuffer.length > 0) {
                bufferGeometry.setAttribute('uv', new BufferAttribute(uvsBuffer, 2));
            }
            bufferGeometry.computeVertexNormals(); // 이거 하면 라이팅 적용이 안 됨..
            const material = this.materials.get(materialId);
            if (material) {
                const sbmChild = new BaseMesh(bufferGeometry, material, { id: `${meshId}_${randomString()}`, name: meshId.toString(), });
                group.add(sbmChild);
            }
            progress.loaded++;
            progress.timeStamp = performance.now() - startTIme;
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(progress);
        }
        const caches = { materialsCache, meshsCache, };
        return Promise.resolve({ model, caches, });
    }
    /**
     * @param dataView
     * @param offset
     * @param onProgress
     */
    _parseV3(dataView, onProgress) {
        let offset = 0;
        const WaterMarkLength = 2;
        const AppIDLength = 32;
        const UserKeyLength = 32;
        // const WaterMark = []
        // const AppID = []
        // const UserKey = []
        // for (let i = 0; i < WaterMarkLength; i++) {
        //   WaterMark.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        // for (let i = 0; i < AppIDLength; i++) {
        //   AppID.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        // for (let i = 0; i < UserKeyLength; i++) {
        //   UserKey.push(dataView.getSoonUint8(offset))
        //   offset += 1
        // }
        offset += WaterMarkLength + AppIDLength + UserKeyLength;
        // 开始计时
        const startTIme = performance.now();
        // 模型解析进度数据
        const progress = {
            total: 0,
            loaded: 0,
            timeStamp: 0,
        };
        if (!this.sbmInfo)
            return Promise.reject('In soonspacejs: sbm 模型资源解析时 \'sbmInfo\' 缺失!');
        const model = new Model(Object.assign(Object.assign({}, this.sbmInfo), { format: 'sbm' }));
        const group = new Group({ id: randomString(), });
        model.add(group);
        // 材质数量
        const materialCount = dataView.getSoonUint16(offset);
        offset += 2;
        // Mesh 数量
        const meshCount = dataView.getSoonUint16(offset);
        offset += 2;
        progress.total = meshCount;
        const materialsCache = {};
        // 准备材质
        for (let i = 0; i < materialCount; ++i) {
            // 材质ID
            const materialId = dataView.getSoonUint16(offset).toString();
            offset += 2;
            materialsCache[materialId] = {
                materialInfo: [],
            };
            // a
            // const a0 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a1 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a2 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const a3 = dataView.getSoonFloat32(offset)
            offset += 4;
            //d
            const d0 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d1 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d2 = dataView.getSoonFloat32(offset);
            offset += 4;
            const d3 = dataView.getSoonFloat32(offset);
            offset += 4;
            // s
            // const s0 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s1 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s2 = dataView.getSoonFloat32(offset)
            offset += 4;
            // const s3 = dataView.getSoonFloat32(offset)
            offset += 4;
            // side
            let side = dataView.getSoonUint8(offset);
            offset += 1;
            // sync threejs side
            if (side === 0)
                side = FrontSide;
            else if (side === 1)
                side = BackSide;
            else if (side === 2)
                side = DoubleSide;
            // 纹理名称长度
            const textureNameLength = dataView.getSoonUint16(offset);
            offset += 2;
            let texture = null;
            if (textureNameLength > 0) {
                // 纹理名称
                let textureName = '';
                // 上次保存的字符串
                let prveStr = '';
                for (let i = 0; i < textureNameLength; i++) {
                    const byte = dataView.getSoonUint8(offset);
                    // 字节大于 127s
                    if (byte > 127) {
                        prveStr = prveStr + '%' + byte.toString(16).toUpperCase();
                    }
                    // 上次字节大于 127
                    else if (prveStr.length > 0) {
                        textureName += decodeURIComponent(prveStr) + String.fromCharCode(byte);
                        prveStr = '';
                    }
                    // 字节小于 127 并且上次字节也小于 127
                    else {
                        textureName += String.fromCharCode(byte);
                    }
                    offset += 1;
                }
                textureName = textureName.replace('\\', '/');
                const { url, isPlatform, } = this.sbmInfo;
                const textureUrl = this.getTextureUrl(url, textureName, isPlatform);
                materialsCache[materialId]['textureUrl'] = textureUrl;
                texture = generateSbmTexture(textureUrl);
            }
            if (!this.materials.has(materialId)) {
                const materialInfo = [d0, d1, d2, d3, side];
                const material = generateSbmMaterial(materialId, materialInfo, texture, isPNG(materialsCache[materialId]['textureUrl']));
                this.materials.set(materialId, material);
                materialsCache[materialId]['materialInfo'] = materialInfo;
            }
        }
        // Mesh 缓存
        const meshsCache = {};
        // 准备结构
        for (let i = 0; i < meshCount; ++i) {
            // 网格ID
            const meshId = dataView.getSoonUint16(offset).toString();
            offset += 2;
            // meshNameLength
            const meshNameLength = dataView.getSoonUint16(offset);
            offset += 2;
            // 网格名称
            let meshName = '';
            if (meshNameLength > 0) {
                const meshNameUint8 = [];
                for (let i = 0; i < meshNameLength; i++) {
                    const byte = dataView.getSoonUint8(offset);
                    meshNameUint8.push(byte);
                    offset += 1;
                }
                const meshNameBuffer = new Uint8Array(meshNameUint8);
                meshName = textDecoder.decode(meshNameBuffer);
            }
            // 对应材质ID
            const materialId = dataView.getSoonUint16(offset).toString();
            offset += 2;
            meshsCache[meshId] = {
                meshName,
                materialId,
                position: new ArrayBuffer(0),
                uv: new ArrayBuffer(0),
            };
            const vertices = [];
            const texcoords = [];
            const faces = [];
            const faceVertexUvs = [];
            // verticesCount
            const verticesCount = dataView.getSoonUint32(offset);
            offset += 4;
            if (verticesCount > 0) {
                for (let i = 0; i < verticesCount; i++) {
                    const vector3 = new Vector3();
                    // x
                    vector3.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    vector3.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // z
                    vector3.setZ(dataView.getSoonFloat32(offset));
                    offset += 4;
                    vertices.push(vector3);
                }
            }
            // normalsCount
            const normalsCount = dataView.getSoonUint32(offset);
            offset += 4;
            if (normalsCount > 0) {
                for (let i = 0; i < normalsCount; i++) {
                    const normal = new Vector3();
                    // x
                    normal.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    normal.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // z
                    normal.setZ(dataView.getSoonFloat32(offset));
                    offset += 4;
                }
            }
            // texcoordCount
            const texcoordCount = dataView.getSoonUint32(offset);
            offset += 4;
            if (texcoordCount > 0) {
                for (let i = 0; i < texcoordCount; i++) {
                    const texcoord = new Vector2();
                    // x
                    texcoord.setX(dataView.getSoonFloat32(offset));
                    offset += 4;
                    // y
                    texcoord.setY(dataView.getSoonFloat32(offset));
                    offset += 4;
                    texcoords.push(texcoord);
                }
            }
            // idxCount
            const idxCount = dataView.getSoonUint32(offset);
            offset += 4;
            if (idxCount > 0) {
                for (let i = 0; i < idxCount; i++) {
                    // a
                    const a = dataView.getSoonUint32(offset);
                    offset += 4;
                    // b
                    const b = dataView.getSoonUint32(offset);
                    offset += 4;
                    // c
                    const c = dataView.getSoonUint32(offset);
                    offset += 4;
                    const face = [a, b, c];
                    faces.push(face);
                    if (texcoords.length > 0) {
                        faceVertexUvs.push([
                            texcoords[face[0]],
                            texcoords[face[1]],
                            texcoords[face[2]]
                        ]);
                    }
                }
            }
            const positions = [], uvs = [];
            for (let i = 0; i < faces.length; i++) {
                const face = faces[i];
                const vertex = vertices[face[0]], vertex2 = vertices[face[1]], vertex3 = vertices[face[2]];
                // 缓存顶点
                positions.push(...vertex.toArray(), ...vertex2.toArray(), ...vertex3.toArray());
                let uv = new Vector2(), uv2 = new Vector2(), uv3 = new Vector2();
                const vertexUvs = faceVertexUvs[i];
                if (vertexUvs !== undefined) {
                    uv = vertexUvs[0];
                    uv2 = vertexUvs[1];
                    uv3 = vertexUvs[2];
                }
                // 缓存 uv
                uvs.push(...uv.toArray(), ...uv2.toArray(), ...uv3.toArray());
            }
            const positionsBuffer = new Float32Array(positions), uvsBuffer = new Float32Array(uvs);
            meshsCache[meshId]['position'] = positionsBuffer.buffer;
            meshsCache[meshId]['uv'] = uvsBuffer.buffer;
            // 准备几何体
            const bufferGeometry = new BufferGeometry();
            // bufferPositions
            if (positionsBuffer.length > 0) {
                bufferGeometry.setAttribute('position', new BufferAttribute(positionsBuffer, 3));
            }
            // bufferUvs
            if (uvsBuffer.length > 0) {
                bufferGeometry.setAttribute('uv', new BufferAttribute(uvsBuffer, 2));
            }
            bufferGeometry.computeVertexNormals(); // 이거 하면 라이팅 적용이 안 됨..
            if (this.materials.has(materialId)) {
                const sbmChild = new BaseMesh(bufferGeometry, this.materials.get(materialId), { id: `${meshId}_${randomString()}`, name: meshName, });
                group.add(sbmChild);
            }
            progress.loaded++;
            progress.timeStamp = performance.now() - startTIme;
            onProgress === null || onProgress === void 0 ? void 0 : onProgress(progress);
        }
        const caches = { materialsCache, meshsCache, };
        return Promise.resolve({ model, caches, });
    }
    /**
     * 获取材质贴图路径
     * @param modelUrl 模型资源路径
     * @param name     贴图名称
     * @param isPlatform 是否是平台资源
     */
    getTextureUrl(url, textureName, isPlatform) {
        let textureItemUrl = '';
        let onlyTextureName = textureName;
        const sidx = onlyTextureName.lastIndexOf('/');
        if (sidx !== -1) {
            onlyTextureName = onlyTextureName.substring(sidx + 1);
        }
        textureItemUrl = url;
        if (isPlatform) {
            const spiltUrls = textureItemUrl.split('/');
            if (spiltUrls.length > 1) {
                spiltUrls.splice(spiltUrls.length - 3, spiltUrls.length);
                textureItemUrl = spiltUrls.join('/') + '/Maps/' + onlyTextureName;
            }
        }
        else {
            const sidx = textureItemUrl.lastIndexOf('/');
            if (sidx !== -1) {
                textureItemUrl = textureItemUrl.substring(0, sidx + 1) + 'Maps/' + onlyTextureName;
            }
        }
        return textureItemUrl;
    }
}

new TextDecoder();

class SbmObjectLoader {
    constructor() {
        // material 缓存
        this.materials = new Map();
    }
    /**
     * @example
     * {
     *  materialsCache: {
     *   0: {textureUrl:'xxx.png', materialInfo: [0,0,0,...]}
     *  },
     * meshsCache: {
     *  materialId: 0,
      * position: [0,0,0,...],
      * uv: [0,0,0,...],
      * }
     * }
     * @param sbmObject
     * @param sbmInfo
     * @returns
     */
    parseObject(sbmObject, sbmInfo) {
        const sbm = new Model(Object.assign(Object.assign({}, sbmInfo), { format: 'sbm' }));
        const group = new Group({ id: randomString(), });
        sbm.add(group);
        const { materialsCache, meshsCache, } = sbmObject;
        // 生成材质
        for (const [materialId, materialObj] of Object.entries(materialsCache)) {
            if (this.materials.has(materialId)) {
                continue;
            }
            const { textureUrl, materialInfo, } = materialObj;
            let texture = null;
            if (textureUrl) {
                texture = generateSbmTexture(textureUrl);
            }
            const material = generateSbmMaterial(materialId, materialInfo, texture, isPNG(textureUrl));
            this.materials.set(materialId, material);
        }
        // 生成 mesh
        for (const [meshId, meshObj] of Object.entries(meshsCache)) {
            const { meshName, materialId, position, uv, } = meshObj;
            const material = this.materials.get(materialId.toString());
            if (material) {
                // 准备几何体
                const bufferGeometry = new BufferGeometry();
                const positionsArray = new Float32Array(position);
                const uvsArray = new Float32Array(uv);
                // position
                if (positionsArray.length > 0) {
                    bufferGeometry.setAttribute('position', new BufferAttribute(positionsArray, 3));
                }
                // uv
                if (uvsArray.length > 0) {
                    bufferGeometry.setAttribute('uv', new BufferAttribute(uvsArray, 2));
                }
                bufferGeometry.computeVertexNormals();
                const sbmChild = new BaseMesh(bufferGeometry, material, { id: `${meshId}_${randomString()}`, name: meshName || meshId, });
                group.add(sbmChild);
            }
        }
        return sbm;
    }
}

var SbmLoader = SbkLoader;

class ModelManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.MODEL_MANAGE_TYPE, viewport, scene);
        this.viewport = viewport;
        /**
         * 场景是否卸载
         */
        this.isDisposed = false;
        this.modelsPromiseMap = new Map();
        this.modelsMap = new Map();
        /**
         * workaround for types
         */
        this.store = localforageExports.createInstance({
            name: 'soonspace',
            storeName: 'modelData',
        });
        this.cacheStore = localforageExports.createInstance({
            name: 'soonspace',
            storeName: 'modelCache',
        });
        this.loadingManager = new LoadingManager();
        this.datLoader = new DatLoader(this.cacheStore);
        this.gltfLoader = new GLTFLoader(this.loadingManager);
        this.fbxLoader = new FBXLoader(this.loadingManager);
        this.dracoDecoderPath = null;
        // loading manager
        this._initLoadingManager(this.loadingManager);
    }
    /**
     * 设置 draco path
     * @param path
     */
    setDracoDecoderPath(path) {
        this.dracoDecoderPath = path;
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath(path);
        this.gltfLoader.setDRACOLoader(dracoLoader);
        this.datLoader.dracoDecoderPath = path;
    }
    /**
     * 加载模型
     * @param modelInfo
     * @returns
     */
    async load(modelInfo, parent = this.scene) {
        const { url, } = modelInfo;
        const prevModelPromise = this.modelsPromiseMap.get(url);
        if (prevModelPromise) {
            await prevModelPromise;
            /**
             * 判断场景是否卸载
             */
            if (this.isDisposed) {
                this.dispose();
                return null;
            }
            // 读取缓存模型
            const mapModel = this.modelsMap.get(url);
            if (mapModel) {
                // 克隆缓存模型到场景中
                return this.clone(mapModel, modelInfo, parent);
            }
            return null;
        }
        const modelPromise = this._innerLoad(modelInfo, parent);
        this.modelsPromiseMap.set(url, modelPromise);
        return modelPromise;
    }
    /**
     * 模型解析
     * @param format
     * @param buffer
     * @param modelInfo
     * @returns
     */
    async parse(modelInfo) {
        const { url, id, } = modelInfo;
        if (!url) {
            warn(`id: ${id} url: ${url} is empty`);
            return null;
        }
        const format = url.slice(url.lastIndexOf('.') + 1).toLocaleUpperCase();
        switch (format) {
            case 'SBM':
                return this._parseSbm(modelInfo);
            case 'SBMX':
                return this._parseSbmx(modelInfo);
            case 'DAT':
                return this._parseDat(modelInfo);
            case 'GLB':
            case 'GLTF':
                return this._parseGltf(modelInfo);
            case 'FBX':
                return this._parseFbx(modelInfo);
            default:
                warn(`模型资源（ id: ${id}, url: ${url} ）格式错误，当前格式支持 sbm、sbmx、fbx、gltf、glb !`);
                return null;
        }
    }
    clone(model, info, parent) {
        return new Promise((resolve, reject) => {
            var _a;
            if (model.stype !== 'Model')
                reject('In soonspacejs: 方法 cloneModel 参入对象类型错误!');
            const { id, name, level, visible, position, rotation, scale, onClick, onDblClick, onRightClick, onLoad, userData, } = info;
            function parallelTraverse(a, b, callback) {
                callback(a, b);
                for (let i = 0; i < a.children.length; i++) {
                    parallelTraverse(a.children[i], b.children[i], callback);
                }
            }
            function SkeletonClone(source) {
                const sourceLookup = new Map();
                const cloneLookup = new Map();
                const clone = source.sClone();
                parallelTraverse(source, clone, function (sourceNode, clonedNode) {
                    sourceLookup.set(clonedNode, sourceNode);
                    cloneLookup.set(sourceNode, clonedNode);
                });
                clone.traverse(function (node) {
                    if (node instanceof SkinnedMesh) {
                        const clonedMesh = node;
                        const sourceMesh = sourceLookup.get(node);
                        const sourceBones = sourceMesh.skeleton.bones;
                        clonedMesh.skeleton = sourceMesh.skeleton.clone();
                        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
                        clonedMesh.skeleton.bones = sourceBones.map(function (bone) {
                            return cloneLookup.get(bone);
                        });
                        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
                    }
                });
                return clone;
            }
            // 
            const cloneModel = SkeletonClone(model);
            // 
            cloneModel.animations = cloneModel.animations.map(i => i.clone());
            // 
            if (id)
                cloneModel.sid = id;
            if (name)
                cloneModel.name = name;
            if (level)
                cloneModel.level = level;
            if (visible === false)
                cloneModel.hide();
            // 
            if (position)
                cloneModel.position.set(position.x, position.y, position.z);
            if (rotation)
                cloneModel.rotation.set(rotation.x, rotation.y, rotation.z);
            if (scale)
                cloneModel.scale.set(scale.x, scale.y, scale.z);
            // 
            if (onClick)
                cloneModel.onClick = onClick.bind(cloneModel);
            else
                cloneModel.onClick = null;
            if (onDblClick)
                cloneModel.onDblClick = onDblClick.bind(cloneModel);
            else
                cloneModel.onDblClick = null;
            if (onRightClick)
                cloneModel.onRightClick = onRightClick.bind(cloneModel);
            else
                cloneModel.onRightClick = null;
            if (onLoad)
                cloneModel.onLoad = onLoad.bind(cloneModel);
            else
                cloneModel.onLoad = null;
            // 
            (_a = cloneModel.onLoad) === null || _a === void 0 ? void 0 : _a.call(cloneModel, cloneModel);
            // 
            if (userData)
                cloneModel.userData = userData;
            if (parent !== null)
                this.viewport.scener.addObject(cloneModel, parent || this.scene || model.parent);
            resolve(cloneModel);
        });
    }
    async loadToGroup(groupInfo, modelInfo) {
        const group = this.createGroup(groupInfo, null);
        await Promise.allSettled(modelInfo.map(info => {
            return this.load(info, null)
                .then(model => model && group.add(model))
                .catch(console.error);
        }));
        this.viewport.scener.addObject(group, this.scene);
        return group;
    }
    async addForGroup(group, modelInfo) {
        if (group) {
            await Promise.allSettled(modelInfo.map(async (info) => {
                return this.load(info, null)
                    .then(model => model && this.viewport.scener.addObject(model, group))
                    .catch(console.error);
            }));
        }
        return group;
    }
    /**
     * 清空本地模型缓存数据
     */
    async clearIdb() {
        await this.store.clear();
        await this.cacheStore.clear();
    }
    dispose() {
        var _a;
        this.isDisposed = true;
        this.modelsPromiseMap.clear();
        this.modelsMap.clear();
        (_a = this.gltfLoader.dracoLoader) === null || _a === void 0 ? void 0 : _a.dispose();
        this.datLoader.dispose();
    }
    /**
     * private methods
     */
    _initLoadingManager(manager) {
        manager.addHandler(/\.tga$/i, new TGALoader());
    }
    // 保存模型缓存
    _setModelsMap(url, model) {
        if (!this.modelsMap.has(url)) {
            // 将备份模型存储在当前管理器
            this.modelsMap.set(url, model);
        }
    }
    async _parseSbm(modelInfo) {
        const { useIndexedDB, } = this.viewport.options;
        const { url, } = modelInfo;
        const parseBuffer = async (buffer) => {
            const result = await new SbmLoader().parseBuffer(buffer, modelInfo);
            const { model, caches, } = result;
            caches && idleTask(() => {
                this.cacheStore.setItem(url, caches);
            });
            return model;
        };
        const modelParseDone = (model) => {
            var _a;
            // 触发加载完成回调
            (_a = model.onLoad) === null || _a === void 0 ? void 0 : _a.call(model, model);
        };
        if (useIndexedDB) {
            const sbmCache = await this.cacheStore.getItem(url);
            if (sbmCache) {
                const model = new SbmObjectLoader().parseObject(sbmCache, modelInfo);
                modelParseDone(model);
                return model;
            }
            else {
                const buffer = await this.store.getItem(url) || await this._fetchBuffer(url);
                const model = await parseBuffer(buffer);
                modelParseDone(model);
                return model;
            }
        }
        else {
            const buffer = await this._fetchBuffer(url);
            const model = await parseBuffer(buffer);
            modelParseDone(model);
            return model;
        }
    }
    async _parseSbmx(modelInfo) {
        const { url, } = modelInfo;
        const buffer = await this._getBuffer(url);
        const formatName = getAsciiString(buffer, 0, 8);
        const view = new DataView(buffer.slice(8));
        switch (formatName) {
            case 'SBMG----':
                for (let i = 0; i < view.byteLength; i++) {
                    const byte = view.getUint8(i);
                    const revertByte = ((byte >> 4) & 0x0F) + ((byte << 4) & 0xF0);
                    view.setUint8(i, revertByte);
                }
                return this._parseGltf(modelInfo, view.buffer);
            case 'SBMD----':
                return this._parseDat(modelInfo, view.buffer);
            default:
                return this._parseGltf(modelInfo, view.buffer);
        }
    }
    async _parseDat(modelInfo, _buffer) {
        const { url, } = modelInfo;
        const buffer = _buffer || await this._getBuffer(url);
        const model = new Model(Object.assign(Object.assign({}, modelInfo), { format: 'dat' }));
        const group = await this.datLoader.parseAsync(buffer, url);
        group && model.add(group);
        return model;
    }
    async _parseGltf(modelInfo, _buffer) {
        const { url, } = modelInfo;
        const path = parseFilePath(url);
        const buffer = _buffer || await this._getBuffer(url);
        const model = new Model(Object.assign(Object.assign({}, modelInfo), { format: 'gltf' }));
        const gltf = await this.gltfLoader.parseAsync(buffer, path);
        const { animations, } = gltf;
        if (animations && animations.length > 0)
            model.animations = animations;
        gltf.scene.traverse((child) => {
            if (child.type === 'AmbientLight' ||
                child.type === 'DirectionalLight')
                child.visible = false;
            if (child instanceof InstancedMesh)
                child.frustumCulled = true;
            child.castShadow = true;
            child.receiveShadow = true;
        });
        model.add(gltf.scene);
        return model;
    }
    async _parseFbx(modelInfo) {
        const { url, } = modelInfo;
        const path = parseFilePath(url);
        const buffer = await this._getBuffer(url);
        const model = new Model(Object.assign(Object.assign({}, modelInfo), { format: 'gltf' }));
        const group = this.fbxLoader.parse(buffer, path);
        const { animations, } = group;
        if (animations && animations.length > 0)
            model.animations = animations;
        model.add(group);
        return model;
    }
    async _innerLoad(modelInfo, parent = this.scene) {
        var _a;
        const { url, } = modelInfo;
        // 解析模型
        const model = await this.parse(modelInfo);
        if (!model)
            return null;
        (_a = model.onLoad) === null || _a === void 0 ? void 0 : _a.call(model, model);
        /**
         * 缓存克隆模型
         */
        this._setModelsMap(url, model.sClone());
        if (parent !== null)
            this.viewport.scener.addObject(model, parent);
        return model;
    }
    async _fetchBuffer(url) {
        const { useIndexedDB, } = this.viewport.options;
        const data = await fetchFile(url);
        const buffer = await data.arrayBuffer();
        if (useIndexedDB)
            this.store.setItem(url, buffer);
        return buffer;
    }
    async _getBuffer(url) {
        const { useIndexedDB, } = this.viewport.options;
        if (useIndexedDB) {
            const cachedBuffer = await this.store.getItem(url);
            if (cachedBuffer) {
                return cachedBuffer;
            }
            else {
                return this._fetchBuffer(url);
            }
        }
        else {
            return this._fetchBuffer(url);
        }
    }
}

class PoiManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.POI_MANAGE_TYPE, viewport, scene);
        this.materials = new Map();
    }
    create(info) {
        const material = this._createMaterial(info.url);
        const poi = new Poi(material, info);
        this.viewport.scener.addObject(poi, this.scene);
        return poi;
    }
    clone(poi, poiInfo, parent) {
        if (poi.stype !== 'Poi')
            console.error('In soonspacejs: 方法 clonePoi 参入对象类型错误!');
        const { id, type, name, level, visible, position, rotation, scale, onClick, onDblClick, onRightClick, userData, } = poiInfo;
        // 
        const clonePoi = poi.sClone(false, type);
        this._copyMaterial(clonePoi);
        // 
        if (id)
            clonePoi.sid = id;
        if (name)
            clonePoi.name = name;
        if (level)
            clonePoi.level = level;
        if (isBoolean(visible))
            clonePoi.visible = visible;
        // 
        if (position)
            clonePoi.position.set(position.x, position.y, position.z);
        if (rotation)
            clonePoi.rotation.set(rotation.x, rotation.y, rotation.z);
        if (scale)
            clonePoi.scale.set(scale.x, scale.y, scale.z);
        // 
        if (onClick)
            clonePoi.onClick = onClick.bind(clonePoi);
        else
            clonePoi.onClick = null;
        if (onDblClick)
            clonePoi.onDblClick = onDblClick.bind(clonePoi);
        else
            clonePoi.onDblClick = null;
        if (onRightClick)
            clonePoi.onRightClick = onRightClick.bind(clonePoi);
        else
            clonePoi.onRightClick = null;
        // 
        if (userData)
            clonePoi.userData = userData;
        // 
        if (parent !== null)
            this.viewport.scener.addObject(clonePoi, parent || this.scene || poi.parent);
        return clonePoi;
    }
    createToGroup(groupInfo, poiInfo) {
        const group = this.createGroup(groupInfo, null);
        poiInfo.forEach(info => {
            const material = this._createMaterial(info.url);
            const poi = new Poi(material, info);
            group.add(poi);
        });
        this.viewport.scener.addObject(group, this.scene);
        return group;
    }
    addForGroup(group, poiInfo) {
        if (group) {
            poiInfo.forEach(info => {
                const material = this._createMaterial(info.url);
                const poi = new Poi(material, info);
                group.add(poi);
            });
            this.viewport.scener.addObject(group, this.scene);
        }
        return group;
    }
    _createMaterial(url) {
        const oldMaterial = this.materials.get(url);
        if (!oldMaterial) {
            const map = new TextureLoader().load(url);
            map.flipY = true;
            const material = new SpriteMaterial({ map, color: 0xffffff, });
            this.materials.set(url, material);
            return material;
        }
        return oldMaterial;
    }
    _copyMaterial(poi) {
        poi.traverse(object => {
            if (object instanceof Mesh || object instanceof Sprite)
                if (isArray(object.material))
                    object.material = object.material.map(item => item.clone());
                else if (object.material instanceof Material)
                    object.material = object.material.clone();
        });
    }
}

class PoiNodeManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.POI_NODE_MANAGE_TYPE, viewport, scene);
    }
    create(info) {
        this._openEnableRenderCss(info);
        const poi = new PoiNode(info);
        this.viewport.scener.addObject(poi, this.scene);
        return poi;
    }
    createToGroup(groupInfo, poiNodeInfo) {
        const group = this.createGroup(groupInfo, null);
        poiNodeInfo.forEach(info => {
            this._openEnableRenderCss(info);
            const poiNode = new PoiNode(info);
            group.add(poiNode);
        });
        this.viewport.scener.addObject(group, this.scene);
        return group;
    }
    addForGroup(group, poiNodeInfo) {
        if (group) {
            poiNodeInfo.forEach(info => {
                this._openEnableRenderCss(info);
                const poiNode = new PoiNode(info);
                group.add(poiNode);
            });
            this.viewport.scener.addObject(group, this.scene);
        }
        return group;
    }
    _openEnableRenderCss(info) {
        switch (info.type) {
            case '2d':
            case '2D':
                this.viewport.rendererManager.setInternalState('enableRenderCss2D', true);
                break;
            case '2.5d':
            case '2.5D':
            case '3d':
            case '3D':
                this.viewport.rendererManager.setInternalState('enableRenderCss3D', true);
                break;
        }
    }
}

class Canvas3DManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.CANVAS3D_MANAGE_TYPE, viewport, scene);
    }
    create(info) {
        const canvas = new Canvas3D(info);
        this.viewport.scener.addObject(canvas, this.scene);
        return canvas;
    }
    createToGroup(groupInfo, poiInfo) {
        const group = this.createGroup(groupInfo, null);
        poiInfo.forEach(info => {
            const canvas = new Canvas3D(info);
            group.add(canvas);
        });
        this.viewport.scener.addObject(group, this.scene);
        return group;
    }
    addForGroup(group, poiInfo) {
        if (group) {
            poiInfo.forEach(info => {
                const canvas = new Canvas3D(info);
                group.add(canvas);
            });
            this.viewport.scener.addObject(group, this.scene);
        }
        return group;
    }
}

class Dijkstras {
    constructor() {
        this.graph = new Map();
        this.queue = null;
        this.previous = new Map();
    }
    /**
     * Creates a graph from array.
     * Each element in the array should be in the format:
     * 	[NODE NAME, [[NODE NAME, COST], ...] ]
     *
     * For example: 	[
     *		['A', [['B', 20], ['C', 20]] ],
     *		['B', [['A', 30], ['C', 100]] ],
     *		['C', [['D', 10], ['A', 20]] ],
     *		['D', [['C', 10], ['B', 20]] ]
     *	]
     *
     * @param graphy Array of nodes and vertices.
     **/
    setGraph(graph) {
        if (graph.length < 1)
            return;
        for (const node of graph) {
            const [nodeName, vertices] = node;
            this.graph.set(nodeName, new Map());
            for (const vertex of vertices) {
                const [vertexName, vertexCost] = vertex;
                const vertexMap = this.graph.get(nodeName);
                vertexMap === null || vertexMap === void 0 ? void 0 : vertexMap.set(vertexName, vertexCost);
            }
        }
    }
    /**
     * Find shortest path
     *
     * @param source The starting node.
     * @param target The target node.
     * @return array Path to target, or empty array if unable to find path.
     */
    getPath(source, target) {
        var _a;
        // Already at target
        if (source === target)
            return [];
        // Reset all previous values
        const queue = this.queue = new MinHeap();
        queue.add(source, 0);
        this.previous.set(source, null);
        // Loop all nodes
        let u = null;
        while ((u = queue.shift())) {
            // Reached taget!
            if (u === target) {
                const path = [];
                while (u !== null && this.previous.get(u) !== null) {
                    path.unshift(u);
                    u = (_a = this.previous.get(u)) !== null && _a !== void 0 ? _a : null;
                }
                return path;
            }
            const uDistance = queue.getDistance(u);
            // all remaining vertices are inaccessible from source
            if (uDistance === Infinity)
                return [];
            const neighbours = this.graph.get(u);
            if (neighbours) {
                neighbours.forEach((value, key) => {
                    const nDistance = queue.getDistance(key);
                    const aDistance = uDistance + value;
                    if (aDistance < nDistance) {
                        queue.update(key, aDistance);
                        this.previous.set(key, u);
                    }
                });
            }
        }
        return [];
    }
}

class TopologyManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.TOPOLOGY_MANAGE_TYPE, viewport, scene);
        this.dijkstra = new Dijkstras;
    }
    async createFromGml(topologyInfoForGml) {
        const { url, linkWidth = 20, linkColor = 0x00ff00, renderNode = true, nodeColor = 0x0000ff, } = topologyInfoForGml;
        return xmlToJson(url)
            .then(json => {
            if (!json || !json.MultiLayeredGraph)
                return Promise.reject('In soonspace: createTopologyFromGml "url" path error!');
            const nodes = [];
            const nodeIdAndIndex = new Map;
            let statelist = [];
            let transitionlist = [];
            const x_floor = json.MultiLayeredGraph.SpaceLayerMember.SpaceLayer.X_floor;
            if (isArray(x_floor)) {
                x_floor.forEach(floor => {
                    statelist = [...statelist, ...floor.state];
                    transitionlist = [...transitionlist, ...floor.transition];
                });
            }
            else {
                statelist = [...statelist, ...x_floor.state];
                transitionlist = [...transitionlist, ...x_floor.transition];
            }
            // statelist
            statelist.forEach((state, index) => {
                const nodeId = state.State._attributes['gml:id'];
                const nodeName = state.State.topoNode['gml:Node'].node_name;
                nodes.push({
                    id: isString(nodeId) ? nodeId : '',
                    name: isString(nodeName) ? nodeName : '',
                    position: {
                        x: Number(state.State.topoNode['gml:Node'].xcoord['#text']),
                        y: Number(state.State.topoNode['gml:Node'].zcoord['#text']),
                        z: Number(state.State.topoNode['gml:Node'].ycoord['#text']) * -1,
                    },
                    graphs: [],
                });
                nodeIdAndIndex.set(nodeId, index);
            });
            // transition
            transitionlist.forEach(transition => {
                const startId = transition.Transition.topoEdge['gml:Edge']['gml:directedNode'][0]._attributes['xlink:href'];
                const endId = transition.Transition.topoEdge['gml:Edge']['gml:directedNode'][1]._attributes['xlink:href'];
                const restrict = transition.Transition.topoEdge['gml:Edge'].restrict['#text'];
                const passable = transition.Transition.topoEdge['gml:Edge'].passable['#text'];
                const startIndex = nodeIdAndIndex.get(startId);
                const endIndex = nodeIdAndIndex.get(endId);
                const linkId = transition.Transition._attributes['gml:id'];
                const linkName = transition.Transition.topoEdge['gml:Edge'].link_name['#text'];
                if (startIndex !== undefined && endIndex !== undefined) {
                    if (passable !== '2' && passable !== '3') {
                        nodes[startIndex].graphs.push({
                            targetNodeId: endId,
                            linkInfo: {
                                id: linkId,
                                name: linkName,
                            },
                            enable: true,
                            restrict: parseInt(restrict),
                            passable: parseInt(passable),
                        });
                    }
                    if (passable !== '1' && passable !== '3') {
                        nodes[endIndex].graphs.push({
                            targetNodeId: startId,
                            linkInfo: {
                                id: linkId,
                                name: linkName,
                            },
                            enable: true,
                            restrict: parseInt(restrict),
                            passable: parseInt(passable),
                        });
                    }
                }
            });
            const topology = new Topology(Object.assign(Object.assign({}, topologyInfoForGml), { type: 'network', nodes,
                linkWidth, renderLink: true, linkColor,
                renderNode,
                nodeColor }));
            this.setDijkstraGraph(topology.nodes);
            this.viewport.scener.addObject(topology, this.scene);
            return Promise.resolve(topology);
        });
    }
    create(topologyInfo) {
        const newInfo = this.generateLineTopologyInfoNodeGraphs(topologyInfo);
        const topology = new Topology(newInfo);
        this.setDijkstraGraph(topology.nodes);
        this.viewport.scener.addObject(topology, this.scene);
        return topology;
    }
    resetNodes(topology, nodes) {
        const newInfo = this.generateLineTopologyInfoNodeGraphs(Object.assign(Object.assign({}, topology.info), { nodes }));
        topology.resetNodes(newInfo.nodes);
        this.viewport.signals.objectChanged.dispatch();
        return topology;
    }
    createToGroup(groupInfo, topologyInfos) {
        const group = this.createGroup(groupInfo, null);
        topologyInfos.forEach(info => {
            const newInfo = this.generateLineTopologyInfoNodeGraphs(info);
            const topology = new Topology(newInfo);
            this.setDijkstraGraph(topology.nodes);
            group.add(topology);
        });
        this.viewport.scener.addObject(group, this.scene);
        return group;
    }
    addForGroup(group, topologyInfos) {
        if (group) {
            topologyInfos.forEach(info => {
                const newInfo = this.generateLineTopologyInfoNodeGraphs(info);
                const topology = new Topology(newInfo);
                this.setDijkstraGraph(topology.nodes);
                group.add(topology);
            });
        }
        return group;
    }
    getShortestPath(topology, info) {
        const cloneNodes = cloneDeep(topology.info.nodes);
        const start = IVector3ToVector3(info.start);
        const end = IVector3ToVector3(info.end);
        let startNode = null;
        let startDistance = Infinity;
        let endNode = null;
        let endDistance = Infinity;
        for (let i = 0; i < cloneNodes.length; i++) {
            const node = cloneNodes[i];
            if (node.graphs.length === 0)
                continue;
            const foundNode = topology.nodes.find(n => n.sid === node.id);
            if (!foundNode)
                continue;
            const currentNodePosition = foundNode.getWorldPosition(new Vector3);
            const currentStartDistance = currentNodePosition.distanceTo(start);
            const currentEndDistance = currentNodePosition.distanceTo(end);
            if (currentStartDistance < startDistance) {
                startDistance = currentStartDistance;
                startNode = node;
            }
            if (currentEndDistance < endDistance) {
                endDistance = currentEndDistance;
                endNode = node;
            }
        }
        if (!startNode || !endNode || startNode.id === endNode.id)
            return null;
        const startId = startNode.id;
        const endId = endNode.id;
        const poathids = this.dijkstra.getPath(startId, endId);
        if (poathids.length === 0)
            return null;
        // unshift start node
        poathids.unshift(startNode.id);
        const shortestNodeInfo = [];
        for (let i = 0; i < poathids.length; i++) {
            const node = cloneNodes.find(node => node.id == poathids[i]);
            if (!node)
                continue;
            node.id += randomString();
            node.position.y += 0.01;
            shortestNodeInfo.push(node);
        }
        const topologyInfo = Object.assign(Object.assign(Object.assign({}, info), { type: 'line', nodes: shortestNodeInfo }), topology.getSpaceAttribute(true));
        this.generateLineTopologyInfoNodeGraphs(topologyInfo);
        const shortestPathTopology = new Topology(topologyInfo);
        this.viewport.scener.addObject(shortestPathTopology, this.scene);
        return shortestPathTopology;
    }
    getShortestPathByMultipleStartPoints(topology, info) {
        const { nodes, } = topology.info;
        const nodeInfoAndPathLengthList = [];
        info.start.forEach(point => {
            const start = IVector3ToVector3(point);
            const end = IVector3ToVector3(info.end);
            let startId = null;
            let startDistance = Infinity;
            let endId = null;
            let endDistance = Infinity;
            nodes.forEach(node => {
                if (node.graphs.length > 0) {
                    const currentNode = IVector3ToVector3(node.position);
                    const currentStartDistance = currentNode.distanceTo(start);
                    const currentEndDistance = currentNode.distanceTo(end);
                    if (currentStartDistance < startDistance) {
                        startDistance = currentStartDistance;
                        startId = node.id;
                    }
                    if (currentEndDistance < endDistance) {
                        endDistance = currentEndDistance;
                        endId = node.id;
                    }
                }
            });
            if (startId && endId) {
                let pathLength = 0;
                const poathids = this.dijkstra.getPath(startId, endId);
                if (poathids.length > 0) {
                    const nodeInfo = [{
                            id: 'startPoint',
                            position: start,
                            graphs: [],
                        }];
                    poathids.forEach((id, index) => {
                        const node = nodes.find(node => node.id == id);
                        if (node) {
                            if (index === 0) {
                                pathLength += IVector3ToVector3(node.position).distanceTo(start);
                            }
                            else {
                                pathLength += IVector3ToVector3(node.position).distanceTo(IVector3ToVector3(nodeInfo[nodeInfo.length - 1].position));
                            }
                            nodeInfo.push(node);
                        }
                    });
                    nodeInfo.push({
                        id: 'endPoint',
                        position: end,
                        graphs: [],
                    });
                    pathLength += end.distanceTo(IVector3ToVector3(nodeInfo[nodeInfo.length - 1].position));
                    nodeInfoAndPathLengthList.push({
                        nodeInfo,
                        pathLength,
                    });
                }
            }
        });
        let shortestNodeInfo = [];
        let shortestPathLength = Infinity;
        nodeInfoAndPathLengthList.forEach(({ nodeInfo, pathLength, }) => {
            if (pathLength < shortestPathLength) {
                shortestPathLength = pathLength;
                shortestNodeInfo = nodeInfo;
            }
        });
        if (shortestNodeInfo.length) {
            for (let i = 0; i < shortestNodeInfo.length; i++) {
                shortestNodeInfo[i].position.y += 0.01;
            }
            const topologyInfo = Object.assign(Object.assign({}, info), { type: 'line', nodes: shortestNodeInfo, position: topology.getWorldPosition(new Vector3), rotation: new Euler().setFromQuaternion(topology.getWorldQuaternion(new Quaternion)), scale: topology.getWorldScale(new Vector3) });
            this.generateLineTopologyInfoNodeGraphs(topologyInfo);
            const shortestPathTopology = new Topology(topologyInfo);
            this.viewport.scener.addObject(shortestPathTopology, this.scene);
            return shortestPathTopology;
        }
        return null;
    }
    getShortestPathByMultipleEndPoints(topology, info) {
        const { nodes, } = topology.info;
        const nodeInfoAndPathLengthList = [];
        info.end.forEach(point => {
            const start = IVector3ToVector3(info.start);
            const end = IVector3ToVector3(point);
            let startId = null;
            let startDistance = Infinity;
            let endId = null;
            let endDistance = Infinity;
            nodes.forEach(node => {
                if (node.graphs.length > 0) {
                    const currentNode = IVector3ToVector3(node.position);
                    const currentStartDistance = currentNode.distanceTo(start);
                    const currentEndDistance = currentNode.distanceTo(end);
                    if (currentStartDistance < startDistance) {
                        startDistance = currentStartDistance;
                        startId = node.id;
                    }
                    if (currentEndDistance < endDistance) {
                        endDistance = currentEndDistance;
                        endId = node.id;
                    }
                }
            });
            if (startId && endId) {
                let pathLength = 0;
                const poathids = this.dijkstra.getPath(startId, endId);
                if (poathids.length > 0) {
                    const nodeInfo = [{
                            id: 'startPoint',
                            position: start,
                            graphs: [],
                        }];
                    poathids.forEach((id, index) => {
                        const node = nodes.find(node => node.id == id);
                        if (node) {
                            if (index === 0) {
                                pathLength += IVector3ToVector3(node.position).distanceTo(start);
                            }
                            else {
                                pathLength += IVector3ToVector3(node.position).distanceTo(IVector3ToVector3(nodeInfo[nodeInfo.length - 1].position));
                            }
                            nodeInfo.push(node);
                        }
                    });
                    nodeInfo.push({
                        id: 'endPoint',
                        position: end,
                        graphs: [],
                    });
                    pathLength += end.distanceTo(IVector3ToVector3(nodeInfo[nodeInfo.length - 1].position));
                    nodeInfoAndPathLengthList.push({
                        nodeInfo,
                        pathLength,
                    });
                }
            }
        });
        let shortestNodeInfo = [];
        let shortestPathLength = Infinity;
        nodeInfoAndPathLengthList.forEach(({ nodeInfo, pathLength, }) => {
            if (pathLength < shortestPathLength) {
                shortestPathLength = pathLength;
                shortestNodeInfo = nodeInfo;
            }
        });
        if (shortestNodeInfo.length) {
            for (let i = 0; i < shortestNodeInfo.length; i++) {
                shortestNodeInfo[i].position.y += 0.01;
            }
            const topologyInfo = Object.assign(Object.assign({}, info), { type: 'line', nodes: shortestNodeInfo, position: topology.getWorldPosition(new Vector3), rotation: new Euler().setFromQuaternion(topology.getWorldQuaternion(new Quaternion)), scale: topology.getWorldScale(new Vector3) });
            this.generateLineTopologyInfoNodeGraphs(topologyInfo);
            const shortestPathTopology = new Topology(topologyInfo);
            this.viewport.scener.addObject(shortestPathTopology, this.scene);
            return shortestPathTopology;
        }
        return null;
    }
    setDijkstraGraph(nodes) {
        const nodesGraph = [];
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.graphs.length === 0)
                continue;
            const dijkstraGraph = [];
            for (let j = 0; j < node.graphs.length; j++) {
                const graph = node.graphs[j];
                const targetNode = nodes.find(i => i.sid === graph.targetNodeId);
                if (!targetNode)
                    continue;
                const startPositon = node.getWorldPosition(new Vector3());
                const endPositon = targetNode.getWorldPosition(new Vector3());
                dijkstraGraph.push([
                    graph.targetNodeId,
                    startPositon.distanceTo(endPositon)
                ]);
            }
            nodesGraph.push([node.sid, dijkstraGraph]);
        }
        if (nodesGraph.length > 0)
            this.dijkstra.setGraph(nodesGraph);
    }
    generateLineTopologyInfoNodeGraphs(info) {
        const { type, nodes, } = info;
        if (type === 'line') {
            for (let i = 0; i < nodes.length; i++) {
                // 最后一个点
                if (i === nodes.length - 1)
                    nodes[i].graphs = [];
                // 其他点
                else {
                    const currentNode = info.nodes[i];
                    const nextNode = info.nodes[i + 1];
                    nodes[i].graphs = [{
                            targetNodeId: nextNode.id,
                            linkInfo: {
                                id: `${currentNode.id}_to_${nextNode.id}`,
                                name: `${currentNode.name || currentNode.id}_to_${nextNode.name || nextNode.id}`,
                            },
                            enable: true,
                            restrict: 0,
                            passable: 0,
                        }];
                }
            }
        }
        return Object.assign(Object.assign({}, info), { nodes });
    }
}

class HelperManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.HELPER_MANAGE_TYPE, viewport, scene);
    }
    addGridHelper(options) {
        const { id, size = 1000, divisions = 20, color = '#fff', position = { x: 0, y: 0, z: 0, }, rotation = { x: 0, y: 0, z: 0, }, scale = { x: 1, y: 1, z: 1, }, } = options;
        const helper = new GridHelper(size, divisions, color, color);
        helper.position.set(position.x, position.y, position.z);
        helper.rotation.set(rotation.x, rotation.y, rotation.z);
        helper.scale.set(scale.x, scale.y, scale.z);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addAxesHelper(options) {
        const { id, axesLength = 1000, } = options;
        const helper = new AxesHelper(axesLength);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addBoxHelper(options) {
        const { id, box, color = '#00ff00', } = options;
        const helper = new Box3Helper(box, new Color(color));
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addPlaneHelper(options) {
        const { id, width = 500, height = 500, color = '#00ff00', opacity = 0.2, position = { x: 0, y: 0, z: 0, }, rotation = { x: 0, y: 0, z: 0, }, scale = { x: 1, y: 1, z: 1, }, } = options;
        const helper = new BaseMesh(new PlaneGeometry(width, height), new MeshBasicMaterial({
            color,
            opacity,
            transparent: opacity < 1,
            side: DoubleSide,
        }), {
            id,
            position,
            rotation,
            scale,
        });
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addGroundHelper(options) {
        const { imgUrl, id, width = 500, height = 500, opacity = 1, position = { x: 0, y: 0, z: 0, }, rotation = { x: 0, y: 0, z: 0, }, scale = { x: 1, y: 1, z: 1, }, repeat = { x: 10, y: 10, }, } = options;
        const texture = new TextureLoader().load(imgUrl);
        const geometry = new PlaneGeometry(width, height);
        geometry.computeBoundingBox();
        const material = new MeshStandardMaterial({
            side: DoubleSide,
            map: texture,
            transparent: opacity < 1,
            opacity,
            roughness: 0.8,
        });
        if (material.map) {
            material.map.repeat.set(repeat.x, repeat.x);
            material.map.wrapS = RepeatWrapping;
            material.map.wrapT = RepeatWrapping;
            material.map.version++;
        }
        rotation.x -= Math.PI / 2;
        material.version++;
        const ground = new Ground(geometry, material, { id, position, rotation, scale, });
        ground.userData.sid = id;
        ground.userData.stype = 'Helper';
        this.viewport.scener.addObject(ground, this.scene);
        return ground;
    }
    addDirectionalLightHelper(options) {
        const { id, light, color, size = 50, } = options;
        const helper = new DirectionalLightHelper(light, size, color);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addHemisphereLightHelper(options) {
        const { id, light, color, size = 20, } = options;
        const helper = new HemisphereLightHelper(light, size, color);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addSpotLightHelper(options) {
        const { id, light, color, } = options;
        const helper = new SpotLightHelper(light, color);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addPointLightHelper(options) {
        const { id, light, color, size = 20, } = options;
        const helper = new PointLightHelper(light, size, color);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
    addRectAreaLightHelper(options) {
        const { id, light, color, } = options;
        const helper = new RectAreaLightHelper(light, color);
        helper.userData.sid = id;
        helper.userData.stype = 'Helper';
        this.viewport.scener.addObject(helper, this.scene);
        return helper;
    }
}

class PluginManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.PLUGIN_OBJECT_MANAGE_TYPE, viewport, scene);
    }
    createObject(info, object) {
        const pluginObject = new PluginObject(info);
        if (object)
            pluginObject.add(object);
        this.viewport.scener.addObject(pluginObject, this.scene);
        return pluginObject;
    }
    addToObject(pluginObject, object) {
        if (pluginObject) {
            this.viewport.scener.addObject(object, pluginObject);
            return pluginObject;
        }
        else {
            return null;
        }
    }
}

class GroupManage extends DefaultManage {
    constructor(viewport, scene) {
        super(managerType.GROUP_MANAGE_TYPE, viewport, scene);
    }
}

class Manager {
    constructor(viewport) {
        this.viewport = viewport;
        this.cache = {
            objects: new Map(),
            classified: {
                Group: new Set(),
                Light: new Set(),
                Model: new Set(),
                Poi: new Set(),
                PoiNode: new Set(),
                Canvas3D: new Set(),
                Topology: new Set(),
                Helper: new Set(),
                PluginObject: new Set(),
            },
        };
        this.scene = viewport.scene;
        this.store = {
            groupManager: new GroupManage(viewport, this.scene),
            lightManager: new LightManage(viewport, this.scene),
            modelManager: new ModelManage(viewport, this.scene),
            poiManager: new PoiManage(viewport, this.scene),
            poiNodeManager: new PoiNodeManage(viewport, this.scene),
            canvas3DManager: new Canvas3DManage(viewport, this.scene),
            topologyManager: new TopologyManage(viewport, this.scene),
            helperManager: new HelperManage(viewport, this.scene),
            pluginObjectManager: new PluginManage(viewport, this.scene),
        };
        viewport.postUpdate.set('ManagerRender', this.update.bind(this));
        // cache events
        viewport.signals.objectAdded.add(this.setObjectCache.bind(this));
        viewport.signals.objectRemoved.add(this.deleteObjectCache.bind(this));
    }
    /**
     * level update
     * @returns
     */
    levelUpdate() {
        const showOrHide = (object, visible) => {
            if (object.visible === visible)
                return;
            object.visible = visible;
            object.matrixAutoUpdate = visible;
            object.autoUpdate = true;
        };
        const visibleChange = (object) => {
            const { level, handleHide, autoUpdate, } = object;
            const { max = null, min = null, } = level;
            if (autoUpdate) {
                object.autoUpdate = false;
                this.viewport.signals.objectChanged.dispatch();
            }
            else if (!handleHide && (isNumber(max) || isNumber(min))) {
                const distance = this.viewport.camera.position.distanceTo(object.position);
                if (isNumber(max) && distance > max) {
                    showOrHide(object, false);
                }
                else if (isNumber(min) && distance < min) {
                    showOrHide(object, false);
                }
                else {
                    showOrHide(object, true);
                }
            }
        };
        this.scene.traverse((object) => {
            if (object instanceof BaseObject3D || object instanceof BaseMesh)
                visibleChange(object);
        });
    }
    /**
     *
     * frame update
     *
     */
    update() {
        if (this.scene.children.length === 0)
            return;
        const startTime = performance.now();
        if (this.viewport.options.levelEnabled) {
            this.levelUpdate();
        }
        this.viewport.signals.loadRendered.dispatch(performance.now() - startTime);
    }
    /**
     *
     * objects
     *
     */
    /**
     * 检查是否存在于场景
     * @param object
     * @returns
     */
    isObjectInScene(object) {
        let inScene = false;
        object.traverseAncestors((object) => {
            if (object === this.scene)
                inScene = true;
        });
        return inScene;
    }
    getObjectById(id) {
        /**
         * cached object
         */
        const cachedObject = this.getObjectCache(id);
        if (cachedObject) {
            // 检查是否已经被删除
            const inScene = this.isObjectInScene(cachedObject);
            if (inScene) {
                return cachedObject;
            }
        }
        return null;
    }
    getObjectByName(name) {
        return this._getObjectByProps('name', name);
    }
    getObjectByUserDataProperty(propNameOrFindFunc, propValue) {
        const foundObjects = [];
        this.cache.objects.forEach((object) => {
            if (!this.isObjectInScene(object)) {
                return;
            }
            if (isObject(object) &&
                (object instanceof BaseObject3D ||
                    object instanceof BaseMesh ||
                    object.userData.stype)) {
                if (isFunction(propNameOrFindFunc) &&
                    propNameOrFindFunc(object.userData))
                    foundObjects.push(object);
                else if (isString(propNameOrFindFunc) &&
                    object.userData[propNameOrFindFunc] === propValue)
                    foundObjects.push(object);
            }
        });
        return foundObjects;
    }
    removeObjectById(id) {
        const object = this.getObjectById(id);
        if (object) {
            this.viewport.scener.removeObject(object);
            return true;
        }
        return false;
    }
    _getObjectByProps(key, value) {
        const objects = [];
        this.cache.objects.forEach((object) => {
            if (!this.isObjectInScene(object)) {
                return;
            }
            // model、topology...
            if ((object instanceof BaseObject3D || object instanceof BaseMesh) &&
                isObject(object) &&
                object[key] === value) {
                objects.push(object);
            }
            // light、helper...
            else if (isObject(object) && object.userData.stype) {
                if (key === 'name' && object.name === value)
                    objects.push(object);
                else if (key === 'sid' && object.userData.sid === value)
                    objects.push(object);
            }
        });
        return objects;
    }
    /**
     *
     * cache
     *
     */
    getObjectCache(sid) {
        return this.cache.objects.get(sid);
    }
    setObjectCache(object) {
        const repeatedIdWarning = (cachedObject, id) => {
            const foundCachedObject = this.cache.objects.get(id);
            if (foundCachedObject && foundCachedObject !== cachedObject) {
                warn(`object id ${id} already exists in scene`);
            }
        };
        object === null || object === void 0 ? void 0 : object.traverse((child) => {
            if (child instanceof BaseObject3D || child instanceof BaseMesh) {
                /**
                 * 内部对象不缓存
                 */
                if (typeof child.sid === 'string' && child.sid.startsWith(INNER_ID)) {
                    return;
                }
                repeatedIdWarning(child, child.sid);
                this.cache.objects.set(child.sid, child);
                /**
                 * classified
                 */
                const stype = child.stype;
                if (this.cache.classified[stype]) {
                    this.cache.classified[stype].add(child);
                }
            }
            else if (child.userData.sid && object.userData.stype) {
                repeatedIdWarning(child, child.userData.sid);
                this.cache.objects.set(child.userData.sid, child);
                /**
                 * classified
                 */
                const stype = child.userData.stype;
                if (this.cache.classified[stype]) {
                    this.cache.classified[stype].add(child);
                }
            }
        });
    }
    deleteObjectCache(object) {
        object === null || object === void 0 ? void 0 : object.traverse((child) => {
            if (child instanceof BaseObject3D || child instanceof BaseMesh) {
                this.cache.objects.delete(child.sid);
                /**
                 * classified
                 */
                const stype = child.stype;
                if (this.cache.classified[stype]) {
                    this.cache.classified[stype].delete(child);
                }
            }
            else if (child.userData.sid && object.userData.stype) {
                this.cache.objects.delete(child.userData.sid);
                /**
                 * classified
                 */
                const stype = child.userData.stype;
                if (this.cache.classified[stype]) {
                    this.cache.classified[stype].delete(child);
                }
            }
        });
    }
    /**
     *
     * clear object
     *
     */
    clearObject() {
        this.store.modelManager.clear();
        this.store.poiManager.clear();
        this.store.poiNodeManager.clear();
        this.store.canvas3DManager.clear();
        this.store.topologyManager.clear();
        this.store.helperManager.clear();
        this.store.pluginObjectManager.clear();
    }
    clear() {
        this.clearObject();
        this.store.lightManager.clear();
    }
    dispose() {
        // dispose managers
        this.store.modelManager.dispose();
        // cache
        this.cache.objects.clear();
        // dispose objects
        this.clear();
    }
}

function getPolygonGeometryInfo(points) {
    const matrix3 = createPlaneMatrix(points);
    const modelMatrix = new Matrix4();
    modelMatrix.setFromMatrix3(matrix3);
    const position = points[0];
    const planeMatrix = modelMatrix.clone();
    planeMatrix.setPosition(position);
    const projectionMatrix = planeMatrix.clone().invert();
    const planePoints = points.map(p => {
        const p3 = p.clone().applyMatrix4(projectionMatrix);
        return new Vector2(p3.x, p3.y);
    });
    const shape = new Shape(planePoints);
    const geometry = new ShapeGeometry(shape);
    const polygonBox = new Box2();
    polygonBox.setFromPoints(planePoints);
    const uvMatrix = createUVMatrix(polygonBox);
    const uvAttr = geometry.getAttribute('uv');
    uvAttr.applyMatrix3(uvMatrix);
    geometry.applyMatrix4(modelMatrix);
    return { geometry, polygonBox, modelMatrix, planeMatrix, projectionMatrix, position, };
}
/**
 * 创建平面投影矩阵
 * @param points
 */
function createPlaneMatrix(points) {
    const [p1, p2, p3] = points;
    const plane = new Plane();
    plane.setFromCoplanarPoints(p2, p1, p3);
    const zAxis = plane.normal;
    const xAxis = zAxis.clone().cross(new Vector3(0, 0, 1));
    if (xAxis.equals(new Vector3())) {
        xAxis.set(1, 0, 0);
    }
    const yAxis = zAxis.clone().cross(xAxis);
    xAxis.normalize();
    yAxis.normalize();
    zAxis.normalize();
    const matrix = new Matrix3();
    matrix.elements = [
        xAxis.x, xAxis.y, xAxis.z,
        yAxis.x, yAxis.y, yAxis.z,
        zAxis.x, zAxis.y, zAxis.z
    ];
    return matrix;
}
/**
 * 创建 uv 变换矩阵
 * @remarks
 * 需要对热力图数据进行y值翻转
 * @param points
 * @returns
 */
function createUVMatrix(box) {
    const min = box.min;
    const scale = box.getSize(new Vector2());
    const uvMatrix = new Matrix3();
    uvMatrix.elements = [
        scale.x, 0, 0,
        0, scale.y, 0,
        min.x, min.y, 1
    ];
    return uvMatrix.invert();
}
/**
 * 判断包围合 与 对象的包围盒是否相交
 */
function boundingIsIntersected(target, obj) {
    const box3 = getBoundingBox(obj);
    return target.intersectsBox(box3);
}
function createTexture(image, cache, textureCache) {
    if (typeof image === 'string') {
        let texture = cache ? textureCache === null || textureCache === void 0 ? void 0 : textureCache.get(image) : null;
        if (!texture) {
            const loader = new TextureLoader();
            texture = loader.load(image);
            textureCache === null || textureCache === void 0 ? void 0 : textureCache.set(image, texture);
        }
        return texture;
    }
    if (image instanceof HTMLImageElement) {
        return new Texture(image);
    }
    if (image instanceof HTMLCanvasElement) {
        return new CanvasTexture(image);
    }
    return new VideoTexture(image);
}
/**
 * 设置贴图
 * @param material
 * @param image
 * @param cache
 * @param textureCache
 * @returns
 */
function setTexture(material, image, cache, textureCache) {
    const texture = material.map;
    const newTexture = createTexture(image, cache, textureCache);
    if (!texture) {
        material.map = newTexture;
        return newTexture;
    }
    const source = newTexture.source;
    newTexture.copy(texture);
    newTexture.source = source;
    material.map = newTexture;
    return newTexture;
}

/**
 *  创建 查找位置附近的 box 空间范围内的物体
 * @param boxSpace - 描述查找空间的信息对象
 * @param objects - 所有需要被查找的对象
 * @returns 用于查找的函数
 */
function createFindObjectsInBoxNearPosition(boxSpace, objects) {
    const { top, left, bottom, right, front, back, } = boxSpace;
    const maxVec = new Vector3(right, top, front);
    const minVec = new Vector3(left, bottom, back);
    const box = new Box3();
    return function findObjectsInBoxNearPosition(position) {
        box.max.addVectors(position, maxVec);
        box.min.subVectors(position, minVec);
        return objects.filter((obj) => {
            return boundingIsIntersected(box, obj);
        });
    };
}
/**
 *  创建 查找位置附近的球形空间范围内的物体
 *
 * @param radius - 描述查找半径
 * @param objects - 所有需要被查找的对象
 * @returns 用于查找的函数
 */
function createFindObjectsInSphereNearPosition(radius, objects) {
    const sphere = new Sphere(new Vector3, radius);
    return function findObjectsInSphereNearPosition(position) {
        sphere.center.copy(position);
        return objects.filter((obj) => {
            return boundingIsIntersected(sphere, obj);
        });
    };
}
/**
 *  创建 查找路径附近的范围内的物体
 *
 * @param points - 描述路径的点
 * @param radius - 描述查找半径
 * @returns 用于查找的函数
 */
function createFindObjectsNearPath(points, radius) {
    const max = points.length - 1;
    const allLines = [];
    for (let i = 0; i < max; i++) {
        const start = points[i];
        const end = points[i + 1];
        const line = new Line3(start, end);
        allLines.push(line);
    }
    const sphere = new Sphere(new Vector3(), radius);
    return function findObjectsNearPath(objects) {
        return objects.filter((obj) => {
            const boundingBox = getBoundingBox(obj);
            const position = new Vector3();
            boundingBox.getCenter(position);
            const projLines = allLines.filter((line) => {
                const parameter = line.closestPointToPointParameter(position);
                return 0 <= parameter || parameter >= 1;
            });
            if (projLines.length === 0)
                return false;
            let minDistSquared = Infinity;
            let minClosestPoint = position;
            for (const line of projLines) {
                const closestPoint = line.closestPointToPoint(position, true, new Vector3());
                const distanceSquared = position.distanceToSquared(closestPoint);
                if (distanceSquared < minDistSquared) {
                    minDistSquared = distanceSquared;
                    minClosestPoint = closestPoint;
                }
            }
            sphere.center.copy(minClosestPoint);
            return sphere.intersectsBox(boundingBox);
        });
    };
}

/**
 * 创建 poi mesh
 * @param options
 * @returns
 */
function createPoiMesh(options, textureCache) {
    const { image, color, width, height, position, rotation, needLight, id, name, userData, level, visible, cache } = options, otherOptions = __rest(options, ["image", "color", "width", "height", "position", "rotation", "needLight", "id", "name", "userData", "level", "visible", "cache"]);
    const geometry = new PlaneGeometry(width, height);
    const materialOpts = image ? Object.assign(Object.assign({ transparent: true }, otherOptions), { map: createTexture(image, cache !== null && cache !== void 0 ? cache : true, textureCache) }) : otherOptions;
    const material = needLight ? new MeshPhongMaterial(materialOpts) : new MeshBasicMaterial(materialOpts);
    const meshOptios = { id, name, userData, level, visible, };
    const mesh = new BaseMesh(geometry, material, meshOptios);
    if (position) {
        mesh.position.set(position.x, position.y, position.z);
    }
    if (rotation) {
        mesh.rotation.set(rotation.x, rotation.y, rotation.z);
    }
    return mesh;
}
/**
 * 创建多边形 poi mesh
 * @param options
 * @returns
 */
function createPolygonPoiMesh(options, textureCache) {
    const { points, image, color, needLight, id, name, userData, level, visible, cache } = options, otherOptions = __rest(options, ["points", "image", "color", "needLight", "id", "name", "userData", "level", "visible", "cache"]);
    const pos = points.map(p => new Vector3(p.x, p.y, p.z));
    const materialOpts = image ? Object.assign(Object.assign({ transparent: true }, otherOptions), { map: createTexture(image, cache !== null && cache !== void 0 ? cache : true, textureCache) }) : otherOptions;
    const material = needLight ? new MeshPhongMaterial(materialOpts) : new MeshBasicMaterial(materialOpts);
    const { geometry, position, } = getPolygonGeometryInfo(pos);
    const meshOptios = { id, name, userData, level, visible, };
    const mesh = new BaseMesh(geometry, material, meshOptios);
    mesh.position.copy(position);
    return mesh;
}

// BVH
BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
Mesh.prototype.raycast = acceleratedRaycast;
Raycaster.prototype.firstHitOnly = true;
const _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
const _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();
const _instanceIntersects = [];
const _box3 = /*@__PURE__*/ new Box3();
const _mesh = /*@__PURE__*/ new Mesh();
const _sphere = /*@__PURE__*/ new Sphere();
InstancedMesh.prototype.boundingBox = null;
InstancedMesh.prototype.boundingSphere = null;
InstancedMesh.prototype.computeBoundingBox = function () {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
        this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i = 0; i < count; i++) {
        this.getMatrixAt(i, _instanceLocalMatrix);
        _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
        this.boundingBox.union(_box3);
    }
};
InstancedMesh.prototype.computeBoundingSphere = function () {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
        geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i = 0; i < count; i++) {
        this.getMatrixAt(i, _instanceLocalMatrix);
        _sphere.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
        this.boundingSphere.union(_sphere);
    }
};
InstancedMesh.prototype.raycast = function (raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === undefined)
        return;
    // test with bounding sphere first
    if (this.boundingSphere === null)
        this.computeBoundingSphere();
    _sphere.copy(this.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere) === false)
        return;
    // now test each instance
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        // calculate the world matrix for each instance
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        // the mesh represents this single instance
        _mesh.matrixWorld = _instanceWorldMatrix;
        _mesh.raycast(raycaster, _instanceIntersects);
        // process the result of raycast
        for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
            const intersect = _instanceIntersects[i];
            intersect.instanceId = instanceId;
            intersect.object = this;
            intersects.push(intersect);
        }
        _instanceIntersects.length = 0;
    }
};
// Box3
const _box = /*@__PURE__*/ new Box3();
const _vector = /*@__PURE__*/ new Vector3();
Box3.prototype.expandByObject = function (object, precise = false) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);
    if (object.boundingBox !== undefined) {
        if (object.boundingBox === null) {
            object.computeBoundingBox();
        }
        _box.copy(object.boundingBox);
        _box.applyMatrix4(object.matrixWorld);
        this.union(_box);
    }
    else {
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined) {
                const position = geometry.attributes.position;
                for (let i = 0, l = position.count; i < l; i++) {
                    _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
                    this.expandByPoint(_vector);
                }
            }
            else {
                if (geometry.boundingBox === null) {
                    geometry.computeBoundingBox();
                }
                _box.copy(geometry.boundingBox);
                _box.applyMatrix4(object.matrixWorld);
                this.union(_box);
            }
        }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
        this.expandByObject(children[i], precise);
    }
    return this;
};
// Frustum
Frustum.prototype.intersectsObject = function (object) {
    if (object.boundingSphere !== undefined) {
        if (object.boundingSphere === null)
            object.computeBoundingSphere();
        _sphere.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    else {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere);
};

/**
  ____                    ____                          _
 / ___|  ___   ___  _ __ / ___| _ __   __ _  ___ ___   (_)___
 \___ \ / _ \ / _ \| '_ \\___ \| '_ \ / _` |/ __/ _ \  | / __|
  ___) | (_) | (_) | | | |___) | |_) | (_| | (_|  __/_ | \__ \
 |____/ \___/ \___/|_| |_|____/| .__/ \__,_|\___\___(_)/ |___/
                               |_|                   |__/
*/
/**
 * color management
 */
THREE.ColorManagement.enabled = true;
class SoonSpace {
    constructor(param) {
        this.THREE = THREE;
        this.TWEEN = exports;
        this.utils = shared;
        // 
        this.version = configJson.version;
        // 
        this.animation = Animation;
        this.library = library;
        // 
        this.plugins = {};
        this.textureCache = new Map();
        const defaultOptions = {
            showInfo: false,
            showStats: false,
            showViewHelper: false,
            showGrid: false,
            background: {
                color: 0xaedbf4,
                alpha: false,
            },
            fog: false,
            controls: { type: 'free', },
            hoverEnabled: false,
            levelEnabled: false,
            closeInfoLog: false,
            closeWarnLog: false,
            useIndexedDB: true,
            logarithmicDepthBuffer: true,
        };
        const { el, options = {}, events = {}, } = param;
        // 
        this.domElement = document.querySelector(el);
        // 
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        // 
        this.viewport = new Viewport(this.options);
        this.signals = this.viewport.signals;
        this.manager = new Manager(this.viewport);
        if (!this.domElement)
            throw new Error(`In SoonSpace: Can't find element by "${el}"!`);
        this.domElement.appendChild(this.viewport.container);
        this._init();
        this._initEvents(events);
        this._initDefaultSettings();
    }
    /******/
    /******/
    /******* Init methods */
    /******/
    /******/
    _init() {
        const { showGrid, background, fog, controls, closeInfoLog, closeWarnLog, useIndexedDB, } = this.options;
        if (!closeInfoLog) {
            const logoStr = '  ____                    ____                          _               \n' +
                ' / ___|  ___   ___  _ __ / ___| _ __   __ _  ___ ___   (_)___           \n' +
                ' \\___ \\ / _ \\ / _ \\| \'_ \\\\___ \\| \'_ \\ / _` |/ __/ _ \\  | / __| \n' +
                '  ___) | (_) | (_) | | | |___) | |_) | (_| | (_|  __/_ | \\__ \\        \n' +
                ' |____/ \\___/ \\___/|_| |_|____/| .__/ \\__,_|\\___\\___(_)/ |___/     \n' +
                '                               |_|                   |__/               \n';
            log(logoStr, { color: '#3eaf7c', });
            log(configJson.name, { color: '#3eaf7c', 'font-size': '24px', });
            log(`当前版本: ${this.version}`, { color: '#3eaf7c', 'font-size': '12px', });
            log('文档: http://www.xwbuilders.com:8800', { color: '#3eaf7c', 'font-size': '12px', });
            log('样例: http://www.xwbuilders.com:8800/examples', { color: '#3eaf7c', 'font-size': '12px', });
            log('GitHub: https://github.com/soonspacejs', { color: '#3eaf7c', 'font-size': '12px', });
        }
        // init gridhelper
        if (showGrid)
            this.addGridHelper(showGrid === true ? { id: 'defaultGridHelper', } : showGrid);
        // init background
        if (background === null || background === void 0 ? void 0 : background.skyBox) {
            if (isString(background === null || background === void 0 ? void 0 : background.skyBox))
                this.setSphereSkyBackground(background === null || background === void 0 ? void 0 : background.skyBox);
            else if (isObject(background === null || background === void 0 ? void 0 : background.skyBox))
                this.setSkyBackground(background.skyBox.dirPath, background.skyBox.fileNames);
        }
        else if (background === null || background === void 0 ? void 0 : background.img)
            this.setBackgroundImage(background.img);
        else if (background === null || background === void 0 ? void 0 : background.color)
            this.setBackgroundColor(background.color);
        // init fog
        if (fog)
            this.openSceneFog(fog === true ? undefined : fog);
        // init controls options
        if (controls)
            this.setControlsOptions(controls);
        // init closeWarnLog
        if (closeWarnLog)
            window.console.warn = function () {
                // do nothing
            };
        // init indexedDB
        if (useIndexedDB && !window.indexedDB) {
            this.options.useIndexedDB = false;
            window.console.warn('Your browser doesn\'t support a stable version of IndexedDB. Such and such feature will not be available.');
        }
    }
    _initEvents(events) {
        const { modelHover, modelUnHover, modelClick, modelRightClick, modelDblClick, poiHover, poiUnHover, poiClick, poiRightClick, poiDblClick, selectPosition, sceneClick, resize, } = events;
        // model
        if (modelHover)
            this.signals.modelHover.add(modelHover);
        if (modelUnHover)
            this.signals.modelUnHover.add(modelUnHover);
        if (modelClick)
            this.signals.modelClick.add(modelClick);
        if (modelRightClick)
            this.signals.modelRightClick.add(modelRightClick);
        if (modelDblClick)
            this.signals.modelDblClick.add(modelDblClick);
        // poi
        if (poiHover)
            this.signals.poiHover.add(poiHover);
        if (poiUnHover)
            this.signals.poiUnHover.add(poiUnHover);
        if (poiClick)
            this.signals.poiClick.add(poiClick);
        if (poiRightClick)
            this.signals.poiRightClick.add(poiRightClick);
        if (poiDblClick)
            this.signals.poiDblClick.add(poiDblClick);
        // selectPosition
        if (selectPosition)
            this.signals.selectPosition.add(selectPosition);
        // sceneClick
        if (sceneClick)
            this.signals.sceneClick.add(sceneClick);
        // resize
        if (resize)
            this.signals.windowResize.add(resize);
        this.signals.windowResize.dispatch();
        window.addEventListener('resize', () => this.signals.windowResize.dispatch(), false);
    }
    _initDefaultSettings() {
        this.setEnvironment();
        this.setColorSpace('sRGB');
        this.setToneMapping({ type: 'ACESFilmic', exposure: 0.8, });
    }
    /******/
    /******/
    /******* plugins methods */
    /******/
    /******/
    /**
     * 注册插件
     * @param plugin
     * @param name
     */
    registerPlugin(plugin, name) {
        const p = new plugin(this);
        this.plugins[name] = p;
        return p;
    }
    /**
     * 获取已注册插件
     * @param name
     */
    getPlugin(name) {
        if (this.plugins[name])
            return this.plugins[name];
        else
            return null;
    }
    /**
     * 创建插件对象
     * @param info
     * @param {Object3D} object
     */
    createPluginObject(info, object) {
        return this.manager.store.pluginObjectManager.createObject(info, object);
    }
    /**
     * 向插件对象内添加子集
     * @param id
     * @param object
     * @returns {PluginObject | null}
     */
    addToPluginObject(id, object) {
        const pluginObject = this.getObjectById(id);
        return this.manager.store.pluginObjectManager.addToObject(pluginObject, object);
    }
    /**
     * 根据 ID 获取插件对象
     * @param id
     */
    getPluginObjectById(id) {
        warn('getPluginObjectById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据名称获取插件对象
     * @param name
     */
    getPluginObjectByName(name) {
        warn('getPluginObjectByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据 ID 移除插件对象
     * @param id
     */
    removePluginObjectById(id) {
        warn('removePluginObjectById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /******/
    /******/
    /******* Viewport methods */
    /******/
    /******/
    /**
     * 设置空间反射
     * @param options
     */
    setSSR(options) {
        this.viewport.setSSR(options);
    }
    /**
     * 设置泛光
     * @param bloom
     */
    setBloom(options) {
        this.viewport.setBloom(options);
    }
    /**
     * 环境光遮蔽
     * @param options
     */
    setSSAO(options) {
        this.viewport.setSSAO(options);
    }
    // setSSGI ( options?: SSGIOptions ) {
    //   this.viewport.setSSGI( options )
    // }
    /**
     * 设置场景的颜色空间
     * @param colorSpace
     */
    setColorSpace(colorSpace) {
        this.viewport.setColorSpace(colorSpace);
    }
    /**
     * 设置场景色调
     * @param options
     */
    setToneMapping(options) {
        this.viewport.setToneMapping(options);
    }
    /**
     * 设置开启鼠标悬浮
     * @param enabled
     */
    setHoverEnabled(enabled) {
        this.viewport.setHoverEnabled(enabled);
    }
    /**
     * 设置背景色
     * @param color
     */
    setBackgroundColor(color) {
        this.viewport.setBackgroundColor(color);
    }
    /**
     * 设置透明度背景色
     * @param color
     * @param alpha
     */
    setBackgroundColorAlpha(color, alpha) {
        this.viewport.setBackgroundColorAlpha(color, alpha);
    }
    /**
     * 设置背景图
     * @param imgUrl
     */
    setBackgroundImage(imgUrl) {
        return this.viewport.setBackgroundImage(imgUrl);
    }
    /**
     * 设置球形天空背景
     * @param imgUrl
     */
    setSphereSkyBackground(imgUrl) {
        return this.viewport.setSphereSkyBackground(imgUrl);
    }
    /**
     * 设置天空背景
     * @param dirPath
     * @param fileNames
     */
    setSkyBackground(dirPath, fileNames) {
        return this.viewport.setSkyBackground(dirPath, fileNames);
    }
    /**
     * 设置场景环境
     * @returns
     */
    setEnvironment(options) {
        return this.viewport.setEnvironment(options);
    }
    /**
     * 播放模型动画
     * @param model
     * @param animation
     */
    playModelAnimation(model, animation) {
        return this.viewport.playModelAnimation(model, animation);
    }
    /**
     * 停止播放模型动画
     * @param model
     * @param animation
     */
    stopModelAnimation(model, animation) {
        this.viewport.stopModelAnimation(model, animation);
    }
    /**
     * 通过空间坐标点获取屏幕坐标点
     * @param position
     */
    getOffsetByPosition(position) {
        return this.viewport.getOffsetByPosition(position);
    }
    /**
     * 通过屏幕坐标点获取空间坐标点
     * @param offset
     * @param z
     */
    getPositionByOffset(offset, z) {
        return this.viewport.getPositionByOffset(offset, z);
    }
    /**
     * 手动渲染一次场景
     * @param fn
     */
    render(fn) {
        return this.viewport.render(fn);
    }
    /**
     * 清除事件信号监听
     */
    clearSignals() {
        this.viewport.clearSignals();
    }
    /**
     * 销毁场景
     */
    dispose() {
        this.manager.dispose();
        this.viewport.dispose();
    }
    /******/
    /******/
    /******* Viewport cameraManager methods */
    /******/
    /******/
    /**
     * 获取当前相机视角数据（free）
     */
    getCameraViewpoint() {
        return this.viewport.cameraManager.getCameraViewpoint();
    }
    /**
     * 设置相机视角数据（free）
     */
    setCameraViewpoint(data) {
        this.viewport.cameraManager.setCameraViewpoint(data);
    }
    /**
     * 获取当前相机视角数据（orbit）
     */
    getCameraTargetView() {
        return this.viewport.cameraManager.getCameraViewpoint();
    }
    /**
     * 设置相机视角数据（orbit）
     */
    setCameraTargetView(data) {
        this.viewport.cameraManager.setCameraViewpoint(data);
    }
    /**
     * 相机飞向
     * @param position
     * @param rotation
     * @param options
     */
    flyTo(position, rotation = 'frontTop', options) {
        if (this.viewport.controls.options.type === 'orbit') {
            this.utils.warn('flyTo 方法不适用于 orbit 控制器');
        }
        return this.viewport.cameraManager.flyTo(position, rotation, options);
    }
    /**
     * 相机飞向包围盒
     * @param bbox
     * @param viewpoint
     * @param options
     */
    flyToBoundingBox(bbox, viewpoint = 'frontTop', options) {
        return this.viewport.cameraManager.flyToBoundingBox(bbox, viewpoint, options);
    }
    /**
     * 相机飞向对象
     * @param object
     * @param viewpoint
     * @param options
     */
    flyToObj(object, rotation = 'frontTop', options) {
        return this.viewport.cameraManager.flyToObj(object, rotation, options);
    }
    /**
     * 相机飞向主场景
     * @param viewpoint
     * @param options
     */
    flyMainViewpoint(viewpoint = 'frontTop', options) {
        return this.flyToObj(this.manager.scene, viewpoint, options);
    }
    /**
     * 相机在目标点上环绕
     * @param target
     * @param options
     */
    surroundOnTarget(target, options) {
        return this.viewport.cameraManager.surroundOnTarget(target, options);
    }
    /**
     * 相机在对象上环绕
     * @param object
     * @param options
     */
    surroundOnObject(object, options) {
        return this.viewport.cameraManager.surroundOnObject(object, options);
    }
    /**
     * 获取对象的标签位置坐标
     * @param object
     * @param options
     */
    getObjectLabelPos(object, rotation = 'frontTop', options) {
        return this.viewport.cameraManager.getObjectLabelPos(object, rotation, options);
    }
    /******/
    /******/
    /******* Viewport Controls methods */
    /******/
    /******/
    /**
     * 设置控制器配置
     * @param options
     */
    setControlsOptions(options) {
        return this.viewport.controls.setOptions(options);
    }
    /******/
    /******/
    /******* Viewport Scener methods */
    /******/
    /******/
    /**
     * 添加对象
     * @param object
     * @param parent
     */
    addObject(object, parent) {
        this.viewport.scener.addObject(object, parent);
    }
    /**
     * 移除对象
     * @param object
     */
    removeObject(object) {
        this.viewport.scener.removeObject(object);
    }
    /**
     * 开启场景雾化
     * @param options
     */
    openSceneFog(options) {
        this.viewport.scener.openSceneFog(options);
    }
    /**
     * 关闭场景雾化
     */
    closeSceneFog() {
        this.viewport.scener.closeSceneFog();
    }
    setSky(options) {
        return this.viewport.setSky(options);
    }
    /**
     * @deprecated use screenshot instead
     * @returns
     */
    getScreenshot() {
        return this.screenshot();
    }
    /**
     * 截屏
     * @returns
     */
    screenshot() {
        return this.viewport.screenshot();
    }
    /**
     * 轮廓显示模型
     * @param object
     * @param options
     */
    edgeShow(object, options) {
        return this.viewport.scener.edgeShow(object, options);
    }
    /**
     * 取消轮廓显示模型
     * @param objects
     */
    unEdgeShow(objects) {
        return this.viewport.scener.unEdgeShow(objects);
    }
    /**
     * 描边显示模型
     * @param object
     * @param options
     */
    strokeShow(object, options) {
        return this.viewport.scener.strokeShow(object, options);
    }
    /**
     * 取消描边显示模型
     * @param objects
     */
    unStrokeShow(objects) {
        return this.viewport.scener.unStrokeShow(objects);
    }
    /**
     * 透明显示模型
     * @param object
     * @param options
     */
    opacityShow(object, options) {
        return this.viewport.scener.opacityShow(object, options);
    }
    /**
     * 取消透明显示模型
     * @param objects
     */
    unOpacityShow(objects) {
        return this.viewport.scener.unOpacityShow(objects);
    }
    /**
     * 高亮显示模型
     * @param object
     * @param options
     */
    highlightShow(object, options) {
        return this.viewport.scener.highlightShow(object, options);
    }
    /**
     * 取消高亮显示模型
     * @param objects
     */
    unHighlightShow(objects) {
        return this.viewport.scener.unHighlightShow(objects);
    }
    /**
     * 自发光显示模型
     * @param object
     * @param options
     */
    emissiveShow(object, options) {
        return this.viewport.scener.emissiveShow(object, options);
    }
    /**
     * 取消自发光显示模型
     * @param objects
     */
    unEmissiveShow(objects) {
        return this.viewport.scener.unEmissiveShow(objects);
    }
    /******/
    /******/
    /******* Manager methods */
    /******/
    /******/
    /**
     * 清除除灯光外所有对象
     */
    clearObject() {
        this.manager.clearObject();
    }
    /**
     * 清除所有对象
     */
    clear() {
        this.manager.clear();
    }
    /******/
    /******/
    /******* Light methods */
    /******/
    /******/
    /**
     * 创建环境关
     * @param options
     */
    createAmbientLight(options) {
        return this.manager.store.lightManager.createAmbientLight(options);
    }
    /**
     * 设置环境关
     * @param options
     */
    setAmbientLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setAmbientLight(light, options);
    }
    /**
     * 创建平行光
     * @param options
     */
    createDirectionalLight(options) {
        return this.manager.store.lightManager.createDirectionalLight(options);
    }
    /**
     * 设置平行光
     * @param options
     */
    setDirectionalLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setDirectionalLight(light, options);
    }
    /**
     * 创建半球光
     * @param options
     */
    createHemisphereLight(options) {
        return this.manager.store.lightManager.createHemisphereLight(options);
    }
    /**
     * 设置半球光
     * @param options
     */
    setHemisphereLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setHemisphereLight(light, options);
    }
    /**
     * 创建聚光灯
     * @param options
     */
    createSpotLight(options) {
        return this.manager.store.lightManager.createSpotLight(options);
    }
    /**
     * 设置聚光灯
     * @param options
     */
    setSpotLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setSpotLight(light, options);
    }
    /**
     * 创建点光源
     * @param options
     */
    createPointLight(options) {
        return this.manager.store.lightManager.createPointLight(options);
    }
    /**
     * 设置点光源
     * @param options
     */
    setPointLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setPointLight(light, options);
    }
    /**
     * 创建矩形区域光源
     * @param options
     * @returns
     */
    createRectAreaLight(options) {
        return this.manager.store.lightManager.createRectAreaLight(options);
    }
    /**
     * 设置矩形区域光源
     * @param options
     * @returns
     */
    setRectAreaLight(options) {
        const light = this.getObjectById(options.id);
        return this.manager.store.lightManager.setRectAreaLight(light, options);
    }
    /**
     * 根据 id 查询 Light 对象
     * @param id
     */
    getLightById(id) {
        warn('getLightById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 id 移除 Light 对象
     * @param id
     */
    removeLightById(id) {
        warn('removeLightById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 获取所有 Light 对象
     */
    getAllLight() {
        return this.manager.store.lightManager.getAll();
    }
    /**
     * 清空 Light 对象
     */
    clearLight() {
        return this.manager.store.lightManager.clear();
    }
    /**
     * 显示所有光
     */
    showAllLight() {
        return this.manager.store.lightManager.showAll();
    }
    /**
     * 隐藏所有光
     */
    hideAllLight() {
        return this.manager.store.lightManager.hideAll();
    }
    /**
     * 更新所有灯光阴影
     * @returns
     */
    updateAllShadow() {
        return this.manager.store.lightManager.updateAllShadow();
    }
    /******/
    /******/
    /******* Object methods */
    /******/
    /******/
    getObjectById(id) {
        return this.manager.getObjectById(id);
    }
    getObjectByName(name) {
        return this.manager.getObjectByName(name);
    }
    getObjectByUserDataProperty(property, value) {
        return this.manager.getObjectByUserDataProperty(property, value);
    }
    removeObjectById(id) {
        return this.manager.removeObjectById(id);
    }
    /******/
    /******/
    /******* Group methods */
    /******/
    /******/
    createGroup(groupInfo) {
        return this.manager.store.groupManager.createGroup(groupInfo);
    }
    getGroupById(id) {
        warn('getGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    getGroupByName(name) {
        warn('getGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    getAllGroup() {
        return this.manager.store.groupManager.getAll();
    }
    showAllGroup() {
        return this.manager.store.groupManager.showAll();
    }
    hideAllGroup() {
        return this.manager.store.groupManager.hideAll();
    }
    removeGroupById(id) {
        warn('removeGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /******/
    /******* deprecated  */
    /******* Sbm methods */
    /******/
    /******/
    loadSbm(sbmInfo) {
        warn('loadSbm is deprecated, use loadModel instead');
        return this.loadModel(sbmInfo);
    }
    parseSbm() {
        warn('parseSbm is deprecated!');
    }
    cloneSbm(model, sbmInfo, parent) {
        warn('cloneSbm is deprecated, use cloneModel instead');
        return this.cloneModel(model, sbmInfo, parent);
    }
    getSbmById(id) {
        warn('getSbmById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    getSbmByName(name) {
        warn('getSbmByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    getSbmByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getSbmByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    removeSbmById(id) {
        warn('removeSbmById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    createGroupForSbm(groupInfo) {
        warn('createGroupForSbm is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    loadSbmToGroup(groupInfo, sbmInfoList) {
        warn('loadSbmToGroup is deprecated, use loadModelToGroup instead');
        return this.loadModelToGroup(groupInfo, sbmInfoList);
    }
    addSbmForGroup(groupId, sbmInfoList) {
        warn('addSbmForGroup is deprecated, use addModelForGroup instead');
        return this.addModelForGroup(groupId, sbmInfoList);
    }
    createSbmGroupFromXml() {
        warn('createGroupForSbm is deprecated!');
    }
    getSbmGroupById(id) {
        warn('getSbmGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    getSbmGroupByName(name) {
        warn('getSbmGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    getAllSbmGroup() {
        warn('getAllSbmGroup is deprecated, use getAllGroup instead');
        return this.getAllGroup();
    }
    removeSbmGroupById(id) {
        warn('removeSbmGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    clearSbm() {
        warn('clearSbm is deprecated, use clearModel instead');
        return this.clearModel();
    }
    getAllSbm() {
        warn('getAllSbm is deprecated, use getAllModel instead');
        return this.getAllModel();
    }
    showAllSbm() {
        warn('showAllSbm is deprecated, use showAllModel instead');
        return this.showAllModel();
    }
    hideAllSbm() {
        warn('hideAllSbm is deprecated, use hideAllModel instead');
        return this.hideAllModel();
    }
    getSbmModelMaps() {
        warn('getSbmModelMaps is deprecated, use getModelsMap instead');
        return this.getModelsMap();
    }
    setSbmModelMaps(maps) {
        warn('setSbmModelMaps is deprecated, use setModelsMap instead');
        return this.setModelsMap(maps);
    }
    /******/
    /******/
    /******* Model methods */
    /******/
    /******/
    /**
     * 设置 GLTF 模型的 DRACO 解压库路径
     * @param path
     * @returns
     */
    setModelDracoDecoderPath(path) {
        return this.manager.store.modelManager.setDracoDecoderPath(path);
    }
    /**
     * 加载 Model 模型
     * @param modelInfo
     * @param parent
     */
    loadModel(modelInfo) {
        return this.manager.store.modelManager.load(modelInfo);
    }
    /**
     * 克隆 Model 模型
     * @param model
     * @param modelInfo
     * @param parent
     */
    cloneModel(model, modelInfo, parent) {
        return this.manager.store.modelManager.clone(model, modelInfo, parent);
    }
    /**
     * 根据 id 查询 Model 模型
     * @param id
     */
    getModelById(id) {
        warn('getModelById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Model 模型
     * @param name
     */
    getModelByName(name) {
        warn('getModelByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据用户数据查询 Model 模型
     * @param name
     */
    getModelByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getModelByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    /**
     * 根据 id 删除 Model 模型
     * @param id
     */
    removeModelById(id) {
        warn('removeModelById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 为 Model 创建组
     * @param groupInfo
     */
    createGroupForModel(groupInfo) {
        warn('createGroupForModel is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    /**
     * 加载 Model 模型到组内
     * @param groupInfo
     * @param modelInfo
     */
    loadModelToGroup(groupInfo, modelInfo) {
        return this.manager.store.modelManager.loadToGroup(groupInfo, modelInfo);
    }
    /**
     * 为已有的组添加 Model 模型
     * @param groupId
     * @param modelInfo
     */
    addModelForGroup(groupId, modelInfo) {
        const group = this.getObjectById(groupId);
        return this.manager.store.modelManager.addForGroup(group, modelInfo);
    }
    /**
     * 根据 id 查询 Model 模型组
     * @param id
     */
    getModelGroupById(id) {
        warn('getModelGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Model 模型组
     * @param name
     */
    getModelGroupByName(name) {
        warn('getModelGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 获取所有 Model 模型组
     */
    getAllModelGroup() {
        warn('getAllModelGroup is deprecated, use getAllGroup instead');
        return this.getAllGroup();
    }
    /**
     * 根据 id 删除 Model 模型组
     * @param id
     */
    removeModelGroupById(id) {
        warn('removeModelGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空 Model 模型
     */
    clearModel() {
        return this.manager.store.modelManager.clear();
    }
    /**
     * 获取所有 Model 模型
     */
    getAllModel() {
        return this.manager.store.modelManager.getAll();
    }
    /**
     * 显示所有 Model 模型
     */
    showAllModel() {
        return this.manager.store.modelManager.showAll();
    }
    /**
     * 隐藏所有 Model 模型
     */
    hideAllModel() {
        return this.manager.store.modelManager.hideAll();
    }
    /**
     * 计算 model bvh
     */
    computeModelsBoundsTree(options) {
        return this.viewport.bvh.computeModelsBoundsTree(options);
    }
    /**
     * 清空本地模型缓存数据
     */
    clearIdb() {
        return this.manager.store.modelManager.clearIdb();
    }
    /**
     * 获取 Model 模型缓存
     */
    getModelsMap() {
        return this.manager.store.modelManager.modelsMap;
    }
    /**
     * 设置 Model 模型缓冲
     */
    setModelsMap(map) {
        this.manager.store.modelManager.modelsMap = map;
    }
    /******/
    /******/
    /******* Poi methods */
    /******/
    /******/
    /**
     * 创建 Poi
     * @param info
     */
    createPoi(info) {
        return this.manager.store.poiManager.create(info);
    }
    /**
     * 克隆 Poi
     * @param info
     */
    clonePoi(poi, poiInfo, parent) {
        return this.manager.store.poiManager.clone(poi, poiInfo, parent);
    }
    /**
     * 根据 id 查询 Poi
     * @param id
     */
    getPoiById(id) {
        warn('getPoiById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Poi
     * @param id
     */
    getPoiByName(name) {
        warn('getPoiByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据用户数据查询 Poi
     * @param name
     */
    getPoiByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getPoiByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    /**
     * 根据 id 删除 Poi
     * @param id
     */
    removePoiById(id) {
        warn('removePoiById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 为 Poi 创建组
     * @param groupInfo
     */
    createGroupForPoi(groupInfo) {
        warn('createGroupForPoi is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    /**
     * 创建 Poi 到组内
     * @param groupInfo
     * @param poiInfo
     */
    createPoiToGroup(groupInfo, poiInfo) {
        return this.manager.store.poiManager.createToGroup(groupInfo, poiInfo);
    }
    /**
     * 为已有的组添加 Poi
     * @param groupInfo
     * @param poiInfo
     */
    addPoiForGroup(groupId, poiInfo) {
        const group = this.getObjectById(groupId);
        return this.manager.store.poiManager.addForGroup(group, poiInfo);
    }
    /**
     * 根据 id 查询 Poi 组
     * @param id
     */
    getPoiGroupById(id) {
        warn('getPoiGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Poi 组
     * @param name
     */
    getPoiGroupByName(name) {
        warn('getPoiGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 获取所有 Poi 模型组
     */
    getAllPoiGroup() {
        warn('getAllPoiGroup is deprecated, use getAllGroup instead');
        return this.getAllGroup();
    }
    /**
     * 根据 id 删除 Poi 组
     * @param id
     */
    removePoiGroupById(id) {
        warn('removePoiGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空 Poi
     */
    clearPoi() {
        return this.manager.store.poiManager.clear();
    }
    /**
     * 获取所有 Poi 模型
     */
    getAllPoi() {
        return this.manager.store.poiManager.getAll();
    }
    /**
     * 显示所有 Poi
     */
    showAllPoi() {
        return this.manager.store.poiManager.showAll();
    }
    /**
     * 隐藏所有 Poi
     */
    hideAllPoi() {
        return this.manager.store.poiManager.hideAll();
    }
    /******/
    /******/
    /******* PoiNode methods */
    /******/
    /******/
    /**
     * 创建 PoiNode
     * @param info
     */
    createPoiNode(info) {
        return this.manager.store.poiNodeManager.create(info);
    }
    /**
     * 根据 id 查询 PoiNode
     * @param id
     */
    getPoiNodeById(id) {
        warn('getPoiNodeById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 PoiNode
     * @param id
     */
    getPoiNodeByName(name) {
        warn('getPoiNodeByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据用户数据查询 PoiNode
     * @param name
     */
    getPoiNodeByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getPoiNodeByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    /**
     * 根据 id 删除 PoiNode
     * @param id
     */
    removePoiNodeById(id) {
        warn('removePoiNodeById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 为 PoiNode 创建组
     * @param groupInfo
     */
    createGroupForPoiNode(groupInfo) {
        warn('createGroupForPoiNode is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    /**
     * 创建 PoiNode 到组内
     * @param groupInfo
     * @param poiNodeInfo
     */
    createPoiNodeToGroup(groupInfo, poiNodeInfo) {
        return this.manager.store.poiNodeManager.createToGroup(groupInfo, poiNodeInfo);
    }
    /**
     * 为已有的组添加 PoiNode
     * @param groupInfo
     * @param poiNodeInfo
     */
    addPoiNodeForGroup(groupId, poiNodeInfo) {
        const group = this.getObjectById(groupId);
        return this.manager.store.poiNodeManager.addForGroup(group, poiNodeInfo);
    }
    /**
     * 根据 id 查询 PoiNode 组
     * @param id
     */
    getPoiNodeGroupById(id) {
        warn('getPoiNodeGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 PoiNode 组
     * @param name
     */
    getPoiNodeGroupByName(name) {
        warn('getPoiNodeGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 获取所有 PoiNode 模型组
     */
    getAllPoiNodeGroup() {
        warn('getAllPoiNodeGroup is deprecated, use getAllGroup instead');
        return this.getAllGroup();
    }
    /**
     * 根据 id 删除 PoiNode 组
     * @param id
     */
    removePoiNodeGroupById(id) {
        warn('removePoiNodeGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空 PoiNode
     */
    clearPoiNode() {
        return this.manager.store.poiNodeManager.clear();
    }
    /**
     * 获取所有 PoiNode 模型
     */
    getAllPoiNode() {
        return this.manager.store.poiNodeManager.getAll();
    }
    /**
     * 显示所有 PoiNode
     */
    showAllPoiNode() {
        return this.manager.store.poiNodeManager.showAll();
    }
    /**
     * 隐藏所有 PoiNode
     */
    hideAllPoiNode() {
        return this.manager.store.poiNodeManager.hideAll();
    }
    /**
     * 创建 poi mesh
     * @param options
     * @returns
     */
    createPoiMesh(options) {
        const poi = createPoiMesh(options, this.textureCache);
        this.addObject(poi);
        return poi;
    }
    /**
     * 创建多边形 poi mesh
     * @param options
     * @returns
     */
    createPolygonPoiMesh(options) {
        const poi = createPolygonPoiMesh(options, this.textureCache);
        this.addObject(poi);
        return poi;
    }
    /**
     * 给 mesh 设置纹理贴图
     * @param mesh - 需要设置的 Mesh 对象
     * @param image - 图片 url ，或 图片元素、Canvas元素、Video 元素、null
     * @param options - 选项
     * @returns 返回设置的纹理对象
     */
    setTexture(mesh, image, options = {}) {
        const { cache = true, independ = true, } = options || {};
        let material = mesh.material;
        if (independ) {
            material = material.clone();
            mesh.material = material;
        }
        if (image === null) {
            material.map = null;
            this.render();
            return null;
        }
        const texture = setTexture(material, image, cache, this.textureCache);
        this.render();
        return texture;
    }
    /******/
    /******/
    /******* Canvas3D methods */
    /******/
    /******/
    /**
     * 创建 Canvas3D
     * @param info
     */
    createCanvas3D(info) {
        return this.manager.store.canvas3DManager.create(info);
    }
    /**
     * 根据 id 查询 Canvas3D
     * @param id
     */
    getCanvas3DById(id) {
        warn('getCanvas3DById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Canvas3D
     * @param id
     */
    getCanvas3DByName(name) {
        warn('getCanvas3DByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据用户数据查询 Canvas3D
     * @param name
     */
    getCanvas3DByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getCanvas3DByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    /**
     * 根据 id 删除 Canvas3D
     * @param id
     */
    removeCanvas3DById(id) {
        warn('removeCanvas3DById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 为 Canvas3D 创建组
     * @param groupInfo
     */
    createGroupForCanvas3D(groupInfo) {
        warn('createGroupForCanvas3D is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    /**
     * 创建 Canvas3D 到组内
     * @param groupInfo
     * @param canvasInfo
     */
    createCanvas3DToGroup(groupInfo, canvasInfo) {
        return this.manager.store.canvas3DManager.createToGroup(groupInfo, canvasInfo);
    }
    /**
     * 为已有的组添加 Canvas3D
     * @param groupInfo
     * @param canvasInfo
     */
    addCanvas3DForGroup(groupId, canvasInfo) {
        const group = this.getObjectById(groupId);
        return this.manager.store.canvas3DManager.addForGroup(group, canvasInfo);
    }
    /**
     * 根据 id 查询 Canvas3D 组
     * @param id
     */
    getCanvas3DGroupById(id) {
        warn('getCanvas3DGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Canvas3D 组
     * @param name
     */
    getCanvas3DGroupByName(name) {
        warn('getCanvas3DGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 获取所有 Canvas3D 模型组
     */
    getAllCanvas3DGroup() {
        warn('getAllCanvas3DGroup is deprecated, use getAllGroup instead');
        return this.getAllGroup();
    }
    /**
     * 根据 id 删除 Canvas3D 组
     * @param id
     */
    removeCanvas3DGroupById(id) {
        warn('removeCanvas3DGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空 Canvas3D
     */
    clearCanvas3D() {
        return this.manager.store.canvas3DManager.clear();
    }
    /**
     * 获取所有 Canvas3D 模型
     */
    getAllCanvas3D() {
        return this.manager.store.canvas3DManager.getAll();
    }
    /**
     * 显示所有 Canvas3D
     */
    showAllCanvas3D() {
        return this.manager.store.canvas3DManager.showAll();
    }
    /**
     * 隐藏所有 Canvas3D
     */
    hideAllCanvas3D() {
        return this.manager.store.canvas3DManager.hideAll();
    }
    /******/
    /******/
    /******* Topology methods */
    /******/
    /******/
    /**
     * 获取最短路径
     * @param topology
     * @param info
     */
    getShortestPath(topology, info) {
        return this.manager.store.topologyManager.getShortestPath(topology, info);
    }
    /**
     * 通过多个起点获取最短路径
     * @param topology
     * @param info
     */
    getShortestPathByMultipleStartPoints(topology, info) {
        return this.manager.store.topologyManager.getShortestPathByMultipleStartPoints(topology, info);
    }
    /**
     * 通过多个终点获取最短路径
     * @param topology
     * @param info
     */
    getShortestPathByMultipleEndPoints(topology, info) {
        return this.manager.store.topologyManager.getShortestPathByMultipleEndPoints(topology, info);
    }
    /**
     * 创建 Topology，从 gml 文件资源
     * @param groupInfo
     * @param gmlUrl
     */
    createTopologyFromGml(topologyInfo) {
        return this.manager.store.topologyManager.createFromGml(topologyInfo);
    }
    /**
     * 创建 Topology
     * @param info
     */
    createTopology(info) {
        return this.manager.store.topologyManager.create(info);
    }
    /**
     * 重置 Topology nodes
     * @param info
     */
    resetTopologyNodes(topology, nodes) {
        return this.manager.store.topologyManager.resetNodes(topology, nodes);
    }
    /**
     * 根据 id 查询 Topology
     * @param id
     */
    getTopologyById(id) {
        warn('getTopologyById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Topology
     * @param id
     */
    getTopologyByName(name) {
        warn('getTopologyByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 根据用户数据查询 Topology
     * @param name
     */
    getTopologyByUserDataProperty(propNameOrFindFunc, propValue) {
        warn('getTopologyByUserDataProperty is deprecated, use getObjectByUserDataProperty instead');
        return this.getObjectByUserDataProperty(propNameOrFindFunc, propValue);
    }
    /**
     * 根据 id 删除 Topology
     * @param id
     */
    removeTopologyById(id) {
        warn('removeTopologyById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 为 Topology 创建组
     * @param groupInfo
     */
    createGroupForTopology(groupInfo) {
        warn('createGroupForTopology is deprecated, use createGroup instead');
        return this.createGroup(groupInfo);
    }
    /**
     * 创建 Topology 到组内
     * @param groupInfo
     * @param topologyInfo
     */
    createTopologyToGroup(groupInfo, topologyInfo) {
        return this.manager.store.topologyManager.createToGroup(groupInfo, topologyInfo);
    }
    /**
     * 为已有的组添加 Topology
     * @param groupInfo
     * @param topologyInfo
     */
    addTopologyForGroup(groupId, topologyInfo) {
        const group = this.getObjectById(groupId);
        return this.manager.store.topologyManager.addForGroup(group, topologyInfo);
    }
    /**
     * 根据 id 查询 Topology 组
     * @param id
     */
    getTopologyGroupById(id) {
        warn('getTopologyGroupById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 根据 name 查询 Topology 组
     * @param name
     */
    getTopologyGroupByName(name) {
        warn('getTopologyGroupByName is deprecated, use getObjectByName instead');
        return this.getObjectByName(name);
    }
    /**
     * 获取所有 Topology 模型组
     */
    getAllTopologyGroup() {
        warn('getAllTopologyGroup is deprecated, use getAllGroups instead');
        return this.getAllGroup();
    }
    /**
     * 根据 id 删除 Topology 组
     * @param id
     */
    removeTopologyGroupById(id) {
        warn('removeTopologyGroupById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空 Topology
     */
    clearTopology() {
        return this.manager.store.topologyManager.clear();
    }
    /**
     * 获取所有 Topology 模型
     */
    getAllTopology() {
        return this.manager.store.topologyManager.getAll();
    }
    /**
     * 显示所有 Topology
     */
    showAllTopology() {
        return this.manager.store.topologyManager.showAll();
    }
    /**
     * 隐藏所有 Topology
     */
    hideAllTopology() {
        return this.manager.store.topologyManager.hideAll();
    }
    /******/
    /******/
    /******* Helper methods */
    /******/
    /******/
    /**
     * 添加网格辅助器
     * @param options
     */
    addGridHelper(options) {
        return this.manager.store.helperManager.addGridHelper(options);
    }
    /**
     * 添加轴线辅助器
     * @param options
     */
    addAxesHelper(options) {
        return this.manager.store.helperManager.addAxesHelper(options);
    }
    /**
     * 添加包围盒辅助器
     * @param options
     */
    addBoxHelper(options) {
        return this.manager.store.helperManager.addBoxHelper(options);
    }
    /**
     * 添加面辅助器
     * @param options
     */
    addPlaneHelper(options) {
        return this.manager.store.helperManager.addPlaneHelper(options);
    }
    /**
     * 创建地面
     * @param options
     */
    createGround(options) {
        warn('In soonspacejs: \'createGround\' 已弃用，请使用 \'addGroundHelper\'!');
        return this.addGroundHelper(options);
    }
    /**
     * 添加地面辅助器
     * @param options
     */
    addGroundHelper(options) {
        return this.manager.store.helperManager.addGroundHelper(options);
    }
    /**
     * 添加平行光辅助器
     * @param options
     */
    addDirectionalLightHelper(options) {
        return this.manager.store.helperManager.addDirectionalLightHelper(options);
    }
    /**
     * 添加半球光辅助器
     * @param options
     */
    addHemisphereLightHelper(options) {
        return this.manager.store.helperManager.addHemisphereLightHelper(options);
    }
    /**
     * 添加聚光灯辅助器
     * @param options
     */
    addSpotLightHelper(options) {
        return this.manager.store.helperManager.addSpotLightHelper(options);
    }
    /**
     * 添加点光辅助器
     * @param options
     */
    addPointLightHelper(options) {
        return this.manager.store.helperManager.addPointLightHelper(options);
    }
    /**
     * 添加矩形区域光辅助器
     * @param options
     * @returns
     */
    addRectAreaLightHelper(options) {
        return this.manager.store.helperManager.addRectAreaLightHelper(options);
    }
    /**
     * 通过 ID 获取辅助器
     * @param id
     */
    getHelperById(id) {
        warn('getHelperById is deprecated, use getObjectById instead');
        return this.getObjectById(id);
    }
    /**
     * 通过 ID 移除辅助器
     * @param id
     */
    removeHelperById(id) {
        warn('removeHelperById is deprecated, use removeObjectById instead');
        return this.removeObjectById(id);
    }
    /**
     * 清空辅助器
     */
    clearHelper() {
        return this.manager.store.helperManager.clear();
    }
    /**
     * 显示所有辅助器
     */
    showAllHelper() {
        return this.manager.store.helperManager.showAll();
    }
    /**
     * 隐藏所有辅助器
     */
    hideAllHelper() {
        return this.manager.store.helperManager.hideAll();
    }
    /**
     * 创建用于 查找位置附近的 box 空间范围内的物体 的查找器
     * @param boxSpace - 描述查找空间的信息对象
     * @param objects - 所有需要被查找的对象
     * @returns 用于查找的函数
     */
    createFindObjectsInBoxNearPosition(boxSpace, objects) {
        return createFindObjectsInBoxNearPosition(boxSpace, objects);
    }
    /**
     * 创建用于 查找位置附近的球形区域范围内的物体 的查找器
     *
     * @param radius - 描述查找半径
     * @param objects - 所有需要被查找的对象
     * @returns 用于查找的函数
     */
    createFindObjectsInSphereNearPosition(radius, objects) {
        return createFindObjectsInSphereNearPosition(radius, objects);
    }
    /**
   *  创建用于 查找路径附近的范围内的物体 的查找器
   *
   * @param points - 描述路径的点
   * @param radius - 描述查找半径
   * @returns 用于查找的函数
   */
    createFindObjectsNearPath(points, radius) {
        return createFindObjectsNearPath(points, radius);
    }
    /**
     * 创建路径动画
     * @param target - 被动画的目标对象
     * @param points - 路径点列表
     * @param options - 选项
     * @returns
     */
    createPathAnimation(target, points, options) {
        return new PathAnimation(target, points, options);
    }
    /**
     * 创建沿拓扑路径运动的动画
     * @param target - 被动画的目标对象
     * @param topology - 拓扑路径
     * @param options - 选项
     * @returns
     */
    createTopologyAnimation(target, topology, options) {
        const points = topology.nodes.map((node) => {
            return node.getWorldPosition(new Vector3());
        });
        return new PathAnimation(target, points, options);
    }
    /**
     * 创建沿路径运动的动画 action
     *
     * @param target
     * @param path
     * @param options
     * @returns 返回 AnimationOperate，它是对 AnimationAction 的扩展
     */
    createPathAnimationAction(target, path, options) {
        return createPathAnimation(target, path, this, options);
    }
    /**
     * 创建相机动画
     * @param path
     * @param mixer
     * @param options
     * @returns
     */
    createPathAnimationActionForCamera(path, options) {
        var _a;
        const camera = (_a = options === null || options === void 0 ? void 0 : options.camera) !== null && _a !== void 0 ? _a : this.viewport.camera;
        return createPathAnimationActionForCamera(camera, path, this, options);
    }
    /**
     * 创建骨骼路径动画
     * @param options
     * @returns
     */
    createBonePathAnimation(model, path, options) {
        return createBonePathAnimation(model, path, this, options);
    }
}
SoonSpace.THREE = THREE;
SoonSpace.TWEEN = exports;
SoonSpace.utils = shared;

export { Ee as AnimationActionController, Ge as AnimationActionKeyframe, qe as AnimationActionOperate, Ve as AnimationClipKeyframe, Ot as DirectionSide, ae as GuiAnimationActionController, SoonSpace, boundingIsIntersected, Le as configVertexWeightByEquallyDivided, re as configVertexWeightForChainBones, Ye as configVertexWeightForEqualChainBones, $e as createAnimationOperate, rn as createBonePathAnimation, oe as createChainBones, Vt as createChainBonesByAxials, Ae as createChainBonesByJoints, Ce as createChainSkeletalModel, Ze as createChainSkinnedMesh, tn as createChainSkinnedMeshForMesh, on as createCurveAnimationClip, Re as createCurveAnimationClipByCurve, Ne as createCurveAnimationClipByPolyline, Ke as createCurveAnimationClipForBones, sn as createCurveAnimationClipForBonesTarget, Me as createCurveBufferGeometry, Ie as createEqualChainBones, createFindObjectsInBoxNearPosition, createFindObjectsInSphereNearPosition, createFindObjectsNearPath, cn as createGuiAnimationController, _e as createKeyframeTracksForBones, We as createKeyframeTracksForBonesTarget, ce as createKeyframeTracksOfCurveAnimation, De as createKeyframeTracksOfCurveAnimationByPolyline, Je as createLineSegmentsByCurve, Bt as createLines, createPlaneMatrix, createPoiMesh, createPolygonPoiMesh, Zt as createPolylineBufferGeometry, be as createPolylineCurve, createTexture, createUVMatrix, SoonSpace as default, en as getAllRootBones, Pe as getClosestDistanceInfoOfPointToLines, Wt as getCurveDivisionLength, ee as getCurvePointAwayFrom, He as getCurvePointAwayFromOrigin, Qe as getCurveULengths, ve as getDistanceInfoOfPointToLines, Ct as getDurationOfPathAnimationOptions, Fe as getFirstRootBone, Gt as getKeyframeTransformDatas, Ue as getKeyframeTransformDatasByPolyline, Te as getLengthsOfTs, te as getLinesInfo, getPolygonGeometryInfo, Xe as getProjectionLines, nn as getRootBone, Se as getSampleDataForBones, Be as getSampleDataForBonesTarget, Yt as getSampleNum, qt as getTS, $t as getTimes, Oe as getTrackKeyframeTimeRatios, setTexture };
//# sourceMappingURL=index.esm.js.map
