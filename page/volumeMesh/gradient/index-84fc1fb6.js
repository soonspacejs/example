(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const a of s.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const po = "153",
  ki = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  Hi = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  fd = 0,
  Pl = 1,
  pd = 2,
  Fp = 3,
  Bp = 0,
  vc = 1,
  md = 2,
  An = 3,
  Zt = 0,
  wt = 1,
  Gt = 2,
  zp = 2,
  jn = 0,
  ji = 1,
  Ll = 2,
  Il = 3,
  Dl = 4,
  gd = 5,
  Wi = 100,
  _d = 101,
  xd = 102,
  Ul = 103,
  Nl = 104,
  yd = 200,
  vd = 201,
  Md = 202,
  Sd = 203,
  Mc = 204,
  Sc = 205,
  bd = 206,
  wd = 207,
  Ed = 208,
  Ad = 209,
  Td = 210,
  Rd = 0,
  Cd = 1,
  Pd = 2,
  oo = 3,
  Ld = 4,
  Id = 5,
  Dd = 6,
  Ud = 7,
  kr = 0,
  Nd = 1,
  Od = 2,
  Pn = 0,
  Fd = 1,
  Bd = 2,
  zd = 3,
  kd = 4,
  Hd = 5,
  mo = 300,
  yi = 301,
  vi = 302,
  Er = 303,
  Ar = 304,
  Zs = 306,
  Mi = 1e3,
  Dt = 1001,
  Fs = 1002,
  gt = 1003,
  Tr = 1004,
  kp = 1004,
  Ds = 1005,
  Hp = 1005,
  ot = 1006,
  go = 1007,
  Gp = 1007,
  Dn = 1008,
  Vp = 1008,
  _n = 1009,
  Gd = 1010,
  Vd = 1011,
  _o = 1012,
  bc = 1013,
  Zn = 1014,
  on = 1015,
  Bs = 1016,
  wc = 1017,
  Ec = 1018,
  mi = 1020,
  Wd = 1021,
  qt = 1023,
  Xd = 1024,
  Yd = 1025,
  gi = 1026,
  ts = 1027,
  Ac = 1028,
  Tc = 1029,
  qd = 1030,
  Rc = 1031,
  Cc = 1033,
  Ja = 33776,
  Qa = 33777,
  eo = 33778,
  to = 33779,
  Ol = 35840,
  Fl = 35841,
  Bl = 35842,
  zl = 35843,
  Zd = 36196,
  kl = 37492,
  Hl = 37496,
  Gl = 37808,
  Vl = 37809,
  Wl = 37810,
  Xl = 37811,
  Yl = 37812,
  ql = 37813,
  Zl = 37814,
  $l = 37815,
  Kl = 37816,
  jl = 37817,
  Jl = 37818,
  Ql = 37819,
  ec = 37820,
  tc = 37821,
  no = 36492,
  $d = 36283,
  nc = 36284,
  ic = 36285,
  sc = 36286,
  Kd = 2200,
  jd = 2201,
  Jd = 2202,
  zs = 2300,
  ns = 2301,
  io = 2302,
  Yi = 2400,
  qi = 2401,
  Rr = 2402,
  xo = 2500,
  Pc = 2501,
  Qd = 0,
  Lc = 1,
  lo = 2,
  Ic = 3e3,
  _i = 3001,
  ef = 3200,
  tf = 3201,
  wi = 0,
  nf = 1,
  xi = "",
  Oe = "srgb",
  xn = "srgb-linear",
  Dc = "display-p3",
  Wp = 0,
  so = 7680,
  Xp = 7681,
  Yp = 7682,
  qp = 7683,
  Zp = 34055,
  $p = 34056,
  Kp = 5386,
  jp = 512,
  Jp = 513,
  Qp = 514,
  em = 515,
  tm = 516,
  nm = 517,
  im = 518,
  sf = 519,
  rf = 512,
  af = 513,
  of = 514,
  lf = 515,
  cf = 516,
  hf = 517,
  uf = 518,
  df = 519,
  Cr = 35044,
  sm = 35048,
  rm = 35040,
  am = 35045,
  om = 35049,
  lm = 35041,
  cm = 35046,
  hm = 35050,
  um = 35042,
  dm = "100",
  Pr = "300 es",
  co = 1035,
  Rn = 2e3,
  Lr = 2001;
class Un {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let s = 0, a = i.length; s < a; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const Ot = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Eh = 1234567;
const Ji = Math.PI / 180,
  ks = 180 / Math.PI;
function en() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    Ot[r & 255] +
    Ot[(r >> 8) & 255] +
    Ot[(r >> 16) & 255] +
    Ot[(r >> 24) & 255] +
    "-" +
    Ot[e & 255] +
    Ot[(e >> 8) & 255] +
    "-" +
    Ot[((e >> 16) & 15) | 64] +
    Ot[(e >> 24) & 255] +
    "-" +
    Ot[(t & 63) | 128] +
    Ot[(t >> 8) & 255] +
    "-" +
    Ot[(t >> 16) & 255] +
    Ot[(t >> 24) & 255] +
    Ot[n & 255] +
    Ot[(n >> 8) & 255] +
    Ot[(n >> 16) & 255] +
    Ot[(n >> 24) & 255]
  ).toLowerCase();
}
function _t(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function Uc(r, e) {
  return ((r % e) + e) % e;
}
function fm(r, e, t, n, i) {
  return n + ((r - e) * (i - n)) / (t - e);
}
function pm(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function Mr(r, e, t) {
  return (1 - t) * r + t * e;
}
function mm(r, e, t, n) {
  return Mr(r, e, 1 - Math.exp(-t * n));
}
function gm(r, e = 1) {
  return e - Math.abs(Uc(r, e * 2) - e);
}
function _m(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function xm(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function ym(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function vm(r, e) {
  return r + Math.random() * (e - r);
}
function Mm(r) {
  return r * (0.5 - Math.random());
}
function Sm(r) {
  r !== void 0 && (Eh = r);
  let e = (Eh += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function bm(r) {
  return r * Ji;
}
function wm(r) {
  return r * ks;
}
function rc(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function ff(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function ho(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function Em(r, e, t, n, i) {
  const s = Math.cos,
    a = Math.sin,
    o = s(t / 2),
    l = a(t / 2),
    c = s((e + n) / 2),
    h = a((e + n) / 2),
    u = s((e - n) / 2),
    d = a((e - n) / 2),
    f = s((n - e) / 2),
    m = a((n - e) / 2);
  switch (i) {
    case "XYX":
      r.set(o * h, l * u, l * d, o * c);
      break;
    case "YZY":
      r.set(l * d, o * h, l * u, o * c);
      break;
    case "ZXZ":
      r.set(l * u, l * d, o * h, o * c);
      break;
    case "XZX":
      r.set(o * h, l * m, l * f, o * c);
      break;
    case "YXY":
      r.set(l * f, o * h, l * m, o * c);
      break;
    case "ZYZ":
      r.set(l * m, l * f, o * h, o * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Qt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Xe(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const pf = {
  DEG2RAD: Ji,
  RAD2DEG: ks,
  generateUUID: en,
  clamp: _t,
  euclideanModulo: Uc,
  mapLinear: fm,
  inverseLerp: pm,
  lerp: Mr,
  damp: mm,
  pingpong: gm,
  smoothstep: _m,
  smootherstep: xm,
  randInt: ym,
  randFloat: vm,
  randFloatSpread: Mm,
  seededRandom: Sm,
  degToRad: bm,
  radToDeg: wm,
  isPowerOfTwo: rc,
  ceilPowerOfTwo: ff,
  floorPowerOfTwo: ho,
  setQuaternionFromProperEuler: Em,
  normalize: Xe,
  denormalize: Qt,
};
class K {
  constructor(e = 0, t = 0) {
    (K.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(_t(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * n - a * i + e.x), (this.y = s * i + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class We {
  constructor(e, t, n, i, s, a, o, l, c) {
    (We.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, a, o, l, c);
  }
  set(e, t, n, i, s, a, o, l, c) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = i),
      (h[2] = o),
      (h[3] = t),
      (h[4] = s),
      (h[5] = l),
      (h[6] = n),
      (h[7] = a),
      (h[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      o = n[3],
      l = n[6],
      c = n[1],
      h = n[4],
      u = n[7],
      d = n[2],
      f = n[5],
      m = n[8],
      _ = i[0],
      g = i[3],
      p = i[6],
      v = i[1],
      x = i[4],
      y = i[7],
      S = i[2],
      w = i[5],
      R = i[8];
    return (
      (s[0] = a * _ + o * v + l * S),
      (s[3] = a * g + o * x + l * w),
      (s[6] = a * p + o * y + l * R),
      (s[1] = c * _ + h * v + u * S),
      (s[4] = c * g + h * x + u * w),
      (s[7] = c * p + h * y + u * R),
      (s[2] = d * _ + f * v + m * S),
      (s[5] = d * g + f * x + m * w),
      (s[8] = d * p + f * y + m * R),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      h = e[8];
    return (
      t * a * h - t * o * c - n * s * h + n * o * l + i * s * c - i * a * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = h * a - o * c,
      d = o * l - h * s,
      f = c * s - a * l,
      m = t * u + n * d + i * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / m;
    return (
      (e[0] = u * _),
      (e[1] = (i * c - h * n) * _),
      (e[2] = (o * n - i * a) * _),
      (e[3] = d * _),
      (e[4] = (h * t - i * l) * _),
      (e[5] = (i * s - o * t) * _),
      (e[6] = f * _),
      (e[7] = (n * l - c * t) * _),
      (e[8] = (a * t - n * s) * _),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * a + c * o) + a + e,
        -i * c,
        i * l,
        -i * (-c * a + l * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(zo.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(zo.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(zo.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const zo = new We();
function mf(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
const Am = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function Ps(r, e) {
  return new Am[r](e);
}
function Ir(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
const Ah = {};
function Sr(r) {
  r in Ah || ((Ah[r] = !0), console.warn(r));
}
function Us(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function ko(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const Tm = new We().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  Rm = new We().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function Cm(r) {
  return r.convertSRGBToLinear().applyMatrix3(Rm);
}
function Pm(r) {
  return r.applyMatrix3(Tm).convertLinearToSRGB();
}
const Lm = { [xn]: (r) => r, [Oe]: (r) => r.convertSRGBToLinear(), [Dc]: Cm },
  Im = { [xn]: (r) => r, [Oe]: (r) => r.convertLinearToSRGB(), [Dc]: Pm },
  nn = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(r) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !r);
    },
    get workingColorSpace() {
      return xn;
    },
    set workingColorSpace(r) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (r, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return r;
      const n = Lm[e],
        i = Im[t];
      if (n === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(n(r));
    },
    fromWorkingColorSpace: function (r, e) {
      return this.convert(r, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (r, e) {
      return this.convert(r, e, this.workingColorSpace);
    },
  };
let os;
class Nc {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      os === void 0 && (os = Ir("canvas")),
        (os.width = e.width),
        (os.height = e.height);
      const n = os.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = os);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Ir("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let a = 0; a < s.length; a++) s[a] = Us(s[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(Us(t[n] / 255) * 255))
          : (t[n] = Us(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let Dm = 0;
class Zi {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: Dm++ }),
      (this.uuid = en()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let a = 0, o = i.length; a < o; a++)
          i[a].isDataTexture ? s.push(Ho(i[a].image)) : s.push(Ho(i[a]));
      } else s = Ho(i);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Ho(r) {
  return (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && r instanceof ImageBitmap)
    ? Nc.getDataURL(r)
    : r.data
    ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Um = 0;
class ht extends Un {
  constructor(
    e = ht.DEFAULT_IMAGE,
    t = ht.DEFAULT_MAPPING,
    n = Dt,
    i = Dt,
    s = ot,
    a = Dn,
    o = qt,
    l = _n,
    c = ht.DEFAULT_ANISOTROPY,
    h = xi
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: Um++ }),
      (this.uuid = en()),
      (this.name = ""),
      (this.source = new Zi(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new K(0, 0)),
      (this.repeat = new K(1, 1)),
      (this.center = new K(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new We()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof h == "string"
        ? (this.colorSpace = h)
        : (Sr(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = h === _i ? Oe : xi)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== mo) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Mi:
          e.x = e.x - Math.floor(e.x);
          break;
        case Dt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Fs:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Mi:
          e.y = e.y - Math.floor(e.y);
          break;
        case Dt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Fs:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Sr("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Oe ? _i : Ic
    );
  }
  set encoding(e) {
    Sr("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === _i ? Oe : xi);
  }
}
ht.DEFAULT_IMAGE = null;
ht.DEFAULT_MAPPING = mo;
ht.DEFAULT_ANISOTROPY = 1;
class tt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (tt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * s),
      (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * s),
      (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * s),
      (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, s;
    const l = e.elements,
      c = l[0],
      h = l[4],
      u = l[8],
      d = l[1],
      f = l[5],
      m = l[9],
      _ = l[2],
      g = l[6],
      p = l[10];
    if (
      Math.abs(h - d) < 0.01 &&
      Math.abs(u - _) < 0.01 &&
      Math.abs(m - g) < 0.01
    ) {
      if (
        Math.abs(h + d) < 0.1 &&
        Math.abs(u + _) < 0.1 &&
        Math.abs(m + g) < 0.1 &&
        Math.abs(c + f + p - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const x = (c + 1) / 2,
        y = (f + 1) / 2,
        S = (p + 1) / 2,
        w = (h + d) / 4,
        R = (u + _) / 4,
        P = (m + g) / 4;
      return (
        x > y && x > S
          ? x < 0.01
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(x)), (i = w / n), (s = R / n))
          : y > S
          ? y < 0.01
            ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(y)), (n = w / i), (s = P / i))
          : S < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(S)), (n = R / s), (i = P / s)),
        this.set(n, i, s, t),
        this
      );
    }
    let v = Math.sqrt(
      (g - m) * (g - m) + (u - _) * (u - _) + (d - h) * (d - h)
    );
    return (
      Math.abs(v) < 0.001 && (v = 1),
      (this.x = (g - m) / v),
      (this.y = (u - _) / v),
      (this.z = (d - h) / v),
      (this.w = Math.acos((c + f + p - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class yn extends Un {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new tt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new tt(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 &&
      (Sr(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (n.colorSpace = n.encoding === _i ? Oe : xi)),
      (this.texture = new ht(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : ot),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Zi(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class yo extends ht {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = gt),
      (this.minFilter = gt),
      (this.wrapR = Dt),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Nm extends yn {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = n),
      (this.texture = new yo(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Hr extends ht {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = gt),
      (this.minFilter = gt),
      (this.wrapR = Dt),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Om extends yn {
  constructor(e = 1, t = 1, n = 1) {
    super(e, t),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = n),
      (this.texture = new Hr(null, e, t, n)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Fm extends yn {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let a = 0; a < n; a++)
      (this.texture[a] = s.clone()),
        (this.texture[a].isRenderTargetTexture = !0);
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      (this.width = e), (this.height = t), (this.depth = n);
      for (let i = 0, s = this.texture.length; i < s; i++)
        (this.texture[i].image.width = e),
          (this.texture[i].image.height = t),
          (this.texture[i].image.depth = n);
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, n = e.texture.length; t < n; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class et {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, s, a, o) {
    let l = n[i + 0],
      c = n[i + 1],
      h = n[i + 2],
      u = n[i + 3];
    const d = s[a + 0],
      f = s[a + 1],
      m = s[a + 2],
      _ = s[a + 3];
    if (o === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
      return;
    }
    if (o === 1) {
      (e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = m), (e[t + 3] = _);
      return;
    }
    if (u !== _ || l !== d || c !== f || h !== m) {
      let g = 1 - o;
      const p = l * d + c * f + h * m + u * _,
        v = p >= 0 ? 1 : -1,
        x = 1 - p * p;
      if (x > Number.EPSILON) {
        const S = Math.sqrt(x),
          w = Math.atan2(S, p * v);
        (g = Math.sin(g * w) / S), (o = Math.sin(o * w) / S);
      }
      const y = o * v;
      if (
        ((l = l * g + d * y),
        (c = c * g + f * y),
        (h = h * g + m * y),
        (u = u * g + _ * y),
        g === 1 - o)
      ) {
        const S = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
        (l *= S), (c *= S), (h *= S), (u *= S);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
  }
  static multiplyQuaternionsFlat(e, t, n, i, s, a) {
    const o = n[i],
      l = n[i + 1],
      c = n[i + 2],
      h = n[i + 3],
      u = s[a],
      d = s[a + 1],
      f = s[a + 2],
      m = s[a + 3];
    return (
      (e[t] = o * m + h * u + l * f - c * d),
      (e[t + 1] = l * m + h * d + c * u - o * f),
      (e[t + 2] = c * m + h * f + o * d - l * u),
      (e[t + 3] = h * m - o * u - l * d - c * f),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(n / 2),
      h = o(i / 2),
      u = o(s / 2),
      d = l(n / 2),
      f = l(i / 2),
      m = l(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "YXZ":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      case "ZXY":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "ZYX":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      case "YZX":
        (this._x = d * h * u + c * f * m),
          (this._y = c * f * u + d * h * m),
          (this._z = c * h * m - d * f * u),
          (this._w = c * h * u - d * f * m);
        break;
      case "XZY":
        (this._x = d * h * u - c * f * m),
          (this._y = c * f * u - d * h * m),
          (this._z = c * h * m + d * f * u),
          (this._w = c * h * u + d * f * m);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      s = t[8],
      a = t[1],
      o = t[5],
      l = t[9],
      c = t[2],
      h = t[6],
      u = t[10],
      d = n + o + u;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      (this._w = 0.25 / f),
        (this._x = (h - l) * f),
        (this._y = (s - c) * f),
        (this._z = (a - i) * f);
    } else if (n > o && n > u) {
      const f = 2 * Math.sqrt(1 + n - o - u);
      (this._w = (h - l) / f),
        (this._x = 0.25 * f),
        (this._y = (i + a) / f),
        (this._z = (s + c) / f);
    } else if (o > u) {
      const f = 2 * Math.sqrt(1 + o - n - u);
      (this._w = (s - c) / f),
        (this._x = (i + a) / f),
        (this._y = 0.25 * f),
        (this._z = (l + h) / f);
    } else {
      const f = 2 * Math.sqrt(1 + u - n - o);
      (this._w = (a - i) / f),
        (this._x = (s + c) / f),
        (this._y = (l + h) / f),
        (this._z = 0.25 * f);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(_t(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._w,
      o = t._x,
      l = t._y,
      c = t._z,
      h = t._w;
    return (
      (this._x = n * h + a * o + i * c - s * l),
      (this._y = i * h + a * l + s * o - n * c),
      (this._z = s * h + a * c + n * l - i * o),
      (this._w = a * h - n * o - i * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + n * e._x + i * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = i), (this._z = s), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return (
        (this._w = f * a + t * this._w),
        (this._x = f * n + t * this._x),
        (this._y = f * i + t * this._y),
        (this._z = f * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      h = Math.atan2(c, o),
      u = Math.sin((1 - t) * h) / c,
      d = Math.sin(t * h) / c;
    return (
      (this._w = a * u + this._w * d),
      (this._x = n * u + this._x * d),
      (this._y = i * u + this._y * d),
      (this._z = s * u + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(s),
      n * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class b {
  constructor(e = 0, t = 0, n = 0) {
    (b.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Th.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Th.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * i),
      (this.y = s[1] * t + s[4] * n + s[7] * i),
      (this.z = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * a),
      (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * a),
      (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = l * t + a * i - o * n,
      h = l * n + o * t - s * i,
      u = l * i + s * n - a * t,
      d = -s * t - a * n - o * i;
    return (
      (this.x = c * l + d * -s + h * -o - u * -a),
      (this.y = h * l + d * -a + u * -s - c * -o),
      (this.z = u * l + d * -o + c * -a - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * i),
      (this.y = s[1] * t + s[5] * n + s[9] * i),
      (this.z = s[2] * t + s[6] * n + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = t.x,
      o = t.y,
      l = t.z;
    return (
      (this.x = i * l - s * o),
      (this.y = s * a - n * l),
      (this.z = n * o - i * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Go.copy(this).projectOnVector(e), this.sub(Go);
  }
  reflect(e) {
    return this.sub(Go.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(_t(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Go = new b(),
  Th = new et();
class Vt {
  constructor(
    e = new b(1 / 0, 1 / 0, 1 / 0),
    t = new b(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(zn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(zn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = zn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        ls.copy(e.boundingBox),
        ls.applyMatrix4(e.matrixWorld),
        this.union(ls);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const s = i.attributes.position;
          for (let a = 0, o = s.count; a < o; a++)
            zn.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
              this.expandByPoint(zn);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            ls.copy(i.boundingBox),
            ls.applyMatrix4(e.matrixWorld),
            this.union(ls);
    }
    const n = e.children;
    for (let i = 0, s = n.length; i < s; i++) this.expandByObject(n[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, zn),
      zn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(nr),
      oa.subVectors(this.max, nr),
      cs.subVectors(e.a, nr),
      hs.subVectors(e.b, nr),
      us.subVectors(e.c, nr),
      ii.subVectors(hs, cs),
      si.subVectors(us, hs),
      Ci.subVectors(cs, us);
    let t = [
      0,
      -ii.z,
      ii.y,
      0,
      -si.z,
      si.y,
      0,
      -Ci.z,
      Ci.y,
      ii.z,
      0,
      -ii.x,
      si.z,
      0,
      -si.x,
      Ci.z,
      0,
      -Ci.x,
      -ii.y,
      ii.x,
      0,
      -si.y,
      si.x,
      0,
      -Ci.y,
      Ci.x,
      0,
    ];
    return !Vo(t, cs, hs, us, oa) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Vo(t, cs, hs, us, oa))
      ? !1
      : (la.crossVectors(ii, si),
        (t = [la.x, la.y, la.z]),
        Vo(t, cs, hs, us, oa));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, zn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(zn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Bn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Bn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Bn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Bn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Bn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Bn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Bn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Bn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Bn),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Bn = [
    new b(),
    new b(),
    new b(),
    new b(),
    new b(),
    new b(),
    new b(),
    new b(),
  ],
  zn = new b(),
  ls = new Vt(),
  cs = new b(),
  hs = new b(),
  us = new b(),
  ii = new b(),
  si = new b(),
  Ci = new b(),
  nr = new b(),
  oa = new b(),
  la = new b(),
  Pi = new b();
function Vo(r, e, t, n, i) {
  for (let s = 0, a = r.length - 3; s <= a; s += 3) {
    Pi.fromArray(r, s);
    const o =
        i.x * Math.abs(Pi.x) + i.y * Math.abs(Pi.y) + i.z * Math.abs(Pi.z),
      l = e.dot(Pi),
      c = t.dot(Pi),
      h = n.dot(Pi);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > o) return !1;
  }
  return !0;
}
const Bm = new Vt(),
  ir = new b(),
  Wo = new b();
class hn {
  constructor(e = new b(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Bm.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let s = 0, a = e.length; s < a; s++)
      i = Math.max(i, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    ir.subVectors(e, this.center);
    const t = ir.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(ir, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Wo.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(ir.copy(e.center).add(Wo)),
            this.expandByPoint(ir.copy(e.center).sub(Wo))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kn = new b(),
  Xo = new b(),
  ca = new b(),
  ri = new b(),
  Yo = new b(),
  ha = new b(),
  qo = new b();
class $s {
  constructor(e = new b(), t = new b(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, kn)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = kn.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (kn.copy(this.origin).addScaledVector(this.direction, t),
        kn.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    Xo.copy(e).add(t).multiplyScalar(0.5),
      ca.copy(t).sub(e).normalize(),
      ri.copy(this.origin).sub(Xo);
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(ca),
      o = ri.dot(this.direction),
      l = -ri.dot(ca),
      c = ri.lengthSq(),
      h = Math.abs(1 - a * a);
    let u, d, f, m;
    if (h > 0)
      if (((u = a * l - o), (d = a * o - l), (m = s * h), u >= 0))
        if (d >= -m)
          if (d <= m) {
            const _ = 1 / h;
            (u *= _),
              (d *= _),
              (f = u * (u + a * d + 2 * o) + d * (a * u + d + 2 * l) + c);
          } else
            (d = s),
              (u = Math.max(0, -(a * d + o))),
              (f = -u * u + d * (d + 2 * l) + c);
        else
          (d = -s),
            (u = Math.max(0, -(a * d + o))),
            (f = -u * u + d * (d + 2 * l) + c);
      else
        d <= -m
          ? ((u = Math.max(0, -(-a * s + o))),
            (d = u > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (f = -u * u + d * (d + 2 * l) + c))
          : d <= m
          ? ((u = 0),
            (d = Math.min(Math.max(-s, -l), s)),
            (f = d * (d + 2 * l) + c))
          : ((u = Math.max(0, -(a * s + o))),
            (d = u > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (f = -u * u + d * (d + 2 * l) + c));
    else
      (d = a > 0 ? -s : s),
        (u = Math.max(0, -(a * d + o))),
        (f = -u * u + d * (d + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, u),
      i && i.copy(Xo).addScaledVector(ca, d),
      f
    );
  }
  intersectSphere(e, t) {
    kn.subVectors(e.center, this.origin);
    const n = kn.dot(this.direction),
      i = kn.dot(kn) - n * n,
      s = e.radius * e.radius;
    if (i > s) return null;
    const a = Math.sqrt(s - i),
      o = n - a,
      l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, s, a, o, l;
    const c = 1 / this.direction.x,
      h = 1 / this.direction.y,
      u = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - d.x) * c), (i = (e.max.x - d.x) * c))
        : ((n = (e.max.x - d.x) * c), (i = (e.min.x - d.x) * c)),
      h >= 0
        ? ((s = (e.min.y - d.y) * h), (a = (e.max.y - d.y) * h))
        : ((s = (e.max.y - d.y) * h), (a = (e.min.y - d.y) * h)),
      n > a ||
      s > i ||
      ((s > n || isNaN(n)) && (n = s),
      (a < i || isNaN(i)) && (i = a),
      u >= 0
        ? ((o = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u))
        : ((o = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
      n > l || o > i) ||
      ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, kn) !== null;
  }
  intersectTriangle(e, t, n, i, s) {
    Yo.subVectors(t, e), ha.subVectors(n, e), qo.crossVectors(Yo, ha);
    let a = this.direction.dot(qo),
      o;
    if (a > 0) {
      if (i) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    ri.subVectors(this.origin, e);
    const l = o * this.direction.dot(ha.crossVectors(ri, ha));
    if (l < 0) return null;
    const c = o * this.direction.dot(Yo.cross(ri));
    if (c < 0 || l + c > a) return null;
    const h = -o * ri.dot(qo);
    return h < 0 ? null : this.at(h / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ue {
  constructor(e, t, n, i, s, a, o, l, c, h, u, d, f, m, _, g) {
    (Ue.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, n, i, s, a, o, l, c, h, u, d, f, m, _, g);
  }
  set(e, t, n, i, s, a, o, l, c, h, u, d, f, m, _, g) {
    const p = this.elements;
    return (
      (p[0] = e),
      (p[4] = t),
      (p[8] = n),
      (p[12] = i),
      (p[1] = s),
      (p[5] = a),
      (p[9] = o),
      (p[13] = l),
      (p[2] = c),
      (p[6] = h),
      (p[10] = u),
      (p[14] = d),
      (p[3] = f),
      (p[7] = m),
      (p[11] = _),
      (p[15] = g),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Ue().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / ds.setFromMatrixColumn(e, 0).length(),
      s = 1 / ds.setFromMatrixColumn(e, 1).length(),
      a = 1 / ds.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z,
      a = Math.cos(n),
      o = Math.sin(n),
      l = Math.cos(i),
      c = Math.sin(i),
      h = Math.cos(s),
      u = Math.sin(s);
    if (e.order === "XYZ") {
      const d = a * h,
        f = a * u,
        m = o * h,
        _ = o * u;
      (t[0] = l * h),
        (t[4] = -l * u),
        (t[8] = c),
        (t[1] = f + m * c),
        (t[5] = d - _ * c),
        (t[9] = -o * l),
        (t[2] = _ - d * c),
        (t[6] = m + f * c),
        (t[10] = a * l);
    } else if (e.order === "YXZ") {
      const d = l * h,
        f = l * u,
        m = c * h,
        _ = c * u;
      (t[0] = d + _ * o),
        (t[4] = m * o - f),
        (t[8] = a * c),
        (t[1] = a * u),
        (t[5] = a * h),
        (t[9] = -o),
        (t[2] = f * o - m),
        (t[6] = _ + d * o),
        (t[10] = a * l);
    } else if (e.order === "ZXY") {
      const d = l * h,
        f = l * u,
        m = c * h,
        _ = c * u;
      (t[0] = d - _ * o),
        (t[4] = -a * u),
        (t[8] = m + f * o),
        (t[1] = f + m * o),
        (t[5] = a * h),
        (t[9] = _ - d * o),
        (t[2] = -a * c),
        (t[6] = o),
        (t[10] = a * l);
    } else if (e.order === "ZYX") {
      const d = a * h,
        f = a * u,
        m = o * h,
        _ = o * u;
      (t[0] = l * h),
        (t[4] = m * c - f),
        (t[8] = d * c + _),
        (t[1] = l * u),
        (t[5] = _ * c + d),
        (t[9] = f * c - m),
        (t[2] = -c),
        (t[6] = o * l),
        (t[10] = a * l);
    } else if (e.order === "YZX") {
      const d = a * l,
        f = a * c,
        m = o * l,
        _ = o * c;
      (t[0] = l * h),
        (t[4] = _ - d * u),
        (t[8] = m * u + f),
        (t[1] = u),
        (t[5] = a * h),
        (t[9] = -o * h),
        (t[2] = -c * h),
        (t[6] = f * u + m),
        (t[10] = d - _ * u);
    } else if (e.order === "XZY") {
      const d = a * l,
        f = a * c,
        m = o * l,
        _ = o * c;
      (t[0] = l * h),
        (t[4] = -u),
        (t[8] = c * h),
        (t[1] = d * u + _),
        (t[5] = a * h),
        (t[9] = f * u - m),
        (t[2] = m * u - f),
        (t[6] = o * h),
        (t[10] = _ * u + d);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(zm, e, km);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      jt.subVectors(e, t),
      jt.lengthSq() === 0 && (jt.z = 1),
      jt.normalize(),
      ai.crossVectors(n, jt),
      ai.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (jt.x += 1e-4) : (jt.z += 1e-4),
        jt.normalize(),
        ai.crossVectors(n, jt)),
      ai.normalize(),
      ua.crossVectors(jt, ai),
      (i[0] = ai.x),
      (i[4] = ua.x),
      (i[8] = jt.x),
      (i[1] = ai.y),
      (i[5] = ua.y),
      (i[9] = jt.y),
      (i[2] = ai.z),
      (i[6] = ua.z),
      (i[10] = jt.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      o = n[4],
      l = n[8],
      c = n[12],
      h = n[1],
      u = n[5],
      d = n[9],
      f = n[13],
      m = n[2],
      _ = n[6],
      g = n[10],
      p = n[14],
      v = n[3],
      x = n[7],
      y = n[11],
      S = n[15],
      w = i[0],
      R = i[4],
      P = i[8],
      M = i[12],
      A = i[1],
      k = i[5],
      X = i[9],
      U = i[13],
      O = i[2],
      N = i[6],
      Z = i[10],
      B = i[14],
      G = i[3],
      $ = i[7],
      Y = i[11],
      he = i[15];
    return (
      (s[0] = a * w + o * A + l * O + c * G),
      (s[4] = a * R + o * k + l * N + c * $),
      (s[8] = a * P + o * X + l * Z + c * Y),
      (s[12] = a * M + o * U + l * B + c * he),
      (s[1] = h * w + u * A + d * O + f * G),
      (s[5] = h * R + u * k + d * N + f * $),
      (s[9] = h * P + u * X + d * Z + f * Y),
      (s[13] = h * M + u * U + d * B + f * he),
      (s[2] = m * w + _ * A + g * O + p * G),
      (s[6] = m * R + _ * k + g * N + p * $),
      (s[10] = m * P + _ * X + g * Z + p * Y),
      (s[14] = m * M + _ * U + g * B + p * he),
      (s[3] = v * w + x * A + y * O + S * G),
      (s[7] = v * R + x * k + y * N + S * $),
      (s[11] = v * P + x * X + y * Z + S * Y),
      (s[15] = v * M + x * U + y * B + S * he),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      h = e[2],
      u = e[6],
      d = e[10],
      f = e[14],
      m = e[3],
      _ = e[7],
      g = e[11],
      p = e[15];
    return (
      m *
        (+s * l * u -
          i * c * u -
          s * o * d +
          n * c * d +
          i * o * f -
          n * l * f) +
      _ *
        (+t * l * f -
          t * c * d +
          s * a * d -
          i * a * f +
          i * c * h -
          s * l * h) +
      g *
        (+t * c * u -
          t * o * f -
          s * a * u +
          n * a * f +
          s * o * h -
          n * c * h) +
      p *
        (-i * o * h - t * l * u + t * o * d + i * a * u - n * a * d + n * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      u = e[9],
      d = e[10],
      f = e[11],
      m = e[12],
      _ = e[13],
      g = e[14],
      p = e[15],
      v = u * g * c - _ * d * c + _ * l * f - o * g * f - u * l * p + o * d * p,
      x = m * d * c - h * g * c - m * l * f + a * g * f + h * l * p - a * d * p,
      y = h * _ * c - m * u * c + m * o * f - a * _ * f - h * o * p + a * u * p,
      S = m * u * l - h * _ * l - m * o * d + a * _ * d + h * o * g - a * u * g,
      w = t * v + n * x + i * y + s * S;
    if (w === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / w;
    return (
      (e[0] = v * R),
      (e[1] =
        (_ * d * s -
          u * g * s -
          _ * i * f +
          n * g * f +
          u * i * p -
          n * d * p) *
        R),
      (e[2] =
        (o * g * s -
          _ * l * s +
          _ * i * c -
          n * g * c -
          o * i * p +
          n * l * p) *
        R),
      (e[3] =
        (u * l * s -
          o * d * s -
          u * i * c +
          n * d * c +
          o * i * f -
          n * l * f) *
        R),
      (e[4] = x * R),
      (e[5] =
        (h * g * s -
          m * d * s +
          m * i * f -
          t * g * f -
          h * i * p +
          t * d * p) *
        R),
      (e[6] =
        (m * l * s -
          a * g * s -
          m * i * c +
          t * g * c +
          a * i * p -
          t * l * p) *
        R),
      (e[7] =
        (a * d * s -
          h * l * s +
          h * i * c -
          t * d * c -
          a * i * f +
          t * l * f) *
        R),
      (e[8] = y * R),
      (e[9] =
        (m * u * s -
          h * _ * s -
          m * n * f +
          t * _ * f +
          h * n * p -
          t * u * p) *
        R),
      (e[10] =
        (a * _ * s -
          m * o * s +
          m * n * c -
          t * _ * c -
          a * n * p +
          t * o * p) *
        R),
      (e[11] =
        (h * o * s -
          a * u * s -
          h * n * c +
          t * u * c +
          a * n * f -
          t * o * f) *
        R),
      (e[12] = S * R),
      (e[13] =
        (h * _ * i -
          m * u * i +
          m * n * d -
          t * _ * d -
          h * n * g +
          t * u * g) *
        R),
      (e[14] =
        (m * o * i -
          a * _ * i -
          m * n * l +
          t * _ * l +
          a * n * g -
          t * o * g) *
        R),
      (e[15] =
        (a * u * i -
          h * o * i +
          h * n * l -
          t * u * l -
          a * n * d +
          t * o * d) *
        R),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = 1 - n,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      h = s * o;
    return (
      this.set(
        c * a + n,
        c * o - i * l,
        c * l + i * o,
        0,
        c * o + i * l,
        h * o + n,
        h * l - i * a,
        0,
        c * l - i * o,
        h * l + i * a,
        s * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      s = t._x,
      a = t._y,
      o = t._z,
      l = t._w,
      c = s + s,
      h = a + a,
      u = o + o,
      d = s * c,
      f = s * h,
      m = s * u,
      _ = a * h,
      g = a * u,
      p = o * u,
      v = l * c,
      x = l * h,
      y = l * u,
      S = n.x,
      w = n.y,
      R = n.z;
    return (
      (i[0] = (1 - (_ + p)) * S),
      (i[1] = (f + y) * S),
      (i[2] = (m - x) * S),
      (i[3] = 0),
      (i[4] = (f - y) * w),
      (i[5] = (1 - (d + p)) * w),
      (i[6] = (g + v) * w),
      (i[7] = 0),
      (i[8] = (m + x) * R),
      (i[9] = (g - v) * R),
      (i[10] = (1 - (d + _)) * R),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let s = ds.set(i[0], i[1], i[2]).length();
    const a = ds.set(i[4], i[5], i[6]).length(),
      o = ds.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      dn.copy(this);
    const c = 1 / s,
      h = 1 / a,
      u = 1 / o;
    return (
      (dn.elements[0] *= c),
      (dn.elements[1] *= c),
      (dn.elements[2] *= c),
      (dn.elements[4] *= h),
      (dn.elements[5] *= h),
      (dn.elements[6] *= h),
      (dn.elements[8] *= u),
      (dn.elements[9] *= u),
      (dn.elements[10] *= u),
      t.setFromRotationMatrix(dn),
      (n.x = s),
      (n.y = a),
      (n.z = o),
      this
    );
  }
  makePerspective(e, t, n, i, s, a, o = Rn) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      h = (2 * s) / (n - i),
      u = (t + e) / (t - e),
      d = (n + i) / (n - i);
    let f, m;
    if (o === Rn) (f = -(a + s) / (a - s)), (m = (-2 * a * s) / (a - s));
    else if (o === Lr) (f = -a / (a - s)), (m = (-a * s) / (a - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = u),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = h),
      (l[9] = d),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = f),
      (l[14] = m),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, s, a, o = Rn) {
    const l = this.elements,
      c = 1 / (t - e),
      h = 1 / (n - i),
      u = 1 / (a - s),
      d = (t + e) * c,
      f = (n + i) * h;
    let m, _;
    if (o === Rn) (m = (a + s) * u), (_ = -2 * u);
    else if (o === Lr) (m = s * u), (_ = -1 * u);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -d),
      (l[1] = 0),
      (l[5] = 2 * h),
      (l[9] = 0),
      (l[13] = -f),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = _),
      (l[14] = -m),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const ds = new b(),
  dn = new Ue(),
  zm = new b(0, 0, 0),
  km = new b(1, 1, 1),
  ai = new b(),
  ua = new b(),
  jt = new b(),
  Rh = new Ue(),
  Ch = new et();
class an {
  constructor(e = 0, t = 0, n = 0, i = an.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      s = i[0],
      a = i[4],
      o = i[8],
      l = i[1],
      c = i[5],
      h = i[9],
      u = i[2],
      d = i[6],
      f = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(_t(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-h, f)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-_t(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(o, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-u, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(_t(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-u, f)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-_t(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(_t(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-u, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, f)));
        break;
      case "XZY":
        (this._z = Math.asin(-_t(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-h, f)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      Rh.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Rh, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Ch.setFromEuler(this), this.setFromQuaternion(Ch, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
an.DEFAULT_ORDER = "XYZ";
class vo {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Hm = 0;
const Ph = new b(),
  fs = new et(),
  Hn = new Ue(),
  da = new b(),
  sr = new b(),
  Gm = new b(),
  Vm = new et(),
  Lh = new b(1, 0, 0),
  Ih = new b(0, 1, 0),
  Dh = new b(0, 0, 1),
  Wm = { type: "added" },
  Uh = { type: "removed" };
class qe extends Un {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Hm++ }),
      (this.uuid = en()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = qe.DEFAULT_UP.clone());
    const e = new b(),
      t = new an(),
      n = new et(),
      i = new b(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Ue() },
        normalMatrix: { value: new We() },
      }),
      (this.matrix = new Ue()),
      (this.matrixWorld = new Ue()),
      (this.matrixAutoUpdate = qe.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new vo()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return fs.setFromAxisAngle(e, t), this.quaternion.multiply(fs), this;
  }
  rotateOnWorldAxis(e, t) {
    return fs.setFromAxisAngle(e, t), this.quaternion.premultiply(fs), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Lh, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Ih, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Dh, e);
  }
  translateOnAxis(e, t) {
    return (
      Ph.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Ph.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Lh, e);
  }
  translateY(e) {
    return this.translateOnAxis(Ih, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Dh, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Hn.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? da.copy(e) : da.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      sr.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Hn.lookAt(sr, da, this.up)
        : Hn.lookAt(da, sr, this.up),
      this.quaternion.setFromRotationMatrix(Hn),
      i &&
        (Hn.extractRotation(i.matrixWorld),
        fs.setFromRotationMatrix(Hn),
        this.quaternion.premultiply(fs.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(Wm))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Uh)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(Uh);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Hn.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Hn.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Hn),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let i = 0, s = this.children.length; i < s; i++) {
      const a = this.children[i].getObjectsByProperty(e, t);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sr, e, Gm), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(sr, Vm, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 &&
        n !== null &&
        n.matrixWorldAutoUpdate === !0 &&
        n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, a = i.length; s < a; s++) {
        const o = i[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const u = l[c];
            s(e.shapes, u);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        i.material = o;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        h = a(e.images),
        u = a(e.shapes),
        d = a(e.skeletons),
        f = a(e.animations),
        m = a(e.nodes);
      o.length > 0 && (n.geometries = o),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        h.length > 0 && (n.images = h),
        u.length > 0 && (n.shapes = u),
        d.length > 0 && (n.skeletons = d),
        f.length > 0 && (n.animations = f),
        m.length > 0 && (n.nodes = m);
    }
    return (n.object = i), n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
qe.DEFAULT_UP = new b(0, 1, 0);
qe.DEFAULT_MATRIX_AUTO_UPDATE = !0;
qe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const fn = new b(),
  Gn = new b(),
  Zo = new b(),
  Vn = new b(),
  ps = new b(),
  ms = new b(),
  Nh = new b(),
  $o = new b(),
  Ko = new b(),
  jo = new b();
let fa = !1;
class Yt {
  constructor(e = new b(), t = new b(), n = new b()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), fn.subVectors(e, t), i.cross(fn);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, s) {
    fn.subVectors(i, t), Gn.subVectors(n, t), Zo.subVectors(e, t);
    const a = fn.dot(fn),
      o = fn.dot(Gn),
      l = fn.dot(Zo),
      c = Gn.dot(Gn),
      h = Gn.dot(Zo),
      u = a * c - o * o;
    if (u === 0) return s.set(-2, -1, -1);
    const d = 1 / u,
      f = (c * l - o * h) * d,
      m = (a * h - o * l) * d;
    return s.set(1 - f - m, m, f);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, Vn),
      Vn.x >= 0 && Vn.y >= 0 && Vn.x + Vn.y <= 1
    );
  }
  static getUV(e, t, n, i, s, a, o, l) {
    return (
      fa === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (fa = !0)),
      this.getInterpolation(e, t, n, i, s, a, o, l)
    );
  }
  static getInterpolation(e, t, n, i, s, a, o, l) {
    return (
      this.getBarycoord(e, t, n, i, Vn),
      l.setScalar(0),
      l.addScaledVector(s, Vn.x),
      l.addScaledVector(a, Vn.y),
      l.addScaledVector(o, Vn.z),
      l
    );
  }
  static isFrontFacing(e, t, n, i) {
    return fn.subVectors(n, t), Gn.subVectors(e, t), fn.cross(Gn).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      fn.subVectors(this.c, this.b),
      Gn.subVectors(this.a, this.b),
      fn.cross(Gn).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Yt.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Yt.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, s) {
    return (
      fa === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (fa = !0)),
      Yt.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    );
  }
  getInterpolation(e, t, n, i, s) {
    return Yt.getInterpolation(e, this.a, this.b, this.c, t, n, i, s);
  }
  containsPoint(e) {
    return Yt.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Yt.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      s = this.c;
    let a, o;
    ps.subVectors(i, n), ms.subVectors(s, n), $o.subVectors(e, n);
    const l = ps.dot($o),
      c = ms.dot($o);
    if (l <= 0 && c <= 0) return t.copy(n);
    Ko.subVectors(e, i);
    const h = ps.dot(Ko),
      u = ms.dot(Ko);
    if (h >= 0 && u <= h) return t.copy(i);
    const d = l * u - h * c;
    if (d <= 0 && l >= 0 && h <= 0)
      return (a = l / (l - h)), t.copy(n).addScaledVector(ps, a);
    jo.subVectors(e, s);
    const f = ps.dot(jo),
      m = ms.dot(jo);
    if (m >= 0 && f <= m) return t.copy(s);
    const _ = f * c - l * m;
    if (_ <= 0 && c >= 0 && m <= 0)
      return (o = c / (c - m)), t.copy(n).addScaledVector(ms, o);
    const g = h * m - f * u;
    if (g <= 0 && u - h >= 0 && f - m >= 0)
      return (
        Nh.subVectors(s, i),
        (o = (u - h) / (u - h + (f - m))),
        t.copy(i).addScaledVector(Nh, o)
      );
    const p = 1 / (g + _ + d);
    return (
      (a = _ * p),
      (o = d * p),
      t.copy(n).addScaledVector(ps, a).addScaledVector(ms, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Xm = 0;
class At extends Un {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Xm++ }),
      (this.uuid = en()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ji),
      (this.side = Zt),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = Mc),
      (this.blendDst = Sc),
      (this.blendEquation = Wi),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = oo),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = sf),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = so),
      (this.stencilZFail = so),
      (this.stencilZPass = so),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ji && (n.blending = this.blending),
      this.side !== Zt && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const s = i(e.textures),
        a = i(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const gf = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  pn = { h: 0, s: 0, l: 0 },
  pa = { h: 0, s: 0, l: 0 };
function Jo(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? r + (e - r) * 6 * (2 / 3 - t)
      : r
  );
}
class de {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, n)
    );
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Oe) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      nn.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = nn.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      nn.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = nn.workingColorSpace) {
    if (((e = Uc(e, 1)), (t = _t(t, 0, 1)), (n = _t(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - s;
      (this.r = Jo(a, s, e + 1 / 3)),
        (this.g = Jo(a, s, e)),
        (this.b = Jo(a, s, e - 1 / 3));
    }
    return nn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Oe) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = i[1],
        o = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (a === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Oe) {
    const n = gf[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Us(e.r)), (this.g = Us(e.g)), (this.b = Us(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = ko(e.r)), (this.g = ko(e.g)), (this.b = ko(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Oe) {
    return (
      nn.fromWorkingColorSpace(Ft.copy(this), e),
      Math.round(_t(Ft.r * 255, 0, 255)) * 65536 +
        Math.round(_t(Ft.g * 255, 0, 255)) * 256 +
        Math.round(_t(Ft.b * 255, 0, 255))
    );
  }
  getHexString(e = Oe) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = nn.workingColorSpace) {
    nn.fromWorkingColorSpace(Ft.copy(this), t);
    const n = Ft.r,
      i = Ft.g,
      s = Ft.b,
      a = Math.max(n, i, s),
      o = Math.min(n, i, s);
    let l, c;
    const h = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const u = a - o;
      switch (((c = h <= 0.5 ? u / (a + o) : u / (2 - a - o)), a)) {
        case n:
          l = (i - s) / u + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - n) / u + 2;
          break;
        case s:
          l = (n - i) / u + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = h), e;
  }
  getRGB(e, t = nn.workingColorSpace) {
    return (
      nn.fromWorkingColorSpace(Ft.copy(this), t),
      (e.r = Ft.r),
      (e.g = Ft.g),
      (e.b = Ft.b),
      e
    );
  }
  getStyle(e = Oe) {
    nn.fromWorkingColorSpace(Ft.copy(this), e);
    const t = Ft.r,
      n = Ft.g,
      i = Ft.b;
    return e !== Oe
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(pn),
      (pn.h += e),
      (pn.s += t),
      (pn.l += n),
      this.setHSL(pn.h, pn.s, pn.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(pn), e.getHSL(pa);
    const n = Mr(pn.h, pa.h, t),
      i = Mr(pn.s, pa.s, t),
      s = Mr(pn.l, pa.l, t);
    return this.setHSL(n, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * i),
      (this.g = s[1] * t + s[4] * n + s[7] * i),
      (this.b = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ft = new de();
de.NAMES = gf;
class Ut extends At {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = kr),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Xn = Ym();
function Ym() {
  const r = new ArrayBuffer(4),
    e = new Float32Array(r),
    t = new Uint32Array(r),
    n = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((n[l] = 0), (n[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((n[l] = 1024 >> (-c - 14)),
        (n[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((n[l] = (c + 15) << 10),
        (n[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((n[l] = 31744), (n[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((n[l] = 31744), (n[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    a = new Uint32Array(64),
    o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      h = 0;
    for (; !(c & 8388608); ) (c <<= 1), (h -= 8388608);
    (c &= -8388609), (h += 947912704), (s[l] = c | h);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) a[l] = l << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (o[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: a,
    offsetTable: o,
  };
}
function Wt(r) {
  Math.abs(r) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (r = _t(r, -65504, 65504)),
    (Xn.floatView[0] = r);
  const e = Xn.uint32View[0],
    t = (e >> 23) & 511;
  return Xn.baseTable[t] + ((e & 8388607) >> Xn.shiftTable[t]);
}
function gr(r) {
  const e = r >> 10;
  return (
    (Xn.uint32View[0] =
      Xn.mantissaTable[Xn.offsetTable[e] + (r & 1023)] + Xn.exponentTable[e]),
    Xn.floatView[0]
  );
}
const qm = { toHalfFloat: Wt, fromHalfFloat: gr },
  St = new b(),
  ma = new K();
class nt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Cr),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = on),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        ma.fromBufferAttribute(this, t),
          ma.applyMatrix3(e),
          this.setXY(t, ma.x, ma.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        St.fromBufferAttribute(this, t),
          St.applyMatrix3(e),
          this.setXYZ(t, St.x, St.y, St.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      St.fromBufferAttribute(this, t),
        St.applyMatrix4(e),
        this.setXYZ(t, St.x, St.y, St.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      St.fromBufferAttribute(this, t),
        St.applyNormalMatrix(e),
        this.setXYZ(t, St.x, St.y, St.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      St.fromBufferAttribute(this, t),
        St.transformDirection(e),
        this.setXYZ(t, St.x, St.y, St.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Xe(t, this.array)), (n = Xe(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array)),
        (s = Xe(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Cr && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class Zm extends nt {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class $m extends nt {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class Km extends nt {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class jm extends nt {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class Oc extends nt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Jm extends nt {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class Fc extends nt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Qm extends nt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = gr(this.array[e * this.itemSize]);
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize] = Wt(t)),
      this
    );
  }
  getY(e) {
    let t = gr(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 1] = Wt(t)),
      this
    );
  }
  getZ(e) {
    let t = gr(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 2] = Wt(t)),
      this
    );
  }
  getW(e) {
    let t = gr(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.array[e * this.itemSize + 3] = Wt(t)),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Xe(t, this.array)), (n = Xe(n, this.array))),
      (this.array[e + 0] = Wt(t)),
      (this.array[e + 1] = Wt(n)),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array))),
      (this.array[e + 0] = Wt(t)),
      (this.array[e + 1] = Wt(n)),
      (this.array[e + 2] = Wt(i)),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array)),
        (s = Xe(s, this.array))),
      (this.array[e + 0] = Wt(t)),
      (this.array[e + 1] = Wt(n)),
      (this.array[e + 2] = Wt(i)),
      (this.array[e + 3] = Wt(s)),
      this
    );
  }
}
class Te extends nt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class eg extends nt {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let tg = 0;
const tn = new Ue(),
  Qo = new qe(),
  gs = new b(),
  Jt = new Vt(),
  rr = new Vt(),
  Pt = new b();
class He extends Un {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: tg++ }),
      (this.uuid = en()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (mf(e) ? Fc : Oc)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new We().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return tn.makeRotationFromQuaternion(e), this.applyMatrix4(tn), this;
  }
  rotateX(e) {
    return tn.makeRotationX(e), this.applyMatrix4(tn), this;
  }
  rotateY(e) {
    return tn.makeRotationY(e), this.applyMatrix4(tn), this;
  }
  rotateZ(e) {
    return tn.makeRotationZ(e), this.applyMatrix4(tn), this;
  }
  translate(e, t, n) {
    return tn.makeTranslation(e, t, n), this.applyMatrix4(tn), this;
  }
  scale(e, t, n) {
    return tn.makeScale(e, t, n), this.applyMatrix4(tn), this;
  }
  lookAt(e) {
    return Qo.lookAt(e), Qo.updateMatrix(), this.applyMatrix4(Qo.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(gs).negate(),
      this.translate(gs.x, gs.y, gs.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Te(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Vt());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new b(-1 / 0, -1 / 0, -1 / 0),
          new b(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          Jt.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Pt.addVectors(this.boundingBox.min, Jt.min),
                this.boundingBox.expandByPoint(Pt),
                Pt.addVectors(this.boundingBox.max, Jt.max),
                this.boundingBox.expandByPoint(Pt))
              : (this.boundingBox.expandByPoint(Jt.min),
                this.boundingBox.expandByPoint(Jt.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new hn());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new b(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((Jt.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          rr.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Pt.addVectors(Jt.min, rr.min),
                Jt.expandByPoint(Pt),
                Pt.addVectors(Jt.max, rr.max),
                Jt.expandByPoint(Pt))
              : (Jt.expandByPoint(rr.min), Jt.expandByPoint(rr.max));
        }
      Jt.getCenter(n);
      let i = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Pt.fromBufferAttribute(e, s),
          (i = Math.max(i, n.distanceToSquared(Pt)));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, h = o.count; c < h; c++)
            Pt.fromBufferAttribute(o, c),
              l && (gs.fromBufferAttribute(e, c), Pt.add(gs)),
              (i = Math.max(i, n.distanceToSquared(Pt)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.array,
      i = t.position.array,
      s = t.normal.array,
      a = t.uv.array,
      o = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new nt(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      h = [];
    for (let A = 0; A < o; A++) (c[A] = new b()), (h[A] = new b());
    const u = new b(),
      d = new b(),
      f = new b(),
      m = new K(),
      _ = new K(),
      g = new K(),
      p = new b(),
      v = new b();
    function x(A, k, X) {
      u.fromArray(i, A * 3),
        d.fromArray(i, k * 3),
        f.fromArray(i, X * 3),
        m.fromArray(a, A * 2),
        _.fromArray(a, k * 2),
        g.fromArray(a, X * 2),
        d.sub(u),
        f.sub(u),
        _.sub(m),
        g.sub(m);
      const U = 1 / (_.x * g.y - g.x * _.y);
      isFinite(U) &&
        (p
          .copy(d)
          .multiplyScalar(g.y)
          .addScaledVector(f, -_.y)
          .multiplyScalar(U),
        v
          .copy(f)
          .multiplyScalar(_.x)
          .addScaledVector(d, -g.x)
          .multiplyScalar(U),
        c[A].add(p),
        c[k].add(p),
        c[X].add(p),
        h[A].add(v),
        h[k].add(v),
        h[X].add(v));
    }
    let y = this.groups;
    y.length === 0 && (y = [{ start: 0, count: n.length }]);
    for (let A = 0, k = y.length; A < k; ++A) {
      const X = y[A],
        U = X.start,
        O = X.count;
      for (let N = U, Z = U + O; N < Z; N += 3) x(n[N + 0], n[N + 1], n[N + 2]);
    }
    const S = new b(),
      w = new b(),
      R = new b(),
      P = new b();
    function M(A) {
      R.fromArray(s, A * 3), P.copy(R);
      const k = c[A];
      S.copy(k),
        S.sub(R.multiplyScalar(R.dot(k))).normalize(),
        w.crossVectors(P, k);
      const U = w.dot(h[A]) < 0 ? -1 : 1;
      (l[A * 4] = S.x),
        (l[A * 4 + 1] = S.y),
        (l[A * 4 + 2] = S.z),
        (l[A * 4 + 3] = U);
    }
    for (let A = 0, k = y.length; A < k; ++A) {
      const X = y[A],
        U = X.start,
        O = X.count;
      for (let N = U, Z = U + O; N < Z; N += 3)
        M(n[N + 0]), M(n[N + 1]), M(n[N + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new nt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let d = 0, f = n.count; d < f; d++) n.setXYZ(d, 0, 0, 0);
      const i = new b(),
        s = new b(),
        a = new b(),
        o = new b(),
        l = new b(),
        c = new b(),
        h = new b(),
        u = new b();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const m = e.getX(d + 0),
            _ = e.getX(d + 1),
            g = e.getX(d + 2);
          i.fromBufferAttribute(t, m),
            s.fromBufferAttribute(t, _),
            a.fromBufferAttribute(t, g),
            h.subVectors(a, s),
            u.subVectors(i, s),
            h.cross(u),
            o.fromBufferAttribute(n, m),
            l.fromBufferAttribute(n, _),
            c.fromBufferAttribute(n, g),
            o.add(h),
            l.add(h),
            c.add(h),
            n.setXYZ(m, o.x, o.y, o.z),
            n.setXYZ(_, l.x, l.y, l.z),
            n.setXYZ(g, c.x, c.y, c.z);
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          i.fromBufferAttribute(t, d + 0),
            s.fromBufferAttribute(t, d + 1),
            a.fromBufferAttribute(t, d + 2),
            h.subVectors(a, s),
            u.subVectors(i, s),
            h.cross(u),
            n.setXYZ(d + 0, h.x, h.y, h.z),
            n.setXYZ(d + 1, h.x, h.y, h.z),
            n.setXYZ(d + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Pt.fromBufferAttribute(e, t),
        Pt.normalize(),
        e.setXYZ(t, Pt.x, Pt.y, Pt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        h = o.itemSize,
        u = o.normalized,
        d = new c.constructor(l.length * h);
      let f = 0,
        m = 0;
      for (let _ = 0, g = l.length; _ < g; _++) {
        o.isInterleavedBufferAttribute
          ? (f = l[_] * o.data.stride + o.offset)
          : (f = l[_] * h);
        for (let p = 0; p < h; p++) d[m++] = c[f++];
      }
      return new nt(d, h, u);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new He(),
      n = this.index.array,
      i = this.attributes;
    for (const o in i) {
      const l = i[o],
        c = e(l, n);
      t.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let h = 0, u = c.length; h < u; h++) {
        const d = c[h],
          f = e(d, n);
        l.push(f);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        h = [];
      for (let u = 0, d = c.length; u < d; u++) {
        const f = c[u];
        h.push(f.toJSON(e.data));
      }
      h.length > 0 && ((i[l] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const h = i[c];
      this.setAttribute(c, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const h = [],
        u = s[c];
      for (let d = 0, f = u.length; d < f; d++) h.push(u[d].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, h = a.length; c < h; c++) {
      const u = a[c];
      this.addGroup(u.start, u.count, u.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Oh = new Ue(),
  Li = new $s(),
  ga = new hn(),
  Fh = new b(),
  _s = new b(),
  xs = new b(),
  ys = new b(),
  el = new b(),
  _a = new b(),
  xa = new K(),
  ya = new K(),
  va = new K(),
  Bh = new b(),
  zh = new b(),
  kh = new b(),
  Ma = new b(),
  Sa = new b();
class ce extends qe {
  constructor(e = new He(), t = new Ut()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      s = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      _a.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const h = o[l],
          u = s[l];
        h !== 0 &&
          (el.fromBufferAttribute(u, e),
          a ? _a.addScaledVector(el, h) : _a.addScaledVector(el.sub(t), h));
      }
      t.add(_a);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ga.copy(n.boundingSphere),
      ga.applyMatrix4(s),
      Li.copy(e.ray).recast(e.near),
      !(
        ga.containsPoint(Li.origin) === !1 &&
        (Li.intersectSphere(ga, Fh) === null ||
          Li.origin.distanceToSquared(Fh) > (e.far - e.near) ** 2)
      ) &&
        (Oh.copy(s).invert(),
        Li.copy(e.ray).applyMatrix4(Oh),
        !(n.boundingBox !== null && Li.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t, Li)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const s = this.geometry,
      a = this.material,
      o = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      h = s.attributes.uv1,
      u = s.attributes.normal,
      d = s.groups,
      f = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let m = 0, _ = d.length; m < _; m++) {
          const g = d[m],
            p = a[g.materialIndex],
            v = Math.max(g.start, f.start),
            x = Math.min(
              o.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let y = v, S = x; y < S; y += 3) {
            const w = o.getX(y),
              R = o.getX(y + 1),
              P = o.getX(y + 2);
            (i = ba(this, p, e, n, c, h, u, w, R, P)),
              i &&
                ((i.faceIndex = Math.floor(y / 3)),
                (i.face.materialIndex = g.materialIndex),
                t.push(i));
          }
        }
      else {
        const m = Math.max(0, f.start),
          _ = Math.min(o.count, f.start + f.count);
        for (let g = m, p = _; g < p; g += 3) {
          const v = o.getX(g),
            x = o.getX(g + 1),
            y = o.getX(g + 2);
          (i = ba(this, a, e, n, c, h, u, v, x, y)),
            i && ((i.faceIndex = Math.floor(g / 3)), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let m = 0, _ = d.length; m < _; m++) {
          const g = d[m],
            p = a[g.materialIndex],
            v = Math.max(g.start, f.start),
            x = Math.min(
              l.count,
              Math.min(g.start + g.count, f.start + f.count)
            );
          for (let y = v, S = x; y < S; y += 3) {
            const w = y,
              R = y + 1,
              P = y + 2;
            (i = ba(this, p, e, n, c, h, u, w, R, P)),
              i &&
                ((i.faceIndex = Math.floor(y / 3)),
                (i.face.materialIndex = g.materialIndex),
                t.push(i));
          }
        }
      else {
        const m = Math.max(0, f.start),
          _ = Math.min(l.count, f.start + f.count);
        for (let g = m, p = _; g < p; g += 3) {
          const v = g,
            x = g + 1,
            y = g + 2;
          (i = ba(this, a, e, n, c, h, u, v, x, y)),
            i && ((i.faceIndex = Math.floor(g / 3)), t.push(i));
        }
      }
  }
}
function ng(r, e, t, n, i, s, a, o) {
  let l;
  if (
    (e.side === wt
      ? (l = n.intersectTriangle(a, s, i, !0, o))
      : (l = n.intersectTriangle(i, s, a, e.side === Zt, o)),
    l === null)
  )
    return null;
  Sa.copy(o), Sa.applyMatrix4(r.matrixWorld);
  const c = t.ray.origin.distanceTo(Sa);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Sa.clone(), object: r };
}
function ba(r, e, t, n, i, s, a, o, l, c) {
  r.getVertexPosition(o, _s),
    r.getVertexPosition(l, xs),
    r.getVertexPosition(c, ys);
  const h = ng(r, e, t, n, _s, xs, ys, Ma);
  if (h) {
    i &&
      (xa.fromBufferAttribute(i, o),
      ya.fromBufferAttribute(i, l),
      va.fromBufferAttribute(i, c),
      (h.uv = Yt.getInterpolation(Ma, _s, xs, ys, xa, ya, va, new K()))),
      s &&
        (xa.fromBufferAttribute(s, o),
        ya.fromBufferAttribute(s, l),
        va.fromBufferAttribute(s, c),
        (h.uv1 = Yt.getInterpolation(Ma, _s, xs, ys, xa, ya, va, new K())),
        (h.uv2 = h.uv1)),
      a &&
        (Bh.fromBufferAttribute(a, o),
        zh.fromBufferAttribute(a, l),
        kh.fromBufferAttribute(a, c),
        (h.normal = Yt.getInterpolation(Ma, _s, xs, ys, Bh, zh, kh, new b())),
        h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
    const u = { a: o, b: l, c, normal: new b(), materialIndex: 0 };
    Yt.getNormal(_s, xs, ys, u.normal), (h.face = u);
  }
  return h;
}
class at extends He {
  constructor(e = 1, t = 1, n = 1, i = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (a = Math.floor(a));
    const l = [],
      c = [],
      h = [],
      u = [];
    let d = 0,
      f = 0;
    m("z", "y", "x", -1, -1, n, t, e, a, s, 0),
      m("z", "y", "x", 1, -1, n, t, -e, a, s, 1),
      m("x", "z", "y", 1, 1, e, n, t, i, a, 2),
      m("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
      m("x", "y", "z", 1, -1, e, t, n, i, s, 4),
      m("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Te(c, 3)),
      this.setAttribute("normal", new Te(h, 3)),
      this.setAttribute("uv", new Te(u, 2));
    function m(_, g, p, v, x, y, S, w, R, P, M) {
      const A = y / R,
        k = S / P,
        X = y / 2,
        U = S / 2,
        O = w / 2,
        N = R + 1,
        Z = P + 1;
      let B = 0,
        G = 0;
      const $ = new b();
      for (let Y = 0; Y < Z; Y++) {
        const he = Y * k - U;
        for (let F = 0; F < N; F++) {
          const ne = F * A - X;
          ($[_] = ne * v),
            ($[g] = he * x),
            ($[p] = O),
            c.push($.x, $.y, $.z),
            ($[_] = 0),
            ($[g] = 0),
            ($[p] = w > 0 ? 1 : -1),
            h.push($.x, $.y, $.z),
            u.push(F / R),
            u.push(1 - Y / P),
            (B += 1);
        }
      }
      for (let Y = 0; Y < P; Y++)
        for (let he = 0; he < R; he++) {
          const F = d + he + N * Y,
            ne = d + he + N * (Y + 1),
            ie = d + (he + 1) + N * (Y + 1),
            me = d + (he + 1) + N * Y;
          l.push(F, ne, me), l.push(ne, ie, me), (G += 6);
        }
      o.addGroup(f, G, M), (f += G), (d += B);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new at(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Hs(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function Ht(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = Hs(r[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function ig(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function _f(r) {
  return r.getRenderTarget() === null ? r.outputColorSpace : xn;
}
const xf = { clone: Hs, merge: Ht };
var sg = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  rg = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class cn extends At {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = sg),
      (this.fragmentShader = rg),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Hs(e.uniforms)),
      (this.uniformsGroups = ig(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture
        ? (t.uniforms[i] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[i] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[i] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[i] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[i] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: a.toArray() })
        : (t.uniforms[i] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Mo extends qe {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Ue()),
      (this.projectionMatrix = new Ue()),
      (this.projectionMatrixInverse = new Ue()),
      (this.coordinateSystem = Rn);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Et extends Mo {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = ks * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ji * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ks * 2 * Math.atan(Math.tan(Ji * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, s, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Ji * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      s = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (s += (a.offsetX * i) / l),
        (t -= (a.offsetY * n) / c),
        (i *= a.width / l),
        (n *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - n,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const vs = -90,
  Ms = 1;
class yf extends qe {
  constructor(e, t, n) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = n),
      (this.coordinateSystem = null);
    const i = new Et(vs, Ms, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new Et(vs, Ms, e, t);
    (s.layers = this.layers), this.add(s);
    const a = new Et(vs, Ms, e, t);
    (a.layers = this.layers), this.add(a);
    const o = new Et(vs, Ms, e, t);
    (o.layers = this.layers), this.add(o);
    const l = new Et(vs, Ms, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new Et(vs, Ms, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [n, i, s, a, o, l] = t;
    for (const c of t) this.remove(c);
    if (e === Rn)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === Lr)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [i, s, a, o, l, c] = this.children,
      h = e.getRenderTarget(),
      u = e.toneMapping,
      d = e.xr.enabled;
    (e.toneMapping = Pn), (e.xr.enabled = !1);
    const f = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, s),
      e.setRenderTarget(n, 2),
      e.render(t, a),
      e.setRenderTarget(n, 3),
      e.render(t, o),
      e.setRenderTarget(n, 4),
      e.render(t, l),
      (n.texture.generateMipmaps = f),
      e.setRenderTarget(n, 5),
      e.render(t, c),
      e.setRenderTarget(h),
      (e.toneMapping = u),
      (e.xr.enabled = d),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class Gr extends ht {
  constructor(e, t, n, i, s, a, o, l, c, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : yi),
      super(e, t, n, i, s, a, o, l, c, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class vf extends yn {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    t.encoding !== void 0 &&
      (Sr(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === _i ? Oe : xi)),
      (this.texture = new Gr(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : ot);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new at(5, 5, 5),
      s = new cn({
        name: "CubemapFromEquirect",
        uniforms: Hs(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: wt,
        blending: jn,
      });
    s.uniforms.tEquirect.value = t;
    const a = new ce(i, s),
      o = t.minFilter;
    return (
      t.minFilter === Dn && (t.minFilter = ot),
      new yf(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(s);
  }
}
const tl = new b(),
  ag = new b(),
  og = new We();
class ui {
  constructor(e = new b(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = tl.subVectors(n, t).cross(ag.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(tl),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || og.getNormalMatrix(e),
      i = this.coplanarPoint(tl).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ii = new hn(),
  wa = new b();
class So {
  constructor(
    e = new ui(),
    t = new ui(),
    n = new ui(),
    i = new ui(),
    s = new ui(),
    a = new ui()
  ) {
    this.planes = [e, t, n, i, s, a];
  }
  set(e, t, n, i, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(n),
      o[3].copy(i),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Rn) {
    const n = this.planes,
      i = e.elements,
      s = i[0],
      a = i[1],
      o = i[2],
      l = i[3],
      c = i[4],
      h = i[5],
      u = i[6],
      d = i[7],
      f = i[8],
      m = i[9],
      _ = i[10],
      g = i[11],
      p = i[12],
      v = i[13],
      x = i[14],
      y = i[15];
    if (
      (n[0].setComponents(l - s, d - c, g - f, y - p).normalize(),
      n[1].setComponents(l + s, d + c, g + f, y + p).normalize(),
      n[2].setComponents(l + a, d + h, g + m, y + v).normalize(),
      n[3].setComponents(l - a, d - h, g - m, y - v).normalize(),
      n[4].setComponents(l - o, d - u, g - _, y - x).normalize(),
      t === Rn)
    )
      n[5].setComponents(l + o, d + u, g + _, y + x).normalize();
    else if (t === Lr) n[5].setComponents(o, u, _, x).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ii.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Ii.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ii);
  }
  intersectsSprite(e) {
    return (
      Ii.center.set(0, 0, 0),
      (Ii.radius = 0.7071067811865476),
      Ii.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ii)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((wa.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (wa.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (wa.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(wa) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Mf() {
  let r = null,
    e = !1,
    t = null,
    n = null;
  function i(s, a) {
    t(s, a), (n = r.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = r.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      r = s;
    },
  };
}
function lg(r, e) {
  const t = e.isWebGL2,
    n = new WeakMap();
  function i(c, h) {
    const u = c.array,
      d = c.usage,
      f = r.createBuffer();
    r.bindBuffer(h, f), r.bufferData(h, u, d), c.onUploadCallback();
    let m;
    if (u instanceof Float32Array) m = r.FLOAT;
    else if (u instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) m = r.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else m = r.UNSIGNED_SHORT;
    else if (u instanceof Int16Array) m = r.SHORT;
    else if (u instanceof Uint32Array) m = r.UNSIGNED_INT;
    else if (u instanceof Int32Array) m = r.INT;
    else if (u instanceof Int8Array) m = r.BYTE;
    else if (u instanceof Uint8Array) m = r.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray) m = r.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + u
      );
    return {
      buffer: f,
      type: m,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function s(c, h, u) {
    const d = h.array,
      f = h.updateRange;
    r.bindBuffer(u, c),
      f.count === -1
        ? r.bufferSubData(u, 0, d)
        : (t
            ? r.bufferSubData(
                u,
                f.offset * d.BYTES_PER_ELEMENT,
                d,
                f.offset,
                f.count
              )
            : r.bufferSubData(
                u,
                f.offset * d.BYTES_PER_ELEMENT,
                d.subarray(f.offset, f.offset + f.count)
              ),
          (f.count = -1)),
      h.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = n.get(c);
    h && (r.deleteBuffer(h.buffer), n.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const d = n.get(c);
      (!d || d.version < c.version) &&
        n.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = n.get(c);
    u === void 0
      ? n.set(c, i(c, h))
      : u.version < c.version && (s(u.buffer, c, h), (u.version = c.version));
  }
  return { get: a, remove: o, update: l };
}
class Qn extends He {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const s = e / 2,
      a = t / 2,
      o = Math.floor(n),
      l = Math.floor(i),
      c = o + 1,
      h = l + 1,
      u = e / o,
      d = t / l,
      f = [],
      m = [],
      _ = [],
      g = [];
    for (let p = 0; p < h; p++) {
      const v = p * d - a;
      for (let x = 0; x < c; x++) {
        const y = x * u - s;
        m.push(y, -v, 0), _.push(0, 0, 1), g.push(x / o), g.push(1 - p / l);
      }
    }
    for (let p = 0; p < l; p++)
      for (let v = 0; v < o; v++) {
        const x = v + c * p,
          y = v + c * (p + 1),
          S = v + 1 + c * (p + 1),
          w = v + 1 + c * p;
        f.push(x, y, w), f.push(y, S, w);
      }
    this.setIndex(f),
      this.setAttribute("position", new Te(m, 3)),
      this.setAttribute("normal", new Te(_, 3)),
      this.setAttribute("uv", new Te(g, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Qn(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var cg = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  hg = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  ug = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  dg = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  fg = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  pg = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  mg = "vec3 transformed = vec3( position );",
  gg = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  _g = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  xg = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  yg = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  vg = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  Mg = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Sg = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  bg = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  wg = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Eg = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Ag = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  Tg = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Rg = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Cg = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Pg = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Lg = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Ig = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Dg = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Ug = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Ng = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  Og = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Fg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  Bg = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  zg = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  kg = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Hg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Gg = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Vg = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  Wg = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  Xg = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  Yg = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  qg = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  Zg = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  $g = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Kg = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  jg = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  Jg = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  Qg = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  e0 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  t0 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  n0 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  i0 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  s0 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  r0 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  a0 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  o0 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  l0 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  c0 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  h0 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  u0 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  d0 = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
  f0 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  p0 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  m0 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  g0 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  _0 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  x0 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  y0 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  v0 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  M0 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  S0 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  b0 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  w0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  E0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  A0 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  T0 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  R0 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  C0 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  P0 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  L0 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  I0 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  D0 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  U0 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  N0 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  O0 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  F0 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  B0 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  z0 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  k0 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  H0 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  G0 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  V0 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  W0 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  X0 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  Y0 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  q0 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  Z0 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  $0 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  K0 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  j0 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  J0 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  Q0 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  e_ = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  t_ = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  n_ = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  i_ = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const s_ = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  r_ = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  a_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  o_ = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  l_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  c_ = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  h_ = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  u_ = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  d_ = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  f_ = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  p_ = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  m_ = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  g_ = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  __ = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  x_ = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  y_ = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  v_ = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  M_ = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  S_ = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  b_ = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  w_ = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  E_ = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  A_ = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  T_ = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  R_ = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  C_ = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  P_ = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  L_ = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  I_ = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  D_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  U_ = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  N_ = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  O_ = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  F_ = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Ve = {
    alphamap_fragment: cg,
    alphamap_pars_fragment: hg,
    alphatest_fragment: ug,
    alphatest_pars_fragment: dg,
    aomap_fragment: fg,
    aomap_pars_fragment: pg,
    begin_vertex: mg,
    beginnormal_vertex: gg,
    bsdfs: _g,
    iridescence_fragment: xg,
    bumpmap_pars_fragment: yg,
    clipping_planes_fragment: vg,
    clipping_planes_pars_fragment: Mg,
    clipping_planes_pars_vertex: Sg,
    clipping_planes_vertex: bg,
    color_fragment: wg,
    color_pars_fragment: Eg,
    color_pars_vertex: Ag,
    color_vertex: Tg,
    common: Rg,
    cube_uv_reflection_fragment: Cg,
    defaultnormal_vertex: Pg,
    displacementmap_pars_vertex: Lg,
    displacementmap_vertex: Ig,
    emissivemap_fragment: Dg,
    emissivemap_pars_fragment: Ug,
    encodings_fragment: Ng,
    encodings_pars_fragment: Og,
    envmap_fragment: Fg,
    envmap_common_pars_fragment: Bg,
    envmap_pars_fragment: zg,
    envmap_pars_vertex: kg,
    envmap_physical_pars_fragment: Jg,
    envmap_vertex: Hg,
    fog_vertex: Gg,
    fog_pars_vertex: Vg,
    fog_fragment: Wg,
    fog_pars_fragment: Xg,
    gradientmap_pars_fragment: Yg,
    lightmap_fragment: qg,
    lightmap_pars_fragment: Zg,
    lights_lambert_fragment: $g,
    lights_lambert_pars_fragment: Kg,
    lights_pars_begin: jg,
    lights_toon_fragment: Qg,
    lights_toon_pars_fragment: e0,
    lights_phong_fragment: t0,
    lights_phong_pars_fragment: n0,
    lights_physical_fragment: i0,
    lights_physical_pars_fragment: s0,
    lights_fragment_begin: r0,
    lights_fragment_maps: a0,
    lights_fragment_end: o0,
    logdepthbuf_fragment: l0,
    logdepthbuf_pars_fragment: c0,
    logdepthbuf_pars_vertex: h0,
    logdepthbuf_vertex: u0,
    map_fragment: d0,
    map_pars_fragment: f0,
    map_particle_fragment: p0,
    map_particle_pars_fragment: m0,
    metalnessmap_fragment: g0,
    metalnessmap_pars_fragment: _0,
    morphcolor_vertex: x0,
    morphnormal_vertex: y0,
    morphtarget_pars_vertex: v0,
    morphtarget_vertex: M0,
    normal_fragment_begin: S0,
    normal_fragment_maps: b0,
    normal_pars_fragment: w0,
    normal_pars_vertex: E0,
    normal_vertex: A0,
    normalmap_pars_fragment: T0,
    clearcoat_normal_fragment_begin: R0,
    clearcoat_normal_fragment_maps: C0,
    clearcoat_pars_fragment: P0,
    iridescence_pars_fragment: L0,
    output_fragment: I0,
    packing: D0,
    premultiplied_alpha_fragment: U0,
    project_vertex: N0,
    dithering_fragment: O0,
    dithering_pars_fragment: F0,
    roughnessmap_fragment: B0,
    roughnessmap_pars_fragment: z0,
    shadowmap_pars_fragment: k0,
    shadowmap_pars_vertex: H0,
    shadowmap_vertex: G0,
    shadowmask_pars_fragment: V0,
    skinbase_vertex: W0,
    skinning_pars_vertex: X0,
    skinning_vertex: Y0,
    skinnormal_vertex: q0,
    specularmap_fragment: Z0,
    specularmap_pars_fragment: $0,
    tonemapping_fragment: K0,
    tonemapping_pars_fragment: j0,
    transmission_fragment: J0,
    transmission_pars_fragment: Q0,
    uv_pars_fragment: e_,
    uv_pars_vertex: t_,
    uv_vertex: n_,
    worldpos_vertex: i_,
    background_vert: s_,
    background_frag: r_,
    backgroundCube_vert: a_,
    backgroundCube_frag: o_,
    cube_vert: l_,
    cube_frag: c_,
    depth_vert: h_,
    depth_frag: u_,
    distanceRGBA_vert: d_,
    distanceRGBA_frag: f_,
    equirect_vert: p_,
    equirect_frag: m_,
    linedashed_vert: g_,
    linedashed_frag: __,
    meshbasic_vert: x_,
    meshbasic_frag: y_,
    meshlambert_vert: v_,
    meshlambert_frag: M_,
    meshmatcap_vert: S_,
    meshmatcap_frag: b_,
    meshnormal_vert: w_,
    meshnormal_frag: E_,
    meshphong_vert: A_,
    meshphong_frag: T_,
    meshphysical_vert: R_,
    meshphysical_frag: C_,
    meshtoon_vert: P_,
    meshtoon_frag: L_,
    points_vert: I_,
    points_frag: D_,
    shadow_vert: U_,
    shadow_frag: N_,
    sprite_vert: O_,
    sprite_frag: F_,
  },
  fe = {
    common: {
      diffuse: { value: new de(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new We() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new We() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new We() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new We() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new We() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new We() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new We() },
      normalScale: { value: new K(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new We() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new We() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new We() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new We() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new de(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new de(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new We() },
      alphaTest: { value: 0 },
      uvTransform: { value: new We() },
    },
    sprite: {
      diffuse: { value: new de(16777215) },
      opacity: { value: 1 },
      center: { value: new K(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new We() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new We() },
      alphaTest: { value: 0 },
    },
  },
  mn = {
    basic: {
      uniforms: Ht([
        fe.common,
        fe.specularmap,
        fe.envmap,
        fe.aomap,
        fe.lightmap,
        fe.fog,
      ]),
      vertexShader: Ve.meshbasic_vert,
      fragmentShader: Ve.meshbasic_frag,
    },
    lambert: {
      uniforms: Ht([
        fe.common,
        fe.specularmap,
        fe.envmap,
        fe.aomap,
        fe.lightmap,
        fe.emissivemap,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        fe.fog,
        fe.lights,
        { emissive: { value: new de(0) } },
      ]),
      vertexShader: Ve.meshlambert_vert,
      fragmentShader: Ve.meshlambert_frag,
    },
    phong: {
      uniforms: Ht([
        fe.common,
        fe.specularmap,
        fe.envmap,
        fe.aomap,
        fe.lightmap,
        fe.emissivemap,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        fe.fog,
        fe.lights,
        {
          emissive: { value: new de(0) },
          specular: { value: new de(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ve.meshphong_vert,
      fragmentShader: Ve.meshphong_frag,
    },
    standard: {
      uniforms: Ht([
        fe.common,
        fe.envmap,
        fe.aomap,
        fe.lightmap,
        fe.emissivemap,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        fe.roughnessmap,
        fe.metalnessmap,
        fe.fog,
        fe.lights,
        {
          emissive: { value: new de(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ve.meshphysical_vert,
      fragmentShader: Ve.meshphysical_frag,
    },
    toon: {
      uniforms: Ht([
        fe.common,
        fe.aomap,
        fe.lightmap,
        fe.emissivemap,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        fe.gradientmap,
        fe.fog,
        fe.lights,
        { emissive: { value: new de(0) } },
      ]),
      vertexShader: Ve.meshtoon_vert,
      fragmentShader: Ve.meshtoon_frag,
    },
    matcap: {
      uniforms: Ht([
        fe.common,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        fe.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ve.meshmatcap_vert,
      fragmentShader: Ve.meshmatcap_frag,
    },
    points: {
      uniforms: Ht([fe.points, fe.fog]),
      vertexShader: Ve.points_vert,
      fragmentShader: Ve.points_frag,
    },
    dashed: {
      uniforms: Ht([
        fe.common,
        fe.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ve.linedashed_vert,
      fragmentShader: Ve.linedashed_frag,
    },
    depth: {
      uniforms: Ht([fe.common, fe.displacementmap]),
      vertexShader: Ve.depth_vert,
      fragmentShader: Ve.depth_frag,
    },
    normal: {
      uniforms: Ht([
        fe.common,
        fe.bumpmap,
        fe.normalmap,
        fe.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ve.meshnormal_vert,
      fragmentShader: Ve.meshnormal_frag,
    },
    sprite: {
      uniforms: Ht([fe.sprite, fe.fog]),
      vertexShader: Ve.sprite_vert,
      fragmentShader: Ve.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new We() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ve.background_vert,
      fragmentShader: Ve.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ve.backgroundCube_vert,
      fragmentShader: Ve.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ve.cube_vert,
      fragmentShader: Ve.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ve.equirect_vert,
      fragmentShader: Ve.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ht([
        fe.common,
        fe.displacementmap,
        {
          referencePosition: { value: new b() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ve.distanceRGBA_vert,
      fragmentShader: Ve.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ht([
        fe.lights,
        fe.fog,
        { color: { value: new de(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ve.shadow_vert,
      fragmentShader: Ve.shadow_frag,
    },
  };
mn.physical = {
  uniforms: Ht([
    mn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new We() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new We() },
      clearcoatNormalScale: { value: new K(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new We() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new We() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new We() },
      sheen: { value: 0 },
      sheenColor: { value: new de(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new We() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new We() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new We() },
      transmissionSamplerSize: { value: new K() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new We() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new de(0) },
      specularColor: { value: new de(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new We() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new We() },
      anisotropyVector: { value: new K() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new We() },
    },
  ]),
  vertexShader: Ve.meshphysical_vert,
  fragmentShader: Ve.meshphysical_frag,
};
const Ea = { r: 0, b: 0, g: 0 };
function B_(r, e, t, n, i, s, a) {
  const o = new de(0);
  let l = s === !0 ? 0 : 1,
    c,
    h,
    u = null,
    d = 0,
    f = null;
  function m(g, p) {
    let v = !1,
      x = p.isScene === !0 ? p.background : null;
    switch (
      (x && x.isTexture && (x = (p.backgroundBlurriness > 0 ? t : e).get(x)),
      x === null ? _(o, l) : x && x.isColor && (_(x, 1), (v = !0)),
      r.xr.getEnvironmentBlendMode())
    ) {
      case "opaque":
        v = !0;
        break;
      case "additive":
        n.buffers.color.setClear(0, 0, 0, 1, a), (v = !0);
        break;
      case "alpha-blend":
        n.buffers.color.setClear(0, 0, 0, 0, a), (v = !0);
        break;
    }
    (r.autoClear || v) &&
      r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
      x && (x.isCubeTexture || x.mapping === Zs)
        ? (h === void 0 &&
            ((h = new ce(
              new at(1, 1, 1),
              new cn({
                name: "BackgroundCubeMaterial",
                uniforms: Hs(mn.backgroundCube.uniforms),
                vertexShader: mn.backgroundCube.vertexShader,
                fragmentShader: mn.backgroundCube.fragmentShader,
                side: wt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (w, R, P) {
              this.matrixWorld.copyPosition(P.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(h)),
          (h.material.uniforms.envMap.value = x),
          (h.material.uniforms.flipEnvMap.value =
            x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            p.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (h.material.toneMapped = x.colorSpace !== Oe),
          (u !== x || d !== x.version || f !== r.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (u = x),
            (d = x.version),
            (f = r.toneMapping)),
          h.layers.enableAll(),
          g.unshift(h, h.geometry, h.material, 0, 0, null))
        : x &&
          x.isTexture &&
          (c === void 0 &&
            ((c = new ce(
              new Qn(2, 2),
              new cn({
                name: "BackgroundMaterial",
                uniforms: Hs(mn.background.uniforms),
                vertexShader: mn.background.vertexShader,
                fragmentShader: mn.background.fragmentShader,
                side: Zt,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(c)),
          (c.material.uniforms.t2D.value = x),
          (c.material.uniforms.backgroundIntensity.value =
            p.backgroundIntensity),
          (c.material.toneMapped = x.colorSpace !== Oe),
          x.matrixAutoUpdate === !0 && x.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(x.matrix),
          (u !== x || d !== x.version || f !== r.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (u = x),
            (d = x.version),
            (f = r.toneMapping)),
          c.layers.enableAll(),
          g.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function _(g, p) {
    g.getRGB(Ea, _f(r)), n.buffers.color.setClear(Ea.r, Ea.g, Ea.b, p, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (g, p = 1) {
      o.set(g), (l = p), _(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (g) {
      (l = g), _(o, l);
    },
    render: m,
  };
}
function z_(r, e, t, n) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = n.isWebGL2 || s !== null,
    o = {},
    l = g(null);
  let c = l,
    h = !1;
  function u(O, N, Z, B, G) {
    let $ = !1;
    if (a) {
      const Y = _(B, Z, N);
      c !== Y && ((c = Y), f(c.object)),
        ($ = p(O, B, Z, G)),
        $ && v(O, B, Z, G);
    } else {
      const Y = N.wireframe === !0;
      (c.geometry !== B.id || c.program !== Z.id || c.wireframe !== Y) &&
        ((c.geometry = B.id), (c.program = Z.id), (c.wireframe = Y), ($ = !0));
    }
    G !== null && t.update(G, r.ELEMENT_ARRAY_BUFFER),
      ($ || h) &&
        ((h = !1),
        P(O, N, Z, B),
        G !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(G).buffer));
  }
  function d() {
    return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
  }
  function f(O) {
    return n.isWebGL2 ? r.bindVertexArray(O) : s.bindVertexArrayOES(O);
  }
  function m(O) {
    return n.isWebGL2 ? r.deleteVertexArray(O) : s.deleteVertexArrayOES(O);
  }
  function _(O, N, Z) {
    const B = Z.wireframe === !0;
    let G = o[O.id];
    G === void 0 && ((G = {}), (o[O.id] = G));
    let $ = G[N.id];
    $ === void 0 && (($ = {}), (G[N.id] = $));
    let Y = $[B];
    return Y === void 0 && ((Y = g(d())), ($[B] = Y)), Y;
  }
  function g(O) {
    const N = [],
      Z = [],
      B = [];
    for (let G = 0; G < i; G++) (N[G] = 0), (Z[G] = 0), (B[G] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: N,
      enabledAttributes: Z,
      attributeDivisors: B,
      object: O,
      attributes: {},
      index: null,
    };
  }
  function p(O, N, Z, B) {
    const G = c.attributes,
      $ = N.attributes;
    let Y = 0;
    const he = Z.getAttributes();
    for (const F in he)
      if (he[F].location >= 0) {
        const ie = G[F];
        let me = $[F];
        if (
          (me === void 0 &&
            (F === "instanceMatrix" &&
              O.instanceMatrix &&
              (me = O.instanceMatrix),
            F === "instanceColor" && O.instanceColor && (me = O.instanceColor)),
          ie === void 0 || ie.attribute !== me || (me && ie.data !== me.data))
        )
          return !0;
        Y++;
      }
    return c.attributesNum !== Y || c.index !== B;
  }
  function v(O, N, Z, B) {
    const G = {},
      $ = N.attributes;
    let Y = 0;
    const he = Z.getAttributes();
    for (const F in he)
      if (he[F].location >= 0) {
        let ie = $[F];
        ie === void 0 &&
          (F === "instanceMatrix" &&
            O.instanceMatrix &&
            (ie = O.instanceMatrix),
          F === "instanceColor" && O.instanceColor && (ie = O.instanceColor));
        const me = {};
        (me.attribute = ie),
          ie && ie.data && (me.data = ie.data),
          (G[F] = me),
          Y++;
      }
    (c.attributes = G), (c.attributesNum = Y), (c.index = B);
  }
  function x() {
    const O = c.newAttributes;
    for (let N = 0, Z = O.length; N < Z; N++) O[N] = 0;
  }
  function y(O) {
    S(O, 0);
  }
  function S(O, N) {
    const Z = c.newAttributes,
      B = c.enabledAttributes,
      G = c.attributeDivisors;
    (Z[O] = 1),
      B[O] === 0 && (r.enableVertexAttribArray(O), (B[O] = 1)),
      G[O] !== N &&
        ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](O, N),
        (G[O] = N));
  }
  function w() {
    const O = c.newAttributes,
      N = c.enabledAttributes;
    for (let Z = 0, B = N.length; Z < B; Z++)
      N[Z] !== O[Z] && (r.disableVertexAttribArray(Z), (N[Z] = 0));
  }
  function R(O, N, Z, B, G, $, Y) {
    Y === !0
      ? r.vertexAttribIPointer(O, N, Z, G, $)
      : r.vertexAttribPointer(O, N, Z, B, G, $);
  }
  function P(O, N, Z, B) {
    if (
      n.isWebGL2 === !1 &&
      (O.isInstancedMesh || B.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    x();
    const G = B.attributes,
      $ = Z.getAttributes(),
      Y = N.defaultAttributeValues;
    for (const he in $) {
      const F = $[he];
      if (F.location >= 0) {
        let ne = G[he];
        if (
          (ne === void 0 &&
            (he === "instanceMatrix" &&
              O.instanceMatrix &&
              (ne = O.instanceMatrix),
            he === "instanceColor" &&
              O.instanceColor &&
              (ne = O.instanceColor)),
          ne !== void 0)
        ) {
          const ie = ne.normalized,
            me = ne.itemSize,
            ge = t.get(ne);
          if (ge === void 0) continue;
          const Me = ge.buffer,
            Ne = ge.type,
            Ce = ge.bytesPerElement,
            Ze =
              n.isWebGL2 === !0 &&
              (Ne === r.INT || Ne === r.UNSIGNED_INT || ne.gpuType === bc);
          if (ne.isInterleavedBufferAttribute) {
            const Pe = ne.data,
              I = Pe.stride,
              le = ne.offset;
            if (Pe.isInstancedInterleavedBuffer) {
              for (let Q = 0; Q < F.locationSize; Q++)
                S(F.location + Q, Pe.meshPerAttribute);
              O.isInstancedMesh !== !0 &&
                B._maxInstanceCount === void 0 &&
                (B._maxInstanceCount = Pe.meshPerAttribute * Pe.count);
            } else for (let Q = 0; Q < F.locationSize; Q++) y(F.location + Q);
            r.bindBuffer(r.ARRAY_BUFFER, Me);
            for (let Q = 0; Q < F.locationSize; Q++)
              R(
                F.location + Q,
                me / F.locationSize,
                Ne,
                ie,
                I * Ce,
                (le + (me / F.locationSize) * Q) * Ce,
                Ze
              );
          } else {
            if (ne.isInstancedBufferAttribute) {
              for (let Pe = 0; Pe < F.locationSize; Pe++)
                S(F.location + Pe, ne.meshPerAttribute);
              O.isInstancedMesh !== !0 &&
                B._maxInstanceCount === void 0 &&
                (B._maxInstanceCount = ne.meshPerAttribute * ne.count);
            } else
              for (let Pe = 0; Pe < F.locationSize; Pe++) y(F.location + Pe);
            r.bindBuffer(r.ARRAY_BUFFER, Me);
            for (let Pe = 0; Pe < F.locationSize; Pe++)
              R(
                F.location + Pe,
                me / F.locationSize,
                Ne,
                ie,
                me * Ce,
                (me / F.locationSize) * Pe * Ce,
                Ze
              );
          }
        } else if (Y !== void 0) {
          const ie = Y[he];
          if (ie !== void 0)
            switch (ie.length) {
              case 2:
                r.vertexAttrib2fv(F.location, ie);
                break;
              case 3:
                r.vertexAttrib3fv(F.location, ie);
                break;
              case 4:
                r.vertexAttrib4fv(F.location, ie);
                break;
              default:
                r.vertexAttrib1fv(F.location, ie);
            }
        }
      }
    }
    w();
  }
  function M() {
    X();
    for (const O in o) {
      const N = o[O];
      for (const Z in N) {
        const B = N[Z];
        for (const G in B) m(B[G].object), delete B[G];
        delete N[Z];
      }
      delete o[O];
    }
  }
  function A(O) {
    if (o[O.id] === void 0) return;
    const N = o[O.id];
    for (const Z in N) {
      const B = N[Z];
      for (const G in B) m(B[G].object), delete B[G];
      delete N[Z];
    }
    delete o[O.id];
  }
  function k(O) {
    for (const N in o) {
      const Z = o[N];
      if (Z[O.id] === void 0) continue;
      const B = Z[O.id];
      for (const G in B) m(B[G].object), delete B[G];
      delete Z[O.id];
    }
  }
  function X() {
    U(), (h = !0), c !== l && ((c = l), f(c.object));
  }
  function U() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: u,
    reset: X,
    resetDefaultState: U,
    dispose: M,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: k,
    initAttributes: x,
    enableAttribute: y,
    disableUnusedAttributes: w,
  };
}
function k_(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function a(c) {
    s = c;
  }
  function o(c, h) {
    r.drawArrays(s, c, h), t.update(h, s, 1);
  }
  function l(c, h, u) {
    if (u === 0) return;
    let d, f;
    if (i) (d = r), (f = "drawArraysInstanced");
    else if (
      ((d = e.get("ANGLE_instanced_arrays")),
      (f = "drawArraysInstancedANGLE"),
      d === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    d[f](s, c, h, u), t.update(h, s, u);
  }
  (this.setMode = a), (this.render = o), (this.renderInstances = l);
}
function H_(r, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const R = e.get("EXT_texture_filter_anisotropic");
      n = r.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function s(R) {
    if (R === "highp") {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision >
          0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      R = "mediump";
    }
    return R === "mediump" &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision >
        0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext < "u" &&
    r.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const l = s(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    u = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    d = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    f = r.getParameter(r.MAX_TEXTURE_SIZE),
    m = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    _ = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    g = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    p = r.getParameter(r.MAX_VARYING_VECTORS),
    v = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    x = d > 0,
    y = a || e.has("OES_texture_float"),
    S = x && y,
    w = a ? r.getParameter(r.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: h,
    maxTextures: u,
    maxVertexTextures: d,
    maxTextureSize: f,
    maxCubemapSize: m,
    maxAttributes: _,
    maxVertexUniforms: g,
    maxVaryings: p,
    maxFragmentUniforms: v,
    vertexTextures: x,
    floatFragmentTextures: y,
    floatVertexTextures: S,
    maxSamples: w,
  };
}
function G_(r) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    s = !1;
  const a = new ui(),
    o = new We(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (u, d) {
      const f = u.length !== 0 || d || n !== 0 || i;
      return (i = d), (n = u.length), f;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (u, d) {
      t = h(u, d, 0);
    }),
    (this.setState = function (u, d, f) {
      const m = u.clippingPlanes,
        _ = u.clipIntersection,
        g = u.clipShadows,
        p = r.get(u);
      if (!i || m === null || m.length === 0 || (s && !g)) s ? h(null) : c();
      else {
        const v = s ? 0 : n,
          x = v * 4;
        let y = p.clippingState || null;
        (l.value = y), (y = h(m, d, x, f));
        for (let S = 0; S !== x; ++S) y[S] = t[S];
        (p.clippingState = y),
          (this.numIntersection = _ ? this.numPlanes : 0),
          (this.numPlanes += v);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function h(u, d, f, m) {
    const _ = u !== null ? u.length : 0;
    let g = null;
    if (_ !== 0) {
      if (((g = l.value), m !== !0 || g === null)) {
        const p = f + _ * 4,
          v = d.matrixWorldInverse;
        o.getNormalMatrix(v),
          (g === null || g.length < p) && (g = new Float32Array(p));
        for (let x = 0, y = f; x !== _; ++x, y += 4)
          a.copy(u[x]).applyMatrix4(v, o),
            a.normal.toArray(g, y),
            (g[y + 3] = a.constant);
      }
      (l.value = g), (l.needsUpdate = !0);
    }
    return (e.numPlanes = _), (e.numIntersection = 0), g;
  }
}
function V_(r) {
  let e = new WeakMap();
  function t(a, o) {
    return o === Er ? (a.mapping = yi) : o === Ar && (a.mapping = vi), a;
  }
  function n(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === Er || o === Ar)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new vf(l.height / 2);
            return (
              c.fromEquirectangularTexture(r, a),
              e.set(a, c),
              a.addEventListener("dispose", i),
              t(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const o = a.target;
    o.removeEventListener("dispose", i);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
class Ks extends Mo {
  constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = n - e,
      a = n + e,
      o = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= h * this.view.offsetY),
        (l = o - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      a,
      o,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const Ls = 4,
  Hh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Xi = 20,
  nl = new Ks(),
  Gh = new de();
let il = null;
const Gi = (1 + Math.sqrt(5)) / 2,
  Ss = 1 / Gi,
  Vh = [
    new b(1, 1, 1),
    new b(-1, 1, 1),
    new b(1, 1, -1),
    new b(-1, 1, -1),
    new b(0, Gi, Ss),
    new b(0, Gi, -Ss),
    new b(Ss, 0, Gi),
    new b(-Ss, 0, Gi),
    new b(Gi, Ss, 0),
    new b(-Gi, Ss, 0),
  ];
class ac {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (il = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Yh()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Xh()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(il),
      (e.scissorTest = !1),
      Aa(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === yi || e.mapping === vi
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (il = this._renderer.getRenderTarget());
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: ot,
        minFilter: ot,
        generateMipmaps: !1,
        type: Bs,
        format: qt,
        colorSpace: xn,
        depthBuffer: !1,
      },
      i = Wh(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Wh(e, t, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = W_(s)),
        (this._blurMaterial = X_(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new ce(this._lodPlanes[0], e);
    this._renderer.compile(t, nl);
  }
  _sceneToCubeUV(e, t, n, i) {
    const o = new Et(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      u = h.autoClear,
      d = h.toneMapping;
    h.getClearColor(Gh), (h.toneMapping = Pn), (h.autoClear = !1);
    const f = new Ut({
        name: "PMREM.Background",
        side: wt,
        depthWrite: !1,
        depthTest: !1,
      }),
      m = new ce(new at(), f);
    let _ = !1;
    const g = e.background;
    g
      ? g.isColor && (f.color.copy(g), (e.background = null), (_ = !0))
      : (f.color.copy(Gh), (_ = !0));
    for (let p = 0; p < 6; p++) {
      const v = p % 3;
      v === 0
        ? (o.up.set(0, l[p], 0), o.lookAt(c[p], 0, 0))
        : v === 1
        ? (o.up.set(0, 0, l[p]), o.lookAt(0, c[p], 0))
        : (o.up.set(0, l[p], 0), o.lookAt(0, 0, c[p]));
      const x = this._cubeSize;
      Aa(i, v * x, p > 2 ? x : 0, x, x),
        h.setRenderTarget(i),
        _ && h.render(m, o),
        h.render(e, o);
    }
    m.geometry.dispose(),
      m.material.dispose(),
      (h.toneMapping = d),
      (h.autoClear = u),
      (e.background = g);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === yi || e.mapping === vi;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Yh()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Xh());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new ce(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Aa(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, nl);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        a = Vh[(i - 1) % Vh.length];
      this._blur(e, i - 1, i, s, a);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, i, "latitudinal", s),
      this._halfBlur(a, e, n, n, i, "longitudinal", s);
  }
  _halfBlur(e, t, n, i, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      u = new ce(this._lodPlanes[i], c),
      d = c.uniforms,
      f = this._sizeLods[n] - 1,
      m = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * Xi - 1),
      _ = s / m,
      g = isFinite(s) ? 1 + Math.floor(h * _) : Xi;
    g > Xi &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Xi}`
      );
    const p = [];
    let v = 0;
    for (let R = 0; R < Xi; ++R) {
      const P = R / _,
        M = Math.exp((-P * P) / 2);
      p.push(M), R === 0 ? (v += M) : R < g && (v += 2 * M);
    }
    for (let R = 0; R < p.length; R++) p[R] = p[R] / v;
    (d.envMap.value = e.texture),
      (d.samples.value = g),
      (d.weights.value = p),
      (d.latitudinal.value = a === "latitudinal"),
      o && (d.poleAxis.value = o);
    const { _lodMax: x } = this;
    (d.dTheta.value = m), (d.mipInt.value = x - n);
    const y = this._sizeLods[i],
      S = 3 * y * (i > x - Ls ? i - x + Ls : 0),
      w = 4 * (this._cubeSize - y);
    Aa(t, S, w, 3 * y, 2 * y), l.setRenderTarget(t), l.render(u, nl);
  }
}
function W_(r) {
  const e = [],
    t = [],
    n = [];
  let i = r;
  const s = r - Ls + 1 + Hh.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, i);
    t.push(o);
    let l = 1 / o;
    a > r - Ls ? (l = Hh[a - r + Ls - 1]) : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2),
      h = -c,
      u = 1 + c,
      d = [h, h, u, h, u, u, h, h, u, u, h, u],
      f = 6,
      m = 6,
      _ = 3,
      g = 2,
      p = 1,
      v = new Float32Array(_ * m * f),
      x = new Float32Array(g * m * f),
      y = new Float32Array(p * m * f);
    for (let w = 0; w < f; w++) {
      const R = ((w % 3) * 2) / 3 - 1,
        P = w > 2 ? 0 : -1,
        M = [
          R,
          P,
          0,
          R + 2 / 3,
          P,
          0,
          R + 2 / 3,
          P + 1,
          0,
          R,
          P,
          0,
          R + 2 / 3,
          P + 1,
          0,
          R,
          P + 1,
          0,
        ];
      v.set(M, _ * m * w), x.set(d, g * m * w);
      const A = [w, w, w, w, w, w];
      y.set(A, p * m * w);
    }
    const S = new He();
    S.setAttribute("position", new nt(v, _)),
      S.setAttribute("uv", new nt(x, g)),
      S.setAttribute("faceIndex", new nt(y, p)),
      e.push(S),
      i > Ls && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Wh(r, e, t) {
  const n = new yn(r, e, t);
  return (
    (n.texture.mapping = Zs),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function Aa(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function X_(r, e, t) {
  const n = new Float32Array(Xi),
    i = new b(0, 1, 0);
  return new cn({
    name: "SphericalGaussianBlur",
    defines: {
      n: Xi,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Bc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: jn,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Xh() {
  return new cn({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Bc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: jn,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Yh() {
  return new cn({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Bc(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: jn,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Bc() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Y_(r) {
  let e = new WeakMap(),
    t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === Er || l === Ar,
        h = l === yi || l === vi;
      if (c || h)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let u = e.get(o);
          return (
            t === null && (t = new ac(r)),
            (u = c ? t.fromEquirectangular(o, u) : t.fromCubemap(o, u)),
            e.set(o, u),
            u.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const u = o.image;
            if ((c && u && u.height > 0) || (h && u && i(u))) {
              t === null && (t = new ac(r));
              const d = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, d), o.addEventListener("dispose", s), d.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function i(o) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++) o[h] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function q_(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          r.getExtension("WEBGL_depth_texture") ||
          r.getExtension("MOZ_WEBGL_depth_texture") ||
          r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          r.getExtension("EXT_texture_filter_anisotropic") ||
          r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          r.getExtension("WEBGL_compressed_texture_s3tc") ||
          r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          r.getExtension("WEBGL_compressed_texture_pvrtc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        i
      );
    },
  };
}
function Z_(r, e, t, n) {
  const i = {},
    s = new WeakMap();
  function a(u) {
    const d = u.target;
    d.index !== null && e.remove(d.index);
    for (const m in d.attributes) e.remove(d.attributes[m]);
    for (const m in d.morphAttributes) {
      const _ = d.morphAttributes[m];
      for (let g = 0, p = _.length; g < p; g++) e.remove(_[g]);
    }
    d.removeEventListener("dispose", a), delete i[d.id];
    const f = s.get(d);
    f && (e.remove(f), s.delete(d)),
      n.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(u, d) {
    return (
      i[d.id] === !0 ||
        (d.addEventListener("dispose", a),
        (i[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function l(u) {
    const d = u.attributes;
    for (const m in d) e.update(d[m], r.ARRAY_BUFFER);
    const f = u.morphAttributes;
    for (const m in f) {
      const _ = f[m];
      for (let g = 0, p = _.length; g < p; g++) e.update(_[g], r.ARRAY_BUFFER);
    }
  }
  function c(u) {
    const d = [],
      f = u.index,
      m = u.attributes.position;
    let _ = 0;
    if (f !== null) {
      const v = f.array;
      _ = f.version;
      for (let x = 0, y = v.length; x < y; x += 3) {
        const S = v[x + 0],
          w = v[x + 1],
          R = v[x + 2];
        d.push(S, w, w, R, R, S);
      }
    } else {
      const v = m.array;
      _ = m.version;
      for (let x = 0, y = v.length / 3 - 1; x < y; x += 3) {
        const S = x + 0,
          w = x + 1,
          R = x + 2;
        d.push(S, w, w, R, R, S);
      }
    }
    const g = new (mf(d) ? Fc : Oc)(d, 1);
    g.version = _;
    const p = s.get(u);
    p && e.remove(p), s.set(u, g);
  }
  function h(u) {
    const d = s.get(u);
    if (d) {
      const f = u.index;
      f !== null && d.version < f.version && c(u);
    } else c(u);
    return s.get(u);
  }
  return { get: o, update: l, getWireframeAttribute: h };
}
function $_(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function a(d) {
    s = d;
  }
  let o, l;
  function c(d) {
    (o = d.type), (l = d.bytesPerElement);
  }
  function h(d, f) {
    r.drawElements(s, f, o, d * l), t.update(f, s, 1);
  }
  function u(d, f, m) {
    if (m === 0) return;
    let _, g;
    if (i) (_ = r), (g = "drawElementsInstanced");
    else if (
      ((_ = e.get("ANGLE_instanced_arrays")),
      (g = "drawElementsInstancedANGLE"),
      _ === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    _[g](s, f, o, d * l, m), t.update(f, s, m);
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = h),
    (this.renderInstances = u);
}
function K_(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, a, o) {
    switch ((t.calls++, a)) {
      case r.TRIANGLES:
        t.triangles += o * (s / 3);
        break;
      case r.LINES:
        t.lines += o * (s / 2);
        break;
      case r.LINE_STRIP:
        t.lines += o * (s - 1);
        break;
      case r.LINE_LOOP:
        t.lines += o * s;
        break;
      case r.POINTS:
        t.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function j_(r, e) {
  return r[0] - e[0];
}
function J_(r, e) {
  return Math.abs(e[1]) - Math.abs(r[1]);
}
function Q_(r, e, t) {
  const n = {},
    i = new Float32Array(8),
    s = new WeakMap(),
    a = new tt(),
    o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function l(c, h, u) {
    const d = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const m =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        _ = m !== void 0 ? m.length : 0;
      let g = s.get(h);
      if (g === void 0 || g.count !== _) {
        let N = function () {
          U.dispose(), s.delete(h), h.removeEventListener("dispose", N);
        };
        var f = N;
        g !== void 0 && g.texture.dispose();
        const x = h.morphAttributes.position !== void 0,
          y = h.morphAttributes.normal !== void 0,
          S = h.morphAttributes.color !== void 0,
          w = h.morphAttributes.position || [],
          R = h.morphAttributes.normal || [],
          P = h.morphAttributes.color || [];
        let M = 0;
        x === !0 && (M = 1), y === !0 && (M = 2), S === !0 && (M = 3);
        let A = h.attributes.position.count * M,
          k = 1;
        A > e.maxTextureSize &&
          ((k = Math.ceil(A / e.maxTextureSize)), (A = e.maxTextureSize));
        const X = new Float32Array(A * k * 4 * _),
          U = new yo(X, A, k, _);
        (U.type = on), (U.needsUpdate = !0);
        const O = M * 4;
        for (let Z = 0; Z < _; Z++) {
          const B = w[Z],
            G = R[Z],
            $ = P[Z],
            Y = A * k * 4 * Z;
          for (let he = 0; he < B.count; he++) {
            const F = he * O;
            x === !0 &&
              (a.fromBufferAttribute(B, he),
              (X[Y + F + 0] = a.x),
              (X[Y + F + 1] = a.y),
              (X[Y + F + 2] = a.z),
              (X[Y + F + 3] = 0)),
              y === !0 &&
                (a.fromBufferAttribute(G, he),
                (X[Y + F + 4] = a.x),
                (X[Y + F + 5] = a.y),
                (X[Y + F + 6] = a.z),
                (X[Y + F + 7] = 0)),
              S === !0 &&
                (a.fromBufferAttribute($, he),
                (X[Y + F + 8] = a.x),
                (X[Y + F + 9] = a.y),
                (X[Y + F + 10] = a.z),
                (X[Y + F + 11] = $.itemSize === 4 ? a.w : 1));
          }
        }
        (g = { count: _, texture: U, size: new K(A, k) }),
          s.set(h, g),
          h.addEventListener("dispose", N);
      }
      let p = 0;
      for (let x = 0; x < d.length; x++) p += d[x];
      const v = h.morphTargetsRelative ? 1 : 1 - p;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", v),
        u.getUniforms().setValue(r, "morphTargetInfluences", d),
        u.getUniforms().setValue(r, "morphTargetsTexture", g.texture, t),
        u.getUniforms().setValue(r, "morphTargetsTextureSize", g.size);
    } else {
      const m = d === void 0 ? 0 : d.length;
      let _ = n[h.id];
      if (_ === void 0 || _.length !== m) {
        _ = [];
        for (let y = 0; y < m; y++) _[y] = [y, 0];
        n[h.id] = _;
      }
      for (let y = 0; y < m; y++) {
        const S = _[y];
        (S[0] = y), (S[1] = d[y]);
      }
      _.sort(J_);
      for (let y = 0; y < 8; y++)
        y < m && _[y][1]
          ? ((o[y][0] = _[y][0]), (o[y][1] = _[y][1]))
          : ((o[y][0] = Number.MAX_SAFE_INTEGER), (o[y][1] = 0));
      o.sort(j_);
      const g = h.morphAttributes.position,
        p = h.morphAttributes.normal;
      let v = 0;
      for (let y = 0; y < 8; y++) {
        const S = o[y],
          w = S[0],
          R = S[1];
        w !== Number.MAX_SAFE_INTEGER && R
          ? (g &&
              h.getAttribute("morphTarget" + y) !== g[w] &&
              h.setAttribute("morphTarget" + y, g[w]),
            p &&
              h.getAttribute("morphNormal" + y) !== p[w] &&
              h.setAttribute("morphNormal" + y, p[w]),
            (i[y] = R),
            (v += R))
          : (g &&
              h.hasAttribute("morphTarget" + y) === !0 &&
              h.deleteAttribute("morphTarget" + y),
            p &&
              h.hasAttribute("morphNormal" + y) === !0 &&
              h.deleteAttribute("morphNormal" + y),
            (i[y] = 0));
      }
      const x = h.morphTargetsRelative ? 1 : 1 - v;
      u.getUniforms().setValue(r, "morphTargetBaseInfluence", x),
        u.getUniforms().setValue(r, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function ex(r, e, t, n) {
  let i = new WeakMap();
  function s(l) {
    const c = n.render.frame,
      h = l.geometry,
      u = e.get(l, h);
    return (
      i.get(u) !== c && (e.update(u), i.set(u, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        t.update(l.instanceMatrix, r.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER)),
      u
    );
  }
  function a() {
    i = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: a };
}
const Sf = new ht(),
  bf = new yo(),
  wf = new Hr(),
  Ef = new Gr(),
  qh = [],
  Zh = [],
  $h = new Float32Array(16),
  Kh = new Float32Array(9),
  jh = new Float32Array(4);
function js(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let s = qh[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (qh[i] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += t), r[a].toArray(s, o);
  }
  return s;
}
function Tt(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function Rt(r, e) {
  for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function bo(r, e) {
  let t = Zh[e];
  t === void 0 && ((t = new Int32Array(e)), (Zh[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
  return t;
}
function tx(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function nx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tt(t, e)) return;
    r.uniform2fv(this.addr, e), Rt(t, e);
  }
}
function ix(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Tt(t, e)) return;
    r.uniform3fv(this.addr, e), Rt(t, e);
  }
}
function sx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tt(t, e)) return;
    r.uniform4fv(this.addr, e), Rt(t, e);
  }
}
function rx(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tt(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Rt(t, e);
  } else {
    if (Tt(t, n)) return;
    jh.set(n), r.uniformMatrix2fv(this.addr, !1, jh), Rt(t, n);
  }
}
function ax(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tt(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Rt(t, e);
  } else {
    if (Tt(t, n)) return;
    Kh.set(n), r.uniformMatrix3fv(this.addr, !1, Kh), Rt(t, n);
  }
}
function ox(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Tt(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Rt(t, e);
  } else {
    if (Tt(t, n)) return;
    $h.set(n), r.uniformMatrix4fv(this.addr, !1, $h), Rt(t, n);
  }
}
function lx(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function cx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tt(t, e)) return;
    r.uniform2iv(this.addr, e), Rt(t, e);
  }
}
function hx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Tt(t, e)) return;
    r.uniform3iv(this.addr, e), Rt(t, e);
  }
}
function ux(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tt(t, e)) return;
    r.uniform4iv(this.addr, e), Rt(t, e);
  }
}
function dx(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function fx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Tt(t, e)) return;
    r.uniform2uiv(this.addr, e), Rt(t, e);
  }
}
function px(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Tt(t, e)) return;
    r.uniform3uiv(this.addr, e), Rt(t, e);
  }
}
function mx(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Tt(t, e)) return;
    r.uniform4uiv(this.addr, e), Rt(t, e);
  }
}
function gx(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2D(e || Sf, i);
}
function _x(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || wf, i);
}
function xx(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || Ef, i);
}
function yx(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || bf, i);
}
function vx(r) {
  switch (r) {
    case 5126:
      return tx;
    case 35664:
      return nx;
    case 35665:
      return ix;
    case 35666:
      return sx;
    case 35674:
      return rx;
    case 35675:
      return ax;
    case 35676:
      return ox;
    case 5124:
    case 35670:
      return lx;
    case 35667:
    case 35671:
      return cx;
    case 35668:
    case 35672:
      return hx;
    case 35669:
    case 35673:
      return ux;
    case 5125:
      return dx;
    case 36294:
      return fx;
    case 36295:
      return px;
    case 36296:
      return mx;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gx;
    case 35679:
    case 36299:
    case 36307:
      return _x;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return xx;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return yx;
  }
}
function Mx(r, e) {
  r.uniform1fv(this.addr, e);
}
function Sx(r, e) {
  const t = js(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function bx(r, e) {
  const t = js(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function wx(r, e) {
  const t = js(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function Ex(r, e) {
  const t = js(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function Ax(r, e) {
  const t = js(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function Tx(r, e) {
  const t = js(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function Rx(r, e) {
  r.uniform1iv(this.addr, e);
}
function Cx(r, e) {
  r.uniform2iv(this.addr, e);
}
function Px(r, e) {
  r.uniform3iv(this.addr, e);
}
function Lx(r, e) {
  r.uniform4iv(this.addr, e);
}
function Ix(r, e) {
  r.uniform1uiv(this.addr, e);
}
function Dx(r, e) {
  r.uniform2uiv(this.addr, e);
}
function Ux(r, e) {
  r.uniform3uiv(this.addr, e);
}
function Nx(r, e) {
  r.uniform4uiv(this.addr, e);
}
function Ox(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = bo(t, i);
  Tt(n, s) || (r.uniform1iv(this.addr, s), Rt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || Sf, s[a]);
}
function Fx(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = bo(t, i);
  Tt(n, s) || (r.uniform1iv(this.addr, s), Rt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || wf, s[a]);
}
function Bx(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = bo(t, i);
  Tt(n, s) || (r.uniform1iv(this.addr, s), Rt(n, s));
  for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || Ef, s[a]);
}
function zx(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = bo(t, i);
  Tt(n, s) || (r.uniform1iv(this.addr, s), Rt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || bf, s[a]);
}
function kx(r) {
  switch (r) {
    case 5126:
      return Mx;
    case 35664:
      return Sx;
    case 35665:
      return bx;
    case 35666:
      return wx;
    case 35674:
      return Ex;
    case 35675:
      return Ax;
    case 35676:
      return Tx;
    case 5124:
    case 35670:
      return Rx;
    case 35667:
    case 35671:
      return Cx;
    case 35668:
    case 35672:
      return Px;
    case 35669:
    case 35673:
      return Lx;
    case 5125:
      return Ix;
    case 36294:
      return Dx;
    case 36295:
      return Ux;
    case 36296:
      return Nx;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Ox;
    case 35679:
    case 36299:
    case 36307:
      return Fx;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Bx;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return zx;
  }
}
class Hx {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = vx(t.type));
  }
}
class Gx {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = kx(t.type));
  }
}
class Vx {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let s = 0, a = i.length; s !== a; ++s) {
      const o = i[s];
      o.setValue(e, t[o.id], n);
    }
  }
}
const sl = /(\w+)(\])?(\[|\.)?/g;
function Jh(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function Wx(r, e, t) {
  const n = r.name,
    i = n.length;
  for (sl.lastIndex = 0; ; ) {
    const s = sl.exec(n),
      a = sl.lastIndex;
    let o = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === i))) {
      Jh(t, c === void 0 ? new Hx(o, r, e) : new Gx(o, r, e));
      break;
    } else {
      let u = t.map[o];
      u === void 0 && ((u = new Vx(o)), Jh(t, u)), (t = u);
    }
  }
}
class ro {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const s = e.getActiveUniform(t, i),
        a = e.getUniformLocation(t, s.name);
      Wx(s, a, this);
    }
  }
  setValue(e, t, n, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s],
        l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Qh(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
let Xx = 0;
function Yx(r, e) {
  const t = r.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = i; a < s; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function qx(r) {
  switch (r) {
    case xn:
      return ["Linear", "( value )"];
    case Oe:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", r),
        ["Linear", "( value )"]
      );
  }
}
function eu(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const a = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      Yx(r.getShaderSource(e), a)
    );
  } else return i;
}
function Zx(r, e) {
  const t = qx(e);
  return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function $x(r, e) {
  let t;
  switch (e) {
    case Fd:
      t = "Linear";
      break;
    case Bd:
      t = "Reinhard";
      break;
    case zd:
      t = "OptimizedCineon";
      break;
    case kd:
      t = "ACESFilmic";
      break;
    case Hd:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function Kx(r) {
  return [
    r.extensionDerivatives ||
    r.envMapCubeUVHeight ||
    r.bumpMap ||
    r.normalMapTangentSpace ||
    r.clearcoatNormalMap ||
    r.flatShading ||
    r.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
    r.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
    r.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(_r).join(`
`);
}
function jx(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function Jx(r, e) {
  const t = {},
    n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i),
      a = s.name;
    let o = 1;
    s.type === r.FLOAT_MAT2 && (o = 2),
      s.type === r.FLOAT_MAT3 && (o = 3),
      s.type === r.FLOAT_MAT4 && (o = 4),
      (t[a] = {
        type: s.type,
        location: r.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return t;
}
function _r(r) {
  return r !== "";
}
function tu(r, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function nu(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Qx = /^[ \t]*#include +<([\w\d./]+)>/gm;
function oc(r) {
  return r.replace(Qx, ey);
}
function ey(r, e) {
  const t = Ve[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return oc(t);
}
const ty =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function iu(r) {
  return r.replace(ty, ny);
}
function ny(r, e, t, n) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function su(r) {
  let e =
    "precision " +
    r.precision +
    ` float;
precision ` +
    r.precision +
    " int;";
  return (
    r.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : r.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function iy(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    r.shadowMapType === vc
      ? (e = "SHADOWMAP_TYPE_PCF")
      : r.shadowMapType === md
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : r.shadowMapType === An && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function sy(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case yi:
      case vi:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Zs:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function ry(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case vi:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function ay(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case kr:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Nd:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Od:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function oy(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function ly(r, e, t, n) {
  const i = r.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const l = iy(t),
    c = sy(t),
    h = ry(t),
    u = ay(t),
    d = oy(t),
    f = t.isWebGL2 ? "" : Kx(t),
    m = jx(s),
    _ = i.createProgram();
  let g,
    p,
    v = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((g = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        m,
      ].filter(_r).join(`
`)),
      g.length > 0 &&
        (g += `
`),
      (p = [
        f,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        m,
      ].filter(_r).join(`
`)),
      p.length > 0 &&
        (p += `
`))
    : ((g = [
        su(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(_r).join(`
`)),
      (p = [
        f,
        su(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        m,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + u : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Pn ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Pn ? Ve.tonemapping_pars_fragment : "",
        t.toneMapping !== Pn ? $x("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ve.encodings_pars_fragment,
        Zx("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(_r).join(`
`))),
    (a = oc(a)),
    (a = tu(a, t)),
    (a = nu(a, t)),
    (o = oc(o)),
    (o = tu(o, t)),
    (o = nu(o, t)),
    (a = iu(a)),
    (o = iu(o)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((v = `#version 300 es
`),
      (g =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        g),
      (p =
        [
          "#define varying in",
          t.glslVersion === Pr
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Pr ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        p));
  const x = v + g + a,
    y = v + p + o,
    S = Qh(i, i.VERTEX_SHADER, x),
    w = Qh(i, i.FRAGMENT_SHADER, y);
  if (
    (i.attachShader(_, S),
    i.attachShader(_, w),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(_, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(_, 0, "position"),
    i.linkProgram(_),
    r.debug.checkShaderErrors)
  ) {
    const M = i.getProgramInfoLog(_).trim(),
      A = i.getShaderInfoLog(S).trim(),
      k = i.getShaderInfoLog(w).trim();
    let X = !0,
      U = !0;
    if (i.getProgramParameter(_, i.LINK_STATUS) === !1)
      if (((X = !1), typeof r.debug.onShaderError == "function"))
        r.debug.onShaderError(i, _, S, w);
      else {
        const O = eu(i, S, "vertex"),
          N = eu(i, w, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            i.getError() +
            " - VALIDATE_STATUS " +
            i.getProgramParameter(_, i.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            M +
            `
` +
            O +
            `
` +
            N
        );
      }
    else
      M !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", M)
        : (A === "" || k === "") && (U = !1);
    U &&
      (this.diagnostics = {
        runnable: X,
        programLog: M,
        vertexShader: { log: A, prefix: g },
        fragmentShader: { log: k, prefix: p },
      });
  }
  i.deleteShader(S), i.deleteShader(w);
  let R;
  this.getUniforms = function () {
    return R === void 0 && (R = new ro(i, _)), R;
  };
  let P;
  return (
    (this.getAttributes = function () {
      return P === void 0 && (P = Jx(i, _)), P;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(_),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = Xx++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = _),
    (this.vertexShader = S),
    (this.fragmentShader = w),
    this
  );
}
let cy = 0;
class hy {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new uy(e)), t.set(e, n)), n;
  }
}
class uy {
  constructor(e) {
    (this.id = cy++), (this.code = e), (this.usedTimes = 0);
  }
}
function dy(r, e, t, n, i, s, a) {
  const o = new vo(),
    l = new hy(),
    c = [],
    h = i.isWebGL2,
    u = i.logarithmicDepthBuffer,
    d = i.vertexTextures;
  let f = i.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function _(M) {
    return M === 0 ? "uv" : `uv${M}`;
  }
  function g(M, A, k, X, U) {
    const O = X.fog,
      N = U.geometry,
      Z = M.isMeshStandardMaterial ? X.environment : null,
      B = (M.isMeshStandardMaterial ? t : e).get(M.envMap || Z),
      G = B && B.mapping === Zs ? B.image.height : null,
      $ = m[M.type];
    M.precision !== null &&
      ((f = i.getMaxPrecision(M.precision)),
      f !== M.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          M.precision,
          "not supported, using",
          f,
          "instead."
        ));
    const Y =
        N.morphAttributes.position ||
        N.morphAttributes.normal ||
        N.morphAttributes.color,
      he = Y !== void 0 ? Y.length : 0;
    let F = 0;
    N.morphAttributes.position !== void 0 && (F = 1),
      N.morphAttributes.normal !== void 0 && (F = 2),
      N.morphAttributes.color !== void 0 && (F = 3);
    let ne, ie, me, ge;
    if ($) {
      const vt = mn[$];
      (ne = vt.vertexShader), (ie = vt.fragmentShader);
    } else
      (ne = M.vertexShader),
        (ie = M.fragmentShader),
        l.update(M),
        (me = l.getVertexShaderID(M)),
        (ge = l.getFragmentShaderID(M));
    const Me = r.getRenderTarget(),
      Ne = U.isInstancedMesh === !0,
      Ce = !!M.map,
      Ze = !!M.matcap,
      Pe = !!B,
      I = !!M.aoMap,
      le = !!M.lightMap,
      Q = !!M.bumpMap,
      oe = !!M.normalMap,
      ee = !!M.displacementMap,
      we = !!M.emissiveMap,
      _e = !!M.metalnessMap,
      xe = !!M.roughnessMap,
      Le = M.anisotropy > 0,
      ze = M.clearcoat > 0,
      it = M.iridescence > 0,
      C = M.sheen > 0,
      E = M.transmission > 0,
      q = Le && !!M.anisotropyMap,
      ae = ze && !!M.clearcoatMap,
      se = ze && !!M.clearcoatNormalMap,
      L = ze && !!M.clearcoatRoughnessMap,
      te = it && !!M.iridescenceMap,
      re = it && !!M.iridescenceThicknessMap,
      W = C && !!M.sheenColorMap,
      Se = C && !!M.sheenRoughnessMap,
      Re = !!M.specularMap,
      Ee = !!M.specularColorMap,
      be = !!M.specularIntensityMap,
      ve = E && !!M.transmissionMap,
      Ie = E && !!M.thicknessMap,
      Ye = !!M.gradientMap,
      D = !!M.alphaMap,
      pe = M.alphaTest > 0,
      V = !!M.extensions,
      ue = !!N.attributes.uv1,
      ye = !!N.attributes.uv2,
      Qe = !!N.attributes.uv3;
    return {
      isWebGL2: h,
      shaderID: $,
      shaderType: M.type,
      shaderName: M.name,
      vertexShader: ne,
      fragmentShader: ie,
      defines: M.defines,
      customVertexShaderID: me,
      customFragmentShaderID: ge,
      isRawShaderMaterial: M.isRawShaderMaterial === !0,
      glslVersion: M.glslVersion,
      precision: f,
      instancing: Ne,
      instancingColor: Ne && U.instanceColor !== null,
      supportsVertexTextures: d,
      outputColorSpace:
        Me === null
          ? r.outputColorSpace
          : Me.isXRRenderTarget === !0
          ? Me.texture.colorSpace
          : xn,
      map: Ce,
      matcap: Ze,
      envMap: Pe,
      envMapMode: Pe && B.mapping,
      envMapCubeUVHeight: G,
      aoMap: I,
      lightMap: le,
      bumpMap: Q,
      normalMap: oe,
      displacementMap: d && ee,
      emissiveMap: we,
      normalMapObjectSpace: oe && M.normalMapType === nf,
      normalMapTangentSpace: oe && M.normalMapType === wi,
      metalnessMap: _e,
      roughnessMap: xe,
      anisotropy: Le,
      anisotropyMap: q,
      clearcoat: ze,
      clearcoatMap: ae,
      clearcoatNormalMap: se,
      clearcoatRoughnessMap: L,
      iridescence: it,
      iridescenceMap: te,
      iridescenceThicknessMap: re,
      sheen: C,
      sheenColorMap: W,
      sheenRoughnessMap: Se,
      specularMap: Re,
      specularColorMap: Ee,
      specularIntensityMap: be,
      transmission: E,
      transmissionMap: ve,
      thicknessMap: Ie,
      gradientMap: Ye,
      opaque: M.transparent === !1 && M.blending === ji,
      alphaMap: D,
      alphaTest: pe,
      combine: M.combine,
      mapUv: Ce && _(M.map.channel),
      aoMapUv: I && _(M.aoMap.channel),
      lightMapUv: le && _(M.lightMap.channel),
      bumpMapUv: Q && _(M.bumpMap.channel),
      normalMapUv: oe && _(M.normalMap.channel),
      displacementMapUv: ee && _(M.displacementMap.channel),
      emissiveMapUv: we && _(M.emissiveMap.channel),
      metalnessMapUv: _e && _(M.metalnessMap.channel),
      roughnessMapUv: xe && _(M.roughnessMap.channel),
      anisotropyMapUv: q && _(M.anisotropyMap.channel),
      clearcoatMapUv: ae && _(M.clearcoatMap.channel),
      clearcoatNormalMapUv: se && _(M.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: L && _(M.clearcoatRoughnessMap.channel),
      iridescenceMapUv: te && _(M.iridescenceMap.channel),
      iridescenceThicknessMapUv: re && _(M.iridescenceThicknessMap.channel),
      sheenColorMapUv: W && _(M.sheenColorMap.channel),
      sheenRoughnessMapUv: Se && _(M.sheenRoughnessMap.channel),
      specularMapUv: Re && _(M.specularMap.channel),
      specularColorMapUv: Ee && _(M.specularColorMap.channel),
      specularIntensityMapUv: be && _(M.specularIntensityMap.channel),
      transmissionMapUv: ve && _(M.transmissionMap.channel),
      thicknessMapUv: Ie && _(M.thicknessMap.channel),
      alphaMapUv: D && _(M.alphaMap.channel),
      vertexTangents: !!N.attributes.tangent && (oe || Le),
      vertexColors: M.vertexColors,
      vertexAlphas:
        M.vertexColors === !0 &&
        !!N.attributes.color &&
        N.attributes.color.itemSize === 4,
      vertexUv1s: ue,
      vertexUv2s: ye,
      vertexUv3s: Qe,
      pointsUvs: U.isPoints === !0 && !!N.attributes.uv && (Ce || D),
      fog: !!O,
      useFog: M.fog === !0,
      fogExp2: O && O.isFogExp2,
      flatShading: M.flatShading === !0,
      sizeAttenuation: M.sizeAttenuation === !0,
      logarithmicDepthBuffer: u,
      skinning: U.isSkinnedMesh === !0,
      morphTargets: N.morphAttributes.position !== void 0,
      morphNormals: N.morphAttributes.normal !== void 0,
      morphColors: N.morphAttributes.color !== void 0,
      morphTargetsCount: he,
      morphTextureStride: F,
      numDirLights: A.directional.length,
      numPointLights: A.point.length,
      numSpotLights: A.spot.length,
      numSpotLightMaps: A.spotLightMap.length,
      numRectAreaLights: A.rectArea.length,
      numHemiLights: A.hemi.length,
      numDirLightShadows: A.directionalShadowMap.length,
      numPointLightShadows: A.pointShadowMap.length,
      numSpotLightShadows: A.spotShadowMap.length,
      numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: M.dithering,
      shadowMapEnabled: r.shadowMap.enabled && k.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: M.toneMapped ? r.toneMapping : Pn,
      useLegacyLights: r.useLegacyLights,
      premultipliedAlpha: M.premultipliedAlpha,
      doubleSided: M.side === Gt,
      flipSided: M.side === wt,
      useDepthPacking: M.depthPacking >= 0,
      depthPacking: M.depthPacking || 0,
      index0AttributeName: M.index0AttributeName,
      extensionDerivatives: V && M.extensions.derivatives === !0,
      extensionFragDepth: V && M.extensions.fragDepth === !0,
      extensionDrawBuffers: V && M.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: V && M.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: M.customProgramCacheKey(),
    };
  }
  function p(M) {
    const A = [];
    if (
      (M.shaderID
        ? A.push(M.shaderID)
        : (A.push(M.customVertexShaderID), A.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const k in M.defines) A.push(k), A.push(M.defines[k]);
    return (
      M.isRawShaderMaterial === !1 &&
        (v(A, M), x(A, M), A.push(r.outputColorSpace)),
      A.push(M.customProgramCacheKey),
      A.join()
    );
  }
  function v(M, A) {
    M.push(A.precision),
      M.push(A.outputColorSpace),
      M.push(A.envMapMode),
      M.push(A.envMapCubeUVHeight),
      M.push(A.mapUv),
      M.push(A.alphaMapUv),
      M.push(A.lightMapUv),
      M.push(A.aoMapUv),
      M.push(A.bumpMapUv),
      M.push(A.normalMapUv),
      M.push(A.displacementMapUv),
      M.push(A.emissiveMapUv),
      M.push(A.metalnessMapUv),
      M.push(A.roughnessMapUv),
      M.push(A.anisotropyMapUv),
      M.push(A.clearcoatMapUv),
      M.push(A.clearcoatNormalMapUv),
      M.push(A.clearcoatRoughnessMapUv),
      M.push(A.iridescenceMapUv),
      M.push(A.iridescenceThicknessMapUv),
      M.push(A.sheenColorMapUv),
      M.push(A.sheenRoughnessMapUv),
      M.push(A.specularMapUv),
      M.push(A.specularColorMapUv),
      M.push(A.specularIntensityMapUv),
      M.push(A.transmissionMapUv),
      M.push(A.thicknessMapUv),
      M.push(A.combine),
      M.push(A.fogExp2),
      M.push(A.sizeAttenuation),
      M.push(A.morphTargetsCount),
      M.push(A.morphAttributeCount),
      M.push(A.numDirLights),
      M.push(A.numPointLights),
      M.push(A.numSpotLights),
      M.push(A.numSpotLightMaps),
      M.push(A.numHemiLights),
      M.push(A.numRectAreaLights),
      M.push(A.numDirLightShadows),
      M.push(A.numPointLightShadows),
      M.push(A.numSpotLightShadows),
      M.push(A.numSpotLightShadowsWithMaps),
      M.push(A.shadowMapType),
      M.push(A.toneMapping),
      M.push(A.numClippingPlanes),
      M.push(A.numClipIntersection),
      M.push(A.depthPacking);
  }
  function x(M, A) {
    o.disableAll(),
      A.isWebGL2 && o.enable(0),
      A.supportsVertexTextures && o.enable(1),
      A.instancing && o.enable(2),
      A.instancingColor && o.enable(3),
      A.matcap && o.enable(4),
      A.envMap && o.enable(5),
      A.normalMapObjectSpace && o.enable(6),
      A.normalMapTangentSpace && o.enable(7),
      A.clearcoat && o.enable(8),
      A.iridescence && o.enable(9),
      A.alphaTest && o.enable(10),
      A.vertexColors && o.enable(11),
      A.vertexAlphas && o.enable(12),
      A.vertexUv1s && o.enable(13),
      A.vertexUv2s && o.enable(14),
      A.vertexUv3s && o.enable(15),
      A.vertexTangents && o.enable(16),
      A.anisotropy && o.enable(17),
      M.push(o.mask),
      o.disableAll(),
      A.fog && o.enable(0),
      A.useFog && o.enable(1),
      A.flatShading && o.enable(2),
      A.logarithmicDepthBuffer && o.enable(3),
      A.skinning && o.enable(4),
      A.morphTargets && o.enable(5),
      A.morphNormals && o.enable(6),
      A.morphColors && o.enable(7),
      A.premultipliedAlpha && o.enable(8),
      A.shadowMapEnabled && o.enable(9),
      A.useLegacyLights && o.enable(10),
      A.doubleSided && o.enable(11),
      A.flipSided && o.enable(12),
      A.useDepthPacking && o.enable(13),
      A.dithering && o.enable(14),
      A.transmission && o.enable(15),
      A.sheen && o.enable(16),
      A.opaque && o.enable(17),
      A.pointsUvs && o.enable(18),
      M.push(o.mask);
  }
  function y(M) {
    const A = m[M.type];
    let k;
    if (A) {
      const X = mn[A];
      k = xf.clone(X.uniforms);
    } else k = M.uniforms;
    return k;
  }
  function S(M, A) {
    let k;
    for (let X = 0, U = c.length; X < U; X++) {
      const O = c[X];
      if (O.cacheKey === A) {
        (k = O), ++k.usedTimes;
        break;
      }
    }
    return k === void 0 && ((k = new ly(r, A, M, s)), c.push(k)), k;
  }
  function w(M) {
    if (--M.usedTimes === 0) {
      const A = c.indexOf(M);
      (c[A] = c[c.length - 1]), c.pop(), M.destroy();
    }
  }
  function R(M) {
    l.remove(M);
  }
  function P() {
    l.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: p,
    getUniforms: y,
    acquireProgram: S,
    releaseProgram: w,
    releaseShaderCache: R,
    programs: c,
    dispose: P,
  };
}
function fy() {
  let r = new WeakMap();
  function e(s) {
    let a = r.get(s);
    return a === void 0 && ((a = {}), r.set(s, a)), a;
  }
  function t(s) {
    r.delete(s);
  }
  function n(s, a, o) {
    r.get(s)[a] = o;
  }
  function i() {
    r = new WeakMap();
  }
  return { get: e, remove: t, update: n, dispose: i };
}
function py(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.material.id !== e.material.id
    ? r.material.id - e.material.id
    : r.z !== e.z
    ? r.z - e.z
    : r.id - e.id;
}
function ru(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.z !== e.z
    ? e.z - r.z
    : r.id - e.id;
}
function au() {
  const r = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function a(u, d, f, m, _, g) {
    let p = r[e];
    return (
      p === void 0
        ? ((p = {
            id: u.id,
            object: u,
            geometry: d,
            material: f,
            groupOrder: m,
            renderOrder: u.renderOrder,
            z: _,
            group: g,
          }),
          (r[e] = p))
        : ((p.id = u.id),
          (p.object = u),
          (p.geometry = d),
          (p.material = f),
          (p.groupOrder = m),
          (p.renderOrder = u.renderOrder),
          (p.z = _),
          (p.group = g)),
      e++,
      p
    );
  }
  function o(u, d, f, m, _, g) {
    const p = a(u, d, f, m, _, g);
    f.transmission > 0
      ? n.push(p)
      : f.transparent === !0
      ? i.push(p)
      : t.push(p);
  }
  function l(u, d, f, m, _, g) {
    const p = a(u, d, f, m, _, g);
    f.transmission > 0
      ? n.unshift(p)
      : f.transparent === !0
      ? i.unshift(p)
      : t.unshift(p);
  }
  function c(u, d) {
    t.length > 1 && t.sort(u || py),
      n.length > 1 && n.sort(d || ru),
      i.length > 1 && i.sort(d || ru);
  }
  function h() {
    for (let u = e, d = r.length; u < d; u++) {
      const f = r[u];
      if (f.id === null) break;
      (f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: s,
    push: o,
    unshift: l,
    finish: h,
    sort: c,
  };
}
function my() {
  let r = new WeakMap();
  function e(n, i) {
    const s = r.get(n);
    let a;
    return (
      s === void 0
        ? ((a = new au()), r.set(n, [a]))
        : i >= s.length
        ? ((a = new au()), s.push(a))
        : (a = s[i]),
      a
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function gy() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new b(), color: new de() };
          break;
        case "SpotLight":
          t = {
            position: new b(),
            direction: new b(),
            color: new de(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new b(), color: new de(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new b(), skyColor: new de(), groundColor: new de() };
          break;
        case "RectAreaLight":
          t = {
            color: new de(),
            position: new b(),
            halfWidth: new b(),
            halfHeight: new b(),
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
function _y() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new K(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new K(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new K(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
let xy = 0;
function yy(r, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (r.map ? 1 : 0)
  );
}
function vy(r, e) {
  const t = new gy(),
    n = _y(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let h = 0; h < 9; h++) i.probe.push(new b());
  const s = new b(),
    a = new Ue(),
    o = new Ue();
  function l(h, u) {
    let d = 0,
      f = 0,
      m = 0;
    for (let k = 0; k < 9; k++) i.probe[k].set(0, 0, 0);
    let _ = 0,
      g = 0,
      p = 0,
      v = 0,
      x = 0,
      y = 0,
      S = 0,
      w = 0,
      R = 0,
      P = 0;
    h.sort(yy);
    const M = u === !0 ? Math.PI : 1;
    for (let k = 0, X = h.length; k < X; k++) {
      const U = h[k],
        O = U.color,
        N = U.intensity,
        Z = U.distance,
        B = U.shadow && U.shadow.map ? U.shadow.map.texture : null;
      if (U.isAmbientLight)
        (d += O.r * N * M), (f += O.g * N * M), (m += O.b * N * M);
      else if (U.isLightProbe)
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(U.sh.coefficients[G], N);
      else if (U.isDirectionalLight) {
        const G = t.get(U);
        if (
          (G.color.copy(U.color).multiplyScalar(U.intensity * M), U.castShadow)
        ) {
          const $ = U.shadow,
            Y = n.get(U);
          (Y.shadowBias = $.bias),
            (Y.shadowNormalBias = $.normalBias),
            (Y.shadowRadius = $.radius),
            (Y.shadowMapSize = $.mapSize),
            (i.directionalShadow[_] = Y),
            (i.directionalShadowMap[_] = B),
            (i.directionalShadowMatrix[_] = U.shadow.matrix),
            y++;
        }
        (i.directional[_] = G), _++;
      } else if (U.isSpotLight) {
        const G = t.get(U);
        G.position.setFromMatrixPosition(U.matrixWorld),
          G.color.copy(O).multiplyScalar(N * M),
          (G.distance = Z),
          (G.coneCos = Math.cos(U.angle)),
          (G.penumbraCos = Math.cos(U.angle * (1 - U.penumbra))),
          (G.decay = U.decay),
          (i.spot[p] = G);
        const $ = U.shadow;
        if (
          (U.map &&
            ((i.spotLightMap[R] = U.map),
            R++,
            $.updateMatrices(U),
            U.castShadow && P++),
          (i.spotLightMatrix[p] = $.matrix),
          U.castShadow)
        ) {
          const Y = n.get(U);
          (Y.shadowBias = $.bias),
            (Y.shadowNormalBias = $.normalBias),
            (Y.shadowRadius = $.radius),
            (Y.shadowMapSize = $.mapSize),
            (i.spotShadow[p] = Y),
            (i.spotShadowMap[p] = B),
            w++;
        }
        p++;
      } else if (U.isRectAreaLight) {
        const G = t.get(U);
        G.color.copy(O).multiplyScalar(N),
          G.halfWidth.set(U.width * 0.5, 0, 0),
          G.halfHeight.set(0, U.height * 0.5, 0),
          (i.rectArea[v] = G),
          v++;
      } else if (U.isPointLight) {
        const G = t.get(U);
        if (
          (G.color.copy(U.color).multiplyScalar(U.intensity * M),
          (G.distance = U.distance),
          (G.decay = U.decay),
          U.castShadow)
        ) {
          const $ = U.shadow,
            Y = n.get(U);
          (Y.shadowBias = $.bias),
            (Y.shadowNormalBias = $.normalBias),
            (Y.shadowRadius = $.radius),
            (Y.shadowMapSize = $.mapSize),
            (Y.shadowCameraNear = $.camera.near),
            (Y.shadowCameraFar = $.camera.far),
            (i.pointShadow[g] = Y),
            (i.pointShadowMap[g] = B),
            (i.pointShadowMatrix[g] = U.shadow.matrix),
            S++;
        }
        (i.point[g] = G), g++;
      } else if (U.isHemisphereLight) {
        const G = t.get(U);
        G.skyColor.copy(U.color).multiplyScalar(N * M),
          G.groundColor.copy(U.groundColor).multiplyScalar(N * M),
          (i.hemi[x] = G),
          x++;
      }
    }
    v > 0 &&
      (e.isWebGL2 || r.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = fe.LTC_FLOAT_1), (i.rectAreaLTC2 = fe.LTC_FLOAT_2))
        : r.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = fe.LTC_HALF_1), (i.rectAreaLTC2 = fe.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = d),
      (i.ambient[1] = f),
      (i.ambient[2] = m);
    const A = i.hash;
    (A.directionalLength !== _ ||
      A.pointLength !== g ||
      A.spotLength !== p ||
      A.rectAreaLength !== v ||
      A.hemiLength !== x ||
      A.numDirectionalShadows !== y ||
      A.numPointShadows !== S ||
      A.numSpotShadows !== w ||
      A.numSpotMaps !== R) &&
      ((i.directional.length = _),
      (i.spot.length = p),
      (i.rectArea.length = v),
      (i.point.length = g),
      (i.hemi.length = x),
      (i.directionalShadow.length = y),
      (i.directionalShadowMap.length = y),
      (i.pointShadow.length = S),
      (i.pointShadowMap.length = S),
      (i.spotShadow.length = w),
      (i.spotShadowMap.length = w),
      (i.directionalShadowMatrix.length = y),
      (i.pointShadowMatrix.length = S),
      (i.spotLightMatrix.length = w + R - P),
      (i.spotLightMap.length = R),
      (i.numSpotLightShadowsWithMaps = P),
      (A.directionalLength = _),
      (A.pointLength = g),
      (A.spotLength = p),
      (A.rectAreaLength = v),
      (A.hemiLength = x),
      (A.numDirectionalShadows = y),
      (A.numPointShadows = S),
      (A.numSpotShadows = w),
      (A.numSpotMaps = R),
      (i.version = xy++));
  }
  function c(h, u) {
    let d = 0,
      f = 0,
      m = 0,
      _ = 0,
      g = 0;
    const p = u.matrixWorldInverse;
    for (let v = 0, x = h.length; v < x; v++) {
      const y = h[v];
      if (y.isDirectionalLight) {
        const S = i.directional[d];
        S.direction.setFromMatrixPosition(y.matrixWorld),
          s.setFromMatrixPosition(y.target.matrixWorld),
          S.direction.sub(s),
          S.direction.transformDirection(p),
          d++;
      } else if (y.isSpotLight) {
        const S = i.spot[m];
        S.position.setFromMatrixPosition(y.matrixWorld),
          S.position.applyMatrix4(p),
          S.direction.setFromMatrixPosition(y.matrixWorld),
          s.setFromMatrixPosition(y.target.matrixWorld),
          S.direction.sub(s),
          S.direction.transformDirection(p),
          m++;
      } else if (y.isRectAreaLight) {
        const S = i.rectArea[_];
        S.position.setFromMatrixPosition(y.matrixWorld),
          S.position.applyMatrix4(p),
          o.identity(),
          a.copy(y.matrixWorld),
          a.premultiply(p),
          o.extractRotation(a),
          S.halfWidth.set(y.width * 0.5, 0, 0),
          S.halfHeight.set(0, y.height * 0.5, 0),
          S.halfWidth.applyMatrix4(o),
          S.halfHeight.applyMatrix4(o),
          _++;
      } else if (y.isPointLight) {
        const S = i.point[f];
        S.position.setFromMatrixPosition(y.matrixWorld),
          S.position.applyMatrix4(p),
          f++;
      } else if (y.isHemisphereLight) {
        const S = i.hemi[g];
        S.direction.setFromMatrixPosition(y.matrixWorld),
          S.direction.transformDirection(p),
          g++;
      }
    }
  }
  return { setup: l, setupView: c, state: i };
}
function ou(r, e) {
  const t = new vy(r, e),
    n = [],
    i = [];
  function s() {
    (n.length = 0), (i.length = 0);
  }
  function a(u) {
    n.push(u);
  }
  function o(u) {
    i.push(u);
  }
  function l(u) {
    t.setup(n, u);
  }
  function c(u) {
    t.setupView(n, u);
  }
  return {
    init: s,
    state: { lightsArray: n, shadowsArray: i, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o,
  };
}
function My(r, e) {
  let t = new WeakMap();
  function n(s, a = 0) {
    const o = t.get(s);
    let l;
    return (
      o === void 0
        ? ((l = new ou(r, e)), t.set(s, [l]))
        : a >= o.length
        ? ((l = new ou(r, e)), o.push(l))
        : (l = o[a]),
      l
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
class zc extends At {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = ef),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class kc extends At {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const Sy = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  by = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function wy(r, e, t) {
  let n = new So();
  const i = new K(),
    s = new K(),
    a = new tt(),
    o = new zc({ depthPacking: tf }),
    l = new kc(),
    c = {},
    h = t.maxTextureSize,
    u = { [Zt]: wt, [wt]: Zt, [Gt]: Gt },
    d = new cn({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new K() },
        radius: { value: 4 },
      },
      vertexShader: Sy,
      fragmentShader: by,
    }),
    f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new He();
  m.setAttribute(
    "position",
    new nt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const _ = new ce(m, d),
    g = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = vc);
  let p = this.type;
  this.render = function (S, w, R) {
    if (
      g.enabled === !1 ||
      (g.autoUpdate === !1 && g.needsUpdate === !1) ||
      S.length === 0
    )
      return;
    const P = r.getRenderTarget(),
      M = r.getActiveCubeFace(),
      A = r.getActiveMipmapLevel(),
      k = r.state;
    k.setBlending(jn),
      k.buffers.color.setClear(1, 1, 1, 1),
      k.buffers.depth.setTest(!0),
      k.setScissorTest(!1);
    const X = p !== An && this.type === An,
      U = p === An && this.type !== An;
    for (let O = 0, N = S.length; O < N; O++) {
      const Z = S[O],
        B = Z.shadow;
      if (B === void 0) {
        console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
        continue;
      }
      if (B.autoUpdate === !1 && B.needsUpdate === !1) continue;
      i.copy(B.mapSize);
      const G = B.getFrameExtents();
      if (
        (i.multiply(G),
        s.copy(B.mapSize),
        (i.x > h || i.y > h) &&
          (i.x > h &&
            ((s.x = Math.floor(h / G.x)),
            (i.x = s.x * G.x),
            (B.mapSize.x = s.x)),
          i.y > h &&
            ((s.y = Math.floor(h / G.y)),
            (i.y = s.y * G.y),
            (B.mapSize.y = s.y))),
        B.map === null || X === !0 || U === !0)
      ) {
        const Y = this.type !== An ? { minFilter: gt, magFilter: gt } : {};
        B.map !== null && B.map.dispose(),
          (B.map = new yn(i.x, i.y, Y)),
          (B.map.texture.name = Z.name + ".shadowMap"),
          B.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(B.map), r.clear();
      const $ = B.getViewportCount();
      for (let Y = 0; Y < $; Y++) {
        const he = B.getViewport(Y);
        a.set(s.x * he.x, s.y * he.y, s.x * he.z, s.y * he.w),
          k.viewport(a),
          B.updateMatrices(Z, Y),
          (n = B.getFrustum()),
          y(w, R, B.camera, Z, this.type);
      }
      B.isPointLightShadow !== !0 && this.type === An && v(B, R),
        (B.needsUpdate = !1);
    }
    (p = this.type), (g.needsUpdate = !1), r.setRenderTarget(P, M, A);
  };
  function v(S, w) {
    const R = e.update(_);
    d.defines.VSM_SAMPLES !== S.blurSamples &&
      ((d.defines.VSM_SAMPLES = S.blurSamples),
      (f.defines.VSM_SAMPLES = S.blurSamples),
      (d.needsUpdate = !0),
      (f.needsUpdate = !0)),
      S.mapPass === null && (S.mapPass = new yn(i.x, i.y)),
      (d.uniforms.shadow_pass.value = S.map.texture),
      (d.uniforms.resolution.value = S.mapSize),
      (d.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.mapPass),
      r.clear(),
      r.renderBufferDirect(w, null, R, d, _, null),
      (f.uniforms.shadow_pass.value = S.mapPass.texture),
      (f.uniforms.resolution.value = S.mapSize),
      (f.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.map),
      r.clear(),
      r.renderBufferDirect(w, null, R, f, _, null);
  }
  function x(S, w, R, P) {
    let M = null;
    const A =
      R.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (A !== void 0) M = A;
    else if (
      ((M = R.isPointLight === !0 ? l : o),
      (r.localClippingEnabled &&
        w.clipShadows === !0 &&
        Array.isArray(w.clippingPlanes) &&
        w.clippingPlanes.length !== 0) ||
        (w.displacementMap && w.displacementScale !== 0) ||
        (w.alphaMap && w.alphaTest > 0) ||
        (w.map && w.alphaTest > 0))
    ) {
      const k = M.uuid,
        X = w.uuid;
      let U = c[k];
      U === void 0 && ((U = {}), (c[k] = U));
      let O = U[X];
      O === void 0 && ((O = M.clone()), (U[X] = O)), (M = O);
    }
    if (
      ((M.visible = w.visible),
      (M.wireframe = w.wireframe),
      P === An
        ? (M.side = w.shadowSide !== null ? w.shadowSide : w.side)
        : (M.side = w.shadowSide !== null ? w.shadowSide : u[w.side]),
      (M.alphaMap = w.alphaMap),
      (M.alphaTest = w.alphaTest),
      (M.map = w.map),
      (M.clipShadows = w.clipShadows),
      (M.clippingPlanes = w.clippingPlanes),
      (M.clipIntersection = w.clipIntersection),
      (M.displacementMap = w.displacementMap),
      (M.displacementScale = w.displacementScale),
      (M.displacementBias = w.displacementBias),
      (M.wireframeLinewidth = w.wireframeLinewidth),
      (M.linewidth = w.linewidth),
      R.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const k = r.properties.get(M);
      k.light = R;
    }
    return M;
  }
  function y(S, w, R, P, M) {
    if (S.visible === !1) return;
    if (
      S.layers.test(w.layers) &&
      (S.isMesh || S.isLine || S.isPoints) &&
      (S.castShadow || (S.receiveShadow && M === An)) &&
      (!S.frustumCulled || n.intersectsObject(S))
    ) {
      S.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, S.matrixWorld);
      const X = e.update(S),
        U = S.material;
      if (Array.isArray(U)) {
        const O = X.groups;
        for (let N = 0, Z = O.length; N < Z; N++) {
          const B = O[N],
            G = U[B.materialIndex];
          if (G && G.visible) {
            const $ = x(S, G, P, M);
            r.renderBufferDirect(R, null, X, $, S, B);
          }
        }
      } else if (U.visible) {
        const O = x(S, U, P, M);
        r.renderBufferDirect(R, null, X, O, S, null);
      }
    }
    const k = S.children;
    for (let X = 0, U = k.length; X < U; X++) y(k[X], w, R, P, M);
  }
}
function Ey(r, e, t) {
  const n = t.isWebGL2;
  function i() {
    let D = !1;
    const pe = new tt();
    let V = null;
    const ue = new tt(0, 0, 0, 0);
    return {
      setMask: function (ye) {
        V !== ye && !D && (r.colorMask(ye, ye, ye, ye), (V = ye));
      },
      setLocked: function (ye) {
        D = ye;
      },
      setClear: function (ye, Qe, dt, vt, Ai) {
        Ai === !0 && ((ye *= vt), (Qe *= vt), (dt *= vt)),
          pe.set(ye, Qe, dt, vt),
          ue.equals(pe) === !1 && (r.clearColor(ye, Qe, dt, vt), ue.copy(pe));
      },
      reset: function () {
        (D = !1), (V = null), ue.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let D = !1,
      pe = null,
      V = null,
      ue = null;
    return {
      setTest: function (ye) {
        ye ? Me(r.DEPTH_TEST) : Ne(r.DEPTH_TEST);
      },
      setMask: function (ye) {
        pe !== ye && !D && (r.depthMask(ye), (pe = ye));
      },
      setFunc: function (ye) {
        if (V !== ye) {
          switch (ye) {
            case Rd:
              r.depthFunc(r.NEVER);
              break;
            case Cd:
              r.depthFunc(r.ALWAYS);
              break;
            case Pd:
              r.depthFunc(r.LESS);
              break;
            case oo:
              r.depthFunc(r.LEQUAL);
              break;
            case Ld:
              r.depthFunc(r.EQUAL);
              break;
            case Id:
              r.depthFunc(r.GEQUAL);
              break;
            case Dd:
              r.depthFunc(r.GREATER);
              break;
            case Ud:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          V = ye;
        }
      },
      setLocked: function (ye) {
        D = ye;
      },
      setClear: function (ye) {
        ue !== ye && (r.clearDepth(ye), (ue = ye));
      },
      reset: function () {
        (D = !1), (pe = null), (V = null), (ue = null);
      },
    };
  }
  function a() {
    let D = !1,
      pe = null,
      V = null,
      ue = null,
      ye = null,
      Qe = null,
      dt = null,
      vt = null,
      Ai = null;
    return {
      setTest: function (ft) {
        D || (ft ? Me(r.STENCIL_TEST) : Ne(r.STENCIL_TEST));
      },
      setMask: function (ft) {
        pe !== ft && !D && (r.stencilMask(ft), (pe = ft));
      },
      setFunc: function (ft, wn, Bt) {
        (V !== ft || ue !== wn || ye !== Bt) &&
          (r.stencilFunc(ft, wn, Bt), (V = ft), (ue = wn), (ye = Bt));
      },
      setOp: function (ft, wn, Bt) {
        (Qe !== ft || dt !== wn || vt !== Bt) &&
          (r.stencilOp(ft, wn, Bt), (Qe = ft), (dt = wn), (vt = Bt));
      },
      setLocked: function (ft) {
        D = ft;
      },
      setClear: function (ft) {
        Ai !== ft && (r.clearStencil(ft), (Ai = ft));
      },
      reset: function () {
        (D = !1),
          (pe = null),
          (V = null),
          (ue = null),
          (ye = null),
          (Qe = null),
          (dt = null),
          (vt = null),
          (Ai = null);
      },
    };
  }
  const o = new i(),
    l = new s(),
    c = new a(),
    h = new WeakMap(),
    u = new WeakMap();
  let d = {},
    f = {},
    m = new WeakMap(),
    _ = [],
    g = null,
    p = !1,
    v = null,
    x = null,
    y = null,
    S = null,
    w = null,
    R = null,
    P = null,
    M = !1,
    A = null,
    k = null,
    X = null,
    U = null,
    O = null;
  const N = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let Z = !1,
    B = 0;
  const G = r.getParameter(r.VERSION);
  G.indexOf("WebGL") !== -1
    ? ((B = parseFloat(/^WebGL (\d)/.exec(G)[1])), (Z = B >= 1))
    : G.indexOf("OpenGL ES") !== -1 &&
      ((B = parseFloat(/^OpenGL ES (\d)/.exec(G)[1])), (Z = B >= 2));
  let $ = null,
    Y = {};
  const he = r.getParameter(r.SCISSOR_BOX),
    F = r.getParameter(r.VIEWPORT),
    ne = new tt().fromArray(he),
    ie = new tt().fromArray(F);
  function me(D, pe, V, ue) {
    const ye = new Uint8Array(4),
      Qe = r.createTexture();
    r.bindTexture(D, Qe),
      r.texParameteri(D, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(D, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let dt = 0; dt < V; dt++)
      n && (D === r.TEXTURE_3D || D === r.TEXTURE_2D_ARRAY)
        ? r.texImage3D(pe, 0, r.RGBA, 1, 1, ue, 0, r.RGBA, r.UNSIGNED_BYTE, ye)
        : r.texImage2D(
            pe + dt,
            0,
            r.RGBA,
            1,
            1,
            0,
            r.RGBA,
            r.UNSIGNED_BYTE,
            ye
          );
    return Qe;
  }
  const ge = {};
  (ge[r.TEXTURE_2D] = me(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (ge[r.TEXTURE_CUBE_MAP] = me(
      r.TEXTURE_CUBE_MAP,
      r.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    n &&
      ((ge[r.TEXTURE_2D_ARRAY] = me(
        r.TEXTURE_2D_ARRAY,
        r.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (ge[r.TEXTURE_3D] = me(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1))),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    Me(r.DEPTH_TEST),
    l.setFunc(oo),
    ee(!1),
    we(Pl),
    Me(r.CULL_FACE),
    Q(jn);
  function Me(D) {
    d[D] !== !0 && (r.enable(D), (d[D] = !0));
  }
  function Ne(D) {
    d[D] !== !1 && (r.disable(D), (d[D] = !1));
  }
  function Ce(D, pe) {
    return f[D] !== pe
      ? (r.bindFramebuffer(D, pe),
        (f[D] = pe),
        n &&
          (D === r.DRAW_FRAMEBUFFER && (f[r.FRAMEBUFFER] = pe),
          D === r.FRAMEBUFFER && (f[r.DRAW_FRAMEBUFFER] = pe)),
        !0)
      : !1;
  }
  function Ze(D, pe) {
    let V = _,
      ue = !1;
    if (D)
      if (
        ((V = m.get(pe)),
        V === void 0 && ((V = []), m.set(pe, V)),
        D.isWebGLMultipleRenderTargets)
      ) {
        const ye = D.texture;
        if (V.length !== ye.length || V[0] !== r.COLOR_ATTACHMENT0) {
          for (let Qe = 0, dt = ye.length; Qe < dt; Qe++)
            V[Qe] = r.COLOR_ATTACHMENT0 + Qe;
          (V.length = ye.length), (ue = !0);
        }
      } else
        V[0] !== r.COLOR_ATTACHMENT0 &&
          ((V[0] = r.COLOR_ATTACHMENT0), (ue = !0));
    else V[0] !== r.BACK && ((V[0] = r.BACK), (ue = !0));
    ue &&
      (t.isWebGL2
        ? r.drawBuffers(V)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(V));
  }
  function Pe(D) {
    return g !== D ? (r.useProgram(D), (g = D), !0) : !1;
  }
  const I = {
    [Wi]: r.FUNC_ADD,
    [_d]: r.FUNC_SUBTRACT,
    [xd]: r.FUNC_REVERSE_SUBTRACT,
  };
  if (n) (I[Ul] = r.MIN), (I[Nl] = r.MAX);
  else {
    const D = e.get("EXT_blend_minmax");
    D !== null && ((I[Ul] = D.MIN_EXT), (I[Nl] = D.MAX_EXT));
  }
  const le = {
    [yd]: r.ZERO,
    [vd]: r.ONE,
    [Md]: r.SRC_COLOR,
    [Mc]: r.SRC_ALPHA,
    [Td]: r.SRC_ALPHA_SATURATE,
    [Ed]: r.DST_COLOR,
    [bd]: r.DST_ALPHA,
    [Sd]: r.ONE_MINUS_SRC_COLOR,
    [Sc]: r.ONE_MINUS_SRC_ALPHA,
    [Ad]: r.ONE_MINUS_DST_COLOR,
    [wd]: r.ONE_MINUS_DST_ALPHA,
  };
  function Q(D, pe, V, ue, ye, Qe, dt, vt) {
    if (D === jn) {
      p === !0 && (Ne(r.BLEND), (p = !1));
      return;
    }
    if ((p === !1 && (Me(r.BLEND), (p = !0)), D !== gd)) {
      if (D !== v || vt !== M) {
        if (
          ((x !== Wi || w !== Wi) &&
            (r.blendEquation(r.FUNC_ADD), (x = Wi), (w = Wi)),
          vt)
        )
          switch (D) {
            case ji:
              r.blendFuncSeparate(
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Ll:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Il:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Dl:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", D);
              break;
          }
        else
          switch (D) {
            case ji:
              r.blendFuncSeparate(
                r.SRC_ALPHA,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Ll:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Il:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Dl:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", D);
              break;
          }
        (y = null), (S = null), (R = null), (P = null), (v = D), (M = vt);
      }
      return;
    }
    (ye = ye || pe),
      (Qe = Qe || V),
      (dt = dt || ue),
      (pe !== x || ye !== w) &&
        (r.blendEquationSeparate(I[pe], I[ye]), (x = pe), (w = ye)),
      (V !== y || ue !== S || Qe !== R || dt !== P) &&
        (r.blendFuncSeparate(le[V], le[ue], le[Qe], le[dt]),
        (y = V),
        (S = ue),
        (R = Qe),
        (P = dt)),
      (v = D),
      (M = !1);
  }
  function oe(D, pe) {
    D.side === Gt ? Ne(r.CULL_FACE) : Me(r.CULL_FACE);
    let V = D.side === wt;
    pe && (V = !V),
      ee(V),
      D.blending === ji && D.transparent === !1
        ? Q(jn)
        : Q(
            D.blending,
            D.blendEquation,
            D.blendSrc,
            D.blendDst,
            D.blendEquationAlpha,
            D.blendSrcAlpha,
            D.blendDstAlpha,
            D.premultipliedAlpha
          ),
      l.setFunc(D.depthFunc),
      l.setTest(D.depthTest),
      l.setMask(D.depthWrite),
      o.setMask(D.colorWrite);
    const ue = D.stencilWrite;
    c.setTest(ue),
      ue &&
        (c.setMask(D.stencilWriteMask),
        c.setFunc(D.stencilFunc, D.stencilRef, D.stencilFuncMask),
        c.setOp(D.stencilFail, D.stencilZFail, D.stencilZPass)),
      xe(D.polygonOffset, D.polygonOffsetFactor, D.polygonOffsetUnits),
      D.alphaToCoverage === !0
        ? Me(r.SAMPLE_ALPHA_TO_COVERAGE)
        : Ne(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ee(D) {
    A !== D && (D ? r.frontFace(r.CW) : r.frontFace(r.CCW), (A = D));
  }
  function we(D) {
    D !== fd
      ? (Me(r.CULL_FACE),
        D !== k &&
          (D === Pl
            ? r.cullFace(r.BACK)
            : D === pd
            ? r.cullFace(r.FRONT)
            : r.cullFace(r.FRONT_AND_BACK)))
      : Ne(r.CULL_FACE),
      (k = D);
  }
  function _e(D) {
    D !== X && (Z && r.lineWidth(D), (X = D));
  }
  function xe(D, pe, V) {
    D
      ? (Me(r.POLYGON_OFFSET_FILL),
        (U !== pe || O !== V) && (r.polygonOffset(pe, V), (U = pe), (O = V)))
      : Ne(r.POLYGON_OFFSET_FILL);
  }
  function Le(D) {
    D ? Me(r.SCISSOR_TEST) : Ne(r.SCISSOR_TEST);
  }
  function ze(D) {
    D === void 0 && (D = r.TEXTURE0 + N - 1),
      $ !== D && (r.activeTexture(D), ($ = D));
  }
  function it(D, pe, V) {
    V === void 0 && ($ === null ? (V = r.TEXTURE0 + N - 1) : (V = $));
    let ue = Y[V];
    ue === void 0 && ((ue = { type: void 0, texture: void 0 }), (Y[V] = ue)),
      (ue.type !== D || ue.texture !== pe) &&
        ($ !== V && (r.activeTexture(V), ($ = V)),
        r.bindTexture(D, pe || ge[D]),
        (ue.type = D),
        (ue.texture = pe));
  }
  function C() {
    const D = Y[$];
    D !== void 0 &&
      D.type !== void 0 &&
      (r.bindTexture(D.type, null), (D.type = void 0), (D.texture = void 0));
  }
  function E() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function q() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function ae() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function se() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function L() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function te() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function re() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function W() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function Se() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function Re() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (D) {
      console.error("THREE.WebGLState:", D);
    }
  }
  function Ee(D) {
    ne.equals(D) === !1 && (r.scissor(D.x, D.y, D.z, D.w), ne.copy(D));
  }
  function be(D) {
    ie.equals(D) === !1 && (r.viewport(D.x, D.y, D.z, D.w), ie.copy(D));
  }
  function ve(D, pe) {
    let V = u.get(pe);
    V === void 0 && ((V = new WeakMap()), u.set(pe, V));
    let ue = V.get(D);
    ue === void 0 && ((ue = r.getUniformBlockIndex(pe, D.name)), V.set(D, ue));
  }
  function Ie(D, pe) {
    const ue = u.get(pe).get(D);
    h.get(pe) !== ue &&
      (r.uniformBlockBinding(pe, ue, D.__bindingPointIndex), h.set(pe, ue));
  }
  function Ye() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      n === !0 &&
        (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null)),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (d = {}),
      ($ = null),
      (Y = {}),
      (f = {}),
      (m = new WeakMap()),
      (_ = []),
      (g = null),
      (p = !1),
      (v = null),
      (x = null),
      (y = null),
      (S = null),
      (w = null),
      (R = null),
      (P = null),
      (M = !1),
      (A = null),
      (k = null),
      (X = null),
      (U = null),
      (O = null),
      ne.set(0, 0, r.canvas.width, r.canvas.height),
      ie.set(0, 0, r.canvas.width, r.canvas.height),
      o.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: o, depth: l, stencil: c },
    enable: Me,
    disable: Ne,
    bindFramebuffer: Ce,
    drawBuffers: Ze,
    useProgram: Pe,
    setBlending: Q,
    setMaterial: oe,
    setFlipSided: ee,
    setCullFace: we,
    setLineWidth: _e,
    setPolygonOffset: xe,
    setScissorTest: Le,
    activeTexture: ze,
    bindTexture: it,
    unbindTexture: C,
    compressedTexImage2D: E,
    compressedTexImage3D: q,
    texImage2D: Se,
    texImage3D: Re,
    updateUBOMapping: ve,
    uniformBlockBinding: Ie,
    texStorage2D: re,
    texStorage3D: W,
    texSubImage2D: ae,
    texSubImage3D: se,
    compressedTexSubImage2D: L,
    compressedTexSubImage3D: te,
    scissor: Ee,
    viewport: be,
    reset: Ye,
  };
}
function Ay(r, e, t, n, i, s, a) {
  const o = i.isWebGL2,
    l = i.maxTextures,
    c = i.maxCubemapSize,
    h = i.maxTextureSize,
    u = i.maxSamples,
    d = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    f =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    m = new WeakMap();
  let _;
  const g = new WeakMap();
  let p = !1;
  try {
    p =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function v(C, E) {
    return p ? new OffscreenCanvas(C, E) : Ir("canvas");
  }
  function x(C, E, q, ae) {
    let se = 1;
    if (
      ((C.width > ae || C.height > ae) &&
        (se = ae / Math.max(C.width, C.height)),
      se < 1 || E === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && C instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && C instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && C instanceof ImageBitmap)
      ) {
        const L = E ? ho : Math.floor,
          te = L(se * C.width),
          re = L(se * C.height);
        _ === void 0 && (_ = v(te, re));
        const W = q ? v(te, re) : _;
        return (
          (W.width = te),
          (W.height = re),
          W.getContext("2d").drawImage(C, 0, 0, te, re),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              C.width +
              "x" +
              C.height +
              ") to (" +
              te +
              "x" +
              re +
              ")."
          ),
          W
        );
      } else
        return (
          "data" in C &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                C.width +
                "x" +
                C.height +
                ")."
            ),
          C
        );
    return C;
  }
  function y(C) {
    return rc(C.width) && rc(C.height);
  }
  function S(C) {
    return o
      ? !1
      : C.wrapS !== Dt ||
          C.wrapT !== Dt ||
          (C.minFilter !== gt && C.minFilter !== ot);
  }
  function w(C, E) {
    return C.generateMipmaps && E && C.minFilter !== gt && C.minFilter !== ot;
  }
  function R(C) {
    r.generateMipmap(C);
  }
  function P(C, E, q, ae, se = !1) {
    if (o === !1) return E;
    if (C !== null) {
      if (r[C] !== void 0) return r[C];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          C +
          "'"
      );
    }
    let L = E;
    return (
      E === r.RED &&
        (q === r.FLOAT && (L = r.R32F),
        q === r.HALF_FLOAT && (L = r.R16F),
        q === r.UNSIGNED_BYTE && (L = r.R8)),
      E === r.RG &&
        (q === r.FLOAT && (L = r.RG32F),
        q === r.HALF_FLOAT && (L = r.RG16F),
        q === r.UNSIGNED_BYTE && (L = r.RG8)),
      E === r.RGBA &&
        (q === r.FLOAT && (L = r.RGBA32F),
        q === r.HALF_FLOAT && (L = r.RGBA16F),
        q === r.UNSIGNED_BYTE &&
          (L = ae === Oe && se === !1 ? r.SRGB8_ALPHA8 : r.RGBA8),
        q === r.UNSIGNED_SHORT_4_4_4_4 && (L = r.RGBA4),
        q === r.UNSIGNED_SHORT_5_5_5_1 && (L = r.RGB5_A1)),
      (L === r.R16F ||
        L === r.R32F ||
        L === r.RG16F ||
        L === r.RG32F ||
        L === r.RGBA16F ||
        L === r.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      L
    );
  }
  function M(C, E, q) {
    return w(C, q) === !0 ||
      (C.isFramebufferTexture && C.minFilter !== gt && C.minFilter !== ot)
      ? Math.log2(Math.max(E.width, E.height)) + 1
      : C.mipmaps !== void 0 && C.mipmaps.length > 0
      ? C.mipmaps.length
      : C.isCompressedTexture && Array.isArray(C.image)
      ? E.mipmaps.length
      : 1;
  }
  function A(C) {
    return C === gt || C === Tr || C === Ds ? r.NEAREST : r.LINEAR;
  }
  function k(C) {
    const E = C.target;
    E.removeEventListener("dispose", k), U(E), E.isVideoTexture && m.delete(E);
  }
  function X(C) {
    const E = C.target;
    E.removeEventListener("dispose", X), N(E);
  }
  function U(C) {
    const E = n.get(C);
    if (E.__webglInit === void 0) return;
    const q = C.source,
      ae = g.get(q);
    if (ae) {
      const se = ae[E.__cacheKey];
      se.usedTimes--,
        se.usedTimes === 0 && O(C),
        Object.keys(ae).length === 0 && g.delete(q);
    }
    n.remove(C);
  }
  function O(C) {
    const E = n.get(C);
    r.deleteTexture(E.__webglTexture);
    const q = C.source,
      ae = g.get(q);
    delete ae[E.__cacheKey], a.memory.textures--;
  }
  function N(C) {
    const E = C.texture,
      q = n.get(C),
      ae = n.get(E);
    if (
      (ae.__webglTexture !== void 0 &&
        (r.deleteTexture(ae.__webglTexture), a.memory.textures--),
      C.depthTexture && C.depthTexture.dispose(),
      C.isWebGLCubeRenderTarget)
    )
      for (let se = 0; se < 6; se++)
        r.deleteFramebuffer(q.__webglFramebuffer[se]),
          q.__webglDepthbuffer &&
            r.deleteRenderbuffer(q.__webglDepthbuffer[se]);
    else {
      if (
        (r.deleteFramebuffer(q.__webglFramebuffer),
        q.__webglDepthbuffer && r.deleteRenderbuffer(q.__webglDepthbuffer),
        q.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer(q.__webglMultisampledFramebuffer),
        q.__webglColorRenderbuffer)
      )
        for (let se = 0; se < q.__webglColorRenderbuffer.length; se++)
          q.__webglColorRenderbuffer[se] &&
            r.deleteRenderbuffer(q.__webglColorRenderbuffer[se]);
      q.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer(q.__webglDepthRenderbuffer);
    }
    if (C.isWebGLMultipleRenderTargets)
      for (let se = 0, L = E.length; se < L; se++) {
        const te = n.get(E[se]);
        te.__webglTexture &&
          (r.deleteTexture(te.__webglTexture), a.memory.textures--),
          n.remove(E[se]);
      }
    n.remove(E), n.remove(C);
  }
  let Z = 0;
  function B() {
    Z = 0;
  }
  function G() {
    const C = Z;
    return (
      C >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            C +
            " texture units while this GPU supports only " +
            l
        ),
      (Z += 1),
      C
    );
  }
  function $(C) {
    const E = [];
    return (
      E.push(C.wrapS),
      E.push(C.wrapT),
      E.push(C.wrapR || 0),
      E.push(C.magFilter),
      E.push(C.minFilter),
      E.push(C.anisotropy),
      E.push(C.internalFormat),
      E.push(C.format),
      E.push(C.type),
      E.push(C.generateMipmaps),
      E.push(C.premultiplyAlpha),
      E.push(C.flipY),
      E.push(C.unpackAlignment),
      E.push(C.colorSpace),
      E.join()
    );
  }
  function Y(C, E) {
    const q = n.get(C);
    if (
      (C.isVideoTexture && ze(C),
      C.isRenderTargetTexture === !1 &&
        C.version > 0 &&
        q.__version !== C.version)
    ) {
      const ae = C.image;
      if (ae === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ae.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Ce(q, C, E);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, q.__webglTexture, r.TEXTURE0 + E);
  }
  function he(C, E) {
    const q = n.get(C);
    if (C.version > 0 && q.__version !== C.version) {
      Ce(q, C, E);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, q.__webglTexture, r.TEXTURE0 + E);
  }
  function F(C, E) {
    const q = n.get(C);
    if (C.version > 0 && q.__version !== C.version) {
      Ce(q, C, E);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, q.__webglTexture, r.TEXTURE0 + E);
  }
  function ne(C, E) {
    const q = n.get(C);
    if (C.version > 0 && q.__version !== C.version) {
      Ze(q, C, E);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, q.__webglTexture, r.TEXTURE0 + E);
  }
  const ie = { [Mi]: r.REPEAT, [Dt]: r.CLAMP_TO_EDGE, [Fs]: r.MIRRORED_REPEAT },
    me = {
      [gt]: r.NEAREST,
      [Tr]: r.NEAREST_MIPMAP_NEAREST,
      [Ds]: r.NEAREST_MIPMAP_LINEAR,
      [ot]: r.LINEAR,
      [go]: r.LINEAR_MIPMAP_NEAREST,
      [Dn]: r.LINEAR_MIPMAP_LINEAR,
    },
    ge = {
      [rf]: r.NEVER,
      [df]: r.ALWAYS,
      [af]: r.LESS,
      [lf]: r.LEQUAL,
      [of]: r.EQUAL,
      [uf]: r.GEQUAL,
      [cf]: r.GREATER,
      [hf]: r.NOTEQUAL,
    };
  function Me(C, E, q) {
    if (
      (q
        ? (r.texParameteri(C, r.TEXTURE_WRAP_S, ie[E.wrapS]),
          r.texParameteri(C, r.TEXTURE_WRAP_T, ie[E.wrapT]),
          (C === r.TEXTURE_3D || C === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(C, r.TEXTURE_WRAP_R, ie[E.wrapR]),
          r.texParameteri(C, r.TEXTURE_MAG_FILTER, me[E.magFilter]),
          r.texParameteri(C, r.TEXTURE_MIN_FILTER, me[E.minFilter]))
        : (r.texParameteri(C, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
          r.texParameteri(C, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
          (C === r.TEXTURE_3D || C === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(C, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE),
          (E.wrapS !== Dt || E.wrapT !== Dt) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          r.texParameteri(C, r.TEXTURE_MAG_FILTER, A(E.magFilter)),
          r.texParameteri(C, r.TEXTURE_MIN_FILTER, A(E.minFilter)),
          E.minFilter !== gt &&
            E.minFilter !== ot &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      E.compareFunction &&
        (r.texParameteri(C, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(C, r.TEXTURE_COMPARE_FUNC, ge[E.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const ae = e.get("EXT_texture_filter_anisotropic");
      if (
        E.magFilter === gt ||
        (E.minFilter !== Ds && E.minFilter !== Dn) ||
        (E.type === on && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          E.type === Bs &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (E.anisotropy > 1 || n.get(E).__currentAnisotropy) &&
        (r.texParameterf(
          C,
          ae.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(E.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(E).__currentAnisotropy = E.anisotropy));
    }
  }
  function Ne(C, E) {
    let q = !1;
    C.__webglInit === void 0 &&
      ((C.__webglInit = !0), E.addEventListener("dispose", k));
    const ae = E.source;
    let se = g.get(ae);
    se === void 0 && ((se = {}), g.set(ae, se));
    const L = $(E);
    if (L !== C.__cacheKey) {
      se[L] === void 0 &&
        ((se[L] = { texture: r.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (q = !0)),
        se[L].usedTimes++;
      const te = se[C.__cacheKey];
      te !== void 0 &&
        (se[C.__cacheKey].usedTimes--, te.usedTimes === 0 && O(E)),
        (C.__cacheKey = L),
        (C.__webglTexture = se[L].texture);
    }
    return q;
  }
  function Ce(C, E, q) {
    let ae = r.TEXTURE_2D;
    (E.isDataArrayTexture || E.isCompressedArrayTexture) &&
      (ae = r.TEXTURE_2D_ARRAY),
      E.isData3DTexture && (ae = r.TEXTURE_3D);
    const se = Ne(C, E),
      L = E.source;
    t.bindTexture(ae, C.__webglTexture, r.TEXTURE0 + q);
    const te = n.get(L);
    if (L.version !== te.__version || se === !0) {
      t.activeTexture(r.TEXTURE0 + q),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const re = S(E) && y(E.image) === !1;
      let W = x(E.image, re, !1, h);
      W = it(E, W);
      const Se = y(W) || o,
        Re = s.convert(E.format, E.colorSpace);
      let Ee = s.convert(E.type),
        be = P(E.internalFormat, Re, Ee, E.colorSpace);
      Me(ae, E, Se);
      let ve;
      const Ie = E.mipmaps,
        Ye = o && E.isVideoTexture !== !0,
        D = te.__version === void 0 || se === !0,
        pe = M(E, W, Se);
      if (E.isDepthTexture)
        (be = r.DEPTH_COMPONENT),
          o
            ? E.type === on
              ? (be = r.DEPTH_COMPONENT32F)
              : E.type === Zn
              ? (be = r.DEPTH_COMPONENT24)
              : E.type === mi
              ? (be = r.DEPTH24_STENCIL8)
              : (be = r.DEPTH_COMPONENT16)
            : E.type === on &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          E.format === gi &&
            be === r.DEPTH_COMPONENT &&
            E.type !== _o &&
            E.type !== Zn &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (E.type = Zn),
            (Ee = s.convert(E.type))),
          E.format === ts &&
            be === r.DEPTH_COMPONENT &&
            ((be = r.DEPTH_STENCIL),
            E.type !== mi &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (E.type = mi),
              (Ee = s.convert(E.type)))),
          D &&
            (Ye
              ? t.texStorage2D(r.TEXTURE_2D, 1, be, W.width, W.height)
              : t.texImage2D(
                  r.TEXTURE_2D,
                  0,
                  be,
                  W.width,
                  W.height,
                  0,
                  Re,
                  Ee,
                  null
                ));
      else if (E.isDataTexture)
        if (Ie.length > 0 && Se) {
          Ye &&
            D &&
            t.texStorage2D(r.TEXTURE_2D, pe, be, Ie[0].width, Ie[0].height);
          for (let V = 0, ue = Ie.length; V < ue; V++)
            (ve = Ie[V]),
              Ye
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    V,
                    0,
                    0,
                    ve.width,
                    ve.height,
                    Re,
                    Ee,
                    ve.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    V,
                    be,
                    ve.width,
                    ve.height,
                    0,
                    Re,
                    Ee,
                    ve.data
                  );
          E.generateMipmaps = !1;
        } else
          Ye
            ? (D && t.texStorage2D(r.TEXTURE_2D, pe, be, W.width, W.height),
              t.texSubImage2D(
                r.TEXTURE_2D,
                0,
                0,
                0,
                W.width,
                W.height,
                Re,
                Ee,
                W.data
              ))
            : t.texImage2D(
                r.TEXTURE_2D,
                0,
                be,
                W.width,
                W.height,
                0,
                Re,
                Ee,
                W.data
              );
      else if (E.isCompressedTexture)
        if (E.isCompressedArrayTexture) {
          Ye &&
            D &&
            t.texStorage3D(
              r.TEXTURE_2D_ARRAY,
              pe,
              be,
              Ie[0].width,
              Ie[0].height,
              W.depth
            );
          for (let V = 0, ue = Ie.length; V < ue; V++)
            (ve = Ie[V]),
              E.format !== qt
                ? Re !== null
                  ? Ye
                    ? t.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        V,
                        0,
                        0,
                        0,
                        ve.width,
                        ve.height,
                        W.depth,
                        Re,
                        ve.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        r.TEXTURE_2D_ARRAY,
                        V,
                        be,
                        ve.width,
                        ve.height,
                        W.depth,
                        0,
                        ve.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ye
                ? t.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    V,
                    0,
                    0,
                    0,
                    ve.width,
                    ve.height,
                    W.depth,
                    Re,
                    Ee,
                    ve.data
                  )
                : t.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    V,
                    be,
                    ve.width,
                    ve.height,
                    W.depth,
                    0,
                    Re,
                    Ee,
                    ve.data
                  );
        } else {
          Ye &&
            D &&
            t.texStorage2D(r.TEXTURE_2D, pe, be, Ie[0].width, Ie[0].height);
          for (let V = 0, ue = Ie.length; V < ue; V++)
            (ve = Ie[V]),
              E.format !== qt
                ? Re !== null
                  ? Ye
                    ? t.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        V,
                        0,
                        0,
                        ve.width,
                        ve.height,
                        Re,
                        ve.data
                      )
                    : t.compressedTexImage2D(
                        r.TEXTURE_2D,
                        V,
                        be,
                        ve.width,
                        ve.height,
                        0,
                        ve.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Ye
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    V,
                    0,
                    0,
                    ve.width,
                    ve.height,
                    Re,
                    Ee,
                    ve.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    V,
                    be,
                    ve.width,
                    ve.height,
                    0,
                    Re,
                    Ee,
                    ve.data
                  );
        }
      else if (E.isDataArrayTexture)
        Ye
          ? (D &&
              t.texStorage3D(
                r.TEXTURE_2D_ARRAY,
                pe,
                be,
                W.width,
                W.height,
                W.depth
              ),
            t.texSubImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              W.width,
              W.height,
              W.depth,
              Re,
              Ee,
              W.data
            ))
          : t.texImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              be,
              W.width,
              W.height,
              W.depth,
              0,
              Re,
              Ee,
              W.data
            );
      else if (E.isData3DTexture)
        Ye
          ? (D &&
              t.texStorage3D(r.TEXTURE_3D, pe, be, W.width, W.height, W.depth),
            t.texSubImage3D(
              r.TEXTURE_3D,
              0,
              0,
              0,
              0,
              W.width,
              W.height,
              W.depth,
              Re,
              Ee,
              W.data
            ))
          : t.texImage3D(
              r.TEXTURE_3D,
              0,
              be,
              W.width,
              W.height,
              W.depth,
              0,
              Re,
              Ee,
              W.data
            );
      else if (E.isFramebufferTexture) {
        if (D)
          if (Ye) t.texStorage2D(r.TEXTURE_2D, pe, be, W.width, W.height);
          else {
            let V = W.width,
              ue = W.height;
            for (let ye = 0; ye < pe; ye++)
              t.texImage2D(r.TEXTURE_2D, ye, be, V, ue, 0, Re, Ee, null),
                (V >>= 1),
                (ue >>= 1);
          }
      } else if (Ie.length > 0 && Se) {
        Ye &&
          D &&
          t.texStorage2D(r.TEXTURE_2D, pe, be, Ie[0].width, Ie[0].height);
        for (let V = 0, ue = Ie.length; V < ue; V++)
          (ve = Ie[V]),
            Ye
              ? t.texSubImage2D(r.TEXTURE_2D, V, 0, 0, Re, Ee, ve)
              : t.texImage2D(r.TEXTURE_2D, V, be, Re, Ee, ve);
        E.generateMipmaps = !1;
      } else
        Ye
          ? (D && t.texStorage2D(r.TEXTURE_2D, pe, be, W.width, W.height),
            t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Re, Ee, W))
          : t.texImage2D(r.TEXTURE_2D, 0, be, Re, Ee, W);
      w(E, Se) && R(ae),
        (te.__version = L.version),
        E.onUpdate && E.onUpdate(E);
    }
    C.__version = E.version;
  }
  function Ze(C, E, q) {
    if (E.image.length !== 6) return;
    const ae = Ne(C, E),
      se = E.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, C.__webglTexture, r.TEXTURE0 + q);
    const L = n.get(se);
    if (se.version !== L.__version || ae === !0) {
      t.activeTexture(r.TEXTURE0 + q),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, E.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, E.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const te = E.isCompressedTexture || E.image[0].isCompressedTexture,
        re = E.image[0] && E.image[0].isDataTexture,
        W = [];
      for (let V = 0; V < 6; V++)
        !te && !re
          ? (W[V] = x(E.image[V], !1, !0, c))
          : (W[V] = re ? E.image[V].image : E.image[V]),
          (W[V] = it(E, W[V]));
      const Se = W[0],
        Re = y(Se) || o,
        Ee = s.convert(E.format, E.colorSpace),
        be = s.convert(E.type),
        ve = P(E.internalFormat, Ee, be, E.colorSpace),
        Ie = o && E.isVideoTexture !== !0,
        Ye = L.__version === void 0 || ae === !0;
      let D = M(E, Se, Re);
      Me(r.TEXTURE_CUBE_MAP, E, Re);
      let pe;
      if (te) {
        Ie &&
          Ye &&
          t.texStorage2D(r.TEXTURE_CUBE_MAP, D, ve, Se.width, Se.height);
        for (let V = 0; V < 6; V++) {
          pe = W[V].mipmaps;
          for (let ue = 0; ue < pe.length; ue++) {
            const ye = pe[ue];
            E.format !== qt
              ? Ee !== null
                ? Ie
                  ? t.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                      ue,
                      0,
                      0,
                      ye.width,
                      ye.height,
                      Ee,
                      ye.data
                    )
                  : t.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                      ue,
                      ve,
                      ye.width,
                      ye.height,
                      0,
                      ye.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : Ie
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  ue,
                  0,
                  0,
                  ye.width,
                  ye.height,
                  Ee,
                  be,
                  ye.data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  ue,
                  ve,
                  ye.width,
                  ye.height,
                  0,
                  Ee,
                  be,
                  ye.data
                );
          }
        }
      } else {
        (pe = E.mipmaps),
          Ie &&
            Ye &&
            (pe.length > 0 && D++,
            t.texStorage2D(r.TEXTURE_CUBE_MAP, D, ve, W[0].width, W[0].height));
        for (let V = 0; V < 6; V++)
          if (re) {
            Ie
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  0,
                  0,
                  0,
                  W[V].width,
                  W[V].height,
                  Ee,
                  be,
                  W[V].data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  0,
                  ve,
                  W[V].width,
                  W[V].height,
                  0,
                  Ee,
                  be,
                  W[V].data
                );
            for (let ue = 0; ue < pe.length; ue++) {
              const Qe = pe[ue].image[V].image;
              Ie
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                    ue + 1,
                    0,
                    0,
                    Qe.width,
                    Qe.height,
                    Ee,
                    be,
                    Qe.data
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                    ue + 1,
                    ve,
                    Qe.width,
                    Qe.height,
                    0,
                    Ee,
                    be,
                    Qe.data
                  );
            }
          } else {
            Ie
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  0,
                  0,
                  0,
                  Ee,
                  be,
                  W[V]
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                  0,
                  ve,
                  Ee,
                  be,
                  W[V]
                );
            for (let ue = 0; ue < pe.length; ue++) {
              const ye = pe[ue];
              Ie
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                    ue + 1,
                    0,
                    0,
                    Ee,
                    be,
                    ye.image[V]
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + V,
                    ue + 1,
                    ve,
                    Ee,
                    be,
                    ye.image[V]
                  );
            }
          }
      }
      w(E, Re) && R(r.TEXTURE_CUBE_MAP),
        (L.__version = se.version),
        E.onUpdate && E.onUpdate(E);
    }
    C.__version = E.version;
  }
  function Pe(C, E, q, ae, se) {
    const L = s.convert(q.format, q.colorSpace),
      te = s.convert(q.type),
      re = P(q.internalFormat, L, te, q.colorSpace);
    n.get(E).__hasExternalTextures ||
      (se === r.TEXTURE_3D || se === r.TEXTURE_2D_ARRAY
        ? t.texImage3D(se, 0, re, E.width, E.height, E.depth, 0, L, te, null)
        : t.texImage2D(se, 0, re, E.width, E.height, 0, L, te, null)),
      t.bindFramebuffer(r.FRAMEBUFFER, C),
      Le(E)
        ? d.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            ae,
            se,
            n.get(q).__webglTexture,
            0,
            xe(E)
          )
        : (se === r.TEXTURE_2D ||
            (se >= r.TEXTURE_CUBE_MAP_POSITIVE_X &&
              se <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            ae,
            se,
            n.get(q).__webglTexture,
            0
          ),
      t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function I(C, E, q) {
    if (
      (r.bindRenderbuffer(r.RENDERBUFFER, C), E.depthBuffer && !E.stencilBuffer)
    ) {
      let ae = r.DEPTH_COMPONENT16;
      if (q || Le(E)) {
        const se = E.depthTexture;
        se &&
          se.isDepthTexture &&
          (se.type === on
            ? (ae = r.DEPTH_COMPONENT32F)
            : se.type === Zn && (ae = r.DEPTH_COMPONENT24));
        const L = xe(E);
        Le(E)
          ? d.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              L,
              ae,
              E.width,
              E.height
            )
          : r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              L,
              ae,
              E.width,
              E.height
            );
      } else r.renderbufferStorage(r.RENDERBUFFER, ae, E.width, E.height);
      r.framebufferRenderbuffer(
        r.FRAMEBUFFER,
        r.DEPTH_ATTACHMENT,
        r.RENDERBUFFER,
        C
      );
    } else if (E.depthBuffer && E.stencilBuffer) {
      const ae = xe(E);
      q && Le(E) === !1
        ? r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            ae,
            r.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : Le(E)
        ? d.renderbufferStorageMultisampleEXT(
            r.RENDERBUFFER,
            ae,
            r.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : r.renderbufferStorage(
            r.RENDERBUFFER,
            r.DEPTH_STENCIL,
            E.width,
            E.height
          ),
        r.framebufferRenderbuffer(
          r.FRAMEBUFFER,
          r.DEPTH_STENCIL_ATTACHMENT,
          r.RENDERBUFFER,
          C
        );
    } else {
      const ae =
        E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
      for (let se = 0; se < ae.length; se++) {
        const L = ae[se],
          te = s.convert(L.format, L.colorSpace),
          re = s.convert(L.type),
          W = P(L.internalFormat, te, re, L.colorSpace),
          Se = xe(E);
        q && Le(E) === !1
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              Se,
              W,
              E.width,
              E.height
            )
          : Le(E)
          ? d.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              Se,
              W,
              E.width,
              E.height
            )
          : r.renderbufferStorage(r.RENDERBUFFER, W, E.width, E.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function le(C, E) {
    if (E && E.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(r.FRAMEBUFFER, C),
      !(E.depthTexture && E.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(E.depthTexture).__webglTexture ||
      E.depthTexture.image.width !== E.width ||
      E.depthTexture.image.height !== E.height) &&
      ((E.depthTexture.image.width = E.width),
      (E.depthTexture.image.height = E.height),
      (E.depthTexture.needsUpdate = !0)),
      Y(E.depthTexture, 0);
    const ae = n.get(E.depthTexture).__webglTexture,
      se = xe(E);
    if (E.depthTexture.format === gi)
      Le(E)
        ? d.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ae,
            0,
            se
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ae,
            0
          );
    else if (E.depthTexture.format === ts)
      Le(E)
        ? d.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ae,
            0,
            se
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ae,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Q(C) {
    const E = n.get(C),
      q = C.isWebGLCubeRenderTarget === !0;
    if (C.depthTexture && !E.__autoAllocateDepthBuffer) {
      if (q)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      le(E.__webglFramebuffer, C);
    } else if (q) {
      E.__webglDepthbuffer = [];
      for (let ae = 0; ae < 6; ae++)
        t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer[ae]),
          (E.__webglDepthbuffer[ae] = r.createRenderbuffer()),
          I(E.__webglDepthbuffer[ae], C, !1);
    } else
      t.bindFramebuffer(r.FRAMEBUFFER, E.__webglFramebuffer),
        (E.__webglDepthbuffer = r.createRenderbuffer()),
        I(E.__webglDepthbuffer, C, !1);
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function oe(C, E, q) {
    const ae = n.get(C);
    E !== void 0 &&
      Pe(
        ae.__webglFramebuffer,
        C,
        C.texture,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D
      ),
      q !== void 0 && Q(C);
  }
  function ee(C) {
    const E = C.texture,
      q = n.get(C),
      ae = n.get(E);
    C.addEventListener("dispose", X),
      C.isWebGLMultipleRenderTargets !== !0 &&
        (ae.__webglTexture === void 0 &&
          (ae.__webglTexture = r.createTexture()),
        (ae.__version = E.version),
        a.memory.textures++);
    const se = C.isWebGLCubeRenderTarget === !0,
      L = C.isWebGLMultipleRenderTargets === !0,
      te = y(C) || o;
    if (se) {
      q.__webglFramebuffer = [];
      for (let re = 0; re < 6; re++)
        q.__webglFramebuffer[re] = r.createFramebuffer();
    } else {
      if (((q.__webglFramebuffer = r.createFramebuffer()), L))
        if (i.drawBuffers) {
          const re = C.texture;
          for (let W = 0, Se = re.length; W < Se; W++) {
            const Re = n.get(re[W]);
            Re.__webglTexture === void 0 &&
              ((Re.__webglTexture = r.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && C.samples > 0 && Le(C) === !1) {
        const re = L ? E : [E];
        (q.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(r.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
        for (let W = 0; W < re.length; W++) {
          const Se = re[W];
          (q.__webglColorRenderbuffer[W] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, q.__webglColorRenderbuffer[W]);
          const Re = s.convert(Se.format, Se.colorSpace),
            Ee = s.convert(Se.type),
            be = P(
              Se.internalFormat,
              Re,
              Ee,
              Se.colorSpace,
              C.isXRRenderTarget === !0
            ),
            ve = xe(C);
          r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            ve,
            be,
            C.width,
            C.height
          ),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + W,
              r.RENDERBUFFER,
              q.__webglColorRenderbuffer[W]
            );
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          C.depthBuffer &&
            ((q.__webglDepthRenderbuffer = r.createRenderbuffer()),
            I(q.__webglDepthRenderbuffer, C, !0)),
          t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (se) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, ae.__webglTexture),
        Me(r.TEXTURE_CUBE_MAP, E, te);
      for (let re = 0; re < 6; re++)
        Pe(
          q.__webglFramebuffer[re],
          C,
          E,
          r.COLOR_ATTACHMENT0,
          r.TEXTURE_CUBE_MAP_POSITIVE_X + re
        );
      w(E, te) && R(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (L) {
      const re = C.texture;
      for (let W = 0, Se = re.length; W < Se; W++) {
        const Re = re[W],
          Ee = n.get(Re);
        t.bindTexture(r.TEXTURE_2D, Ee.__webglTexture),
          Me(r.TEXTURE_2D, Re, te),
          Pe(
            q.__webglFramebuffer,
            C,
            Re,
            r.COLOR_ATTACHMENT0 + W,
            r.TEXTURE_2D
          ),
          w(Re, te) && R(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let re = r.TEXTURE_2D;
      (C.isWebGL3DRenderTarget || C.isWebGLArrayRenderTarget) &&
        (o
          ? (re = C.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(re, ae.__webglTexture),
        Me(re, E, te),
        Pe(q.__webglFramebuffer, C, E, r.COLOR_ATTACHMENT0, re),
        w(E, te) && R(re),
        t.unbindTexture();
    }
    C.depthBuffer && Q(C);
  }
  function we(C) {
    const E = y(C) || o,
      q = C.isWebGLMultipleRenderTargets === !0 ? C.texture : [C.texture];
    for (let ae = 0, se = q.length; ae < se; ae++) {
      const L = q[ae];
      if (w(L, E)) {
        const te = C.isWebGLCubeRenderTarget
            ? r.TEXTURE_CUBE_MAP
            : r.TEXTURE_2D,
          re = n.get(L).__webglTexture;
        t.bindTexture(te, re), R(te), t.unbindTexture();
      }
    }
  }
  function _e(C) {
    if (o && C.samples > 0 && Le(C) === !1) {
      const E = C.isWebGLMultipleRenderTargets ? C.texture : [C.texture],
        q = C.width,
        ae = C.height;
      let se = r.COLOR_BUFFER_BIT;
      const L = [],
        te = C.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        re = n.get(C),
        W = C.isWebGLMultipleRenderTargets === !0;
      if (W)
        for (let Se = 0; Se < E.length; Se++)
          t.bindFramebuffer(r.FRAMEBUFFER, re.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + Se,
              r.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(r.FRAMEBUFFER, re.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + Se,
              r.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(r.READ_FRAMEBUFFER, re.__webglMultisampledFramebuffer),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, re.__webglFramebuffer);
      for (let Se = 0; Se < E.length; Se++) {
        L.push(r.COLOR_ATTACHMENT0 + Se), C.depthBuffer && L.push(te);
        const Re =
          re.__ignoreDepthValues !== void 0 ? re.__ignoreDepthValues : !1;
        if (
          (Re === !1 &&
            (C.depthBuffer && (se |= r.DEPTH_BUFFER_BIT),
            C.stencilBuffer && (se |= r.STENCIL_BUFFER_BIT)),
          W &&
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              re.__webglColorRenderbuffer[Se]
            ),
          Re === !0 &&
            (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [te]),
            r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [te])),
          W)
        ) {
          const Ee = n.get(E[Se]).__webglTexture;
          r.framebufferTexture2D(
            r.DRAW_FRAMEBUFFER,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_2D,
            Ee,
            0
          );
        }
        r.blitFramebuffer(0, 0, q, ae, 0, 0, q, ae, se, r.NEAREST),
          f && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, L);
      }
      if (
        (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        W)
      )
        for (let Se = 0; Se < E.length; Se++) {
          t.bindFramebuffer(r.FRAMEBUFFER, re.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + Se,
              r.RENDERBUFFER,
              re.__webglColorRenderbuffer[Se]
            );
          const Re = n.get(E[Se]).__webglTexture;
          t.bindFramebuffer(r.FRAMEBUFFER, re.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + Se,
              r.TEXTURE_2D,
              Re,
              0
            );
        }
      t.bindFramebuffer(r.DRAW_FRAMEBUFFER, re.__webglMultisampledFramebuffer);
    }
  }
  function xe(C) {
    return Math.min(u, C.samples);
  }
  function Le(C) {
    const E = n.get(C);
    return (
      o &&
      C.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      E.__useRenderToTexture !== !1
    );
  }
  function ze(C) {
    const E = a.render.frame;
    m.get(C) !== E && (m.set(C, E), C.update());
  }
  function it(C, E) {
    const q = C.colorSpace,
      ae = C.format,
      se = C.type;
    return (
      C.isCompressedTexture === !0 ||
        C.format === co ||
        (q !== xn &&
          q !== xi &&
          (q === Oe
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && ae === qt
                ? ((C.format = co),
                  (C.minFilter = ot),
                  (C.generateMipmaps = !1))
                : (E = Nc.sRGBToLinear(E))
              : (ae !== qt || se !== _n) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                q
              ))),
      E
    );
  }
  (this.allocateTextureUnit = G),
    (this.resetTextureUnits = B),
    (this.setTexture2D = Y),
    (this.setTexture2DArray = he),
    (this.setTexture3D = F),
    (this.setTextureCube = ne),
    (this.rebindTextures = oe),
    (this.setupRenderTarget = ee),
    (this.updateRenderTargetMipmap = we),
    (this.updateMultisampleRenderTarget = _e),
    (this.setupDepthRenderbuffer = Q),
    (this.setupFrameBufferTexture = Pe),
    (this.useMultisampledRTT = Le);
}
function Af(r, e, t) {
  const n = t.isWebGL2;
  function i(s, a = xi) {
    let o;
    if (s === _n) return r.UNSIGNED_BYTE;
    if (s === wc) return r.UNSIGNED_SHORT_4_4_4_4;
    if (s === Ec) return r.UNSIGNED_SHORT_5_5_5_1;
    if (s === Gd) return r.BYTE;
    if (s === Vd) return r.SHORT;
    if (s === _o) return r.UNSIGNED_SHORT;
    if (s === bc) return r.INT;
    if (s === Zn) return r.UNSIGNED_INT;
    if (s === on) return r.FLOAT;
    if (s === Bs)
      return n
        ? r.HALF_FLOAT
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === Wd) return r.ALPHA;
    if (s === qt) return r.RGBA;
    if (s === Xd) return r.LUMINANCE;
    if (s === Yd) return r.LUMINANCE_ALPHA;
    if (s === gi) return r.DEPTH_COMPONENT;
    if (s === ts) return r.DEPTH_STENCIL;
    if (s === co)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === Ac) return r.RED;
    if (s === Tc) return r.RED_INTEGER;
    if (s === qd) return r.RG;
    if (s === Rc) return r.RG_INTEGER;
    if (s === Cc) return r.RGBA_INTEGER;
    if (s === Ja || s === Qa || s === eo || s === to)
      if (a === Oe)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (s === Ja) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Qa) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === eo) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === to) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === Ja) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Qa) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === eo) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === to) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Ol || s === Fl || s === Bl || s === zl)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === Ol) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Fl) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Bl) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === zl) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === Zd)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === kl || s === Hl)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (s === kl)
          return a === Oe ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === Hl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Gl ||
      s === Vl ||
      s === Wl ||
      s === Xl ||
      s === Yl ||
      s === ql ||
      s === Zl ||
      s === $l ||
      s === Kl ||
      s === jl ||
      s === Jl ||
      s === Ql ||
      s === ec ||
      s === tc
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (s === Gl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Vl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Wl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Xl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Yl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === ql)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Zl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === $l)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Kl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === jl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === Jl)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === Ql)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === ec)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === tc)
          return a === Oe
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === no)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (s === no)
          return a === Oe
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === $d || s === nc || s === ic || s === sc)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (s === no) return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === nc) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === ic) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === sc) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === mi
      ? n
        ? r.UNSIGNED_INT_24_8
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : r[s] !== void 0
      ? r[s]
      : null;
  }
  return { convert: i };
}
class Tf extends Et {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class $n extends qe {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const Ty = { type: "move" };
class rl {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new $n()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new $n()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new b()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new b())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new $n()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new b()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new b())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const _ of e.hand.values()) {
          const g = t.getJointPose(_, n),
            p = this._getHandJoint(c, _);
          g !== null &&
            (p.matrix.fromArray(g.transform.matrix),
            p.matrix.decompose(p.position, p.rotation, p.scale),
            (p.matrixWorldNeedsUpdate = !0),
            (p.jointRadius = g.radius)),
            (p.visible = g !== null);
        }
        const h = c.joints["index-finger-tip"],
          u = c.joints["thumb-tip"],
          d = h.position.distanceTo(u.position),
          f = 0.02,
          m = 0.005;
        c.inputState.pinching && d > f + m
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= f - m &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && s !== null && (i = s),
        i !== null &&
          (o.matrix.fromArray(i.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(i.linearVelocity))
            : (o.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(i.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(Ty)));
    }
    return (
      o !== null && (o.visible = i !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new $n();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Rf extends ht {
  constructor(e, t, n, i, s, a, o, l, c, h) {
    if (((h = h !== void 0 ? h : gi), h !== gi && h !== ts))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && h === gi && (n = Zn),
      n === void 0 && h === ts && (n = mi),
      super(null, i, s, a, o, l, h, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : gt),
      (this.minFilter = l !== void 0 ? l : gt),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Ry extends Un {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      h = null,
      u = null,
      d = null,
      f = null,
      m = null;
    const _ = t.getContextAttributes();
    let g = null,
      p = null;
    const v = [],
      x = [];
    let y = null;
    const S = new Et();
    S.layers.enable(1), (S.viewport = new tt());
    const w = new Et();
    w.layers.enable(2), (w.viewport = new tt());
    const R = [S, w],
      P = new Tf();
    P.layers.enable(1), P.layers.enable(2);
    let M = null,
      A = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getCamera = function () {}),
      (this.setUserCamera = function (F) {
        y = F;
      }),
      (this.getController = function (F) {
        let ne = v[F];
        return (
          ne === void 0 && ((ne = new rl()), (v[F] = ne)),
          ne.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (F) {
        let ne = v[F];
        return (
          ne === void 0 && ((ne = new rl()), (v[F] = ne)), ne.getGripSpace()
        );
      }),
      (this.getHand = function (F) {
        let ne = v[F];
        return (
          ne === void 0 && ((ne = new rl()), (v[F] = ne)), ne.getHandSpace()
        );
      });
    function k(F) {
      const ne = x.indexOf(F.inputSource);
      if (ne === -1) return;
      const ie = v[ne];
      ie !== void 0 &&
        (ie.update(F.inputSource, F.frame, c || a),
        ie.dispatchEvent({ type: F.type, data: F.inputSource }));
    }
    function X() {
      i.removeEventListener("select", k),
        i.removeEventListener("selectstart", k),
        i.removeEventListener("selectend", k),
        i.removeEventListener("squeeze", k),
        i.removeEventListener("squeezestart", k),
        i.removeEventListener("squeezeend", k),
        i.removeEventListener("end", X),
        i.removeEventListener("inputsourceschange", U);
      for (let F = 0; F < v.length; F++) {
        const ne = x[F];
        ne !== null && ((x[F] = null), v[F].disconnect(ne));
      }
      (M = null),
        (A = null),
        e.setRenderTarget(g),
        (f = null),
        (d = null),
        (u = null),
        (i = null),
        (p = null),
        he.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (F) {
      (s = F),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (F) {
        (o = F),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (F) {
        c = F;
      }),
      (this.getBaseLayer = function () {
        return d !== null ? d : f;
      }),
      (this.getBinding = function () {
        return u;
      }),
      (this.getFrame = function () {
        return m;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (F) {
        if (((i = F), i !== null)) {
          if (
            ((g = e.getRenderTarget()),
            i.addEventListener("select", k),
            i.addEventListener("selectstart", k),
            i.addEventListener("selectend", k),
            i.addEventListener("squeeze", k),
            i.addEventListener("squeezestart", k),
            i.addEventListener("squeezeend", k),
            i.addEventListener("end", X),
            i.addEventListener("inputsourceschange", U),
            _.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ne = {
              antialias: i.renderState.layers === void 0 ? _.antialias : !0,
              alpha: !0,
              depth: _.depth,
              stencil: _.stencil,
              framebufferScaleFactor: s,
            };
            (f = new XRWebGLLayer(i, t, ne)),
              i.updateRenderState({ baseLayer: f }),
              (p = new yn(f.framebufferWidth, f.framebufferHeight, {
                format: qt,
                type: _n,
                colorSpace: e.outputColorSpace,
                stencilBuffer: _.stencil,
              }));
          } else {
            let ne = null,
              ie = null,
              me = null;
            _.depth &&
              ((me = _.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (ne = _.stencil ? ts : gi),
              (ie = _.stencil ? mi : Zn));
            const ge = {
              colorFormat: t.RGBA8,
              depthFormat: me,
              scaleFactor: s,
            };
            (u = new XRWebGLBinding(i, t)),
              (d = u.createProjectionLayer(ge)),
              i.updateRenderState({ layers: [d] }),
              (p = new yn(d.textureWidth, d.textureHeight, {
                format: qt,
                type: _n,
                depthTexture: new Rf(
                  d.textureWidth,
                  d.textureHeight,
                  ie,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ne
                ),
                stencilBuffer: _.stencil,
                colorSpace: e.outputColorSpace,
                samples: _.antialias ? 4 : 0,
              }));
            const Me = e.properties.get(p);
            Me.__ignoreDepthValues = d.ignoreDepthValues;
          }
          (p.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await i.requestReferenceSpace(o)),
            he.setContext(i),
            he.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function U(F) {
      for (let ne = 0; ne < F.removed.length; ne++) {
        const ie = F.removed[ne],
          me = x.indexOf(ie);
        me >= 0 && ((x[me] = null), v[me].disconnect(ie));
      }
      for (let ne = 0; ne < F.added.length; ne++) {
        const ie = F.added[ne];
        let me = x.indexOf(ie);
        if (me === -1) {
          for (let Me = 0; Me < v.length; Me++)
            if (Me >= x.length) {
              x.push(ie), (me = Me);
              break;
            } else if (x[Me] === null) {
              (x[Me] = ie), (me = Me);
              break;
            }
          if (me === -1) break;
        }
        const ge = v[me];
        ge && ge.connect(ie);
      }
    }
    const O = new b(),
      N = new b();
    function Z(F, ne, ie) {
      O.setFromMatrixPosition(ne.matrixWorld),
        N.setFromMatrixPosition(ie.matrixWorld);
      const me = O.distanceTo(N),
        ge = ne.projectionMatrix.elements,
        Me = ie.projectionMatrix.elements,
        Ne = ge[14] / (ge[10] - 1),
        Ce = ge[14] / (ge[10] + 1),
        Ze = (ge[9] + 1) / ge[5],
        Pe = (ge[9] - 1) / ge[5],
        I = (ge[8] - 1) / ge[0],
        le = (Me[8] + 1) / Me[0],
        Q = Ne * I,
        oe = Ne * le,
        ee = me / (-I + le),
        we = ee * -I;
      ne.matrixWorld.decompose(F.position, F.quaternion, F.scale),
        F.translateX(we),
        F.translateZ(ee),
        F.matrixWorld.compose(F.position, F.quaternion, F.scale),
        F.matrixWorldInverse.copy(F.matrixWorld).invert();
      const _e = Ne + ee,
        xe = Ce + ee,
        Le = Q - we,
        ze = oe + (me - we),
        it = ((Ze * Ce) / xe) * _e,
        C = ((Pe * Ce) / xe) * _e;
      F.projectionMatrix.makePerspective(Le, ze, it, C, _e, xe),
        F.projectionMatrixInverse.copy(F.projectionMatrix).invert();
    }
    function B(F, ne) {
      ne === null
        ? F.matrixWorld.copy(F.matrix)
        : F.matrixWorld.multiplyMatrices(ne.matrixWorld, F.matrix),
        F.matrixWorldInverse.copy(F.matrixWorld).invert();
    }
    this.updateCameraXR = function (F) {
      if (i === null) return F;
      y && (F = y),
        (P.near = w.near = S.near = F.near),
        (P.far = w.far = S.far = F.far),
        (M !== P.near || A !== P.far) &&
          (i.updateRenderState({ depthNear: P.near, depthFar: P.far }),
          (M = P.near),
          (A = P.far));
      const ne = F.parent,
        ie = P.cameras;
      B(P, ne);
      for (let me = 0; me < ie.length; me++) B(ie[me], ne);
      return (
        ie.length === 2
          ? Z(P, S, w)
          : P.projectionMatrix.copy(S.projectionMatrix),
        y && G(P, ne),
        P
      );
    };
    function G(F, ne) {
      const ie = y;
      ne === null
        ? ie.matrix.copy(F.matrixWorld)
        : (ie.matrix.copy(ne.matrixWorld),
          ie.matrix.invert(),
          ie.matrix.multiply(F.matrixWorld)),
        ie.matrix.decompose(ie.position, ie.quaternion, ie.scale),
        ie.updateMatrixWorld(!0);
      const me = ie.children;
      for (let ge = 0, Me = me.length; ge < Me; ge++)
        me[ge].updateMatrixWorld(!0);
      ie.projectionMatrix.copy(F.projectionMatrix),
        ie.projectionMatrixInverse.copy(F.projectionMatrixInverse),
        ie.isPerspectiveCamera &&
          ((ie.fov = ks * 2 * Math.atan(1 / ie.projectionMatrix.elements[5])),
          (ie.zoom = 1));
    }
    (this.getFoveation = function () {
      if (!(d === null && f === null)) return l;
    }),
      (this.setFoveation = function (F) {
        (l = F),
          d !== null && (d.fixedFoveation = F),
          f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = F);
      });
    let $ = null;
    function Y(F, ne) {
      if (((h = ne.getViewerPose(c || a)), (m = ne), h !== null)) {
        const ie = h.views;
        f !== null &&
          (e.setRenderTargetFramebuffer(p, f.framebuffer),
          e.setRenderTarget(p));
        let me = !1;
        ie.length !== P.cameras.length && ((P.cameras.length = 0), (me = !0));
        for (let ge = 0; ge < ie.length; ge++) {
          const Me = ie[ge];
          let Ne = null;
          if (f !== null) Ne = f.getViewport(Me);
          else {
            const Ze = u.getViewSubImage(d, Me);
            (Ne = Ze.viewport),
              ge === 0 &&
                (e.setRenderTargetTextures(
                  p,
                  Ze.colorTexture,
                  d.ignoreDepthValues ? void 0 : Ze.depthStencilTexture
                ),
                e.setRenderTarget(p));
          }
          let Ce = R[ge];
          Ce === void 0 &&
            ((Ce = new Et()),
            Ce.layers.enable(ge),
            (Ce.viewport = new tt()),
            (R[ge] = Ce)),
            Ce.matrix.fromArray(Me.transform.matrix),
            Ce.matrix.decompose(Ce.position, Ce.quaternion, Ce.scale),
            Ce.projectionMatrix.fromArray(Me.projectionMatrix),
            Ce.projectionMatrixInverse.copy(Ce.projectionMatrix).invert(),
            Ce.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
            ge === 0 &&
              (P.matrix.copy(Ce.matrix),
              P.matrix.decompose(P.position, P.quaternion, P.scale)),
            me === !0 && P.cameras.push(Ce);
        }
      }
      for (let ie = 0; ie < v.length; ie++) {
        const me = x[ie],
          ge = v[ie];
        me !== null && ge !== void 0 && ge.update(me, ne, c || a);
      }
      $ && $(F, ne),
        ne.detectedPlanes &&
          n.dispatchEvent({ type: "planesdetected", data: ne }),
        (m = null);
    }
    const he = new Mf();
    he.setAnimationLoop(Y),
      (this.setAnimationLoop = function (F) {
        $ = F;
      }),
      (this.dispose = function () {});
  }
}
function Cy(r, e) {
  function t(g, p) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), p.value.copy(g.matrix);
  }
  function n(g, p) {
    p.color.getRGB(g.fogColor.value, _f(r)),
      p.isFog
        ? ((g.fogNear.value = p.near), (g.fogFar.value = p.far))
        : p.isFogExp2 && (g.fogDensity.value = p.density);
  }
  function i(g, p, v, x, y) {
    p.isMeshBasicMaterial || p.isMeshLambertMaterial
      ? s(g, p)
      : p.isMeshToonMaterial
      ? (s(g, p), u(g, p))
      : p.isMeshPhongMaterial
      ? (s(g, p), h(g, p))
      : p.isMeshStandardMaterial
      ? (s(g, p), d(g, p), p.isMeshPhysicalMaterial && f(g, p, y))
      : p.isMeshMatcapMaterial
      ? (s(g, p), m(g, p))
      : p.isMeshDepthMaterial
      ? s(g, p)
      : p.isMeshDistanceMaterial
      ? (s(g, p), _(g, p))
      : p.isMeshNormalMaterial
      ? s(g, p)
      : p.isLineBasicMaterial
      ? (a(g, p), p.isLineDashedMaterial && o(g, p))
      : p.isPointsMaterial
      ? l(g, p, v, x)
      : p.isSpriteMaterial
      ? c(g, p)
      : p.isShadowMaterial
      ? (g.color.value.copy(p.color), (g.opacity.value = p.opacity))
      : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
  }
  function s(g, p) {
    (g.opacity.value = p.opacity),
      p.color && g.diffuse.value.copy(p.color),
      p.emissive &&
        g.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform)),
      p.alphaMap &&
        ((g.alphaMap.value = p.alphaMap), t(p.alphaMap, g.alphaMapTransform)),
      p.bumpMap &&
        ((g.bumpMap.value = p.bumpMap),
        t(p.bumpMap, g.bumpMapTransform),
        (g.bumpScale.value = p.bumpScale),
        p.side === wt && (g.bumpScale.value *= -1)),
      p.normalMap &&
        ((g.normalMap.value = p.normalMap),
        t(p.normalMap, g.normalMapTransform),
        g.normalScale.value.copy(p.normalScale),
        p.side === wt && g.normalScale.value.negate()),
      p.displacementMap &&
        ((g.displacementMap.value = p.displacementMap),
        t(p.displacementMap, g.displacementMapTransform),
        (g.displacementScale.value = p.displacementScale),
        (g.displacementBias.value = p.displacementBias)),
      p.emissiveMap &&
        ((g.emissiveMap.value = p.emissiveMap),
        t(p.emissiveMap, g.emissiveMapTransform)),
      p.specularMap &&
        ((g.specularMap.value = p.specularMap),
        t(p.specularMap, g.specularMapTransform)),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
    const v = e.get(p).envMap;
    if (
      (v &&
        ((g.envMap.value = v),
        (g.flipEnvMap.value =
          v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
        (g.reflectivity.value = p.reflectivity),
        (g.ior.value = p.ior),
        (g.refractionRatio.value = p.refractionRatio)),
      p.lightMap)
    ) {
      g.lightMap.value = p.lightMap;
      const x = r.useLegacyLights === !0 ? Math.PI : 1;
      (g.lightMapIntensity.value = p.lightMapIntensity * x),
        t(p.lightMap, g.lightMapTransform);
    }
    p.aoMap &&
      ((g.aoMap.value = p.aoMap),
      (g.aoMapIntensity.value = p.aoMapIntensity),
      t(p.aoMap, g.aoMapTransform));
  }
  function a(g, p) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform));
  }
  function o(g, p) {
    (g.dashSize.value = p.dashSize),
      (g.totalSize.value = p.dashSize + p.gapSize),
      (g.scale.value = p.scale);
  }
  function l(g, p, v, x) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      (g.size.value = p.size * v),
      (g.scale.value = x * 0.5),
      p.map && ((g.map.value = p.map), t(p.map, g.uvTransform)),
      p.alphaMap &&
        ((g.alphaMap.value = p.alphaMap), t(p.alphaMap, g.alphaMapTransform)),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
  }
  function c(g, p) {
    g.diffuse.value.copy(p.color),
      (g.opacity.value = p.opacity),
      (g.rotation.value = p.rotation),
      p.map && ((g.map.value = p.map), t(p.map, g.mapTransform)),
      p.alphaMap &&
        ((g.alphaMap.value = p.alphaMap), t(p.alphaMap, g.alphaMapTransform)),
      p.alphaTest > 0 && (g.alphaTest.value = p.alphaTest);
  }
  function h(g, p) {
    g.specular.value.copy(p.specular),
      (g.shininess.value = Math.max(p.shininess, 1e-4));
  }
  function u(g, p) {
    p.gradientMap && (g.gradientMap.value = p.gradientMap);
  }
  function d(g, p) {
    (g.metalness.value = p.metalness),
      p.metalnessMap &&
        ((g.metalnessMap.value = p.metalnessMap),
        t(p.metalnessMap, g.metalnessMapTransform)),
      (g.roughness.value = p.roughness),
      p.roughnessMap &&
        ((g.roughnessMap.value = p.roughnessMap),
        t(p.roughnessMap, g.roughnessMapTransform)),
      e.get(p).envMap && (g.envMapIntensity.value = p.envMapIntensity);
  }
  function f(g, p, v) {
    (g.ior.value = p.ior),
      p.sheen > 0 &&
        (g.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        (g.sheenRoughness.value = p.sheenRoughness),
        p.sheenColorMap &&
          ((g.sheenColorMap.value = p.sheenColorMap),
          t(p.sheenColorMap, g.sheenColorMapTransform)),
        p.sheenRoughnessMap &&
          ((g.sheenRoughnessMap.value = p.sheenRoughnessMap),
          t(p.sheenRoughnessMap, g.sheenRoughnessMapTransform))),
      p.clearcoat > 0 &&
        ((g.clearcoat.value = p.clearcoat),
        (g.clearcoatRoughness.value = p.clearcoatRoughness),
        p.clearcoatMap &&
          ((g.clearcoatMap.value = p.clearcoatMap),
          t(p.clearcoatMap, g.clearcoatMapTransform)),
        p.clearcoatRoughnessMap &&
          ((g.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap),
          t(p.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap &&
          ((g.clearcoatNormalMap.value = p.clearcoatNormalMap),
          t(p.clearcoatNormalMap, g.clearcoatNormalMapTransform),
          g.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
          p.side === wt && g.clearcoatNormalScale.value.negate())),
      p.iridescence > 0 &&
        ((g.iridescence.value = p.iridescence),
        (g.iridescenceIOR.value = p.iridescenceIOR),
        (g.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0]),
        (g.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1]),
        p.iridescenceMap &&
          ((g.iridescenceMap.value = p.iridescenceMap),
          t(p.iridescenceMap, g.iridescenceMapTransform)),
        p.iridescenceThicknessMap &&
          ((g.iridescenceThicknessMap.value = p.iridescenceThicknessMap),
          t(p.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))),
      p.transmission > 0 &&
        ((g.transmission.value = p.transmission),
        (g.transmissionSamplerMap.value = v.texture),
        g.transmissionSamplerSize.value.set(v.width, v.height),
        p.transmissionMap &&
          ((g.transmissionMap.value = p.transmissionMap),
          t(p.transmissionMap, g.transmissionMapTransform)),
        (g.thickness.value = p.thickness),
        p.thicknessMap &&
          ((g.thicknessMap.value = p.thicknessMap),
          t(p.thicknessMap, g.thicknessMapTransform)),
        (g.attenuationDistance.value = p.attenuationDistance),
        g.attenuationColor.value.copy(p.attenuationColor)),
      p.anisotropy > 0 &&
        (g.anisotropyVector.value.set(
          p.anisotropy * Math.cos(p.anisotropyRotation),
          p.anisotropy * Math.sin(p.anisotropyRotation)
        ),
        p.anisotropyMap &&
          ((g.anisotropyMap.value = p.anisotropyMap),
          t(p.anisotropyMap, g.anisotropyMapTransform))),
      (g.specularIntensity.value = p.specularIntensity),
      g.specularColor.value.copy(p.specularColor),
      p.specularColorMap &&
        ((g.specularColorMap.value = p.specularColorMap),
        t(p.specularColorMap, g.specularColorMapTransform)),
      p.specularIntensityMap &&
        ((g.specularIntensityMap.value = p.specularIntensityMap),
        t(p.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function m(g, p) {
    p.matcap && (g.matcap.value = p.matcap);
  }
  function _(g, p) {
    const v = e.get(p).light;
    g.referencePosition.value.setFromMatrixPosition(v.matrixWorld),
      (g.nearDistance.value = v.shadow.camera.near),
      (g.farDistance.value = v.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function Py(r, e, t, n) {
  let i = {},
    s = {},
    a = [];
  const o = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(v, x) {
    const y = x.program;
    n.uniformBlockBinding(v, y);
  }
  function c(v, x) {
    let y = i[v.id];
    y === void 0 &&
      (m(v), (y = h(v)), (i[v.id] = y), v.addEventListener("dispose", g));
    const S = x.program;
    n.updateUBOMapping(v, S);
    const w = e.render.frame;
    s[v.id] !== w && (d(v), (s[v.id] = w));
  }
  function h(v) {
    const x = u();
    v.__bindingPointIndex = x;
    const y = r.createBuffer(),
      S = v.__size,
      w = v.usage;
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, y),
      r.bufferData(r.UNIFORM_BUFFER, S, w),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, x, y),
      y
    );
  }
  function u() {
    for (let v = 0; v < o; v++) if (a.indexOf(v) === -1) return a.push(v), v;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function d(v) {
    const x = i[v.id],
      y = v.uniforms,
      S = v.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, x);
    for (let w = 0, R = y.length; w < R; w++) {
      const P = y[w];
      if (f(P, w, S) === !0) {
        const M = P.__offset,
          A = Array.isArray(P.value) ? P.value : [P.value];
        let k = 0;
        for (let X = 0; X < A.length; X++) {
          const U = A[X],
            O = _(U);
          typeof U == "number"
            ? ((P.__data[0] = U),
              r.bufferSubData(r.UNIFORM_BUFFER, M + k, P.__data))
            : U.isMatrix3
            ? ((P.__data[0] = U.elements[0]),
              (P.__data[1] = U.elements[1]),
              (P.__data[2] = U.elements[2]),
              (P.__data[3] = U.elements[0]),
              (P.__data[4] = U.elements[3]),
              (P.__data[5] = U.elements[4]),
              (P.__data[6] = U.elements[5]),
              (P.__data[7] = U.elements[0]),
              (P.__data[8] = U.elements[6]),
              (P.__data[9] = U.elements[7]),
              (P.__data[10] = U.elements[8]),
              (P.__data[11] = U.elements[0]))
            : (U.toArray(P.__data, k),
              (k += O.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        r.bufferSubData(r.UNIFORM_BUFFER, M, P.__data);
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function f(v, x, y) {
    const S = v.value;
    if (y[x] === void 0) {
      if (typeof S == "number") y[x] = S;
      else {
        const w = Array.isArray(S) ? S : [S],
          R = [];
        for (let P = 0; P < w.length; P++) R.push(w[P].clone());
        y[x] = R;
      }
      return !0;
    } else if (typeof S == "number") {
      if (y[x] !== S) return (y[x] = S), !0;
    } else {
      const w = Array.isArray(y[x]) ? y[x] : [y[x]],
        R = Array.isArray(S) ? S : [S];
      for (let P = 0; P < w.length; P++) {
        const M = w[P];
        if (M.equals(R[P]) === !1) return M.copy(R[P]), !0;
      }
    }
    return !1;
  }
  function m(v) {
    const x = v.uniforms;
    let y = 0;
    const S = 16;
    let w = 0;
    for (let R = 0, P = x.length; R < P; R++) {
      const M = x[R],
        A = { boundary: 0, storage: 0 },
        k = Array.isArray(M.value) ? M.value : [M.value];
      for (let X = 0, U = k.length; X < U; X++) {
        const O = k[X],
          N = _(O);
        (A.boundary += N.boundary), (A.storage += N.storage);
      }
      if (
        ((M.__data = new Float32Array(
          A.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (M.__offset = y),
        R > 0)
      ) {
        w = y % S;
        const X = S - w;
        w !== 0 && X - A.boundary < 0 && ((y += S - w), (M.__offset = y));
      }
      y += A.storage;
    }
    return (
      (w = y % S), w > 0 && (y += S - w), (v.__size = y), (v.__cache = {}), this
    );
  }
  function _(v) {
    const x = { boundary: 0, storage: 0 };
    return (
      typeof v == "number"
        ? ((x.boundary = 4), (x.storage = 4))
        : v.isVector2
        ? ((x.boundary = 8), (x.storage = 8))
        : v.isVector3 || v.isColor
        ? ((x.boundary = 16), (x.storage = 12))
        : v.isVector4
        ? ((x.boundary = 16), (x.storage = 16))
        : v.isMatrix3
        ? ((x.boundary = 48), (x.storage = 48))
        : v.isMatrix4
        ? ((x.boundary = 64), (x.storage = 64))
        : v.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            v
          ),
      x
    );
  }
  function g(v) {
    const x = v.target;
    x.removeEventListener("dispose", g);
    const y = a.indexOf(x.__bindingPointIndex);
    a.splice(y, 1), r.deleteBuffer(i[x.id]), delete i[x.id], delete s[x.id];
  }
  function p() {
    for (const v in i) r.deleteBuffer(i[v]);
    (a = []), (i = {}), (s = {});
  }
  return { bind: l, update: c, dispose: p };
}
function Ly() {
  const r = Ir("canvas");
  return (r.style.display = "block"), r;
}
class Hc {
  constructor(e = {}) {
    const {
      canvas: t = Ly(),
      context: n = null,
      depth: i = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: u = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let d;
    n !== null ? (d = n.getContextAttributes().alpha) : (d = a);
    const f = new Uint32Array(4),
      m = new Int32Array(4);
    let _ = null,
      g = null;
    const p = [],
      v = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = Oe),
      (this.useLegacyLights = !0),
      (this.toneMapping = Pn),
      (this.toneMappingExposure = 1);
    const x = this;
    let y = !1,
      S = 0,
      w = 0,
      R = null,
      P = -1,
      M = null;
    const A = new tt(),
      k = new tt();
    let X = null;
    const U = new de(0);
    let O = 0,
      N = t.width,
      Z = t.height,
      B = 1,
      G = null,
      $ = null;
    const Y = new tt(0, 0, N, Z),
      he = new tt(0, 0, N, Z);
    let F = !1;
    const ne = new So();
    let ie = !1,
      me = !1,
      ge = null;
    const Me = new Ue(),
      Ne = new K(),
      Ce = new b(),
      Ze = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Pe() {
      return R === null ? B : 1;
    }
    let I = n;
    function le(T, H) {
      for (let j = 0; j < T.length; j++) {
        const z = T[j],
          J = t.getContext(z, H);
        if (J !== null) return J;
      }
      return null;
    }
    try {
      const T = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: u,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${po}`),
        t.addEventListener("webglcontextlost", pe, !1),
        t.addEventListener("webglcontextrestored", V, !1),
        t.addEventListener("webglcontextcreationerror", ue, !1),
        I === null)
      ) {
        const H = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (x.isWebGL1Renderer === !0 && H.shift(), (I = le(H, T)), I === null)
        )
          throw le(H)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      I instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        I.getShaderPrecisionFormat === void 0 &&
          (I.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (T) {
      throw (console.error("THREE.WebGLRenderer: " + T.message), T);
    }
    let Q,
      oe,
      ee,
      we,
      _e,
      xe,
      Le,
      ze,
      it,
      C,
      E,
      q,
      ae,
      se,
      L,
      te,
      re,
      W,
      Se,
      Re,
      Ee,
      be,
      ve,
      Ie;
    function Ye() {
      (Q = new q_(I)),
        (oe = new H_(I, Q, e)),
        Q.init(oe),
        (be = new Af(I, Q, oe)),
        (ee = new Ey(I, Q, oe)),
        (we = new K_(I)),
        (_e = new fy()),
        (xe = new Ay(I, Q, ee, _e, oe, be, we)),
        (Le = new V_(x)),
        (ze = new Y_(x)),
        (it = new lg(I, oe)),
        (ve = new z_(I, Q, it, oe)),
        (C = new Z_(I, it, we, ve)),
        (E = new ex(I, C, it, we)),
        (Se = new Q_(I, oe, xe)),
        (te = new G_(_e)),
        (q = new dy(x, Le, ze, Q, oe, ve, te)),
        (ae = new Cy(x, _e)),
        (se = new my()),
        (L = new My(Q, oe)),
        (W = new B_(x, Le, ze, ee, E, d, l)),
        (re = new wy(x, E, oe)),
        (Ie = new Py(I, we, oe, ee)),
        (Re = new k_(I, Q, we, oe)),
        (Ee = new $_(I, Q, we, oe)),
        (we.programs = q.programs),
        (x.capabilities = oe),
        (x.extensions = Q),
        (x.properties = _e),
        (x.renderLists = se),
        (x.shadowMap = re),
        (x.state = ee),
        (x.info = we);
    }
    Ye();
    const D = new Ry(x, I);
    (this.xr = D),
      (this.getContext = function () {
        return I;
      }),
      (this.getContextAttributes = function () {
        return I.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const T = Q.get("WEBGL_lose_context");
        T && T.loseContext();
      }),
      (this.forceContextRestore = function () {
        const T = Q.get("WEBGL_lose_context");
        T && T.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return B;
      }),
      (this.setPixelRatio = function (T) {
        T !== void 0 && ((B = T), this.setSize(N, Z, !1));
      }),
      (this.getSize = function (T) {
        return T.set(N, Z);
      }),
      (this.setSize = function (T, H, j = !0) {
        if (D.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (N = T),
          (Z = H),
          (t.width = Math.floor(T * B)),
          (t.height = Math.floor(H * B)),
          j === !0 && ((t.style.width = T + "px"), (t.style.height = H + "px")),
          this.setViewport(0, 0, T, H);
      }),
      (this.getDrawingBufferSize = function (T) {
        return T.set(N * B, Z * B).floor();
      }),
      (this.setDrawingBufferSize = function (T, H, j) {
        (N = T),
          (Z = H),
          (B = j),
          (t.width = Math.floor(T * j)),
          (t.height = Math.floor(H * j)),
          this.setViewport(0, 0, T, H);
      }),
      (this.getCurrentViewport = function (T) {
        return T.copy(A);
      }),
      (this.getViewport = function (T) {
        return T.copy(Y);
      }),
      (this.setViewport = function (T, H, j, z) {
        T.isVector4 ? Y.set(T.x, T.y, T.z, T.w) : Y.set(T, H, j, z),
          ee.viewport(A.copy(Y).multiplyScalar(B).floor());
      }),
      (this.getScissor = function (T) {
        return T.copy(he);
      }),
      (this.setScissor = function (T, H, j, z) {
        T.isVector4 ? he.set(T.x, T.y, T.z, T.w) : he.set(T, H, j, z),
          ee.scissor(k.copy(he).multiplyScalar(B).floor());
      }),
      (this.getScissorTest = function () {
        return F;
      }),
      (this.setScissorTest = function (T) {
        ee.setScissorTest((F = T));
      }),
      (this.setOpaqueSort = function (T) {
        G = T;
      }),
      (this.setTransparentSort = function (T) {
        $ = T;
      }),
      (this.getClearColor = function (T) {
        return T.copy(W.getClearColor());
      }),
      (this.setClearColor = function () {
        W.setClearColor.apply(W, arguments);
      }),
      (this.getClearAlpha = function () {
        return W.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        W.setClearAlpha.apply(W, arguments);
      }),
      (this.clear = function (T = !0, H = !0, j = !0) {
        let z = 0;
        if (T) {
          let J = !1;
          if (R !== null) {
            const Ae = R.texture.format;
            J = Ae === Cc || Ae === Rc || Ae === Tc;
          }
          if (J) {
            const Ae = R.texture.type,
              De =
                Ae === _n ||
                Ae === Zn ||
                Ae === _o ||
                Ae === mi ||
                Ae === wc ||
                Ae === Ec,
              Fe = W.getClearColor(),
              Be = W.getClearAlpha(),
              $e = Fe.r,
              ke = Fe.g,
              Ge = Fe.b,
              rt = _e.get(R).__webglFramebuffer;
            De
              ? ((f[0] = $e),
                (f[1] = ke),
                (f[2] = Ge),
                (f[3] = Be),
                I.clearBufferuiv(I.COLOR, rt, f))
              : ((m[0] = $e),
                (m[1] = ke),
                (m[2] = Ge),
                (m[3] = Be),
                I.clearBufferiv(I.COLOR, rt, m));
          } else z |= I.COLOR_BUFFER_BIT;
        }
        H && (z |= I.DEPTH_BUFFER_BIT),
          j && (z |= I.STENCIL_BUFFER_BIT),
          I.clear(z);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", pe, !1),
          t.removeEventListener("webglcontextrestored", V, !1),
          t.removeEventListener("webglcontextcreationerror", ue, !1),
          se.dispose(),
          L.dispose(),
          _e.dispose(),
          Le.dispose(),
          ze.dispose(),
          E.dispose(),
          ve.dispose(),
          Ie.dispose(),
          q.dispose(),
          D.dispose(),
          D.removeEventListener("sessionstart", ft),
          D.removeEventListener("sessionend", wn),
          ge && (ge.dispose(), (ge = null)),
          Bt.stop();
      });
    function pe(T) {
      T.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (y = !0);
    }
    function V() {
      console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
      const T = we.autoReset,
        H = re.enabled,
        j = re.autoUpdate,
        z = re.needsUpdate,
        J = re.type;
      Ye(),
        (we.autoReset = T),
        (re.enabled = H),
        (re.autoUpdate = j),
        (re.needsUpdate = z),
        (re.type = J);
    }
    function ue(T) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        T.statusMessage
      );
    }
    function ye(T) {
      const H = T.target;
      H.removeEventListener("dispose", ye), Qe(H);
    }
    function Qe(T) {
      dt(T), _e.remove(T);
    }
    function dt(T) {
      const H = _e.get(T).programs;
      H !== void 0 &&
        (H.forEach(function (j) {
          q.releaseProgram(j);
        }),
        T.isShaderMaterial && q.releaseShaderCache(T));
    }
    (this.renderBufferDirect = function (T, H, j, z, J, Ae) {
      H === null && (H = Ze);
      const De = J.isMesh && J.matrixWorld.determinant() < 0,
        Fe = Dp(T, H, j, z, J);
      ee.setMaterial(z, De);
      let Be = j.index,
        $e = 1;
      z.wireframe === !0 && ((Be = C.getWireframeAttribute(j)), ($e = 2));
      const ke = j.drawRange,
        Ge = j.attributes.position;
      let rt = ke.start * $e,
        xt = (ke.start + ke.count) * $e;
      Ae !== null &&
        ((rt = Math.max(rt, Ae.start * $e)),
        (xt = Math.min(xt, (Ae.start + Ae.count) * $e))),
        Be !== null
          ? ((rt = Math.max(rt, 0)), (xt = Math.min(xt, Be.count)))
          : Ge != null &&
            ((rt = Math.max(rt, 0)), (xt = Math.min(xt, Ge.count)));
      const un = xt - rt;
      if (un < 0 || un === 1 / 0) return;
      ve.setup(J, z, Fe, j, Be);
      let Fn,
        Mt = Re;
      if (
        (Be !== null && ((Fn = it.get(Be)), (Mt = Ee), Mt.setIndex(Fn)),
        J.isMesh)
      )
        z.wireframe === !0
          ? (ee.setLineWidth(z.wireframeLinewidth * Pe()), Mt.setMode(I.LINES))
          : Mt.setMode(I.TRIANGLES);
      else if (J.isLine) {
        let je = z.linewidth;
        je === void 0 && (je = 1),
          ee.setLineWidth(je * Pe()),
          J.isLineSegments
            ? Mt.setMode(I.LINES)
            : J.isLineLoop
            ? Mt.setMode(I.LINE_LOOP)
            : Mt.setMode(I.LINE_STRIP);
      } else
        J.isPoints
          ? Mt.setMode(I.POINTS)
          : J.isSprite && Mt.setMode(I.TRIANGLES);
      if (J.isInstancedMesh) Mt.renderInstances(rt, un, J.count);
      else if (j.isInstancedBufferGeometry) {
        const je = j._maxInstanceCount !== void 0 ? j._maxInstanceCount : 1 / 0,
          No = Math.min(j.instanceCount, je);
        Mt.renderInstances(rt, un, No);
      } else Mt.render(rt, un);
    }),
      (this.compile = function (T, H) {
        function j(z, J, Ae) {
          z.transparent === !0 && z.side === Gt && z.forceSinglePass === !1
            ? ((z.side = wt),
              (z.needsUpdate = !0),
              aa(z, J, Ae),
              (z.side = Zt),
              (z.needsUpdate = !0),
              aa(z, J, Ae),
              (z.side = Gt))
            : aa(z, J, Ae);
        }
        (g = L.get(T)),
          g.init(),
          v.push(g),
          T.traverseVisible(function (z) {
            z.isLight &&
              z.layers.test(H.layers) &&
              (g.pushLight(z), z.castShadow && g.pushShadow(z));
          }),
          g.setupLights(x.useLegacyLights),
          T.traverse(function (z) {
            const J = z.material;
            if (J)
              if (Array.isArray(J))
                for (let Ae = 0; Ae < J.length; Ae++) {
                  const De = J[Ae];
                  j(De, T, z);
                }
              else j(J, T, z);
          }),
          v.pop(),
          (g = null);
      });
    let vt = null;
    function Ai(T) {
      vt && vt(T);
    }
    function ft() {
      Bt.stop();
    }
    function wn() {
      Bt.start();
    }
    const Bt = new Mf();
    Bt.setAnimationLoop(Ai),
      typeof self < "u" && Bt.setContext(self),
      (this.setAnimationLoop = function (T) {
        (vt = T), D.setAnimationLoop(T), T === null ? Bt.stop() : Bt.start();
      }),
      D.addEventListener("sessionstart", ft),
      D.addEventListener("sessionend", wn),
      (this.render = function (T, H) {
        if (H !== void 0 && H.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (y === !0) return;
        T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(),
          H.parent === null &&
            H.matrixWorldAutoUpdate === !0 &&
            H.updateMatrixWorld(),
          D.enabled === !0 &&
            D.isPresenting === !0 &&
            (H = D.updateCameraXR(H)),
          T.isScene === !0 && T.onBeforeRender(x, T, H, R),
          (g = L.get(T, v.length)),
          g.init(),
          v.push(g),
          Me.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse),
          ne.setFromProjectionMatrix(Me),
          (me = this.localClippingEnabled),
          (ie = te.init(this.clippingPlanes, me)),
          (_ = se.get(T, p.length)),
          _.init(),
          p.push(_),
          yh(T, H, 0, x.sortObjects),
          _.finish(),
          x.sortObjects === !0 && _.sort(G, $),
          ie === !0 && te.beginShadows();
        const j = g.state.shadowsArray;
        if (
          (re.render(j, T, H),
          ie === !0 && te.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          this.info.render.frame++,
          W.render(_, T),
          g.setupLights(x.useLegacyLights),
          H.isArrayCamera)
        ) {
          const z = H.cameras;
          for (let J = 0, Ae = z.length; J < Ae; J++) {
            const De = z[J];
            vh(_, T, De, De.viewport);
          }
        } else vh(_, T, H);
        R !== null &&
          (xe.updateMultisampleRenderTarget(R), xe.updateRenderTargetMipmap(R)),
          T.isScene === !0 && T.onAfterRender(x, T, H),
          ve.resetDefaultState(),
          (P = -1),
          (M = null),
          v.pop(),
          v.length > 0 ? (g = v[v.length - 1]) : (g = null),
          p.pop(),
          p.length > 0 ? (_ = p[p.length - 1]) : (_ = null);
      });
    function yh(T, H, j, z) {
      if (T.visible === !1) return;
      if (T.layers.test(H.layers)) {
        if (T.isGroup) j = T.renderOrder;
        else if (T.isLOD) T.autoUpdate === !0 && T.update(H);
        else if (T.isLight) g.pushLight(T), T.castShadow && g.pushShadow(T);
        else if (T.isSprite) {
          if (!T.frustumCulled || ne.intersectsSprite(T)) {
            z && Ce.setFromMatrixPosition(T.matrixWorld).applyMatrix4(Me);
            const De = E.update(T),
              Fe = T.material;
            Fe.visible && _.push(T, De, Fe, j, Ce.z, null);
          }
        } else if (
          (T.isMesh || T.isLine || T.isPoints) &&
          (!T.frustumCulled || ne.intersectsObject(T))
        ) {
          T.isSkinnedMesh &&
            T.skeleton.frame !== we.render.frame &&
            (T.skeleton.update(), (T.skeleton.frame = we.render.frame));
          const De = E.update(T),
            Fe = T.material;
          if (
            (z &&
              (T.boundingSphere !== void 0
                ? (T.boundingSphere === null && T.computeBoundingSphere(),
                  Ce.copy(T.boundingSphere.center))
                : (De.boundingSphere === null && De.computeBoundingSphere(),
                  Ce.copy(De.boundingSphere.center)),
              Ce.applyMatrix4(T.matrixWorld).applyMatrix4(Me)),
            Array.isArray(Fe))
          ) {
            const Be = De.groups;
            for (let $e = 0, ke = Be.length; $e < ke; $e++) {
              const Ge = Be[$e],
                rt = Fe[Ge.materialIndex];
              rt && rt.visible && _.push(T, De, rt, j, Ce.z, Ge);
            }
          } else Fe.visible && _.push(T, De, Fe, j, Ce.z, null);
        }
      }
      const Ae = T.children;
      for (let De = 0, Fe = Ae.length; De < Fe; De++) yh(Ae[De], H, j, z);
    }
    function vh(T, H, j, z) {
      const J = T.opaque,
        Ae = T.transmissive,
        De = T.transparent;
      g.setupLightsView(j),
        ie === !0 && te.setGlobalState(x.clippingPlanes, j),
        Ae.length > 0 && Ip(J, Ae, H, j),
        z && ee.viewport(A.copy(z)),
        J.length > 0 && ra(J, H, j),
        Ae.length > 0 && ra(Ae, H, j),
        De.length > 0 && ra(De, H, j),
        ee.buffers.depth.setTest(!0),
        ee.buffers.depth.setMask(!0),
        ee.buffers.color.setMask(!0),
        ee.setPolygonOffset(!1);
    }
    function Ip(T, H, j, z) {
      const J = oe.isWebGL2;
      ge === null &&
        (ge = new yn(1, 1, {
          generateMipmaps: !0,
          type: Q.has("EXT_color_buffer_half_float") ? Bs : _n,
          minFilter: Dn,
          samples: J && o === !0 ? 4 : 0,
        })),
        x.getDrawingBufferSize(Ne),
        J ? ge.setSize(Ne.x, Ne.y) : ge.setSize(ho(Ne.x), ho(Ne.y));
      const Ae = x.getRenderTarget();
      x.setRenderTarget(ge),
        x.getClearColor(U),
        (O = x.getClearAlpha()),
        O < 1 && x.setClearColor(16777215, 0.5),
        x.clear();
      const De = x.toneMapping;
      (x.toneMapping = Pn),
        ra(T, j, z),
        xe.updateMultisampleRenderTarget(ge),
        xe.updateRenderTargetMipmap(ge);
      let Fe = !1;
      for (let Be = 0, $e = H.length; Be < $e; Be++) {
        const ke = H[Be],
          Ge = ke.object,
          rt = ke.geometry,
          xt = ke.material,
          un = ke.group;
        if (xt.side === Gt && Ge.layers.test(z.layers)) {
          const Fn = xt.side;
          (xt.side = wt),
            (xt.needsUpdate = !0),
            Mh(Ge, j, z, rt, xt, un),
            (xt.side = Fn),
            (xt.needsUpdate = !0),
            (Fe = !0);
        }
      }
      Fe === !0 &&
        (xe.updateMultisampleRenderTarget(ge), xe.updateRenderTargetMipmap(ge)),
        x.setRenderTarget(Ae),
        x.setClearColor(U, O),
        (x.toneMapping = De);
    }
    function ra(T, H, j) {
      const z = H.isScene === !0 ? H.overrideMaterial : null;
      for (let J = 0, Ae = T.length; J < Ae; J++) {
        const De = T[J],
          Fe = De.object,
          Be = De.geometry,
          $e = z === null ? De.material : z,
          ke = De.group;
        Fe.layers.test(j.layers) && Mh(Fe, H, j, Be, $e, ke);
      }
    }
    function Mh(T, H, j, z, J, Ae) {
      T.onBeforeRender(x, H, j, z, J, Ae),
        T.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, T.matrixWorld),
        T.normalMatrix.getNormalMatrix(T.modelViewMatrix),
        J.onBeforeRender(x, H, j, z, T, Ae),
        J.transparent === !0 && J.side === Gt && J.forceSinglePass === !1
          ? ((J.side = wt),
            (J.needsUpdate = !0),
            x.renderBufferDirect(j, H, z, J, T, Ae),
            (J.side = Zt),
            (J.needsUpdate = !0),
            x.renderBufferDirect(j, H, z, J, T, Ae),
            (J.side = Gt))
          : x.renderBufferDirect(j, H, z, J, T, Ae),
        T.onAfterRender(x, H, j, z, J, Ae);
    }
    function aa(T, H, j) {
      H.isScene !== !0 && (H = Ze);
      const z = _e.get(T),
        J = g.state.lights,
        Ae = g.state.shadowsArray,
        De = J.state.version,
        Fe = q.getParameters(T, J.state, Ae, H, j),
        Be = q.getProgramCacheKey(Fe);
      let $e = z.programs;
      (z.environment = T.isMeshStandardMaterial ? H.environment : null),
        (z.fog = H.fog),
        (z.envMap = (T.isMeshStandardMaterial ? ze : Le).get(
          T.envMap || z.environment
        )),
        $e === void 0 &&
          (T.addEventListener("dispose", ye),
          ($e = new Map()),
          (z.programs = $e));
      let ke = $e.get(Be);
      if (ke !== void 0) {
        if (z.currentProgram === ke && z.lightsStateVersion === De)
          return Sh(T, Fe), ke;
      } else
        (Fe.uniforms = q.getUniforms(T)),
          T.onBuild(j, Fe, x),
          T.onBeforeCompile(Fe, x),
          (ke = q.acquireProgram(Fe, Be)),
          $e.set(Be, ke),
          (z.uniforms = Fe.uniforms);
      const Ge = z.uniforms;
      ((!T.isShaderMaterial && !T.isRawShaderMaterial) || T.clipping === !0) &&
        (Ge.clippingPlanes = te.uniform),
        Sh(T, Fe),
        (z.needsLights = Np(T)),
        (z.lightsStateVersion = De),
        z.needsLights &&
          ((Ge.ambientLightColor.value = J.state.ambient),
          (Ge.lightProbe.value = J.state.probe),
          (Ge.directionalLights.value = J.state.directional),
          (Ge.directionalLightShadows.value = J.state.directionalShadow),
          (Ge.spotLights.value = J.state.spot),
          (Ge.spotLightShadows.value = J.state.spotShadow),
          (Ge.rectAreaLights.value = J.state.rectArea),
          (Ge.ltc_1.value = J.state.rectAreaLTC1),
          (Ge.ltc_2.value = J.state.rectAreaLTC2),
          (Ge.pointLights.value = J.state.point),
          (Ge.pointLightShadows.value = J.state.pointShadow),
          (Ge.hemisphereLights.value = J.state.hemi),
          (Ge.directionalShadowMap.value = J.state.directionalShadowMap),
          (Ge.directionalShadowMatrix.value = J.state.directionalShadowMatrix),
          (Ge.spotShadowMap.value = J.state.spotShadowMap),
          (Ge.spotLightMatrix.value = J.state.spotLightMatrix),
          (Ge.spotLightMap.value = J.state.spotLightMap),
          (Ge.pointShadowMap.value = J.state.pointShadowMap),
          (Ge.pointShadowMatrix.value = J.state.pointShadowMatrix));
      const rt = ke.getUniforms(),
        xt = ro.seqWithValue(rt.seq, Ge);
      return (z.currentProgram = ke), (z.uniformsList = xt), ke;
    }
    function Sh(T, H) {
      const j = _e.get(T);
      (j.outputColorSpace = H.outputColorSpace),
        (j.instancing = H.instancing),
        (j.skinning = H.skinning),
        (j.morphTargets = H.morphTargets),
        (j.morphNormals = H.morphNormals),
        (j.morphColors = H.morphColors),
        (j.morphTargetsCount = H.morphTargetsCount),
        (j.numClippingPlanes = H.numClippingPlanes),
        (j.numIntersection = H.numClipIntersection),
        (j.vertexAlphas = H.vertexAlphas),
        (j.vertexTangents = H.vertexTangents),
        (j.toneMapping = H.toneMapping);
    }
    function Dp(T, H, j, z, J) {
      H.isScene !== !0 && (H = Ze), xe.resetTextureUnits();
      const Ae = H.fog,
        De = z.isMeshStandardMaterial ? H.environment : null,
        Fe =
          R === null
            ? x.outputColorSpace
            : R.isXRRenderTarget === !0
            ? R.texture.colorSpace
            : xn,
        Be = (z.isMeshStandardMaterial ? ze : Le).get(z.envMap || De),
        $e =
          z.vertexColors === !0 &&
          !!j.attributes.color &&
          j.attributes.color.itemSize === 4,
        ke = !!j.attributes.tangent && (!!z.normalMap || z.anisotropy > 0),
        Ge = !!j.morphAttributes.position,
        rt = !!j.morphAttributes.normal,
        xt = !!j.morphAttributes.color,
        un = z.toneMapped ? x.toneMapping : Pn,
        Fn =
          j.morphAttributes.position ||
          j.morphAttributes.normal ||
          j.morphAttributes.color,
        Mt = Fn !== void 0 ? Fn.length : 0,
        je = _e.get(z),
        No = g.state.lights;
      if (ie === !0 && (me === !0 || T !== M)) {
        const Kt = T === M && z.id === P;
        te.setState(z, T, Kt);
      }
      let Ct = !1;
      z.version === je.__version
        ? ((je.needsLights && je.lightsStateVersion !== No.state.version) ||
            je.outputColorSpace !== Fe ||
            (J.isInstancedMesh && je.instancing === !1) ||
            (!J.isInstancedMesh && je.instancing === !0) ||
            (J.isSkinnedMesh && je.skinning === !1) ||
            (!J.isSkinnedMesh && je.skinning === !0) ||
            je.envMap !== Be ||
            (z.fog === !0 && je.fog !== Ae) ||
            (je.numClippingPlanes !== void 0 &&
              (je.numClippingPlanes !== te.numPlanes ||
                je.numIntersection !== te.numIntersection)) ||
            je.vertexAlphas !== $e ||
            je.vertexTangents !== ke ||
            je.morphTargets !== Ge ||
            je.morphNormals !== rt ||
            je.morphColors !== xt ||
            je.toneMapping !== un ||
            (oe.isWebGL2 === !0 && je.morphTargetsCount !== Mt)) &&
          (Ct = !0)
        : ((Ct = !0), (je.__version = z.version));
      let Ti = je.currentProgram;
      Ct === !0 && (Ti = aa(z, H, J));
      let bh = !1,
        tr = !1,
        Oo = !1;
      const zt = Ti.getUniforms(),
        Ri = je.uniforms;
      if (
        (ee.useProgram(Ti.program) && ((bh = !0), (tr = !0), (Oo = !0)),
        z.id !== P && ((P = z.id), (tr = !0)),
        bh || M !== T)
      ) {
        if (
          (zt.setValue(I, "projectionMatrix", T.projectionMatrix),
          oe.logarithmicDepthBuffer &&
            zt.setValue(
              I,
              "logDepthBufFC",
              2 / (Math.log(T.far + 1) / Math.LN2)
            ),
          M !== T && ((M = T), (tr = !0), (Oo = !0)),
          z.isShaderMaterial ||
            z.isMeshPhongMaterial ||
            z.isMeshToonMaterial ||
            z.isMeshStandardMaterial ||
            z.envMap)
        ) {
          const Kt = zt.map.cameraPosition;
          Kt !== void 0 &&
            Kt.setValue(I, Ce.setFromMatrixPosition(T.matrixWorld));
        }
        (z.isMeshPhongMaterial ||
          z.isMeshToonMaterial ||
          z.isMeshLambertMaterial ||
          z.isMeshBasicMaterial ||
          z.isMeshStandardMaterial ||
          z.isShaderMaterial) &&
          zt.setValue(I, "isOrthographic", T.isOrthographicCamera === !0),
          (z.isMeshPhongMaterial ||
            z.isMeshToonMaterial ||
            z.isMeshLambertMaterial ||
            z.isMeshBasicMaterial ||
            z.isMeshStandardMaterial ||
            z.isShaderMaterial ||
            z.isShadowMaterial ||
            J.isSkinnedMesh) &&
            zt.setValue(I, "viewMatrix", T.matrixWorldInverse);
      }
      if (J.isSkinnedMesh) {
        zt.setOptional(I, J, "bindMatrix"),
          zt.setOptional(I, J, "bindMatrixInverse");
        const Kt = J.skeleton;
        Kt &&
          (oe.floatVertexTextures
            ? (Kt.boneTexture === null && Kt.computeBoneTexture(),
              zt.setValue(I, "boneTexture", Kt.boneTexture, xe),
              zt.setValue(I, "boneTextureSize", Kt.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const Fo = j.morphAttributes;
      if (
        ((Fo.position !== void 0 ||
          Fo.normal !== void 0 ||
          (Fo.color !== void 0 && oe.isWebGL2 === !0)) &&
          Se.update(J, j, Ti),
        (tr || je.receiveShadow !== J.receiveShadow) &&
          ((je.receiveShadow = J.receiveShadow),
          zt.setValue(I, "receiveShadow", J.receiveShadow)),
        z.isMeshGouraudMaterial &&
          z.envMap !== null &&
          ((Ri.envMap.value = Be),
          (Ri.flipEnvMap.value =
            Be.isCubeTexture && Be.isRenderTargetTexture === !1 ? -1 : 1)),
        tr &&
          (zt.setValue(I, "toneMappingExposure", x.toneMappingExposure),
          je.needsLights && Up(Ri, Oo),
          Ae && z.fog === !0 && ae.refreshFogUniforms(Ri, Ae),
          ae.refreshMaterialUniforms(Ri, z, B, Z, ge),
          ro.upload(I, je.uniformsList, Ri, xe)),
        z.isShaderMaterial &&
          z.uniformsNeedUpdate === !0 &&
          (ro.upload(I, je.uniformsList, Ri, xe), (z.uniformsNeedUpdate = !1)),
        z.isSpriteMaterial && zt.setValue(I, "center", J.center),
        zt.setValue(I, "modelViewMatrix", J.modelViewMatrix),
        zt.setValue(I, "normalMatrix", J.normalMatrix),
        zt.setValue(I, "modelMatrix", J.matrixWorld),
        z.isShaderMaterial || z.isRawShaderMaterial)
      ) {
        const Kt = z.uniformsGroups;
        for (let Bo = 0, Op = Kt.length; Bo < Op; Bo++)
          if (oe.isWebGL2) {
            const wh = Kt[Bo];
            Ie.update(wh, Ti), Ie.bind(wh, Ti);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return Ti;
    }
    function Up(T, H) {
      (T.ambientLightColor.needsUpdate = H),
        (T.lightProbe.needsUpdate = H),
        (T.directionalLights.needsUpdate = H),
        (T.directionalLightShadows.needsUpdate = H),
        (T.pointLights.needsUpdate = H),
        (T.pointLightShadows.needsUpdate = H),
        (T.spotLights.needsUpdate = H),
        (T.spotLightShadows.needsUpdate = H),
        (T.rectAreaLights.needsUpdate = H),
        (T.hemisphereLights.needsUpdate = H);
    }
    function Np(T) {
      return (
        T.isMeshLambertMaterial ||
        T.isMeshToonMaterial ||
        T.isMeshPhongMaterial ||
        T.isMeshStandardMaterial ||
        T.isShadowMaterial ||
        (T.isShaderMaterial && T.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return S;
    }),
      (this.getActiveMipmapLevel = function () {
        return w;
      }),
      (this.getRenderTarget = function () {
        return R;
      }),
      (this.setRenderTargetTextures = function (T, H, j) {
        (_e.get(T.texture).__webglTexture = H),
          (_e.get(T.depthTexture).__webglTexture = j);
        const z = _e.get(T);
        (z.__hasExternalTextures = !0),
          z.__hasExternalTextures &&
            ((z.__autoAllocateDepthBuffer = j === void 0),
            z.__autoAllocateDepthBuffer ||
              (Q.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (z.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (T, H) {
        const j = _e.get(T);
        (j.__webglFramebuffer = H), (j.__useDefaultFramebuffer = H === void 0);
      }),
      (this.setRenderTarget = function (T, H = 0, j = 0) {
        (R = T), (S = H), (w = j);
        let z = !0,
          J = null,
          Ae = !1,
          De = !1;
        if (T) {
          const Be = _e.get(T);
          Be.__useDefaultFramebuffer !== void 0
            ? (ee.bindFramebuffer(I.FRAMEBUFFER, null), (z = !1))
            : Be.__webglFramebuffer === void 0
            ? xe.setupRenderTarget(T)
            : Be.__hasExternalTextures &&
              xe.rebindTextures(
                T,
                _e.get(T.texture).__webglTexture,
                _e.get(T.depthTexture).__webglTexture
              );
          const $e = T.texture;
          ($e.isData3DTexture ||
            $e.isDataArrayTexture ||
            $e.isCompressedArrayTexture) &&
            (De = !0);
          const ke = _e.get(T).__webglFramebuffer;
          T.isWebGLCubeRenderTarget
            ? ((J = ke[H]), (Ae = !0))
            : oe.isWebGL2 && T.samples > 0 && xe.useMultisampledRTT(T) === !1
            ? (J = _e.get(T).__webglMultisampledFramebuffer)
            : (J = ke),
            A.copy(T.viewport),
            k.copy(T.scissor),
            (X = T.scissorTest);
        } else
          A.copy(Y).multiplyScalar(B).floor(),
            k.copy(he).multiplyScalar(B).floor(),
            (X = F);
        if (
          (ee.bindFramebuffer(I.FRAMEBUFFER, J) &&
            oe.drawBuffers &&
            z &&
            ee.drawBuffers(T, J),
          ee.viewport(A),
          ee.scissor(k),
          ee.setScissorTest(X),
          Ae)
        ) {
          const Be = _e.get(T.texture);
          I.framebufferTexture2D(
            I.FRAMEBUFFER,
            I.COLOR_ATTACHMENT0,
            I.TEXTURE_CUBE_MAP_POSITIVE_X + H,
            Be.__webglTexture,
            j
          );
        } else if (De) {
          const Be = _e.get(T.texture),
            $e = H || 0;
          I.framebufferTextureLayer(
            I.FRAMEBUFFER,
            I.COLOR_ATTACHMENT0,
            Be.__webglTexture,
            j || 0,
            $e
          );
        }
        P = -1;
      }),
      (this.readRenderTargetPixels = function (T, H, j, z, J, Ae, De) {
        if (!(T && T.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Fe = _e.get(T).__webglFramebuffer;
        if ((T.isWebGLCubeRenderTarget && De !== void 0 && (Fe = Fe[De]), Fe)) {
          ee.bindFramebuffer(I.FRAMEBUFFER, Fe);
          try {
            const Be = T.texture,
              $e = Be.format,
              ke = Be.type;
            if (
              $e !== qt &&
              be.convert($e) !==
                I.getParameter(I.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const Ge =
              ke === Bs &&
              (Q.has("EXT_color_buffer_half_float") ||
                (oe.isWebGL2 && Q.has("EXT_color_buffer_float")));
            if (
              ke !== _n &&
              be.convert(ke) !==
                I.getParameter(I.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                ke === on &&
                (oe.isWebGL2 ||
                  Q.has("OES_texture_float") ||
                  Q.has("WEBGL_color_buffer_float"))
              ) &&
              !Ge
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            H >= 0 &&
              H <= T.width - z &&
              j >= 0 &&
              j <= T.height - J &&
              I.readPixels(H, j, z, J, be.convert($e), be.convert(ke), Ae);
          } finally {
            const Be = R !== null ? _e.get(R).__webglFramebuffer : null;
            ee.bindFramebuffer(I.FRAMEBUFFER, Be);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (T, H, j = 0) {
        const z = Math.pow(2, -j),
          J = Math.floor(H.image.width * z),
          Ae = Math.floor(H.image.height * z);
        xe.setTexture2D(H, 0),
          I.copyTexSubImage2D(I.TEXTURE_2D, j, 0, 0, T.x, T.y, J, Ae),
          ee.unbindTexture();
      }),
      (this.copyTextureToTexture = function (T, H, j, z = 0) {
        const J = H.image.width,
          Ae = H.image.height,
          De = be.convert(j.format),
          Fe = be.convert(j.type);
        xe.setTexture2D(j, 0),
          I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, j.flipY),
          I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha),
          I.pixelStorei(I.UNPACK_ALIGNMENT, j.unpackAlignment),
          H.isDataTexture
            ? I.texSubImage2D(
                I.TEXTURE_2D,
                z,
                T.x,
                T.y,
                J,
                Ae,
                De,
                Fe,
                H.image.data
              )
            : H.isCompressedTexture
            ? I.compressedTexSubImage2D(
                I.TEXTURE_2D,
                z,
                T.x,
                T.y,
                H.mipmaps[0].width,
                H.mipmaps[0].height,
                De,
                H.mipmaps[0].data
              )
            : I.texSubImage2D(I.TEXTURE_2D, z, T.x, T.y, De, Fe, H.image),
          z === 0 && j.generateMipmaps && I.generateMipmap(I.TEXTURE_2D),
          ee.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (T, H, j, z, J = 0) {
        if (x.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Ae = T.max.x - T.min.x + 1,
          De = T.max.y - T.min.y + 1,
          Fe = T.max.z - T.min.z + 1,
          Be = be.convert(z.format),
          $e = be.convert(z.type);
        let ke;
        if (z.isData3DTexture) xe.setTexture3D(z, 0), (ke = I.TEXTURE_3D);
        else if (z.isDataArrayTexture)
          xe.setTexture2DArray(z, 0), (ke = I.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, z.flipY),
          I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha),
          I.pixelStorei(I.UNPACK_ALIGNMENT, z.unpackAlignment);
        const Ge = I.getParameter(I.UNPACK_ROW_LENGTH),
          rt = I.getParameter(I.UNPACK_IMAGE_HEIGHT),
          xt = I.getParameter(I.UNPACK_SKIP_PIXELS),
          un = I.getParameter(I.UNPACK_SKIP_ROWS),
          Fn = I.getParameter(I.UNPACK_SKIP_IMAGES),
          Mt = j.isCompressedTexture ? j.mipmaps[0] : j.image;
        I.pixelStorei(I.UNPACK_ROW_LENGTH, Mt.width),
          I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Mt.height),
          I.pixelStorei(I.UNPACK_SKIP_PIXELS, T.min.x),
          I.pixelStorei(I.UNPACK_SKIP_ROWS, T.min.y),
          I.pixelStorei(I.UNPACK_SKIP_IMAGES, T.min.z),
          j.isDataTexture || j.isData3DTexture
            ? I.texSubImage3D(ke, J, H.x, H.y, H.z, Ae, De, Fe, Be, $e, Mt.data)
            : j.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              I.compressedTexSubImage3D(
                ke,
                J,
                H.x,
                H.y,
                H.z,
                Ae,
                De,
                Fe,
                Be,
                Mt.data
              ))
            : I.texSubImage3D(ke, J, H.x, H.y, H.z, Ae, De, Fe, Be, $e, Mt),
          I.pixelStorei(I.UNPACK_ROW_LENGTH, Ge),
          I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, rt),
          I.pixelStorei(I.UNPACK_SKIP_PIXELS, xt),
          I.pixelStorei(I.UNPACK_SKIP_ROWS, un),
          I.pixelStorei(I.UNPACK_SKIP_IMAGES, Fn),
          J === 0 && z.generateMipmaps && I.generateMipmap(ke),
          ee.unbindTexture();
      }),
      (this.initTexture = function (T) {
        T.isCubeTexture
          ? xe.setTextureCube(T, 0)
          : T.isData3DTexture
          ? xe.setTexture3D(T, 0)
          : T.isDataArrayTexture || T.isCompressedArrayTexture
          ? xe.setTexture2DArray(T, 0)
          : xe.setTexture2D(T, 0),
          ee.unbindTexture();
      }),
      (this.resetState = function () {
        (S = 0), (w = 0), (R = null), ee.reset(), ve.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Rn;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Oe ? _i : Ic
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === _i ? Oe : xn);
  }
}
class Cf extends Hc {}
Cf.prototype.isWebGL1Renderer = !0;
class wo {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new de(e)),
      (this.density = t);
  }
  clone() {
    return new wo(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Eo {
  constructor(e, t = 1, n = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new de(e)),
      (this.near = t),
      (this.far = n);
  }
  clone() {
    return new Eo(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Gc extends qe {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class Vr {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Cr),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = en());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = en()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = en()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const kt = new b();
class Si {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      kt.fromBufferAttribute(this, t),
        kt.applyMatrix4(e),
        this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      kt.fromBufferAttribute(this, t),
        kt.applyNormalMatrix(e),
        this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      kt.fromBufferAttribute(this, t),
        kt.transformDirection(e),
        this.setXYZ(t, kt.x, kt.y, kt.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Xe(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Qt(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Xe(t, this.array)), (n = Xe(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Xe(t, this.array)),
        (n = Xe(n, this.array)),
        (i = Xe(i, this.array)),
        (s = Xe(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new nt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Si(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class Ao extends At {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let bs;
const ar = new b(),
  ws = new b(),
  Es = new b(),
  As = new K(),
  or = new K(),
  Pf = new Ue(),
  Ta = new b(),
  lr = new b(),
  Ra = new b(),
  lu = new K(),
  al = new K(),
  cu = new K();
class di extends qe {
  constructor(e) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), bs === void 0)
    ) {
      bs = new He();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new Vr(t, 5);
      bs.setIndex([0, 1, 2, 0, 2, 3]),
        bs.setAttribute("position", new Si(n, 3, 0, !1)),
        bs.setAttribute("uv", new Si(n, 2, 3, !1));
    }
    (this.geometry = bs),
      (this.material = e !== void 0 ? e : new Ao()),
      (this.center = new K(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      ws.setFromMatrixScale(this.matrixWorld),
      Pf.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Es.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        ws.multiplyScalar(-Es.z);
    const n = this.material.rotation;
    let i, s;
    n !== 0 && ((s = Math.cos(n)), (i = Math.sin(n)));
    const a = this.center;
    Ca(Ta.set(-0.5, -0.5, 0), Es, a, ws, i, s),
      Ca(lr.set(0.5, -0.5, 0), Es, a, ws, i, s),
      Ca(Ra.set(0.5, 0.5, 0), Es, a, ws, i, s),
      lu.set(0, 0),
      al.set(1, 0),
      cu.set(1, 1);
    let o = e.ray.intersectTriangle(Ta, lr, Ra, !1, ar);
    if (
      o === null &&
      (Ca(lr.set(-0.5, 0.5, 0), Es, a, ws, i, s),
      al.set(0, 1),
      (o = e.ray.intersectTriangle(Ta, Ra, lr, !1, ar)),
      o === null)
    )
      return;
    const l = e.ray.origin.distanceTo(ar);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: ar.clone(),
        uv: Yt.getInterpolation(ar, Ta, lr, Ra, lu, al, cu, new K()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Ca(r, e, t, n, i, s) {
  As.subVectors(r, t).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((or.x = s * As.x - i * As.y), (or.y = i * As.x + s * As.y))
      : or.copy(As),
    r.copy(e),
    (r.x += or.x),
    (r.y += or.y),
    r.applyMatrix4(Pf);
}
const Pa = new b(),
  hu = new b();
class Lf extends qe {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(t < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: t, hysteresis: n, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let s = t[n].distance;
        if ((t[n].object.visible && (s -= s * t[n].hysteresis), e < s)) break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Pa.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Pa);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Pa.setFromMatrixPosition(e.matrixWorld),
        hu.setFromMatrixPosition(this.matrixWorld);
      const n = Pa.distanceTo(hu) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s; i++) {
        let a = t[i].distance;
        if ((t[i].object.visible && (a -= a * t[i].hysteresis), n >= a))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const n = this.levels;
    for (let i = 0, s = n.length; i < s; i++) {
      const a = n[i];
      t.object.levels.push({
        object: a.object.uuid,
        distance: a.distance,
        hysteresis: a.hysteresis,
      });
    }
    return t;
  }
}
const uu = new b(),
  du = new tt(),
  fu = new tt(),
  Iy = new b(),
  pu = new Ue(),
  Ts = new b(),
  ol = new hn(),
  mu = new Ue(),
  ll = new $s();
class Vc extends ce {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Ue()),
      (this.bindMatrixInverse = new Ue()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Vt()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      Ts.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Ts),
        this.boundingBox.expandByPoint(Ts);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new hn()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      Ts.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, Ts),
        this.boundingSphere.expandByPoint(Ts);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const n = this.material,
      i = this.matrixWorld;
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      ol.copy(this.boundingSphere),
      ol.applyMatrix4(i),
      e.ray.intersectsSphere(ol) !== !1 &&
        (mu.copy(i).invert(),
        ll.copy(e.ray).applyMatrix4(mu),
        !(
          this.boundingBox !== null && ll.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, ll)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new tt(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    du.fromBufferAttribute(i.attributes.skinIndex, e),
      fu.fromBufferAttribute(i.attributes.skinWeight, e),
      uu.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = fu.getComponent(s);
      if (a !== 0) {
        const o = du.getComponent(s);
        pu.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
          t.addScaledVector(Iy.copy(uu).applyMatrix4(pu), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class To extends qe {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Ns extends ht {
  constructor(e = null, t = 1, n = 1, i, s, a, o, l, c = gt, h = gt, u, d) {
    super(null, a, o, l, c, h, i, s, u, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const gu = new Ue(),
  Dy = new Ue();
class Wr {
  constructor(e = [], t = []) {
    (this.uuid = en()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new Ue());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Ue();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : Dy;
      gu.multiplyMatrices(o, t[s]), gu.toArray(n, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new Wr(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = ff(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Ns(t, e, e, qt, on);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const s = e.bones[n];
      let a = t[s];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (a = new To())),
        this.bones.push(a),
        this.boneInverses.push(new Ue().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const o = n[i];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class Gs extends nt {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Rs = new Ue(),
  _u = new Ue(),
  La = [],
  xu = new Vt(),
  Uy = new Ue(),
  cr = new ce(),
  hr = new hn();
class Wc extends ce {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Gs(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, Uy);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Vt()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Rs),
        xu.copy(e.boundingBox).applyMatrix4(Rs),
        this.boundingBox.union(xu);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new hn()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Rs),
        hr.copy(e.boundingSphere).applyMatrix4(Rs),
        this.boundingSphere.union(hr);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((cr.geometry = this.geometry),
      (cr.material = this.material),
      cr.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        hr.copy(this.boundingSphere),
        hr.applyMatrix4(n),
        e.ray.intersectsSphere(hr) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, Rs),
          _u.multiplyMatrices(n, Rs),
          (cr.matrixWorld = _u),
          cr.raycast(e, La);
        for (let a = 0, o = La.length; a < o; a++) {
          const l = La[a];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        La.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Gs(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Nt extends At {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const yu = new b(),
  vu = new b(),
  Mu = new Ue(),
  cl = new $s(),
  Ia = new hn();
class It extends qe {
  constructor(e = new He(), t = new Nt()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, s = t.count; i < s; i++)
        yu.fromBufferAttribute(t, i - 1),
          vu.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += yu.distanceTo(vu));
      e.setAttribute("lineDistance", new Te(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ia.copy(n.boundingSphere),
      Ia.applyMatrix4(i),
      (Ia.radius += s),
      e.ray.intersectsSphere(Ia) === !1)
    )
      return;
    Mu.copy(i).invert(), cl.copy(e.ray).applyMatrix4(Mu);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = new b(),
      h = new b(),
      u = new b(),
      d = new b(),
      f = this.isLineSegments ? 2 : 1,
      m = n.index,
      g = n.attributes.position;
    if (m !== null) {
      const p = Math.max(0, a.start),
        v = Math.min(m.count, a.start + a.count);
      for (let x = p, y = v - 1; x < y; x += f) {
        const S = m.getX(x),
          w = m.getX(x + 1);
        if (
          (c.fromBufferAttribute(g, S),
          h.fromBufferAttribute(g, w),
          cl.distanceSqToSegment(c, h, d, u) > l)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const P = e.ray.origin.distanceTo(d);
        P < e.near ||
          P > e.far ||
          t.push({
            distance: P,
            point: u.clone().applyMatrix4(this.matrixWorld),
            index: x,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const p = Math.max(0, a.start),
        v = Math.min(g.count, a.start + a.count);
      for (let x = p, y = v - 1; x < y; x += f) {
        if (
          (c.fromBufferAttribute(g, x),
          h.fromBufferAttribute(g, x + 1),
          cl.distanceSqToSegment(c, h, d, u) > l)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const w = e.ray.origin.distanceTo(d);
        w < e.near ||
          w > e.far ||
          t.push({
            distance: w,
            point: u.clone().applyMatrix4(this.matrixWorld),
            index: x,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
const Su = new b(),
  bu = new b();
class Mn extends It {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        Su.fromBufferAttribute(t, i),
          bu.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + Su.distanceTo(bu));
      e.setAttribute("lineDistance", new Te(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class Xc extends It {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Ro extends At {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const wu = new Ue(),
  lc = new $s(),
  Da = new hn(),
  Ua = new b();
class Yc extends qe {
  constructor(e = new He(), t = new Ro()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Da.copy(n.boundingSphere),
      Da.applyMatrix4(i),
      (Da.radius += s),
      e.ray.intersectsSphere(Da) === !1)
    )
      return;
    wu.copy(i).invert(), lc.copy(e.ray).applyMatrix4(wu);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = n.index,
      u = n.attributes.position;
    if (c !== null) {
      const d = Math.max(0, a.start),
        f = Math.min(c.count, a.start + a.count);
      for (let m = d, _ = f; m < _; m++) {
        const g = c.getX(m);
        Ua.fromBufferAttribute(u, g), Eu(Ua, g, l, i, e, t, this);
      }
    } else {
      const d = Math.max(0, a.start),
        f = Math.min(u.count, a.start + a.count);
      for (let m = d, _ = f; m < _; m++)
        Ua.fromBufferAttribute(u, m), Eu(Ua, m, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
function Eu(r, e, t, n, i, s, a) {
  const o = lc.distanceSqToPoint(r);
  if (o < t) {
    const l = new b();
    lc.closestPointToPoint(r, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a,
    });
  }
}
class Ny extends ht {
  constructor(e, t, n, i, s, a, o, l, c) {
    super(e, t, n, i, s, a, o, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = a !== void 0 ? a : ot),
      (this.magFilter = s !== void 0 ? s : ot),
      (this.generateMipmaps = !1);
    const h = this;
    function u() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(u);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(u);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class Oy extends ht {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = gt),
      (this.minFilter = gt),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class qc extends ht {
  constructor(e, t, n, i, s, a, o, l, c, h, u, d) {
    super(null, a, o, l, c, h, i, s, u, d),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: n }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class Fy extends qc {
  constructor(e, t, n, i, s, a) {
    super(e, t, n, s, a),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = Dt);
  }
}
class If extends ht {
  constructor(e, t, n, i, s, a, o, l, c) {
    super(e, t, n, i, s, a, o, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Sn {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n,
      i = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let a = 1; a <= e; a++)
      (n = this.getPoint(a / e)), (s += n.distanceTo(i)), t.push(s), (i = n);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const s = n.length;
    let a;
    t ? (a = t) : (a = e * n[s - 1]);
    let o = 0,
      l = s - 1,
      c;
    for (; o <= l; )
      if (((i = Math.floor(o + (l - o) / 2)), (c = n[i] - a), c < 0)) o = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), n[i] === a)) return i / (s - 1);
    const h = n[i],
      d = n[i + 1] - h,
      f = (a - h) / d;
    return (i + f) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const a = this.getPoint(i),
      o = this.getPoint(s),
      l = t || (a.isVector2 ? new K() : new b());
    return l.copy(o).sub(a).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new b(),
      i = [],
      s = [],
      a = [],
      o = new b(),
      l = new Ue();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      i[f] = this.getTangentAt(m, new b());
    }
    (s[0] = new b()), (a[0] = new b());
    let c = Number.MAX_VALUE;
    const h = Math.abs(i[0].x),
      u = Math.abs(i[0].y),
      d = Math.abs(i[0].z);
    h <= c && ((c = h), n.set(1, 0, 0)),
      u <= c && ((c = u), n.set(0, 1, 0)),
      d <= c && n.set(0, 0, 1),
      o.crossVectors(i[0], n).normalize(),
      s[0].crossVectors(i[0], o),
      a[0].crossVectors(i[0], s[0]);
    for (let f = 1; f <= e; f++) {
      if (
        ((s[f] = s[f - 1].clone()),
        (a[f] = a[f - 1].clone()),
        o.crossVectors(i[f - 1], i[f]),
        o.length() > Number.EPSILON)
      ) {
        o.normalize();
        const m = Math.acos(_t(i[f - 1].dot(i[f]), -1, 1));
        s[f].applyMatrix4(l.makeRotationAxis(o, m));
      }
      a[f].crossVectors(i[f], s[f]);
    }
    if (t === !0) {
      let f = Math.acos(_t(s[0].dot(s[e]), -1, 1));
      (f /= e), i[0].dot(o.crossVectors(s[0], s[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        s[m].applyMatrix4(l.makeRotationAxis(i[m], f * m)),
          a[m].crossVectors(i[m], s[m]);
    }
    return { tangents: i, normals: s, binormals: a };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class Co extends Sn {
  constructor(
    e = 0,
    t = 0,
    n = 1,
    i = 1,
    s = 0,
    a = Math.PI * 2,
    o = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = a),
      (this.aClockwise = o),
      (this.aRotation = l);
  }
  getPoint(e, t) {
    const n = t || new K(),
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (a ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !a && (s === i ? (s = -i) : (s = s - i));
    const o = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(o),
      c = this.aY + this.yRadius * Math.sin(o);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        u = Math.sin(this.aRotation),
        d = l - this.aX,
        f = c - this.aY;
      (l = d * h - f * u + this.aX), (c = d * u + f * h + this.aY);
    }
    return n.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class Df extends Co {
  constructor(e, t, n, i, s, a) {
    super(e, t, n, n, i, s, a),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function Zc() {
  let r = 0,
    e = 0,
    t = 0,
    n = 0;
  function i(s, a, o, l) {
    (r = s),
      (e = o),
      (t = -3 * s + 3 * a - 2 * o - l),
      (n = 2 * s - 2 * a + o + l);
  }
  return {
    initCatmullRom: function (s, a, o, l, c) {
      i(a, o, c * (o - s), c * (l - a));
    },
    initNonuniformCatmullRom: function (s, a, o, l, c, h, u) {
      let d = (a - s) / c - (o - s) / (c + h) + (o - a) / h,
        f = (o - a) / h - (l - a) / (h + u) + (l - o) / u;
      (d *= h), (f *= h), i(a, o, d, f);
    },
    calc: function (s) {
      const a = s * s,
        o = a * s;
      return r + e * s + t * a + n * o;
    },
  };
}
const Na = new b(),
  hl = new Zc(),
  ul = new Zc(),
  dl = new Zc();
class Uf extends Sn {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(e, t = new b()) {
    const n = t,
      i = this.points,
      s = i.length,
      a = (s - (this.closed ? 0 : 1)) * e;
    let o = Math.floor(a),
      l = a - o;
    this.closed
      ? (o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s)
      : l === 0 && o === s - 1 && ((o = s - 2), (l = 1));
    let c, h;
    this.closed || o > 0
      ? (c = i[(o - 1) % s])
      : (Na.subVectors(i[0], i[1]).add(i[0]), (c = Na));
    const u = i[o % s],
      d = i[(o + 1) % s];
    if (
      (this.closed || o + 2 < s
        ? (h = i[(o + 2) % s])
        : (Na.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (h = Na)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(c.distanceToSquared(u), f),
        _ = Math.pow(u.distanceToSquared(d), f),
        g = Math.pow(d.distanceToSquared(h), f);
      _ < 1e-4 && (_ = 1),
        m < 1e-4 && (m = _),
        g < 1e-4 && (g = _),
        hl.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, m, _, g),
        ul.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, m, _, g),
        dl.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, m, _, g);
    } else
      this.curveType === "catmullrom" &&
        (hl.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
        ul.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
        dl.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
    return n.set(hl.calc(l), ul.calc(l), dl.calc(l)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new b().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function Au(r, e, t, n, i) {
  const s = (n - e) * 0.5,
    a = (i - t) * 0.5,
    o = r * r,
    l = r * o;
  return (
    (2 * t - 2 * n + s + a) * l + (-3 * t + 3 * n - 2 * s - a) * o + s * r + t
  );
}
function By(r, e) {
  const t = 1 - r;
  return t * t * e;
}
function zy(r, e) {
  return 2 * (1 - r) * r * e;
}
function ky(r, e) {
  return r * r * e;
}
function br(r, e, t, n) {
  return By(r, e) + zy(r, t) + ky(r, n);
}
function Hy(r, e) {
  const t = 1 - r;
  return t * t * t * e;
}
function Gy(r, e) {
  const t = 1 - r;
  return 3 * t * t * r * e;
}
function Vy(r, e) {
  return 3 * (1 - r) * r * r * e;
}
function Wy(r, e) {
  return r * r * r * e;
}
function wr(r, e, t, n, i) {
  return Hy(r, e) + Gy(r, t) + Vy(r, n) + Wy(r, i);
}
class $c extends Sn {
  constructor(e = new K(), t = new K(), n = new K(), i = new K()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new K()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return n.set(wr(e, i.x, s.x, a.x, o.x), wr(e, i.y, s.y, a.y, o.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Nf extends Sn {
  constructor(e = new b(), t = new b(), n = new b(), i = new b()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(e, t = new b()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2,
      o = this.v3;
    return (
      n.set(
        wr(e, i.x, s.x, a.x, o.x),
        wr(e, i.y, s.y, a.y, o.y),
        wr(e, i.z, s.z, a.z, o.z)
      ),
      n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Po extends Sn {
  constructor(e = new K(), t = new K()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new K()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new K()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Of extends Sn {
  constructor(e = new b(), t = new b()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new b()) {
    const n = t;
    return (
      e === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)),
      n
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new b()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class Kc extends Sn {
  constructor(e = new K(), t = new K(), n = new K()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new K()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2;
    return n.set(br(e, i.x, s.x, a.x), br(e, i.y, s.y, a.y)), n;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class jc extends Sn {
  constructor(e = new b(), t = new b(), n = new b()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = n);
  }
  getPoint(e, t = new b()) {
    const n = t,
      i = this.v0,
      s = this.v1,
      a = this.v2;
    return (
      n.set(br(e, i.x, s.x, a.x), br(e, i.y, s.y, a.y), br(e, i.z, s.z, a.z)), n
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class Jc extends Sn {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new K()) {
    const n = t,
      i = this.points,
      s = (i.length - 1) * e,
      a = Math.floor(s),
      o = s - a,
      l = i[a === 0 ? a : a - 1],
      c = i[a],
      h = i[a > i.length - 2 ? i.length - 1 : a + 1],
      u = i[a > i.length - 3 ? i.length - 1 : a + 2];
    return n.set(Au(o, l.x, c.x, h.x, u.x), Au(o, l.y, c.y, h.y, u.y)), n;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new K().fromArray(i));
    }
    return this;
  }
}
var Qc = Object.freeze({
  __proto__: null,
  ArcCurve: Df,
  CatmullRomCurve3: Uf,
  CubicBezierCurve: $c,
  CubicBezierCurve3: Nf,
  EllipseCurve: Co,
  LineCurve: Po,
  LineCurve3: Of,
  QuadraticBezierCurve: Kc,
  QuadraticBezierCurve3: jc,
  SplineCurve: Jc,
});
class Ff extends Sn {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Po(t, e));
  }
  getPoint(e, t) {
    const n = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= n) {
        const a = i[s] - n,
          o = this.curves[s],
          l = o.getLength(),
          c = l === 0 ? 0 : 1 - a / l;
        return o.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (t += this.curves[n].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const a = s[i],
        o = a.isEllipseCurve
          ? e * 2
          : a.isLineCurve || a.isLineCurve3
          ? 1
          : a.isSplineCurve
          ? e * a.points.length
          : e,
        l = a.getPoints(o);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        (n && n.equals(h)) || (t.push(h), (n = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Qc[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Dr extends Ff {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new K()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new Po(this.currentPoint.clone(), new K(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const s = new Kc(this.currentPoint.clone(), new K(e, t), new K(n, i));
    return this.curves.push(s), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, s, a) {
    const o = new $c(
      this.currentPoint.clone(),
      new K(e, t),
      new K(n, i),
      new K(s, a)
    );
    return this.curves.push(o), this.currentPoint.set(s, a), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      n = new Jc(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, s, a) {
    const o = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + o, t + l, n, i, s, a), this;
  }
  absarc(e, t, n, i, s, a) {
    return this.absellipse(e, t, n, n, i, s, a), this;
  }
  ellipse(e, t, n, i, s, a, o, l) {
    const c = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, n, i, s, a, o, l), this;
  }
  absellipse(e, t, n, i, s, a, o, l) {
    const c = new Co(e, t, n, i, s, a, o, l);
    if (this.curves.length > 0) {
      const u = c.getPoint(0);
      u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Js extends He {
  constructor(
    e = [new K(0, -0.5), new K(0.5, 0), new K(0, 0.5)],
    t = 12,
    n = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: n, phiLength: i }),
      (t = Math.floor(t)),
      (i = _t(i, 0, Math.PI * 2));
    const s = [],
      a = [],
      o = [],
      l = [],
      c = [],
      h = 1 / t,
      u = new b(),
      d = new K(),
      f = new b(),
      m = new b(),
      _ = new b();
    let g = 0,
      p = 0;
    for (let v = 0; v <= e.length - 1; v++)
      switch (v) {
        case 0:
          (g = e[v + 1].x - e[v].x),
            (p = e[v + 1].y - e[v].y),
            (f.x = p * 1),
            (f.y = -g),
            (f.z = p * 0),
            _.copy(f),
            f.normalize(),
            l.push(f.x, f.y, f.z);
          break;
        case e.length - 1:
          l.push(_.x, _.y, _.z);
          break;
        default:
          (g = e[v + 1].x - e[v].x),
            (p = e[v + 1].y - e[v].y),
            (f.x = p * 1),
            (f.y = -g),
            (f.z = p * 0),
            m.copy(f),
            (f.x += _.x),
            (f.y += _.y),
            (f.z += _.z),
            f.normalize(),
            l.push(f.x, f.y, f.z),
            _.copy(m);
      }
    for (let v = 0; v <= t; v++) {
      const x = n + v * h * i,
        y = Math.sin(x),
        S = Math.cos(x);
      for (let w = 0; w <= e.length - 1; w++) {
        (u.x = e[w].x * y),
          (u.y = e[w].y),
          (u.z = e[w].x * S),
          a.push(u.x, u.y, u.z),
          (d.x = v / t),
          (d.y = w / (e.length - 1)),
          o.push(d.x, d.y);
        const R = l[3 * w + 0] * y,
          P = l[3 * w + 1],
          M = l[3 * w + 0] * S;
        c.push(R, P, M);
      }
    }
    for (let v = 0; v < t; v++)
      for (let x = 0; x < e.length - 1; x++) {
        const y = x + v * e.length,
          S = y,
          w = y + e.length,
          R = y + e.length + 1,
          P = y + 1;
        s.push(S, w, P), s.push(R, P, w);
      }
    this.setIndex(s),
      this.setAttribute("position", new Te(a, 3)),
      this.setAttribute("uv", new Te(o, 2)),
      this.setAttribute("normal", new Te(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Js(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Xr extends Js {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const s = new Dr();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(n), i),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: n,
        radialSegments: i,
      });
  }
  static fromJSON(e) {
    return new Xr(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Yr extends He {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const s = [],
      a = [],
      o = [],
      l = [],
      c = new b(),
      h = new K();
    a.push(0, 0, 0), o.push(0, 0, 1), l.push(0.5, 0.5);
    for (let u = 0, d = 3; u <= t; u++, d += 3) {
      const f = n + (u / t) * i;
      (c.x = e * Math.cos(f)),
        (c.y = e * Math.sin(f)),
        a.push(c.x, c.y, c.z),
        o.push(0, 0, 1),
        (h.x = (a[d] / e + 1) / 2),
        (h.y = (a[d + 1] / e + 1) / 2),
        l.push(h.x, h.y);
    }
    for (let u = 1; u <= t; u++) s.push(u, u + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Te(a, 3)),
      this.setAttribute("normal", new Te(o, 3)),
      this.setAttribute("uv", new Te(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Yr(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class mt extends He {
  constructor(
    e = 1,
    t = 1,
    n = 1,
    i = 32,
    s = 1,
    a = !1,
    o = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: i,
        heightSegments: s,
        openEnded: a,
        thetaStart: o,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const h = [],
      u = [],
      d = [],
      f = [];
    let m = 0;
    const _ = [],
      g = n / 2;
    let p = 0;
    v(),
      a === !1 && (e > 0 && x(!0), t > 0 && x(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Te(u, 3)),
      this.setAttribute("normal", new Te(d, 3)),
      this.setAttribute("uv", new Te(f, 2));
    function v() {
      const y = new b(),
        S = new b();
      let w = 0;
      const R = (t - e) / n;
      for (let P = 0; P <= s; P++) {
        const M = [],
          A = P / s,
          k = A * (t - e) + e;
        for (let X = 0; X <= i; X++) {
          const U = X / i,
            O = U * l + o,
            N = Math.sin(O),
            Z = Math.cos(O);
          (S.x = k * N),
            (S.y = -A * n + g),
            (S.z = k * Z),
            u.push(S.x, S.y, S.z),
            y.set(N, R, Z).normalize(),
            d.push(y.x, y.y, y.z),
            f.push(U, 1 - A),
            M.push(m++);
        }
        _.push(M);
      }
      for (let P = 0; P < i; P++)
        for (let M = 0; M < s; M++) {
          const A = _[M][P],
            k = _[M + 1][P],
            X = _[M + 1][P + 1],
            U = _[M][P + 1];
          h.push(A, k, U), h.push(k, X, U), (w += 6);
        }
      c.addGroup(p, w, 0), (p += w);
    }
    function x(y) {
      const S = m,
        w = new K(),
        R = new b();
      let P = 0;
      const M = y === !0 ? e : t,
        A = y === !0 ? 1 : -1;
      for (let X = 1; X <= i; X++)
        u.push(0, g * A, 0), d.push(0, A, 0), f.push(0.5, 0.5), m++;
      const k = m;
      for (let X = 0; X <= i; X++) {
        const O = (X / i) * l + o,
          N = Math.cos(O),
          Z = Math.sin(O);
        (R.x = M * Z),
          (R.y = g * A),
          (R.z = M * N),
          u.push(R.x, R.y, R.z),
          d.push(0, A, 0),
          (w.x = N * 0.5 + 0.5),
          (w.y = Z * 0.5 * A + 0.5),
          f.push(w.x, w.y),
          m++;
      }
      for (let X = 0; X < i; X++) {
        const U = S + X,
          O = k + X;
        y === !0 ? h.push(O, O + 1, U) : h.push(O + 1, O, U), (P += 3);
      }
      c.addGroup(p, P, y === !0 ? 1 : 2), (p += P);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new mt(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class qr extends mt {
  constructor(e = 1, t = 1, n = 32, i = 1, s = !1, a = 0, o = Math.PI * 2) {
    super(0, e, t, n, i, s, a, o),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: n,
        heightSegments: i,
        openEnded: s,
        thetaStart: a,
        thetaLength: o,
      });
  }
  static fromJSON(e) {
    return new qr(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class ei extends He {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: n, detail: i });
    const s = [],
      a = [];
    o(i),
      c(n),
      h(),
      this.setAttribute("position", new Te(s, 3)),
      this.setAttribute("normal", new Te(s.slice(), 3)),
      this.setAttribute("uv", new Te(a, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function o(v) {
      const x = new b(),
        y = new b(),
        S = new b();
      for (let w = 0; w < t.length; w += 3)
        f(t[w + 0], x), f(t[w + 1], y), f(t[w + 2], S), l(x, y, S, v);
    }
    function l(v, x, y, S) {
      const w = S + 1,
        R = [];
      for (let P = 0; P <= w; P++) {
        R[P] = [];
        const M = v.clone().lerp(y, P / w),
          A = x.clone().lerp(y, P / w),
          k = w - P;
        for (let X = 0; X <= k; X++)
          X === 0 && P === w
            ? (R[P][X] = M)
            : (R[P][X] = M.clone().lerp(A, X / k));
      }
      for (let P = 0; P < w; P++)
        for (let M = 0; M < 2 * (w - P) - 1; M++) {
          const A = Math.floor(M / 2);
          M % 2 === 0
            ? (d(R[P][A + 1]), d(R[P + 1][A]), d(R[P][A]))
            : (d(R[P][A + 1]), d(R[P + 1][A + 1]), d(R[P + 1][A]));
        }
    }
    function c(v) {
      const x = new b();
      for (let y = 0; y < s.length; y += 3)
        (x.x = s[y + 0]),
          (x.y = s[y + 1]),
          (x.z = s[y + 2]),
          x.normalize().multiplyScalar(v),
          (s[y + 0] = x.x),
          (s[y + 1] = x.y),
          (s[y + 2] = x.z);
    }
    function h() {
      const v = new b();
      for (let x = 0; x < s.length; x += 3) {
        (v.x = s[x + 0]), (v.y = s[x + 1]), (v.z = s[x + 2]);
        const y = g(v) / 2 / Math.PI + 0.5,
          S = p(v) / Math.PI + 0.5;
        a.push(y, 1 - S);
      }
      m(), u();
    }
    function u() {
      for (let v = 0; v < a.length; v += 6) {
        const x = a[v + 0],
          y = a[v + 2],
          S = a[v + 4],
          w = Math.max(x, y, S),
          R = Math.min(x, y, S);
        w > 0.9 &&
          R < 0.1 &&
          (x < 0.2 && (a[v + 0] += 1),
          y < 0.2 && (a[v + 2] += 1),
          S < 0.2 && (a[v + 4] += 1));
      }
    }
    function d(v) {
      s.push(v.x, v.y, v.z);
    }
    function f(v, x) {
      const y = v * 3;
      (x.x = e[y + 0]), (x.y = e[y + 1]), (x.z = e[y + 2]);
    }
    function m() {
      const v = new b(),
        x = new b(),
        y = new b(),
        S = new b(),
        w = new K(),
        R = new K(),
        P = new K();
      for (let M = 0, A = 0; M < s.length; M += 9, A += 6) {
        v.set(s[M + 0], s[M + 1], s[M + 2]),
          x.set(s[M + 3], s[M + 4], s[M + 5]),
          y.set(s[M + 6], s[M + 7], s[M + 8]),
          w.set(a[A + 0], a[A + 1]),
          R.set(a[A + 2], a[A + 3]),
          P.set(a[A + 4], a[A + 5]),
          S.copy(v).add(x).add(y).divideScalar(3);
        const k = g(S);
        _(w, A + 0, v, k), _(R, A + 2, x, k), _(P, A + 4, y, k);
      }
    }
    function _(v, x, y, S) {
      S < 0 && v.x === 1 && (a[x] = v.x - 1),
        y.x === 0 && y.z === 0 && (a[x] = S / 2 / Math.PI + 0.5);
    }
    function g(v) {
      return Math.atan2(v.z, -v.x);
    }
    function p(v) {
      return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ei(e.vertices, e.indices, e.radius, e.details);
  }
}
class Zr extends ei {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ],
      a = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, a, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Zr(e.radius, e.detail);
  }
}
const Oa = new b(),
  Fa = new b(),
  fl = new b(),
  Ba = new Yt();
class Bf extends He {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        s = Math.cos(Ji * t),
        a = e.getIndex(),
        o = e.getAttribute("position"),
        l = a ? a.count : o.count,
        c = [0, 0, 0],
        h = ["a", "b", "c"],
        u = new Array(3),
        d = {},
        f = [];
      for (let m = 0; m < l; m += 3) {
        a
          ? ((c[0] = a.getX(m)), (c[1] = a.getX(m + 1)), (c[2] = a.getX(m + 2)))
          : ((c[0] = m), (c[1] = m + 1), (c[2] = m + 2));
        const { a: _, b: g, c: p } = Ba;
        if (
          (_.fromBufferAttribute(o, c[0]),
          g.fromBufferAttribute(o, c[1]),
          p.fromBufferAttribute(o, c[2]),
          Ba.getNormal(fl),
          (u[0] = `${Math.round(_.x * i)},${Math.round(_.y * i)},${Math.round(
            _.z * i
          )}`),
          (u[1] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(
            g.z * i
          )}`),
          (u[2] = `${Math.round(p.x * i)},${Math.round(p.y * i)},${Math.round(
            p.z * i
          )}`),
          !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
        )
          for (let v = 0; v < 3; v++) {
            const x = (v + 1) % 3,
              y = u[v],
              S = u[x],
              w = Ba[h[v]],
              R = Ba[h[x]],
              P = `${y}_${S}`,
              M = `${S}_${y}`;
            M in d && d[M]
              ? (fl.dot(d[M].normal) <= s &&
                  (f.push(w.x, w.y, w.z), f.push(R.x, R.y, R.z)),
                (d[M] = null))
              : P in d ||
                (d[P] = { index0: c[v], index1: c[x], normal: fl.clone() });
          }
      }
      for (const m in d)
        if (d[m]) {
          const { index0: _, index1: g } = d[m];
          Oa.fromBufferAttribute(o, _),
            Fa.fromBufferAttribute(o, g),
            f.push(Oa.x, Oa.y, Oa.z),
            f.push(Fa.x, Fa.y, Fa.z);
        }
      this.setAttribute("position", new Te(f, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Qi extends Dr {
  constructor(e) {
    super(e), (this.uuid = en()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Dr().fromJSON(i));
    }
    return this;
  }
}
const Xy = {
  triangulate: function (r, e, t = 2) {
    const n = e && e.length,
      i = n ? e[0] * t : r.length;
    let s = zf(r, 0, i, t, !0);
    const a = [];
    if (!s || s.next === s.prev) return a;
    let o, l, c, h, u, d, f;
    if ((n && (s = Ky(r, e, s, t)), r.length > 80 * t)) {
      (o = c = r[0]), (l = h = r[1]);
      for (let m = t; m < i; m += t)
        (u = r[m]),
          (d = r[m + 1]),
          u < o && (o = u),
          d < l && (l = d),
          u > c && (c = u),
          d > h && (h = d);
      (f = Math.max(c - o, h - l)), (f = f !== 0 ? 32767 / f : 0);
    }
    return Ur(s, a, t, o, l, f, 0), a;
  },
};
function zf(r, e, t, n, i) {
  let s, a;
  if (i === ov(r, e, t, n) > 0)
    for (s = e; s < t; s += n) a = Tu(s, r[s], r[s + 1], a);
  else for (s = t - n; s >= e; s -= n) a = Tu(s, r[s], r[s + 1], a);
  return a && Lo(a, a.next) && (Or(a), (a = a.next)), a;
}
function is(r, e) {
  if (!r) return r;
  e || (e = r);
  let t = r,
    n;
  do
    if (
      ((n = !1), !t.steiner && (Lo(t, t.next) || ut(t.prev, t, t.next) === 0))
    ) {
      if ((Or(t), (t = e = t.prev), t === t.next)) break;
      n = !0;
    } else t = t.next;
  while (n || t !== e);
  return e;
}
function Ur(r, e, t, n, i, s, a) {
  if (!r) return;
  !a && s && tv(r, n, i, s);
  let o = r,
    l,
    c;
  for (; r.prev !== r.next; ) {
    if (((l = r.prev), (c = r.next), s ? qy(r, n, i, s) : Yy(r))) {
      e.push((l.i / t) | 0),
        e.push((r.i / t) | 0),
        e.push((c.i / t) | 0),
        Or(r),
        (r = c.next),
        (o = c.next);
      continue;
    }
    if (((r = c), r === o)) {
      a
        ? a === 1
          ? ((r = Zy(is(r), e, t)), Ur(r, e, t, n, i, s, 2))
          : a === 2 && $y(r, e, t, n, i, s)
        : Ur(is(r), e, t, n, i, s, 1);
      break;
    }
  }
}
function Yy(r) {
  const e = r.prev,
    t = r,
    n = r.next;
  if (ut(e, t, n) >= 0) return !1;
  const i = e.x,
    s = t.x,
    a = n.x,
    o = e.y,
    l = t.y,
    c = n.y,
    h = i < s ? (i < a ? i : a) : s < a ? s : a,
    u = o < l ? (o < c ? o : c) : l < c ? l : c,
    d = i > s ? (i > a ? i : a) : s > a ? s : a,
    f = o > l ? (o > c ? o : c) : l > c ? l : c;
  let m = n.next;
  for (; m !== e; ) {
    if (
      m.x >= h &&
      m.x <= d &&
      m.y >= u &&
      m.y <= f &&
      Is(i, o, s, l, a, c, m.x, m.y) &&
      ut(m.prev, m, m.next) >= 0
    )
      return !1;
    m = m.next;
  }
  return !0;
}
function qy(r, e, t, n) {
  const i = r.prev,
    s = r,
    a = r.next;
  if (ut(i, s, a) >= 0) return !1;
  const o = i.x,
    l = s.x,
    c = a.x,
    h = i.y,
    u = s.y,
    d = a.y,
    f = o < l ? (o < c ? o : c) : l < c ? l : c,
    m = h < u ? (h < d ? h : d) : u < d ? u : d,
    _ = o > l ? (o > c ? o : c) : l > c ? l : c,
    g = h > u ? (h > d ? h : d) : u > d ? u : d,
    p = cc(f, m, e, t, n),
    v = cc(_, g, e, t, n);
  let x = r.prevZ,
    y = r.nextZ;
  for (; x && x.z >= p && y && y.z <= v; ) {
    if (
      (x.x >= f &&
        x.x <= _ &&
        x.y >= m &&
        x.y <= g &&
        x !== i &&
        x !== a &&
        Is(o, h, l, u, c, d, x.x, x.y) &&
        ut(x.prev, x, x.next) >= 0) ||
      ((x = x.prevZ),
      y.x >= f &&
        y.x <= _ &&
        y.y >= m &&
        y.y <= g &&
        y !== i &&
        y !== a &&
        Is(o, h, l, u, c, d, y.x, y.y) &&
        ut(y.prev, y, y.next) >= 0)
    )
      return !1;
    y = y.nextZ;
  }
  for (; x && x.z >= p; ) {
    if (
      x.x >= f &&
      x.x <= _ &&
      x.y >= m &&
      x.y <= g &&
      x !== i &&
      x !== a &&
      Is(o, h, l, u, c, d, x.x, x.y) &&
      ut(x.prev, x, x.next) >= 0
    )
      return !1;
    x = x.prevZ;
  }
  for (; y && y.z <= v; ) {
    if (
      y.x >= f &&
      y.x <= _ &&
      y.y >= m &&
      y.y <= g &&
      y !== i &&
      y !== a &&
      Is(o, h, l, u, c, d, y.x, y.y) &&
      ut(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function Zy(r, e, t) {
  let n = r;
  do {
    const i = n.prev,
      s = n.next.next;
    !Lo(i, s) &&
      kf(i, n, n.next, s) &&
      Nr(i, s) &&
      Nr(s, i) &&
      (e.push((i.i / t) | 0),
      e.push((n.i / t) | 0),
      e.push((s.i / t) | 0),
      Or(n),
      Or(n.next),
      (n = r = s)),
      (n = n.next);
  } while (n !== r);
  return is(n);
}
function $y(r, e, t, n, i, s) {
  let a = r;
  do {
    let o = a.next.next;
    for (; o !== a.prev; ) {
      if (a.i !== o.i && sv(a, o)) {
        let l = Hf(a, o);
        (a = is(a, a.next)),
          (l = is(l, l.next)),
          Ur(a, e, t, n, i, s, 0),
          Ur(l, e, t, n, i, s, 0);
        return;
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== r);
}
function Ky(r, e, t, n) {
  const i = [];
  let s, a, o, l, c;
  for (s = 0, a = e.length; s < a; s++)
    (o = e[s] * n),
      (l = s < a - 1 ? e[s + 1] * n : r.length),
      (c = zf(r, o, l, n, !1)),
      c === c.next && (c.steiner = !0),
      i.push(iv(c));
  for (i.sort(jy), s = 0; s < i.length; s++) t = Jy(i[s], t);
  return t;
}
function jy(r, e) {
  return r.x - e.x;
}
function Jy(r, e) {
  const t = Qy(r, e);
  if (!t) return e;
  const n = Hf(t, r);
  return is(n, n.next), is(t, t.next);
}
function Qy(r, e) {
  let t = e,
    n = -1 / 0,
    i;
  const s = r.x,
    a = r.y;
  do {
    if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
      const d = t.x + ((a - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        d <= s &&
        d > n &&
        ((n = d), (i = t.x < t.next.x ? t : t.next), d === s)
      )
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const o = i,
    l = i.x,
    c = i.y;
  let h = 1 / 0,
    u;
  t = i;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      Is(a < c ? s : n, a, l, c, a < c ? n : s, a, t.x, t.y) &&
      ((u = Math.abs(a - t.y) / (s - t.x)),
      Nr(t, r) &&
        (u < h || (u === h && (t.x > i.x || (t.x === i.x && ev(i, t))))) &&
        ((i = t), (h = u))),
      (t = t.next);
  while (t !== o);
  return i;
}
function ev(r, e) {
  return ut(r.prev, r, e.prev) < 0 && ut(e.next, r, r.next) < 0;
}
function tv(r, e, t, n) {
  let i = r;
  do
    i.z === 0 && (i.z = cc(i.x, i.y, e, t, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== r);
  (i.prevZ.nextZ = null), (i.prevZ = null), nv(i);
}
function nv(r) {
  let e,
    t,
    n,
    i,
    s,
    a,
    o,
    l,
    c = 1;
  do {
    for (t = r, r = null, s = null, a = 0; t; ) {
      for (a++, n = t, o = 0, e = 0; e < c && (o++, (n = n.nextZ), !!n); e++);
      for (l = c; o > 0 || (l > 0 && n); )
        o !== 0 && (l === 0 || !n || t.z <= n.z)
          ? ((i = t), (t = t.nextZ), o--)
          : ((i = n), (n = n.nextZ), l--),
          s ? (s.nextZ = i) : (r = i),
          (i.prevZ = s),
          (s = i);
      t = n;
    }
    (s.nextZ = null), (c *= 2);
  } while (a > 1);
  return r;
}
function cc(r, e, t, n, i) {
  return (
    (r = ((r - t) * i) | 0),
    (e = ((e - n) * i) | 0),
    (r = (r | (r << 8)) & 16711935),
    (r = (r | (r << 4)) & 252645135),
    (r = (r | (r << 2)) & 858993459),
    (r = (r | (r << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    r | (e << 1)
  );
}
function iv(r) {
  let e = r,
    t = r;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== r);
  return t;
}
function Is(r, e, t, n, i, s, a, o) {
  return (
    (i - a) * (e - o) >= (r - a) * (s - o) &&
    (r - a) * (n - o) >= (t - a) * (e - o) &&
    (t - a) * (s - o) >= (i - a) * (n - o)
  );
}
function sv(r, e) {
  return (
    r.next.i !== e.i &&
    r.prev.i !== e.i &&
    !rv(r, e) &&
    ((Nr(r, e) &&
      Nr(e, r) &&
      av(r, e) &&
      (ut(r.prev, r, e.prev) || ut(r, e.prev, e))) ||
      (Lo(r, e) && ut(r.prev, r, r.next) > 0 && ut(e.prev, e, e.next) > 0))
  );
}
function ut(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function Lo(r, e) {
  return r.x === e.x && r.y === e.y;
}
function kf(r, e, t, n) {
  const i = ka(ut(r, e, t)),
    s = ka(ut(r, e, n)),
    a = ka(ut(t, n, r)),
    o = ka(ut(t, n, e));
  return !!(
    (i !== s && a !== o) ||
    (i === 0 && za(r, t, e)) ||
    (s === 0 && za(r, n, e)) ||
    (a === 0 && za(t, r, n)) ||
    (o === 0 && za(t, e, n))
  );
}
function za(r, e, t) {
  return (
    e.x <= Math.max(r.x, t.x) &&
    e.x >= Math.min(r.x, t.x) &&
    e.y <= Math.max(r.y, t.y) &&
    e.y >= Math.min(r.y, t.y)
  );
}
function ka(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function rv(r, e) {
  let t = r;
  do {
    if (
      t.i !== r.i &&
      t.next.i !== r.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      kf(t, t.next, r, e)
    )
      return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function Nr(r, e) {
  return ut(r.prev, r, r.next) < 0
    ? ut(r, e, r.next) >= 0 && ut(r, r.prev, e) >= 0
    : ut(r, e, r.prev) < 0 || ut(r, r.next, e) < 0;
}
function av(r, e) {
  let t = r,
    n = !1;
  const i = (r.x + e.x) / 2,
    s = (r.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (n = !n),
      (t = t.next);
  while (t !== r);
  return n;
}
function Hf(r, e) {
  const t = new hc(r.i, r.x, r.y),
    n = new hc(e.i, e.x, e.y),
    i = r.next,
    s = e.prev;
  return (
    (r.next = e),
    (e.prev = r),
    (t.next = i),
    (i.prev = t),
    (n.next = t),
    (t.prev = n),
    (s.next = n),
    (n.prev = s),
    n
  );
}
function Tu(r, e, t, n) {
  const i = new hc(r, e, t);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Or(r) {
  (r.next.prev = r.prev),
    (r.prev.next = r.next),
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function hc(r, e, t) {
  (this.i = r),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function ov(r, e, t, n) {
  let i = 0;
  for (let s = e, a = t - n; s < t; s += n)
    (i += (r[a] - r[s]) * (r[s + 1] + r[a + 1])), (a = s);
  return i;
}
class Ln {
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      n += e[i].x * e[s].y - e[s].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return Ln.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [],
      i = [],
      s = [];
    Ru(e), Cu(n, e);
    let a = e.length;
    t.forEach(Ru);
    for (let l = 0; l < t.length; l++)
      i.push(a), (a += t[l].length), Cu(n, t[l]);
    const o = Xy.triangulate(n, i);
    for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
    return s;
  }
}
function Ru(r) {
  const e = r.length;
  e > 2 && r[e - 1].equals(r[0]) && r.pop();
}
function Cu(r, e) {
  for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
}
class $r extends He {
  constructor(
    e = new Qi([
      new K(0.5, 0.5),
      new K(-0.5, 0.5),
      new K(-0.5, -0.5),
      new K(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const n = this,
      i = [],
      s = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o];
      a(c);
    }
    this.setAttribute("position", new Te(i, 3)),
      this.setAttribute("uv", new Te(s, 2)),
      this.computeVertexNormals();
    function a(o) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        u = t.depth !== void 0 ? t.depth : 1;
      let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        f = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        m = t.bevelSize !== void 0 ? t.bevelSize : f - 0.1,
        _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const p = t.extrudePath,
        v = t.UVGenerator !== void 0 ? t.UVGenerator : lv;
      let x,
        y = !1,
        S,
        w,
        R,
        P;
      p &&
        ((x = p.getSpacedPoints(h)),
        (y = !0),
        (d = !1),
        (S = p.computeFrenetFrames(h, !1)),
        (w = new b()),
        (R = new b()),
        (P = new b())),
        d || ((g = 0), (f = 0), (m = 0), (_ = 0));
      const M = o.extractPoints(c);
      let A = M.shape;
      const k = M.holes;
      if (!Ln.isClockWise(A)) {
        A = A.reverse();
        for (let I = 0, le = k.length; I < le; I++) {
          const Q = k[I];
          Ln.isClockWise(Q) && (k[I] = Q.reverse());
        }
      }
      const U = Ln.triangulateShape(A, k),
        O = A;
      for (let I = 0, le = k.length; I < le; I++) {
        const Q = k[I];
        A = A.concat(Q);
      }
      function N(I, le, Q) {
        return (
          le || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          I.clone().addScaledVector(le, Q)
        );
      }
      const Z = A.length,
        B = U.length;
      function G(I, le, Q) {
        let oe, ee, we;
        const _e = I.x - le.x,
          xe = I.y - le.y,
          Le = Q.x - I.x,
          ze = Q.y - I.y,
          it = _e * _e + xe * xe,
          C = _e * ze - xe * Le;
        if (Math.abs(C) > Number.EPSILON) {
          const E = Math.sqrt(it),
            q = Math.sqrt(Le * Le + ze * ze),
            ae = le.x - xe / E,
            se = le.y + _e / E,
            L = Q.x - ze / q,
            te = Q.y + Le / q,
            re = ((L - ae) * ze - (te - se) * Le) / (_e * ze - xe * Le);
          (oe = ae + _e * re - I.x), (ee = se + xe * re - I.y);
          const W = oe * oe + ee * ee;
          if (W <= 2) return new K(oe, ee);
          we = Math.sqrt(W / 2);
        } else {
          let E = !1;
          _e > Number.EPSILON
            ? Le > Number.EPSILON && (E = !0)
            : _e < -Number.EPSILON
            ? Le < -Number.EPSILON && (E = !0)
            : Math.sign(xe) === Math.sign(ze) && (E = !0),
            E
              ? ((oe = -xe), (ee = _e), (we = Math.sqrt(it)))
              : ((oe = _e), (ee = xe), (we = Math.sqrt(it / 2)));
        }
        return new K(oe / we, ee / we);
      }
      const $ = [];
      for (
        let I = 0, le = O.length, Q = le - 1, oe = I + 1;
        I < le;
        I++, Q++, oe++
      )
        Q === le && (Q = 0),
          oe === le && (oe = 0),
          ($[I] = G(O[I], O[Q], O[oe]));
      const Y = [];
      let he,
        F = $.concat();
      for (let I = 0, le = k.length; I < le; I++) {
        const Q = k[I];
        he = [];
        for (
          let oe = 0, ee = Q.length, we = ee - 1, _e = oe + 1;
          oe < ee;
          oe++, we++, _e++
        )
          we === ee && (we = 0),
            _e === ee && (_e = 0),
            (he[oe] = G(Q[oe], Q[we], Q[_e]));
        Y.push(he), (F = F.concat(he));
      }
      for (let I = 0; I < g; I++) {
        const le = I / g,
          Q = f * Math.cos((le * Math.PI) / 2),
          oe = m * Math.sin((le * Math.PI) / 2) + _;
        for (let ee = 0, we = O.length; ee < we; ee++) {
          const _e = N(O[ee], $[ee], oe);
          Me(_e.x, _e.y, -Q);
        }
        for (let ee = 0, we = k.length; ee < we; ee++) {
          const _e = k[ee];
          he = Y[ee];
          for (let xe = 0, Le = _e.length; xe < Le; xe++) {
            const ze = N(_e[xe], he[xe], oe);
            Me(ze.x, ze.y, -Q);
          }
        }
      }
      const ne = m + _;
      for (let I = 0; I < Z; I++) {
        const le = d ? N(A[I], F[I], ne) : A[I];
        y
          ? (R.copy(S.normals[0]).multiplyScalar(le.x),
            w.copy(S.binormals[0]).multiplyScalar(le.y),
            P.copy(x[0]).add(R).add(w),
            Me(P.x, P.y, P.z))
          : Me(le.x, le.y, 0);
      }
      for (let I = 1; I <= h; I++)
        for (let le = 0; le < Z; le++) {
          const Q = d ? N(A[le], F[le], ne) : A[le];
          y
            ? (R.copy(S.normals[I]).multiplyScalar(Q.x),
              w.copy(S.binormals[I]).multiplyScalar(Q.y),
              P.copy(x[I]).add(R).add(w),
              Me(P.x, P.y, P.z))
            : Me(Q.x, Q.y, (u / h) * I);
        }
      for (let I = g - 1; I >= 0; I--) {
        const le = I / g,
          Q = f * Math.cos((le * Math.PI) / 2),
          oe = m * Math.sin((le * Math.PI) / 2) + _;
        for (let ee = 0, we = O.length; ee < we; ee++) {
          const _e = N(O[ee], $[ee], oe);
          Me(_e.x, _e.y, u + Q);
        }
        for (let ee = 0, we = k.length; ee < we; ee++) {
          const _e = k[ee];
          he = Y[ee];
          for (let xe = 0, Le = _e.length; xe < Le; xe++) {
            const ze = N(_e[xe], he[xe], oe);
            y
              ? Me(ze.x, ze.y + x[h - 1].y, x[h - 1].x + Q)
              : Me(ze.x, ze.y, u + Q);
          }
        }
      }
      ie(), me();
      function ie() {
        const I = i.length / 3;
        if (d) {
          let le = 0,
            Q = Z * le;
          for (let oe = 0; oe < B; oe++) {
            const ee = U[oe];
            Ne(ee[2] + Q, ee[1] + Q, ee[0] + Q);
          }
          (le = h + g * 2), (Q = Z * le);
          for (let oe = 0; oe < B; oe++) {
            const ee = U[oe];
            Ne(ee[0] + Q, ee[1] + Q, ee[2] + Q);
          }
        } else {
          for (let le = 0; le < B; le++) {
            const Q = U[le];
            Ne(Q[2], Q[1], Q[0]);
          }
          for (let le = 0; le < B; le++) {
            const Q = U[le];
            Ne(Q[0] + Z * h, Q[1] + Z * h, Q[2] + Z * h);
          }
        }
        n.addGroup(I, i.length / 3 - I, 0);
      }
      function me() {
        const I = i.length / 3;
        let le = 0;
        ge(O, le), (le += O.length);
        for (let Q = 0, oe = k.length; Q < oe; Q++) {
          const ee = k[Q];
          ge(ee, le), (le += ee.length);
        }
        n.addGroup(I, i.length / 3 - I, 1);
      }
      function ge(I, le) {
        let Q = I.length;
        for (; --Q >= 0; ) {
          const oe = Q;
          let ee = Q - 1;
          ee < 0 && (ee = I.length - 1);
          for (let we = 0, _e = h + g * 2; we < _e; we++) {
            const xe = Z * we,
              Le = Z * (we + 1),
              ze = le + oe + xe,
              it = le + ee + xe,
              C = le + ee + Le,
              E = le + oe + Le;
            Ce(ze, it, C, E);
          }
        }
      }
      function Me(I, le, Q) {
        l.push(I), l.push(le), l.push(Q);
      }
      function Ne(I, le, Q) {
        Ze(I), Ze(le), Ze(Q);
        const oe = i.length / 3,
          ee = v.generateTopUV(n, i, oe - 3, oe - 2, oe - 1);
        Pe(ee[0]), Pe(ee[1]), Pe(ee[2]);
      }
      function Ce(I, le, Q, oe) {
        Ze(I), Ze(le), Ze(oe), Ze(le), Ze(Q), Ze(oe);
        const ee = i.length / 3,
          we = v.generateSideWallUV(n, i, ee - 6, ee - 3, ee - 2, ee - 1);
        Pe(we[0]), Pe(we[1]), Pe(we[3]), Pe(we[1]), Pe(we[2]), Pe(we[3]);
      }
      function Ze(I) {
        i.push(l[I * 3 + 0]), i.push(l[I * 3 + 1]), i.push(l[I * 3 + 2]);
      }
      function Pe(I) {
        s.push(I.x), s.push(I.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      n = this.parameters.options;
    return cv(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, a = e.shapes.length; s < a; s++) {
      const o = t[e.shapes[s]];
      n.push(o);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new Qc[i.type]().fromJSON(i)),
      new $r(n, e.options)
    );
  }
}
const lv = {
  generateTopUV: function (r, e, t, n, i) {
    const s = e[t * 3],
      a = e[t * 3 + 1],
      o = e[n * 3],
      l = e[n * 3 + 1],
      c = e[i * 3],
      h = e[i * 3 + 1];
    return [new K(s, a), new K(o, l), new K(c, h)];
  },
  generateSideWallUV: function (r, e, t, n, i, s) {
    const a = e[t * 3],
      o = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[n * 3],
      h = e[n * 3 + 1],
      u = e[n * 3 + 2],
      d = e[i * 3],
      f = e[i * 3 + 1],
      m = e[i * 3 + 2],
      _ = e[s * 3],
      g = e[s * 3 + 1],
      p = e[s * 3 + 2];
    return Math.abs(o - h) < Math.abs(a - c)
      ? [new K(a, 1 - l), new K(c, 1 - u), new K(d, 1 - m), new K(_, 1 - p)]
      : [new K(o, 1 - l), new K(h, 1 - u), new K(f, 1 - m), new K(g, 1 - p)];
  },
};
function cv(r, e, t) {
  if (((t.shapes = []), Array.isArray(r)))
    for (let n = 0, i = r.length; n < i; n++) {
      const s = r[n];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(r.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Kr extends ei {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Kr(e.radius, e.detail);
  }
}
class Cn extends ei {
  constructor(e = 1, t = 0) {
    const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(n, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Cn(e.radius, e.detail);
  }
}
class jr extends He {
  constructor(e = 0.5, t = 1, n = 32, i = 1, s = 0, a = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: s,
        thetaLength: a,
      }),
      (n = Math.max(3, n)),
      (i = Math.max(1, i));
    const o = [],
      l = [],
      c = [],
      h = [];
    let u = e;
    const d = (t - e) / i,
      f = new b(),
      m = new K();
    for (let _ = 0; _ <= i; _++) {
      for (let g = 0; g <= n; g++) {
        const p = s + (g / n) * a;
        (f.x = u * Math.cos(p)),
          (f.y = u * Math.sin(p)),
          l.push(f.x, f.y, f.z),
          c.push(0, 0, 1),
          (m.x = (f.x / t + 1) / 2),
          (m.y = (f.y / t + 1) / 2),
          h.push(m.x, m.y);
      }
      u += d;
    }
    for (let _ = 0; _ < i; _++) {
      const g = _ * (n + 1);
      for (let p = 0; p < n; p++) {
        const v = p + g,
          x = v,
          y = v + n + 1,
          S = v + n + 2,
          w = v + 1;
        o.push(x, y, w), o.push(y, S, w);
      }
    }
    this.setIndex(o),
      this.setAttribute("position", new Te(l, 3)),
      this.setAttribute("normal", new Te(c, 3)),
      this.setAttribute("uv", new Te(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new jr(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Jr extends He {
  constructor(
    e = new Qi([new K(0, 0.5), new K(-0.5, -0.5), new K(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const n = [],
      i = [],
      s = [],
      a = [];
    let o = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(o, l, h), (o += l), (l = 0);
    this.setIndex(n),
      this.setAttribute("position", new Te(i, 3)),
      this.setAttribute("normal", new Te(s, 3)),
      this.setAttribute("uv", new Te(a, 2));
    function c(h) {
      const u = i.length / 3,
        d = h.extractPoints(t);
      let f = d.shape;
      const m = d.holes;
      Ln.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, p = m.length; g < p; g++) {
        const v = m[g];
        Ln.isClockWise(v) === !0 && (m[g] = v.reverse());
      }
      const _ = Ln.triangulateShape(f, m);
      for (let g = 0, p = m.length; g < p; g++) {
        const v = m[g];
        f = f.concat(v);
      }
      for (let g = 0, p = f.length; g < p; g++) {
        const v = f[g];
        i.push(v.x, v.y, 0), s.push(0, 0, 1), a.push(v.x, v.y);
      }
      for (let g = 0, p = _.length; g < p; g++) {
        const v = _[g],
          x = v[0] + u,
          y = v[1] + u,
          S = v[2] + u;
        n.push(x, y, S), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return hv(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const a = t[e.shapes[i]];
      n.push(a);
    }
    return new Jr(n, e.curveSegments);
  }
}
function hv(r, e) {
  if (((e.shapes = []), Array.isArray(r)))
    for (let t = 0, n = r.length; t < n; t++) {
      const i = r[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(r.uuid);
  return e;
}
class ti extends He {
  constructor(
    e = 1,
    t = 32,
    n = 16,
    i = 0,
    s = Math.PI * 2,
    a = 0,
    o = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: i,
        phiLength: s,
        thetaStart: a,
        thetaLength: o,
      }),
      (t = Math.max(3, Math.floor(t))),
      (n = Math.max(2, Math.floor(n)));
    const l = Math.min(a + o, Math.PI);
    let c = 0;
    const h = [],
      u = new b(),
      d = new b(),
      f = [],
      m = [],
      _ = [],
      g = [];
    for (let p = 0; p <= n; p++) {
      const v = [],
        x = p / n;
      let y = 0;
      p === 0 && a === 0
        ? (y = 0.5 / t)
        : p === n && l === Math.PI && (y = -0.5 / t);
      for (let S = 0; S <= t; S++) {
        const w = S / t;
        (u.x = -e * Math.cos(i + w * s) * Math.sin(a + x * o)),
          (u.y = e * Math.cos(a + x * o)),
          (u.z = e * Math.sin(i + w * s) * Math.sin(a + x * o)),
          m.push(u.x, u.y, u.z),
          d.copy(u).normalize(),
          _.push(d.x, d.y, d.z),
          g.push(w + y, 1 - x),
          v.push(c++);
      }
      h.push(v);
    }
    for (let p = 0; p < n; p++)
      for (let v = 0; v < t; v++) {
        const x = h[p][v + 1],
          y = h[p][v],
          S = h[p + 1][v],
          w = h[p + 1][v + 1];
        (p !== 0 || a > 0) && f.push(x, y, w),
          (p !== n - 1 || l < Math.PI) && f.push(y, S, w);
      }
    this.setIndex(f),
      this.setAttribute("position", new Te(m, 3)),
      this.setAttribute("normal", new Te(_, 3)),
      this.setAttribute("uv", new Te(g, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ti(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Qr extends ei {
  constructor(e = 1, t = 0) {
    const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(n, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Qr(e.radius, e.detail);
  }
}
class Tn extends He {
  constructor(e = 1, t = 0.4, n = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: i,
        arc: s,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const a = [],
      o = [],
      l = [],
      c = [],
      h = new b(),
      u = new b(),
      d = new b();
    for (let f = 0; f <= n; f++)
      for (let m = 0; m <= i; m++) {
        const _ = (m / i) * s,
          g = (f / n) * Math.PI * 2;
        (u.x = (e + t * Math.cos(g)) * Math.cos(_)),
          (u.y = (e + t * Math.cos(g)) * Math.sin(_)),
          (u.z = t * Math.sin(g)),
          o.push(u.x, u.y, u.z),
          (h.x = e * Math.cos(_)),
          (h.y = e * Math.sin(_)),
          d.subVectors(u, h).normalize(),
          l.push(d.x, d.y, d.z),
          c.push(m / i),
          c.push(f / n);
      }
    for (let f = 1; f <= n; f++)
      for (let m = 1; m <= i; m++) {
        const _ = (i + 1) * f + m - 1,
          g = (i + 1) * (f - 1) + m - 1,
          p = (i + 1) * (f - 1) + m,
          v = (i + 1) * f + m;
        a.push(_, g, v), a.push(g, p, v);
      }
    this.setIndex(a),
      this.setAttribute("position", new Te(o, 3)),
      this.setAttribute("normal", new Te(l, 3)),
      this.setAttribute("uv", new Te(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Tn(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class ea extends He {
  constructor(e = 1, t = 0.4, n = 64, i = 8, s = 2, a = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: i,
        p: s,
        q: a,
      }),
      (n = Math.floor(n)),
      (i = Math.floor(i));
    const o = [],
      l = [],
      c = [],
      h = [],
      u = new b(),
      d = new b(),
      f = new b(),
      m = new b(),
      _ = new b(),
      g = new b(),
      p = new b();
    for (let x = 0; x <= n; ++x) {
      const y = (x / n) * s * Math.PI * 2;
      v(y, s, a, e, f),
        v(y + 0.01, s, a, e, m),
        g.subVectors(m, f),
        p.addVectors(m, f),
        _.crossVectors(g, p),
        p.crossVectors(_, g),
        _.normalize(),
        p.normalize();
      for (let S = 0; S <= i; ++S) {
        const w = (S / i) * Math.PI * 2,
          R = -t * Math.cos(w),
          P = t * Math.sin(w);
        (u.x = f.x + (R * p.x + P * _.x)),
          (u.y = f.y + (R * p.y + P * _.y)),
          (u.z = f.z + (R * p.z + P * _.z)),
          l.push(u.x, u.y, u.z),
          d.subVectors(u, f).normalize(),
          c.push(d.x, d.y, d.z),
          h.push(x / n),
          h.push(S / i);
      }
    }
    for (let x = 1; x <= n; x++)
      for (let y = 1; y <= i; y++) {
        const S = (i + 1) * (x - 1) + (y - 1),
          w = (i + 1) * x + (y - 1),
          R = (i + 1) * x + y,
          P = (i + 1) * (x - 1) + y;
        o.push(S, w, P), o.push(w, R, P);
      }
    this.setIndex(o),
      this.setAttribute("position", new Te(l, 3)),
      this.setAttribute("normal", new Te(c, 3)),
      this.setAttribute("uv", new Te(h, 2));
    function v(x, y, S, w, R) {
      const P = Math.cos(x),
        M = Math.sin(x),
        A = (S / y) * x,
        k = Math.cos(A);
      (R.x = w * (2 + k) * 0.5 * P),
        (R.y = w * (2 + k) * M * 0.5),
        (R.z = w * Math.sin(A) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ea(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class ta extends He {
  constructor(
    e = new jc(new b(-1, -1, 0), new b(-1, 1, 0), new b(1, 1, 0)),
    t = 64,
    n = 1,
    i = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: n,
        radialSegments: i,
        closed: s,
      });
    const a = e.computeFrenetFrames(t, s);
    (this.tangents = a.tangents),
      (this.normals = a.normals),
      (this.binormals = a.binormals);
    const o = new b(),
      l = new b(),
      c = new K();
    let h = new b();
    const u = [],
      d = [],
      f = [],
      m = [];
    _(),
      this.setIndex(m),
      this.setAttribute("position", new Te(u, 3)),
      this.setAttribute("normal", new Te(d, 3)),
      this.setAttribute("uv", new Te(f, 2));
    function _() {
      for (let x = 0; x < t; x++) g(x);
      g(s === !1 ? t : 0), v(), p();
    }
    function g(x) {
      h = e.getPointAt(x / t, h);
      const y = a.normals[x],
        S = a.binormals[x];
      for (let w = 0; w <= i; w++) {
        const R = (w / i) * Math.PI * 2,
          P = Math.sin(R),
          M = -Math.cos(R);
        (l.x = M * y.x + P * S.x),
          (l.y = M * y.y + P * S.y),
          (l.z = M * y.z + P * S.z),
          l.normalize(),
          d.push(l.x, l.y, l.z),
          (o.x = h.x + n * l.x),
          (o.y = h.y + n * l.y),
          (o.z = h.z + n * l.z),
          u.push(o.x, o.y, o.z);
      }
    }
    function p() {
      for (let x = 1; x <= t; x++)
        for (let y = 1; y <= i; y++) {
          const S = (i + 1) * (x - 1) + (y - 1),
            w = (i + 1) * x + (y - 1),
            R = (i + 1) * x + y,
            P = (i + 1) * (x - 1) + y;
          m.push(S, w, P), m.push(w, R, P);
        }
    }
    function v() {
      for (let x = 0; x <= t; x++)
        for (let y = 0; y <= i; y++)
          (c.x = x / t), (c.y = y / i), f.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new ta(
      new Qc[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class Gf extends He {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        n = new Set(),
        i = new b(),
        s = new b();
      if (e.index !== null) {
        const a = e.attributes.position,
          o = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: o.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const u = l[c],
            d = u.start,
            f = u.count;
          for (let m = d, _ = d + f; m < _; m += 3)
            for (let g = 0; g < 3; g++) {
              const p = o.getX(m + g),
                v = o.getX(m + ((g + 1) % 3));
              i.fromBufferAttribute(a, p),
                s.fromBufferAttribute(a, v),
                Pu(i, s, n) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const a = e.attributes.position;
        for (let o = 0, l = a.count / 3; o < l; o++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * o + c,
              u = 3 * o + ((c + 1) % 3);
            i.fromBufferAttribute(a, h),
              s.fromBufferAttribute(a, u),
              Pu(i, s, n) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Te(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function Pu(r, e, t) {
  const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var Lu = Object.freeze({
  __proto__: null,
  BoxGeometry: at,
  CapsuleGeometry: Xr,
  CircleGeometry: Yr,
  ConeGeometry: qr,
  CylinderGeometry: mt,
  DodecahedronGeometry: Zr,
  EdgesGeometry: Bf,
  ExtrudeGeometry: $r,
  IcosahedronGeometry: Kr,
  LatheGeometry: Js,
  OctahedronGeometry: Cn,
  PlaneGeometry: Qn,
  PolyhedronGeometry: ei,
  RingGeometry: jr,
  ShapeGeometry: Jr,
  SphereGeometry: ti,
  TetrahedronGeometry: Qr,
  TorusGeometry: Tn,
  TorusKnotGeometry: ea,
  TubeGeometry: ta,
  WireframeGeometry: Gf,
});
class Vf extends At {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new de(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class Wf extends cn {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class na extends At {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new de(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new de(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Nn extends na {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new K(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return _t((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new de(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new de(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new de(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class Xf extends At {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new de(16777215)),
      (this.specular = new de(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new de(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = kr),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Yf extends At {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new de(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class qf extends At {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class Zf extends At {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new de(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new de(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = kr),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class $f extends At {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new de(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wi),
      (this.normalScale = new K(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Kf extends Nt {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function rn(r, e, t) {
  return eh(r)
    ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
    : r.slice(e, t);
}
function $i(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(r)
    : Array.prototype.slice.call(r);
}
function eh(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function jf(r) {
  function e(i, s) {
    return r[i] - r[s];
  }
  const t = r.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function uc(r, e, t) {
  const n = r.length,
    i = new r.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    const o = t[s] * e;
    for (let l = 0; l !== e; ++l) i[a++] = r[o + l];
  }
  return i;
}
function th(r, e, t, n) {
  let i = 1,
    s = r[0];
  for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
  if (s === void 0) return;
  let a = s[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
          (s = r[i++]);
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
          (s = r[i++]);
      while (s !== void 0);
    else
      do (a = s[n]), a !== void 0 && (e.push(s.time), t.push(a)), (s = r[i++]);
      while (s !== void 0);
}
function uv(r, e, t, n, i = 30) {
  const s = r.clone();
  s.name = e;
  const a = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l],
      h = c.getValueSize(),
      u = [],
      d = [];
    for (let f = 0; f < c.times.length; ++f) {
      const m = c.times[f] * i;
      if (!(m < t || m >= n)) {
        u.push(c.times[f]);
        for (let _ = 0; _ < h; ++_) d.push(c.values[f * h + _]);
      }
    }
    u.length !== 0 &&
      ((c.times = $i(u, c.times.constructor)),
      (c.values = $i(d, c.values.constructor)),
      a.push(c));
  }
  s.tracks = a;
  let o = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    o > s.tracks[l].times[0] && (o = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * o);
  return s.resetDuration(), s;
}
function dv(r, e = 0, t = r, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length,
    s = e / n;
  for (let a = 0; a < i; ++a) {
    const o = t.tracks[a],
      l = o.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = r.tracks.find(function (p) {
      return p.name === o.name && p.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let h = 0;
    const u = o.getValueSize();
    o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = u / 3);
    let d = 0;
    const f = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (d = f / 3);
    const m = o.times.length - 1;
    let _;
    if (s <= o.times[0]) {
      const p = h,
        v = u - h;
      _ = rn(o.values, p, v);
    } else if (s >= o.times[m]) {
      const p = m * u + h,
        v = p + u - h;
      _ = rn(o.values, p, v);
    } else {
      const p = o.createInterpolant(),
        v = h,
        x = u - h;
      p.evaluate(s), (_ = rn(p.resultBuffer, v, x));
    }
    l === "quaternion" &&
      new et().fromArray(_).normalize().conjugate().toArray(_);
    const g = c.times.length;
    for (let p = 0; p < g; ++p) {
      const v = p * f + d;
      if (l === "quaternion")
        et.multiplyQuaternionsFlat(c.values, v, _, 0, c.values, v);
      else {
        const x = f - d * 2;
        for (let y = 0; y < x; ++y) c.values[v + y] -= _[y];
      }
    }
  }
  return (r.blendMode = Pc), r;
}
const fv = {
  arraySlice: rn,
  convertArray: $i,
  isTypedArray: eh,
  getKeyframeOrder: jf,
  sortedArray: uc,
  flattenJSON: th,
  subclip: uv,
  makeClipAdditive: dv,
};
class Qs {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      s = t[n - 1];
    e: {
      t: {
        let a;
        n: {
          i: if (!(e < i)) {
            for (let o = n + 2; ; ) {
              if (i === void 0) {
                if (e < s) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === o) break;
              if (((s = i), (i = t[++n]), e < i)) break t;
            }
            a = t.length;
            break n;
          }
          if (!(e >= s)) {
            const o = t[1];
            e < o && ((n = 2), (s = o));
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === l) break;
              if (((i = s), (s = t[--n - 1]), e >= s)) break t;
            }
            (a = n), (n = 0);
            break n;
          }
          break e;
        }
        for (; n < a; ) {
          const o = (n + a) >>> 1;
          e < t[o] ? (a = o) : (n = o + 1);
        }
        if (((i = t[n]), (s = t[n - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, s, i);
    }
    return this.interpolate_(n, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let a = 0; a !== i; ++a) t[a] = n[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class Jf extends Qs {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Yi, endingEnd: Yi });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let s = e - 2,
      a = e + 1,
      o = i[s],
      l = i[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case qi:
          (s = e), (o = 2 * t - n);
          break;
        case Rr:
          (s = i.length - 2), (o = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (o = n);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case qi:
          (a = e), (l = 2 * n - t);
          break;
        case Rr:
          (a = 1), (l = n + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (l = t);
      }
    const c = (n - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = c / (t - o)),
      (this._weightNext = c / (l - n)),
      (this._offsetPrev = s * h),
      (this._offsetNext = a * h);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      h = this._offsetPrev,
      u = this._offsetNext,
      d = this._weightPrev,
      f = this._weightNext,
      m = (n - t) / (i - t),
      _ = m * m,
      g = _ * m,
      p = -d * g + 2 * d * _ - d * m,
      v = (1 + d) * g + (-1.5 - 2 * d) * _ + (-0.5 + d) * m + 1,
      x = (-1 - f) * g + (1.5 + f) * _ + 0.5 * m,
      y = f * g - f * _;
    for (let S = 0; S !== o; ++S)
      s[S] = p * a[h + S] + v * a[c + S] + x * a[l + S] + y * a[u + S];
    return s;
  }
}
class nh extends Qs {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      h = (n - t) / (i - t),
      u = 1 - h;
    for (let d = 0; d !== o; ++d) s[d] = a[c + d] * u + a[l + d] * h;
    return s;
  }
}
class Qf extends Qs {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class bn {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = $i(t, this.TimeBufferType)),
      (this.values = $i(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: $i(e.times, Array),
        values: $i(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new Qf(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new nh(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Jf(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case zs:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ns:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case io:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return zs;
      case this.InterpolantFactoryMethodLinear:
        return ns;
      case this.InterpolantFactoryMethodSmooth:
        return io;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let s = 0,
      a = i - 1;
    for (; s !== i && n[s] < e; ) ++s;
    for (; a !== -1 && n[a] > t; ) --a;
    if ((++a, s !== 0 || a !== i)) {
      s >= a && ((a = Math.max(a, 1)), (s = a - 1));
      const o = this.getValueSize();
      (this.times = rn(n, s, a)), (this.values = rn(this.values, s * o, a * o));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      s = n.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          o,
          l
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a),
          (e = !1);
        break;
      }
      a = l;
    }
    if (i !== void 0 && eh(i))
      for (let o = 0, l = i.length; o !== l; ++o) {
        const c = i[o];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            o,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = rn(this.times),
      t = rn(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === io,
      s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const c = e[o],
        h = e[o + 1];
      if (c !== h && (o !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const u = o * n,
            d = u - n,
            f = u + n;
          for (let m = 0; m !== n; ++m) {
            const _ = t[u + m];
            if (_ !== t[d + m] || _ !== t[f + m]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const u = o * n,
            d = a * n;
          for (let f = 0; f !== n; ++f) t[d + f] = t[u + f];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * n, l = a * n, c = 0; c !== n; ++c) t[l + c] = t[o + c];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = rn(e, 0, a)), (this.values = rn(t, 0, a * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = rn(this.times, 0),
      t = rn(this.values, 0),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
bn.prototype.TimeBufferType = Float32Array;
bn.prototype.ValueBufferType = Float32Array;
bn.prototype.DefaultInterpolation = ns;
class rs extends bn {}
rs.prototype.ValueTypeName = "bool";
rs.prototype.ValueBufferType = Array;
rs.prototype.DefaultInterpolation = zs;
rs.prototype.InterpolantFactoryMethodLinear = void 0;
rs.prototype.InterpolantFactoryMethodSmooth = void 0;
class ih extends bn {}
ih.prototype.ValueTypeName = "color";
class Vs extends bn {}
Vs.prototype.ValueTypeName = "number";
class ep extends Qs {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = (n - t) / (i - t);
    let c = e * o;
    for (let h = c + o; c !== h; c += 4) et.slerpFlat(s, 0, a, c - o, a, c, l);
    return s;
  }
}
class bi extends bn {
  InterpolantFactoryMethodLinear(e) {
    return new ep(this.times, this.values, this.getValueSize(), e);
  }
}
bi.prototype.ValueTypeName = "quaternion";
bi.prototype.DefaultInterpolation = ns;
bi.prototype.InterpolantFactoryMethodSmooth = void 0;
class as extends bn {}
as.prototype.ValueTypeName = "string";
as.prototype.ValueBufferType = Array;
as.prototype.DefaultInterpolation = zs;
as.prototype.InterpolantFactoryMethodLinear = void 0;
as.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ws extends bn {}
Ws.prototype.ValueTypeName = "vector";
class Xs {
  constructor(e, t = -1, n, i = xo) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = en()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a) t.push(mv(n[a]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, a = n.length; s !== a; ++s) t.push(bn.toJSON(n[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const s = t.length,
      a = [];
    for (let o = 0; o < s; o++) {
      let l = [],
        c = [];
      l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
      const h = jf(l);
      (l = uc(l, 1, h)),
        (c = uc(c, 1, h)),
        !i && l[0] === 0 && (l.push(s), c.push(c[0])),
        a.push(
          new Vs(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        h = c.name.match(s);
      if (h && h.length > 1) {
        const u = h[1];
        let d = i[u];
        d || (i[u] = d = []), d.push(c);
      }
    }
    const a = [];
    for (const o in i)
      a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (u, d, f, m, _) {
        if (f.length !== 0) {
          const g = [],
            p = [];
          th(f, g, p, m), g.length !== 0 && _.push(new u(d, g, p));
        }
      },
      i = [],
      s = e.name || "default",
      a = e.fps || 30,
      o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let u = 0; u < c.length; u++) {
      const d = c[u].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let m;
          for (m = 0; m < d.length; m++)
            if (d[m].morphTargets)
              for (let _ = 0; _ < d[m].morphTargets.length; _++)
                f[d[m].morphTargets[_]] = -1;
          for (const _ in f) {
            const g = [],
              p = [];
            for (let v = 0; v !== d[m].morphTargets.length; ++v) {
              const x = d[m];
              g.push(x.time), p.push(x.morphTarget === _ ? 1 : 0);
            }
            i.push(new Vs(".morphTargetInfluence[" + _ + "]", g, p));
          }
          l = f.length * a;
        } else {
          const f = ".bones[" + t[u].name + "]";
          n(Ws, f + ".position", d, "pos", i),
            n(bi, f + ".quaternion", d, "rot", i),
            n(Ws, f + ".scale", d, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function pv(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Vs;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Ws;
    case "color":
      return ih;
    case "quaternion":
      return bi;
    case "bool":
    case "boolean":
      return rs;
    case "string":
      return as;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function mv(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = pv(r.type);
  if (r.times === void 0) {
    const t = [],
      n = [];
    th(r.keys, t, n, "value"), (r.times = t), (r.values = n);
  }
  return e.parse !== void 0
    ? e.parse(r)
    : new e(r.name, r.times, r.values, r.interpolation);
}
const ss = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  },
};
class sh {
  constructor(e, t, n) {
    const i = this;
    let s = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (h) {
        o++, s === !1 && i.onStart !== void 0 && i.onStart(h, a, o), (s = !0);
      }),
      (this.itemEnd = function (h) {
        a++,
          i.onProgress !== void 0 && i.onProgress(h, a, o),
          a === o && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (h) {
        i.onError !== void 0 && i.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, u) {
        return c.push(h, u), this;
      }),
      (this.removeHandler = function (h) {
        const u = c.indexOf(h);
        return u !== -1 && c.splice(u, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let u = 0, d = c.length; u < d; u += 2) {
          const f = c[u],
            m = c[u + 1];
          if ((f.global && (f.lastIndex = 0), f.test(h))) return m;
        }
        return null;
      });
  }
}
const tp = new sh();
class $t {
  constructor(e) {
    (this.manager = e !== void 0 ? e : tp),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const Wn = {};
class gv extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class vn extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = ss.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Wn[e] !== void 0) {
      Wn[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (Wn[e] = []), Wn[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      o = this.mimeType,
      l = this.responseType;
    fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const h = Wn[e],
            u = c.body.getReader(),
            d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            f = d ? parseInt(d) : 0,
            m = f !== 0;
          let _ = 0;
          const g = new ReadableStream({
            start(p) {
              v();
              function v() {
                u.read().then(({ done: x, value: y }) => {
                  if (x) p.close();
                  else {
                    _ += y.byteLength;
                    const S = new ProgressEvent("progress", {
                      lengthComputable: m,
                      loaded: _,
                      total: f,
                    });
                    for (let w = 0, R = h.length; w < R; w++) {
                      const P = h[w];
                      P.onProgress && P.onProgress(S);
                    }
                    p.enqueue(y), v();
                  }
                });
              }
            },
          });
          return new Response(g);
        } else
          throw new gv(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, o));
          case "json":
            return c.json();
          default:
            if (o === void 0) return c.text();
            {
              const u = /charset="?([^;"\s]*)"?/i.exec(o),
                d = u && u[1] ? u[1].toLowerCase() : void 0,
                f = new TextDecoder(d);
              return c.arrayBuffer().then((m) => f.decode(m));
            }
        }
      })
      .then((c) => {
        ss.add(e, c);
        const h = Wn[e];
        delete Wn[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const f = h[u];
          f.onLoad && f.onLoad(c);
        }
      })
      .catch((c) => {
        const h = Wn[e];
        if (h === void 0) throw (this.manager.itemError(e), c);
        delete Wn[e];
        for (let u = 0, d = h.length; u < d; u++) {
          const f = h[u];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class _v extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new vn(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Xs.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class xv extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = [],
      o = new qc(),
      l = new vn(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let c = 0;
    function h(u) {
      l.load(
        e[u],
        function (d) {
          const f = s.parse(d, !0);
          (a[u] = {
            width: f.width,
            height: f.height,
            format: f.format,
            mipmaps: f.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (f.mipmapCount === 1 && (o.minFilter = ot),
              (o.image = a),
              (o.format = f.format),
              (o.needsUpdate = !0),
              t && t(o));
        },
        n,
        i
      );
    }
    if (Array.isArray(e)) for (let u = 0, d = e.length; u < d; ++u) h(u);
    else
      l.load(
        e,
        function (u) {
          const d = s.parse(u, !0);
          if (d.isCubemap) {
            const f = d.mipmaps.length / d.mipmapCount;
            for (let m = 0; m < f; m++) {
              a[m] = { mipmaps: [] };
              for (let _ = 0; _ < d.mipmapCount; _++)
                a[m].mipmaps.push(d.mipmaps[m * d.mipmapCount + _]),
                  (a[m].format = d.format),
                  (a[m].width = d.width),
                  (a[m].height = d.height);
            }
            o.image = a;
          } else
            (o.image.width = d.width),
              (o.image.height = d.height),
              (o.mipmaps = d.mipmaps);
          d.mipmapCount === 1 && (o.minFilter = ot),
            (o.format = d.format),
            (o.needsUpdate = !0),
            t && t(o);
        },
        n,
        i
      );
    return o;
  }
}
class Ys extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = ss.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = Ir("img");
    function l() {
      h(), ss.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(u) {
      h(), i && i(u), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      o.removeEventListener("load", l, !1),
        o.removeEventListener("error", c, !1);
    }
    return (
      o.addEventListener("load", l, !1),
      o.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class yv extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new Gr();
    s.colorSpace = Oe;
    const a = new Ys(this.manager);
    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
    let o = 0;
    function l(c) {
      a.load(
        e[c],
        function (h) {
          (s.images[c] = h), o++, o === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return s;
  }
}
class vv extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new Ns(),
      o = new vn(this.manager);
    return (
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setPath(this.path),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (l) {
          const c = s.parse(l);
          c &&
            (c.image !== void 0
              ? (a.image = c.image)
              : c.data !== void 0 &&
                ((a.image.width = c.width),
                (a.image.height = c.height),
                (a.image.data = c.data)),
            (a.wrapS = c.wrapS !== void 0 ? c.wrapS : Dt),
            (a.wrapT = c.wrapT !== void 0 ? c.wrapT : Dt),
            (a.magFilter = c.magFilter !== void 0 ? c.magFilter : ot),
            (a.minFilter = c.minFilter !== void 0 ? c.minFilter : ot),
            (a.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0
              ? (a.colorSpace = c.colorSpace)
              : c.encoding !== void 0 && (a.encoding = c.encoding),
            c.flipY !== void 0 && (a.flipY = c.flipY),
            c.format !== void 0 && (a.format = c.format),
            c.type !== void 0 && (a.type = c.type),
            c.mipmaps !== void 0 &&
              ((a.mipmaps = c.mipmaps), (a.minFilter = Dn)),
            c.mipmapCount === 1 && (a.minFilter = ot),
            c.generateMipmaps !== void 0 &&
              (a.generateMipmaps = c.generateMipmaps),
            (a.needsUpdate = !0),
            t && t(a, c));
        },
        n,
        i
      ),
      a
    );
  }
}
class rh extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new ht(),
      a = new Ys(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          (s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        n,
        i
      ),
      s
    );
  }
}
class Ei extends qe {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new de(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class np extends Ei {
  constructor(e, t, n) {
    super(e, n),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(qe.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new de(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const pl = new Ue(),
  Iu = new b(),
  Du = new b();
class ah {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new K(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Ue()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new So()),
      (this._frameExtents = new K(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new tt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    Iu.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Iu),
      Du.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Du),
      t.updateMatrixWorld(),
      pl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(pl),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(pl);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class Mv extends ah {
  constructor() {
    super(new Et(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = ks * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class oh extends Ei {
  constructor(e, t, n = 0, i = Math.PI / 3, s = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(qe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new qe()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new Mv());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Uu = new Ue(),
  ur = new b(),
  ml = new b();
class Sv extends ah {
  constructor() {
    super(new Et(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new K(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new tt(2, 1, 1, 1),
        new tt(0, 1, 1, 1),
        new tt(3, 1, 1, 1),
        new tt(1, 1, 1, 1),
        new tt(3, 0, 1, 1),
        new tt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new b(1, 0, 0),
        new b(-1, 0, 0),
        new b(0, 0, 1),
        new b(0, 0, -1),
        new b(0, 1, 0),
        new b(0, -1, 0),
      ]),
      (this._cubeUps = [
        new b(0, 1, 0),
        new b(0, 1, 0),
        new b(0, 1, 0),
        new b(0, 1, 0),
        new b(0, 0, 1),
        new b(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      ur.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(ur),
      ml.copy(n.position),
      ml.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(ml),
      n.updateMatrixWorld(),
      i.makeTranslation(-ur.x, -ur.y, -ur.z),
      Uu.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Uu);
  }
}
class er extends Ei {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new Sv());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class bv extends ah {
  constructor() {
    super(new Ks(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class lh extends Ei {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(qe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new qe()),
      (this.shadow = new bv());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class ip extends Ei {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class sp extends Ei {
  constructor(e, t, n = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = n),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class rp {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new b());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.282095),
      t.addScaledVector(a[1], 0.488603 * i),
      t.addScaledVector(a[2], 0.488603 * s),
      t.addScaledVector(a[3], 0.488603 * n),
      t.addScaledVector(a[4], 1.092548 * (n * i)),
      t.addScaledVector(a[5], 1.092548 * (i * s)),
      t.addScaledVector(a[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(a[7], 1.092548 * (n * s)),
      t.addScaledVector(a[8], 0.546274 * (n * n - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = this.coefficients;
    return (
      t.copy(a[0]).multiplyScalar(0.886227),
      t.addScaledVector(a[1], 2 * 0.511664 * i),
      t.addScaledVector(a[2], 2 * 0.511664 * s),
      t.addScaledVector(a[3], 2 * 0.511664 * n),
      t.addScaledVector(a[4], 2 * 0.429043 * n * i),
      t.addScaledVector(a[5], 2 * 0.429043 * i * s),
      t.addScaledVector(a[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(a[7], 2 * 0.429043 * n * s),
      t.addScaledVector(a[8], 0.429043 * (n * n - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * n),
      (t[4] = 1.092548 * n * i),
      (t[5] = 1.092548 * i * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * n * s),
      (t[8] = 0.546274 * (n * n - i * i));
  }
}
class Io extends Ei {
  constructor(e = new rp(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class Do extends $t {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, n, i) {
    const s = this,
      a = new vn(s.manager);
    a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function n(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const i = Do.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new de().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== 1 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const a = e.uniforms[s];
        switch (((i.uniforms[s] = {}), a.type)) {
          case "t":
            i.uniforms[s].value = n(a.value);
            break;
          case "c":
            i.uniforms[s].value = new de().setHex(a.value);
            break;
          case "v2":
            i.uniforms[s].value = new K().fromArray(a.value);
            break;
          case "v3":
            i.uniforms[s].value = new b().fromArray(a.value);
            break;
          case "v4":
            i.uniforms[s].value = new tt().fromArray(a.value);
            break;
          case "m3":
            i.uniforms[s].value = new We().fromArray(a.value);
            break;
          case "m4":
            i.uniforms[s].value = new Ue().fromArray(a.value);
            break;
          default:
            i.uniforms[s].value = a.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = n(e.map)),
      e.matcap !== void 0 && (i.matcap = n(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new K().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = n(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = n(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = n(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = n(e.envMap)),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new K().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = n(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: Vf,
      SpriteMaterial: Ao,
      RawShaderMaterial: Wf,
      ShaderMaterial: cn,
      PointsMaterial: Ro,
      MeshPhysicalMaterial: Nn,
      MeshStandardMaterial: na,
      MeshPhongMaterial: Xf,
      MeshToonMaterial: Yf,
      MeshNormalMaterial: qf,
      MeshLambertMaterial: Zf,
      MeshDepthMaterial: zc,
      MeshDistanceMaterial: kc,
      MeshBasicMaterial: Ut,
      MeshMatcapMaterial: $f,
      LineDashedMaterial: Kf,
      LineBasicMaterial: Nt,
      Material: At,
    };
    return new t[e]();
  }
}
class qs {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class ap extends He {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class op extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new vn(s.manager);
    a.setPath(s.path),
      a.setRequestHeader(s.requestHeader),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (o) {
          try {
            t(s.parse(JSON.parse(o)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        n,
        i
      );
  }
  parse(e) {
    const t = {},
      n = {};
    function i(f, m) {
      if (t[m] !== void 0) return t[m];
      const g = f.interleavedBuffers[m],
        p = s(f, g.buffer),
        v = Ps(g.type, p),
        x = new Vr(v, g.stride);
      return (x.uuid = g.uuid), (t[m] = x), x;
    }
    function s(f, m) {
      if (n[m] !== void 0) return n[m];
      const g = f.arrayBuffers[m],
        p = new Uint32Array(g).buffer;
      return (n[m] = p), p;
    }
    const a = e.isInstancedBufferGeometry ? new ap() : new He(),
      o = e.data.index;
    if (o !== void 0) {
      const f = Ps(o.type, o.array);
      a.setIndex(new nt(f, 1));
    }
    const l = e.data.attributes;
    for (const f in l) {
      const m = l[f];
      let _;
      if (m.isInterleavedBufferAttribute) {
        const g = i(e.data, m.data);
        _ = new Si(g, m.itemSize, m.offset, m.normalized);
      } else {
        const g = Ps(m.type, m.array),
          p = m.isInstancedBufferAttribute ? Gs : nt;
        _ = new p(g, m.itemSize, m.normalized);
      }
      m.name !== void 0 && (_.name = m.name),
        m.usage !== void 0 && _.setUsage(m.usage),
        m.updateRange !== void 0 &&
          ((_.updateRange.offset = m.updateRange.offset),
          (_.updateRange.count = m.updateRange.count)),
        a.setAttribute(f, _);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const f in c) {
        const m = c[f],
          _ = [];
        for (let g = 0, p = m.length; g < p; g++) {
          const v = m[g];
          let x;
          if (v.isInterleavedBufferAttribute) {
            const y = i(e.data, v.data);
            x = new Si(y, v.itemSize, v.offset, v.normalized);
          } else {
            const y = Ps(v.type, v.array);
            x = new nt(y, v.itemSize, v.normalized);
          }
          v.name !== void 0 && (x.name = v.name), _.push(x);
        }
        a.morphAttributes[f] = _;
      }
    e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
    const u = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (u !== void 0)
      for (let f = 0, m = u.length; f !== m; ++f) {
        const _ = u[f];
        a.addGroup(_.start, _.count, _.materialIndex);
      }
    const d = e.data.boundingSphere;
    if (d !== void 0) {
      const f = new b();
      d.center !== void 0 && f.fromArray(d.center),
        (a.boundingSphere = new hn(f, d.radius));
    }
    return (
      e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
    );
  }
}
class wv extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = this.path === "" ? qs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || a;
    const o = new vn(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (u) {
            i !== void 0 && i(u),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                u.message
              );
            return;
          }
          const h = c.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(c, t);
        },
        n,
        i
      );
  }
  async loadAsync(e, t) {
    const n = this,
      i = this.path === "" ? qs.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new vn(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const a = await s.loadAsync(e, t),
      o = JSON.parse(a),
      l = o.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(o);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      a = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      o = this.parseTextures(e.textures, a),
      l = this.parseMaterials(e.materials, o),
      c = this.parseObject(e.object, s, l, o, n),
      h = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, h), t !== void 0)) {
      let u = !1;
      for (const d in a)
        if (a[d].data instanceof HTMLImageElement) {
          u = !0;
          break;
        }
      u === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      n = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, n),
      s = await this.parseImagesAsync(e.images),
      a = this.parseTextures(e.textures, s),
      o = this.parseMaterials(e.materials, a),
      l = this.parseObject(e.object, i, o, a, t),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const s = new Qi().fromJSON(e[n]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {},
      i = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, a = e.length; s < a; s++) {
        const o = new Wr().fromJSON(e[s], i);
        n[o.uuid] = o;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new op();
      for (let s = 0, a = e.length; s < a; s++) {
        let o;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            o = i.parse(l);
            break;
          default:
            l.type in Lu
              ? (o = Lu[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (o.uuid = l.uuid),
          l.name !== void 0 && (o.name = l.name),
          l.userData !== void 0 && (o.userData = l.userData),
          (n[l.uuid] = o);
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {},
      i = {};
    if (e !== void 0) {
      const s = new Do();
      s.setTextures(t);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a];
        n[l.uuid] === void 0 && (n[l.uuid] = s.parse(l)),
          (i[l.uuid] = n[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n],
          s = Xs.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this,
      i = {};
    let s;
    function a(l) {
      return (
        n.manager.itemStart(l),
        s.load(
          l,
          function () {
            n.manager.itemEnd(l);
          },
          void 0,
          function () {
            n.manager.itemError(l), n.manager.itemEnd(l);
          }
        )
      );
    }
    function o(l) {
      if (typeof l == "string") {
        const c = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
        return a(h);
      } else
        return l.data
          ? { data: Ps(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new sh(t);
      (s = new Ys(l)), s.setCrossOrigin(this.crossOrigin);
      for (let c = 0, h = e.length; c < h; c++) {
        const u = e[c],
          d = u.url;
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, _ = d.length; m < _; m++) {
            const g = d[m],
              p = o(g);
            p !== null &&
              (p instanceof HTMLImageElement
                ? f.push(p)
                : f.push(new Ns(p.data, p.width, p.height)));
          }
          i[u.uuid] = new Zi(f);
        } else {
          const f = o(u.url);
          i[u.uuid] = new Zi(f);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      n = {};
    let i;
    async function s(a) {
      if (typeof a == "string") {
        const o = a,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(o) ? o : t.resourcePath + o;
        return await i.loadAsync(l);
      } else
        return a.data
          ? { data: Ps(a.type, a.data), width: a.width, height: a.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new Ys(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let a = 0, o = e.length; a < o; a++) {
        const l = e[a],
          c = l.url;
        if (Array.isArray(c)) {
          const h = [];
          for (let u = 0, d = c.length; u < d; u++) {
            const f = c[u],
              m = await s(f);
            m !== null &&
              (m instanceof HTMLImageElement
                ? h.push(m)
                : h.push(new Ns(m.data, m.width, m.height)));
          }
          n[l.uuid] = new Zi(h);
        } else {
          const h = await s(l.url);
          n[l.uuid] = new Zi(h);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(s, a) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          a[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, a = e.length; s < a; s++) {
        const o = e[s];
        o.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
          t[o.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", o.image);
        const l = t[o.image],
          c = l.data;
        let h;
        Array.isArray(c)
          ? ((h = new Gr()), c.length === 6 && (h.needsUpdate = !0))
          : (c && c.data ? (h = new Ns()) : (h = new ht()),
            c && (h.needsUpdate = !0)),
          (h.source = l),
          (h.uuid = o.uuid),
          o.name !== void 0 && (h.name = o.name),
          o.mapping !== void 0 && (h.mapping = n(o.mapping, Ev)),
          o.channel !== void 0 && (h.channel = o.channel),
          o.offset !== void 0 && h.offset.fromArray(o.offset),
          o.repeat !== void 0 && h.repeat.fromArray(o.repeat),
          o.center !== void 0 && h.center.fromArray(o.center),
          o.rotation !== void 0 && (h.rotation = o.rotation),
          o.wrap !== void 0 &&
            ((h.wrapS = n(o.wrap[0], Nu)), (h.wrapT = n(o.wrap[1], Nu))),
          o.format !== void 0 && (h.format = o.format),
          o.internalFormat !== void 0 && (h.internalFormat = o.internalFormat),
          o.type !== void 0 && (h.type = o.type),
          o.colorSpace !== void 0 && (h.colorSpace = o.colorSpace),
          o.encoding !== void 0 && (h.encoding = o.encoding),
          o.minFilter !== void 0 && (h.minFilter = n(o.minFilter, Ou)),
          o.magFilter !== void 0 && (h.magFilter = n(o.magFilter, Ou)),
          o.anisotropy !== void 0 && (h.anisotropy = o.anisotropy),
          o.flipY !== void 0 && (h.flipY = o.flipY),
          o.generateMipmaps !== void 0 &&
            (h.generateMipmaps = o.generateMipmaps),
          o.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = o.premultiplyAlpha),
          o.unpackAlignment !== void 0 &&
            (h.unpackAlignment = o.unpackAlignment),
          o.compareFunction !== void 0 &&
            (h.compareFunction = o.compareFunction),
          o.userData !== void 0 && (h.userData = o.userData),
          (i[o.uuid] = h);
      }
    return i;
  }
  parseObject(e, t, n, i, s) {
    let a;
    function o(d) {
      return (
        t[d] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", d),
        t[d]
      );
    }
    function l(d) {
      if (d !== void 0) {
        if (Array.isArray(d)) {
          const f = [];
          for (let m = 0, _ = d.length; m < _; m++) {
            const g = d[m];
            n[g] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", g),
              f.push(n[g]);
          }
          return f;
        }
        return (
          n[d] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", d),
          n[d]
        );
      }
    }
    function c(d) {
      return (
        i[d] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", d),
        i[d]
      );
    }
    let h, u;
    switch (e.type) {
      case "Scene":
        (a = new Gc()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (a.background = new de(e.background))
              : (a.background = c(e.background))),
          e.environment !== void 0 && (a.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (a.fog = new Eo(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (a.fog = new wo(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (a.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (a.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (a = new Et(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (a.focus = e.focus),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (a = new Ks(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (a.zoom = e.zoom),
          e.view !== void 0 && (a.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        a = new ip(e.color, e.intensity);
        break;
      case "DirectionalLight":
        a = new lh(e.color, e.intensity);
        break;
      case "PointLight":
        a = new er(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        a = new sp(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        a = new oh(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        a = new np(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        a = new Io().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = o(e.geometry)),
          (u = l(e.material)),
          (a = new Vc(h, u)),
          e.bindMode !== void 0 && (a.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (a.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = o(e.geometry)), (u = l(e.material)), (a = new ce(h, u));
        break;
      case "InstancedMesh":
        (h = o(e.geometry)), (u = l(e.material));
        const d = e.count,
          f = e.instanceMatrix,
          m = e.instanceColor;
        (a = new Wc(h, u, d)),
          (a.instanceMatrix = new Gs(new Float32Array(f.array), 16)),
          m !== void 0 &&
            (a.instanceColor = new Gs(new Float32Array(m.array), m.itemSize));
        break;
      case "LOD":
        a = new Lf();
        break;
      case "Line":
        a = new It(o(e.geometry), l(e.material));
        break;
      case "LineLoop":
        a = new Xc(o(e.geometry), l(e.material));
        break;
      case "LineSegments":
        a = new Mn(o(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        a = new Yc(o(e.geometry), l(e.material));
        break;
      case "Sprite":
        a = new di(l(e.material));
        break;
      case "Group":
        a = new $n();
        break;
      case "Bone":
        a = new To();
        break;
      default:
        a = new qe();
    }
    if (
      ((a.uuid = e.uuid),
      e.name !== void 0 && (a.name = e.name),
      e.matrix !== void 0
        ? (a.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (a.matrixAutoUpdate = e.matrixAutoUpdate),
          a.matrixAutoUpdate &&
            a.matrix.decompose(a.position, a.quaternion, a.scale))
        : (e.position !== void 0 && a.position.fromArray(e.position),
          e.rotation !== void 0 && a.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && a.scale.fromArray(e.scale)),
      e.up !== void 0 && a.up.fromArray(e.up),
      e.castShadow !== void 0 && (a.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (a.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          a.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (a.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (a.visible = e.visible),
      e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder),
      e.userData !== void 0 && (a.userData = e.userData),
      e.layers !== void 0 && (a.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const d = e.children;
      for (let f = 0; f < d.length; f++)
        a.add(this.parseObject(d[f], t, n, i, s));
    }
    if (e.animations !== void 0) {
      const d = e.animations;
      for (let f = 0; f < d.length; f++) {
        const m = d[f];
        a.animations.push(s[m]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
      const d = e.levels;
      for (let f = 0; f < d.length; f++) {
        const m = d[f],
          _ = a.getObjectByProperty("uuid", m.object);
        _ !== void 0 && a.addLevel(_, m.distance, m.hysteresis);
      }
    }
    return a;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (n) {
        if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
          const i = t[n.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                n.skeleton
              )
            : n.bind(i, n.bindMatrix);
        }
      });
  }
}
const Ev = {
    UVMapping: mo,
    CubeReflectionMapping: yi,
    CubeRefractionMapping: vi,
    EquirectangularReflectionMapping: Er,
    EquirectangularRefractionMapping: Ar,
    CubeUVReflectionMapping: Zs,
  },
  Nu = {
    RepeatWrapping: Mi,
    ClampToEdgeWrapping: Dt,
    MirroredRepeatWrapping: Fs,
  },
  Ou = {
    NearestFilter: gt,
    NearestMipmapNearestFilter: Tr,
    NearestMipmapLinearFilter: Ds,
    LinearFilter: ot,
    LinearMipmapNearestFilter: go,
    LinearMipmapLinearFilter: Dn,
  };
class lp extends $t {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = ss.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = {};
    (o.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (o.headers = this.requestHeader),
      fetch(e, o)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          ss.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
let Ha;
class ch {
  static getContext() {
    return (
      Ha === void 0 &&
        (Ha = new (window.AudioContext || window.webkitAudioContext)()),
      Ha
    );
  }
  static setContext(e) {
    Ha = e;
  }
}
class Av extends $t {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = this,
      a = new vn(this.manager);
    a.setResponseType("arraybuffer"),
      a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            ch.getContext().decodeAudioData(
              c,
              function (u) {
                t(u);
              },
              o
            );
          } catch (c) {
            o(c);
          }
        },
        n,
        i
      );
    function o(l) {
      i ? i(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
class Tv extends Io {
  constructor(e, t, n = 1) {
    super(void 0, n), (this.isHemisphereLightProbe = !0);
    const i = new de().set(e),
      s = new de().set(t),
      a = new b(i.r, i.g, i.b),
      o = new b(s.r, s.g, s.b),
      l = Math.sqrt(Math.PI),
      c = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(a).add(o).multiplyScalar(l),
      this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c);
  }
}
class Rv extends Io {
  constructor(e, t = 1) {
    super(void 0, t), (this.isAmbientLightProbe = !0);
    const n = new de().set(e);
    this.sh.coefficients[0]
      .set(n.r, n.g, n.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const Fu = new Ue(),
  Bu = new Ue(),
  Di = new Ue();
class Cv {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Et()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Et()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Di.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        s = (i * t.near) / t.focus,
        a = (t.near * Math.tan(Ji * t.fov * 0.5)) / t.zoom;
      let o, l;
      (Bu.elements[12] = -i),
        (Fu.elements[12] = i),
        (o = -a * t.aspect + s),
        (l = a * t.aspect + s),
        (Di.elements[0] = (2 * t.near) / (l - o)),
        (Di.elements[8] = (l + o) / (l - o)),
        this.cameraL.projectionMatrix.copy(Di),
        (o = -a * t.aspect - s),
        (l = a * t.aspect - s),
        (Di.elements[0] = (2 * t.near) / (l - o)),
        (Di.elements[8] = (l + o) / (l - o)),
        this.cameraR.projectionMatrix.copy(Di);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Bu),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Fu);
  }
}
class hh {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = zu()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = zu();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function zu() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Ui = new b(),
  ku = new et(),
  Pv = new b(),
  Ni = new b();
class Lv extends qe {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = ch.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new hh());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      n = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(Ui, ku, Pv),
      Ni.set(0, 0, -1).applyQuaternion(ku),
      t.positionX)
    ) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Ui.x, i),
        t.positionY.linearRampToValueAtTime(Ui.y, i),
        t.positionZ.linearRampToValueAtTime(Ui.z, i),
        t.forwardX.linearRampToValueAtTime(Ni.x, i),
        t.forwardY.linearRampToValueAtTime(Ni.y, i),
        t.forwardZ.linearRampToValueAtTime(Ni.z, i),
        t.upX.linearRampToValueAtTime(n.x, i),
        t.upY.linearRampToValueAtTime(n.y, i),
        t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(Ui.x, Ui.y, Ui.z),
        t.setOrientation(Ni.x, Ni.y, Ni.z, n.x, n.y, n.z);
  }
}
class cp extends qe {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Oi = new b(),
  Hu = new et(),
  Iv = new b(),
  Fi = new b();
class Dv extends cp {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, n) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = n),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Oi, Hu, Iv), Fi.set(0, 0, 1).applyQuaternion(Hu);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Oi.x, n),
        t.positionY.linearRampToValueAtTime(Oi.y, n),
        t.positionZ.linearRampToValueAtTime(Oi.z, n),
        t.orientationX.linearRampToValueAtTime(Fi.x, n),
        t.orientationY.linearRampToValueAtTime(Fi.y, n),
        t.orientationZ.linearRampToValueAtTime(Fi.z, n);
    } else t.setPosition(Oi.x, Oi.y, Oi.z), t.setOrientation(Fi.x, Fi.y, Fi.z);
  }
}
class Uv {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++) e += t[n];
    return e / t.length;
  }
}
class hp {
  constructor(e, t, n) {
    (this.binding = e), (this.valueSize = n);
    let i, s, a;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (a = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (a = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (a = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = a),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const n = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let a = this.cumulativeWeight;
    if (a === 0) {
      for (let o = 0; o !== i; ++o) n[s + o] = n[o];
      a = t;
    } else {
      a += t;
      const o = t / a;
      this._mixBufferRegion(n, s, 0, o, i);
    }
    this.cumulativeWeight = a;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, n),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      n = this.buffer,
      i = e * t + t,
      s = this.cumulativeWeight,
      a = this.cumulativeWeightAdditive,
      o = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(n, i, l, 1 - s, t);
    }
    a > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (n[l] !== n[l + t]) {
        o.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    e.getValue(t, i);
    for (let s = n, a = i; s !== a; ++s) t[s] = t[i + (s % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let n = e; n < t; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  _select(e, t, n, i, s) {
    if (i >= 0.5) for (let a = 0; a !== s; ++a) e[t + a] = e[n + a];
  }
  _slerp(e, t, n, i) {
    et.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, s) {
    const a = this._workIndex * s;
    et.multiplyQuaternionsFlat(e, a, e, t, e, n),
      et.slerpFlat(e, t, e, t, e, a, i);
  }
  _lerp(e, t, n, i, s) {
    const a = 1 - i;
    for (let o = 0; o !== s; ++o) {
      const l = t + o;
      e[l] = e[l] * a + e[n + o] * i;
    }
  }
  _lerpAdditive(e, t, n, i, s) {
    for (let a = 0; a !== s; ++a) {
      const o = t + a;
      e[o] = e[o] + e[n + a] * i;
    }
  }
}
const uh = "\\[\\]\\.:\\/",
  Nv = new RegExp("[" + uh + "]", "g"),
  dh = "[^" + uh + "]",
  Ov = "[^" + uh.replace("\\.", "") + "]",
  Fv = /((?:WC+[\/:])*)/.source.replace("WC", dh),
  Bv = /(WCOD+)?/.source.replace("WCOD", Ov),
  zv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", dh),
  kv = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", dh),
  Hv = new RegExp("^" + Fv + Bv + zv + kv + "$"),
  Gv = ["material", "materials", "bones", "map"];
class Vv {
  constructor(e, t, n) {
    const i = n || Je.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Je {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || Je.parseTrackName(t)),
      (this.node = Je.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new Je.Composite(e, t, n)
      : new Je(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Nv, "");
  }
  static parseTrackName(e) {
    const t = Hv.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = n.nodeName.substring(i + 1);
      Gv.indexOf(s) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = s));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (s) {
          for (let a = 0; a < s.length; a++) {
            const o = s[a];
            if (o.name === t || o.uuid === t) return o;
            const l = n(o.children);
            if (l) return l;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Je.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let o = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (o = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = s);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][o]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Je.Composite = Vv;
Je.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Je.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Je.prototype.GetterByBindingType = [
  Je.prototype._getValue_direct,
  Je.prototype._getValue_array,
  Je.prototype._getValue_arrayElement,
  Je.prototype._getValue_toArray,
];
Je.prototype.SetterByBindingTypeAndVersioning = [
  [
    Je.prototype._setValue_direct,
    Je.prototype._setValue_direct_setNeedsUpdate,
    Je.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Je.prototype._setValue_array,
    Je.prototype._setValue_array_setNeedsUpdate,
    Je.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Je.prototype._setValue_arrayElement,
    Je.prototype._setValue_arrayElement_setNeedsUpdate,
    Je.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Je.prototype._setValue_fromArray,
    Je.prototype._setValue_fromArray_setNeedsUpdate,
    Je.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class Wv {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = en()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      a = s.length;
    let o,
      l = e.length,
      c = this.nCachedObjects_;
    for (let h = 0, u = arguments.length; h !== u; ++h) {
      const d = arguments[h],
        f = d.uuid;
      let m = t[f];
      if (m === void 0) {
        (m = l++), (t[f] = m), e.push(d);
        for (let _ = 0, g = a; _ !== g; ++_) s[_].push(new Je(d, n[_], i[_]));
      } else if (m < c) {
        o = e[m];
        const _ = --c,
          g = e[_];
        (t[g.uuid] = m), (e[m] = g), (t[f] = _), (e[_] = d);
        for (let p = 0, v = a; p !== v; ++p) {
          const x = s[p],
            y = x[_];
          let S = x[m];
          (x[m] = y), S === void 0 && (S = new Je(d, n[p], i[p])), (x[_] = S);
        }
      } else
        e[m] !== o &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let s = this.nCachedObjects_;
    for (let a = 0, o = arguments.length; a !== o; ++a) {
      const l = arguments[a],
        c = l.uuid,
        h = t[c];
      if (h !== void 0 && h >= s) {
        const u = s++,
          d = e[u];
        (t[d.uuid] = h), (e[h] = d), (t[c] = u), (e[u] = l);
        for (let f = 0, m = i; f !== m; ++f) {
          const _ = n[f],
            g = _[u],
            p = _[h];
          (_[h] = g), (_[u] = p);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      n = this._bindings,
      i = n.length;
    let s = this.nCachedObjects_,
      a = e.length;
    for (let o = 0, l = arguments.length; o !== l; ++o) {
      const c = arguments[o],
        h = c.uuid,
        u = t[h];
      if (u !== void 0)
        if ((delete t[h], u < s)) {
          const d = --s,
            f = e[d],
            m = --a,
            _ = e[m];
          (t[f.uuid] = u), (e[u] = f), (t[_.uuid] = d), (e[d] = _), e.pop();
          for (let g = 0, p = i; g !== p; ++g) {
            const v = n[g],
              x = v[d],
              y = v[m];
            (v[u] = x), (v[d] = y), v.pop();
          }
        } else {
          const d = --a,
            f = e[d];
          d > 0 && (t[f.uuid] = u), (e[u] = f), e.pop();
          for (let m = 0, _ = i; m !== _; ++m) {
            const g = n[m];
            (g[u] = g[d]), g.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const a = this._paths,
      o = this._parsedPaths,
      l = this._objects,
      c = l.length,
      h = this.nCachedObjects_,
      u = new Array(c);
    (i = s.length), (n[e] = i), a.push(e), o.push(t), s.push(u);
    for (let d = h, f = l.length; d !== f; ++d) {
      const m = l[d];
      u[d] = new Je(m, e, t);
    }
    return u;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      n = t[e];
    if (n !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        a = this._bindings,
        o = a.length - 1,
        l = a[o],
        c = e[o];
      (t[c] = n),
        (a[n] = l),
        a.pop(),
        (s[n] = s[o]),
        s.pop(),
        (i[n] = i[o]),
        i.pop();
    }
  }
}
class up {
  constructor(e, t, n = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = n),
      (this.blendMode = i);
    const s = t.tracks,
      a = s.length,
      o = new Array(a),
      l = { endingStart: Yi, endingEnd: Yi };
    for (let c = 0; c !== a; ++c) {
      const h = s[c].createInterpolant(null);
      (o[c] = h), (h.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = o),
      (this._propertyBindings = new Array(a)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = jd),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if ((e.fadeOut(t), this.fadeIn(t), n)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        a = s / i,
        o = i / s;
      e.warp(1, a, t), this.warp(o, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer,
      s = i.time,
      a = this.timeScale;
    let o = this._timeScaleInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o));
    const l = o.parameterPositions,
      c = o.sampleValues;
    return (l[0] = s), (l[1] = s + n), (c[0] = e / a), (c[1] = t / a), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * n;
      l < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * l));
    }
    t *= this._updateTimeScale(e);
    const a = this._updateTime(t),
      o = this._updateWeight(e);
    if (o > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Pc:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulateAdditive(o);
          break;
        case xo:
        default:
          for (let h = 0, u = l.length; h !== u; ++h)
            l[h].evaluate(a), c[h].accumulate(i, o);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        (t *= i),
          e > n.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      n = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const a = n === Jd;
    if (e === 0) return s === -1 ? i : a && (s & 1) === 1 ? t - i : i;
    if (n === Kd) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, a))
            : this._setEndings(this.repetitions === 0, !0, a)),
        i >= t || i < 0)
      ) {
        const o = Math.floor(i / t);
        (i -= t * o), (s += Math.abs(o));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, a);
          } else this._setEndings(!1, !1, a);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: o,
            });
        }
      } else this.time = i;
      if (a && (s & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = qi), (i.endingEnd = qi))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? qi : Yi)
          : (i.endingStart = Rr),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? qi : Yi) : (i.endingEnd = Rr));
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer,
      s = i.time;
    let a = this._weightInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._weightInterpolant = a));
    const o = a.parameterPositions,
      l = a.sampleValues;
    return (o[0] = s), (l[0] = t), (o[1] = s + e), (l[1] = n), this;
  }
}
const Xv = new Float32Array(1);
class dp extends Un {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      a = e._propertyBindings,
      o = e._interpolants,
      l = n.uuid,
      c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && ((h = {}), (c[l] = h));
    for (let u = 0; u !== s; ++u) {
      const d = i[u],
        f = d.name;
      let m = h[f];
      if (m !== void 0) ++m.referenceCount, (a[u] = m);
      else {
        if (((m = a[u]), m !== void 0)) {
          m._cacheIndex === null &&
            (++m.referenceCount, this._addInactiveBinding(m, l, f));
          continue;
        }
        const _ = t && t._propertyBindings[u].binding.parsedPath;
        (m = new hp(Je.create(n, f, _), d.ValueTypeName, d.getValueSize())),
          ++m.referenceCount,
          this._addInactiveBinding(m, l, f),
          (a[u] = m);
      }
      o[u].resultBuffer = m.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = t[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const s = t[n];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions,
      s = this._actionsByClip;
    let a = s[t];
    if (a === void 0)
      (a = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = a);
    else {
      const o = a.knownActions;
      (e._byClipCacheIndex = o.length), o.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (a.actionByRoot[n] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      n = t[t.length - 1],
      i = e._cacheIndex;
    (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      a = this._actionsByClip,
      o = a[s],
      l = o.knownActions,
      c = l[l.length - 1],
      h = e._byClipCacheIndex;
    (c._byClipCacheIndex = h),
      (l[h] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const u = o.actionByRoot,
      d = (e._localRoot || this._root).uuid;
    delete u[d],
      l.length === 0 && delete a[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const s = t[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = this._nActiveActions++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      n = e._cacheIndex,
      i = --this._nActiveActions,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let a = i[t];
    a === void 0 && ((a = {}), (i[t] = a)),
      (a[n] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      n = e.binding,
      i = n.rootNode.uuid,
      s = n.path,
      a = this._bindingsByRootAndName,
      o = a[i],
      l = t[t.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete o[s],
      Object.keys(o).length === 0 && delete a[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = this._nActiveBindings++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      n = e._cacheIndex,
      i = --this._nActiveBindings,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = n), (t[n] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let n = e[t];
    return (
      n === void 0 &&
        ((n = new nh(new Float32Array(2), new Float32Array(2), 1, Xv)),
        (n.__cacheIndex = t),
        (e[t] = n)),
      n
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      n = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = t[i];
    (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = n), (t[n] = s);
  }
  clipAction(e, t, n) {
    const i = t || this._root,
      s = i.uuid;
    let a = typeof e == "string" ? Xs.findByName(i, e) : e;
    const o = a !== null ? a.uuid : e,
      l = this._actionsByClip[o];
    let c = null;
    if (
      (n === void 0 && (a !== null ? (n = a.blendMode) : (n = xo)),
      l !== void 0)
    ) {
      const u = l.actionByRoot[s];
      if (u !== void 0 && u.blendMode === n) return u;
      (c = l.knownActions[0]), a === null && (a = c._clip);
    }
    if (a === null) return null;
    const h = new up(this, a, t, n);
    return this._bindAction(h, c), this._addInactiveAction(h, o, s), h;
  }
  existingAction(e, t) {
    const n = t || this._root,
      i = n.uuid,
      s = typeof e == "string" ? Xs.findByName(n, e) : e,
      a = s ? s.uuid : e,
      o = this._actionsByClip[a];
    return (o !== void 0 && o.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n) e[n].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      n = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      a = (this._accuIndex ^= 1);
    for (let c = 0; c !== n; ++c) t[c]._update(i, e, s, a);
    const o = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) o[c].apply(a);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      n = e.uuid,
      i = this._actionsByClip,
      s = i[n];
    if (s !== void 0) {
      const a = s.knownActions;
      for (let o = 0, l = a.length; o !== l; ++o) {
        const c = a[o];
        this._deactivateAction(c);
        const h = c._cacheIndex,
          u = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (u._cacheIndex = h),
          (t[h] = u),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[n];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      n = this._actionsByClip;
    for (const a in n) {
      const o = n[a].actionByRoot,
        l = o[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      s = i[t];
    if (s !== void 0)
      for (const a in s) {
        const o = s[a];
        o.restoreOriginalState(), this._removeInactiveBinding(o);
      }
  }
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class fh {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new fh(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let Yv = 0;
class qv extends Un {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: Yv++ }),
      (this.name = ""),
      (this.usage = Cr),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) this.uniforms.push(t[n].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zv extends Vr {
  constructor(e, t, n = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class $v {
  constructor(e, t, n, i, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = n),
      (this.elementSize = i),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class ph {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new $s(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new vo()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return dc(e, this, n, t), n.sort(Gu), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, s = e.length; i < s; i++) dc(e[i], this, n, t);
    return n.sort(Gu), n;
  }
}
function Gu(r, e) {
  return r.distance - e.distance;
}
function dc(r, e, t, n) {
  if ((r.layers.test(e.layers) && r.raycast(e, t), n === !0)) {
    const i = r.children;
    for (let s = 0, a = i.length; s < a; s++) dc(i[s], e, t, !0);
  }
}
class fc {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos(_t(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Kv {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.theta = t), (this.y = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + n * n)),
      (this.theta = Math.atan2(e, n)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Vu = new K();
class jv {
  constructor(e = new K(1 / 0, 1 / 0), t = new K(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Vu.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Vu).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Wu = new b(),
  Ga = new b();
class fp {
  constructor(e = new b(), t = new b()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    Wu.subVectors(e, this.start), Ga.subVectors(this.end, this.start);
    const n = Ga.dot(Ga);
    let s = Ga.dot(Wu) / n;
    return t && (s = _t(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Xu = new b();
class Jv extends qe {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const n = new He(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let a = 0, o = 1, l = 32; a < l; a++, o++) {
      const c = (a / l) * Math.PI * 2,
        h = (o / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1);
    }
    n.setAttribute("position", new Te(i, 3));
    const s = new Nt({ fog: !1, toneMapped: !1 });
    (this.cone = new Mn(n, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      Xu.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(Xu),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const oi = new b(),
  Va = new Ue(),
  gl = new Ue();
class Qv extends Mn {
  constructor(e) {
    const t = pp(e),
      n = new He(),
      i = [],
      s = [],
      a = new de(0, 0, 1),
      o = new de(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.parent &&
        h.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        s.push(a.r, a.g, a.b),
        s.push(o.r, o.g, o.b));
    }
    n.setAttribute("position", new Te(i, 3)),
      n.setAttribute("color", new Te(s, 3));
    const l = new Nt({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    gl.copy(this.root.matrixWorld).invert();
    for (let s = 0, a = 0; s < t.length; s++) {
      const o = t[s];
      o.parent &&
        o.parent.isBone &&
        (Va.multiplyMatrices(gl, o.matrixWorld),
        oi.setFromMatrixPosition(Va),
        i.setXYZ(a, oi.x, oi.y, oi.z),
        Va.multiplyMatrices(gl, o.parent.matrixWorld),
        oi.setFromMatrixPosition(Va),
        i.setXYZ(a + 1, oi.x, oi.y, oi.z),
        (a += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function pp(r) {
  const e = [];
  r.isBone === !0 && e.push(r);
  for (let t = 0; t < r.children.length; t++)
    e.push.apply(e, pp(r.children[t]));
  return e;
}
class eM extends ce {
  constructor(e, t, n) {
    const i = new ti(t, 4, 2),
      s = new Ut({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = n),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const tM = new b(),
  Yu = new de(),
  qu = new de();
class nM extends qe {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "HemisphereLightHelper");
    const i = new Cn(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Ut({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      a = new Float32Array(s.count * 3);
    i.setAttribute("color", new nt(a, 3)),
      this.add(new ce(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      Yu.copy(this.light.color), qu.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const s = n < i / 2 ? Yu : qu;
        t.setXYZ(n, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(tM.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class iM extends Mn {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    (n = new de(n)), (i = new de(i));
    const s = t / 2,
      a = e / t,
      o = e / 2,
      l = [],
      c = [];
    for (let d = 0, f = 0, m = -o; d <= t; d++, m += a) {
      l.push(-o, 0, m, o, 0, m), l.push(m, 0, -o, m, 0, o);
      const _ = d === s ? n : i;
      _.toArray(c, f),
        (f += 3),
        _.toArray(c, f),
        (f += 3),
        _.toArray(c, f),
        (f += 3),
        _.toArray(c, f),
        (f += 3);
    }
    const h = new He();
    h.setAttribute("position", new Te(l, 3)),
      h.setAttribute("color", new Te(c, 3));
    const u = new Nt({ vertexColors: !0, toneMapped: !1 });
    super(h, u), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class sM extends Mn {
  constructor(e = 10, t = 16, n = 8, i = 64, s = 4473924, a = 8947848) {
    (s = new de(s)), (a = new de(a));
    const o = [],
      l = [];
    if (t > 1)
      for (let u = 0; u < t; u++) {
        const d = (u / t) * (Math.PI * 2),
          f = Math.sin(d) * e,
          m = Math.cos(d) * e;
        o.push(0, 0, 0), o.push(f, 0, m);
        const _ = u & 1 ? s : a;
        l.push(_.r, _.g, _.b), l.push(_.r, _.g, _.b);
      }
    for (let u = 0; u < n; u++) {
      const d = u & 1 ? s : a,
        f = e - (e / n) * u;
      for (let m = 0; m < i; m++) {
        let _ = (m / i) * (Math.PI * 2),
          g = Math.sin(_) * f,
          p = Math.cos(_) * f;
        o.push(g, 0, p),
          l.push(d.r, d.g, d.b),
          (_ = ((m + 1) / i) * (Math.PI * 2)),
          (g = Math.sin(_) * f),
          (p = Math.cos(_) * f),
          o.push(g, 0, p),
          l.push(d.r, d.g, d.b);
      }
    }
    const c = new He();
    c.setAttribute("position", new Te(o, 3)),
      c.setAttribute("color", new Te(l, 3));
    const h = new Nt({ vertexColors: !0, toneMapped: !1 });
    super(c, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Zu = new b(),
  Wa = new b(),
  $u = new b();
class rM extends qe {
  constructor(e, t, n) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new He();
    i.setAttribute(
      "position",
      new Te([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new Nt({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new It(i, s)),
      this.add(this.lightPlane),
      (i = new He()),
      i.setAttribute("position", new Te([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new It(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      Zu.setFromMatrixPosition(this.light.matrixWorld),
      Wa.setFromMatrixPosition(this.light.target.matrixWorld),
      $u.subVectors(Wa, Zu),
      this.lightPlane.lookAt(Wa),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Wa),
      (this.targetLine.scale.z = $u.length());
  }
}
const Xa = new b(),
  pt = new Mo();
class aM extends Mn {
  constructor(e) {
    const t = new He(),
      n = new Nt({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      a = {};
    o("n1", "n2"),
      o("n2", "n4"),
      o("n4", "n3"),
      o("n3", "n1"),
      o("f1", "f2"),
      o("f2", "f4"),
      o("f4", "f3"),
      o("f3", "f1"),
      o("n1", "f1"),
      o("n2", "f2"),
      o("n3", "f3"),
      o("n4", "f4"),
      o("p", "n1"),
      o("p", "n2"),
      o("p", "n3"),
      o("p", "n4"),
      o("u1", "u2"),
      o("u2", "u3"),
      o("u3", "u1"),
      o("c", "t"),
      o("p", "c"),
      o("cn1", "cn2"),
      o("cn3", "cn4"),
      o("cf1", "cf2"),
      o("cf3", "cf4");
    function o(m, _) {
      l(m), l(_);
    }
    function l(m) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        a[m] === void 0 && (a[m] = []),
        a[m].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Te(i, 3)),
      t.setAttribute("color", new Te(s, 3)),
      super(t, n),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
    const c = new de(16755200),
      h = new de(16711680),
      u = new de(43775),
      d = new de(16777215),
      f = new de(3355443);
    this.setColors(c, h, u, d, f);
  }
  setColors(e, t, n, i, s) {
    const o = this.geometry.getAttribute("color");
    o.setXYZ(0, e.r, e.g, e.b),
      o.setXYZ(1, e.r, e.g, e.b),
      o.setXYZ(2, e.r, e.g, e.b),
      o.setXYZ(3, e.r, e.g, e.b),
      o.setXYZ(4, e.r, e.g, e.b),
      o.setXYZ(5, e.r, e.g, e.b),
      o.setXYZ(6, e.r, e.g, e.b),
      o.setXYZ(7, e.r, e.g, e.b),
      o.setXYZ(8, e.r, e.g, e.b),
      o.setXYZ(9, e.r, e.g, e.b),
      o.setXYZ(10, e.r, e.g, e.b),
      o.setXYZ(11, e.r, e.g, e.b),
      o.setXYZ(12, e.r, e.g, e.b),
      o.setXYZ(13, e.r, e.g, e.b),
      o.setXYZ(14, e.r, e.g, e.b),
      o.setXYZ(15, e.r, e.g, e.b),
      o.setXYZ(16, e.r, e.g, e.b),
      o.setXYZ(17, e.r, e.g, e.b),
      o.setXYZ(18, e.r, e.g, e.b),
      o.setXYZ(19, e.r, e.g, e.b),
      o.setXYZ(20, e.r, e.g, e.b),
      o.setXYZ(21, e.r, e.g, e.b),
      o.setXYZ(22, e.r, e.g, e.b),
      o.setXYZ(23, e.r, e.g, e.b),
      o.setXYZ(24, t.r, t.g, t.b),
      o.setXYZ(25, t.r, t.g, t.b),
      o.setXYZ(26, t.r, t.g, t.b),
      o.setXYZ(27, t.r, t.g, t.b),
      o.setXYZ(28, t.r, t.g, t.b),
      o.setXYZ(29, t.r, t.g, t.b),
      o.setXYZ(30, t.r, t.g, t.b),
      o.setXYZ(31, t.r, t.g, t.b),
      o.setXYZ(32, n.r, n.g, n.b),
      o.setXYZ(33, n.r, n.g, n.b),
      o.setXYZ(34, n.r, n.g, n.b),
      o.setXYZ(35, n.r, n.g, n.b),
      o.setXYZ(36, n.r, n.g, n.b),
      o.setXYZ(37, n.r, n.g, n.b),
      o.setXYZ(38, i.r, i.g, i.b),
      o.setXYZ(39, i.r, i.g, i.b),
      o.setXYZ(40, s.r, s.g, s.b),
      o.setXYZ(41, s.r, s.g, s.b),
      o.setXYZ(42, s.r, s.g, s.b),
      o.setXYZ(43, s.r, s.g, s.b),
      o.setXYZ(44, s.r, s.g, s.b),
      o.setXYZ(45, s.r, s.g, s.b),
      o.setXYZ(46, s.r, s.g, s.b),
      o.setXYZ(47, s.r, s.g, s.b),
      o.setXYZ(48, s.r, s.g, s.b),
      o.setXYZ(49, s.r, s.g, s.b),
      (o.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      n = 1,
      i = 1;
    pt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      yt("c", t, e, pt, 0, 0, -1),
      yt("t", t, e, pt, 0, 0, 1),
      yt("n1", t, e, pt, -n, -i, -1),
      yt("n2", t, e, pt, n, -i, -1),
      yt("n3", t, e, pt, -n, i, -1),
      yt("n4", t, e, pt, n, i, -1),
      yt("f1", t, e, pt, -n, -i, 1),
      yt("f2", t, e, pt, n, -i, 1),
      yt("f3", t, e, pt, -n, i, 1),
      yt("f4", t, e, pt, n, i, 1),
      yt("u1", t, e, pt, n * 0.7, i * 1.1, -1),
      yt("u2", t, e, pt, -n * 0.7, i * 1.1, -1),
      yt("u3", t, e, pt, 0, i * 2, -1),
      yt("cf1", t, e, pt, -n, 0, 1),
      yt("cf2", t, e, pt, n, 0, 1),
      yt("cf3", t, e, pt, 0, -i, 1),
      yt("cf4", t, e, pt, 0, i, 1),
      yt("cn1", t, e, pt, -n, 0, -1),
      yt("cn2", t, e, pt, n, 0, -1),
      yt("cn3", t, e, pt, 0, -i, -1),
      yt("cn4", t, e, pt, 0, i, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function yt(r, e, t, n, i, s, a) {
  Xa.set(i, s, a).unproject(n);
  const o = e[r];
  if (o !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = o.length; c < h; c++) l.setXYZ(o[c], Xa.x, Xa.y, Xa.z);
  }
}
const Ya = new Vt();
class oM extends Mn {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new He();
    s.setIndex(new nt(n, 1)),
      s.setAttribute("position", new nt(i, 3)),
      super(s, new Nt({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Ya.setFromObject(this.object),
      Ya.isEmpty())
    )
      return;
    const t = Ya.min,
      n = Ya.max,
      i = this.geometry.attributes.position,
      s = i.array;
    (s[0] = n.x),
      (s[1] = n.y),
      (s[2] = n.z),
      (s[3] = t.x),
      (s[4] = n.y),
      (s[5] = n.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = n.z),
      (s[9] = n.x),
      (s[10] = t.y),
      (s[11] = n.z),
      (s[12] = n.x),
      (s[13] = n.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = n.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = n.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class lM extends Mn {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new He();
    s.setIndex(new nt(n, 1)),
      s.setAttribute("position", new Te(i, 3)),
      super(s, new Nt({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class cM extends It {
  constructor(e, t = 1, n = 16776960) {
    const i = n,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      a = new He();
    a.setAttribute("position", new Te(s, 3)),
      a.computeBoundingSphere(),
      super(a, new Nt({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new He();
    l.setAttribute("position", new Te(o, 3)),
      l.computeBoundingSphere(),
      this.add(
        new ce(
          l,
          new Ut({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const Ku = new b();
let qa, _l;
class hM extends qe {
  constructor(
    e = new b(0, 0, 1),
    t = new b(0, 0, 0),
    n = 1,
    i = 16776960,
    s = n * 0.2,
    a = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      qa === void 0 &&
        ((qa = new He()),
        qa.setAttribute("position", new Te([0, 0, 0, 0, 1, 0], 3)),
        (_l = new mt(0, 0.5, 1, 5, 1)),
        _l.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new It(qa, new Nt({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new ce(_l, new Ut({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(n, s, a);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      Ku.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(Ku, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(n, t, n),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class uM extends Mn {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new He();
    i.setAttribute("position", new Te(t, 3)),
      i.setAttribute("color", new Te(n, 3));
    const s = new Nt({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, t, n) {
    const i = new de(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(t),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(n),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class dM {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new de()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new Dr()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, s, a) {
    return this.currentPath.bezierCurveTo(e, t, n, i, s, a), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(p) {
      const v = [];
      for (let x = 0, y = p.length; x < y; x++) {
        const S = p[x],
          w = new Qi();
        (w.curves = S.curves), v.push(w);
      }
      return v;
    }
    function n(p, v) {
      const x = v.length;
      let y = !1;
      for (let S = x - 1, w = 0; w < x; S = w++) {
        let R = v[S],
          P = v[w],
          M = P.x - R.x,
          A = P.y - R.y;
        if (Math.abs(A) > Number.EPSILON) {
          if (
            (A < 0 && ((R = v[w]), (M = -M), (P = v[S]), (A = -A)),
            p.y < R.y || p.y > P.y)
          )
            continue;
          if (p.y === R.y) {
            if (p.x === R.x) return !0;
          } else {
            const k = A * (p.x - R.x) - M * (p.y - R.y);
            if (k === 0) return !0;
            if (k < 0) continue;
            y = !y;
          }
        } else {
          if (p.y !== R.y) continue;
          if ((P.x <= p.x && p.x <= R.x) || (R.x <= p.x && p.x <= P.x))
            return !0;
        }
      }
      return y;
    }
    const i = Ln.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let a, o, l;
    const c = [];
    if (s.length === 1)
      return (o = s[0]), (l = new Qi()), (l.curves = o.curves), c.push(l), c;
    let h = !i(s[0].getPoints());
    h = e ? !h : h;
    const u = [],
      d = [];
    let f = [],
      m = 0,
      _;
    (d[m] = void 0), (f[m] = []);
    for (let p = 0, v = s.length; p < v; p++)
      (o = s[p]),
        (_ = o.getPoints()),
        (a = i(_)),
        (a = e ? !a : a),
        a
          ? (!h && d[m] && m++,
            (d[m] = { s: new Qi(), p: _ }),
            (d[m].s.curves = o.curves),
            h && m++,
            (f[m] = []))
          : f[m].push({ h: o, p: _[0] });
    if (!d[0]) return t(s);
    if (d.length > 1) {
      let p = !1,
        v = 0;
      for (let x = 0, y = d.length; x < y; x++) u[x] = [];
      for (let x = 0, y = d.length; x < y; x++) {
        const S = f[x];
        for (let w = 0; w < S.length; w++) {
          const R = S[w];
          let P = !0;
          for (let M = 0; M < d.length; M++)
            n(R.p, d[M].p) &&
              (x !== M && v++, P ? ((P = !1), u[M].push(R)) : (p = !0));
          P && u[x].push(R);
        }
      }
      v > 0 && p === !1 && (f = u);
    }
    let g;
    for (let p = 0, v = d.length; p < v; p++) {
      (l = d[p].s), c.push(l), (g = f[p]);
      for (let x = 0, y = g.length; x < y; x++) l.holes.push(g[x].h);
    }
    return c;
  }
}
class fM extends at {
  constructor(e, t, n, i, s, a) {
    console.warn(
      "THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."
    ),
      super(e, t, n, i, s, a);
  }
}
class pM extends Xr {
  constructor(e, t, n, i) {
    console.warn(
      "THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."
    ),
      super(e, t, n, i);
  }
}
class mM extends Yr {
  constructor(e, t, n, i) {
    console.warn(
      "THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."
    ),
      super(e, t, n, i);
  }
}
class gM extends qr {
  constructor(e, t, n, i, s, a, o) {
    console.warn(
      "THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."
    ),
      super(e, t, n, i, s, a, o);
  }
}
class _M extends mt {
  constructor(e, t, n, i, s, a, o, l) {
    console.warn(
      "THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."
    ),
      super(e, t, n, i, s, a, o, l);
  }
}
class xM extends Zr {
  constructor(e, t) {
    console.warn(
      "THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."
    ),
      super(e, t);
  }
}
class yM extends $r {
  constructor(e, t) {
    console.warn(
      "THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."
    ),
      super(e, t);
  }
}
class vM extends Kr {
  constructor(e, t) {
    console.warn(
      "THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."
    ),
      super(e, t);
  }
}
class MM extends Js {
  constructor(e, t, n, i) {
    console.warn(
      "THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."
    ),
      super(e, t, n, i);
  }
}
class SM extends Cn {
  constructor(e, t) {
    console.warn(
      "THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."
    ),
      super(e, t);
  }
}
class bM extends Qn {
  constructor(e, t, n, i) {
    console.warn(
      "THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."
    ),
      super(e, t, n, i);
  }
}
class wM extends ei {
  constructor(e, t, n, i) {
    console.warn(
      "THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."
    ),
      super(e, t, n, i);
  }
}
class EM extends jr {
  constructor(e, t, n, i, s, a) {
    console.warn(
      "THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."
    ),
      super(e, t, n, i, s, a);
  }
}
class AM extends Jr {
  constructor(e, t) {
    console.warn(
      "THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."
    ),
      super(e, t);
  }
}
class TM extends ti {
  constructor(e, t, n, i, s, a, o) {
    console.warn(
      "THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."
    ),
      super(e, t, n, i, s, a, o);
  }
}
class RM extends Qr {
  constructor(e, t) {
    console.warn(
      "THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."
    ),
      super(e, t);
  }
}
class CM extends Tn {
  constructor(e, t, n, i, s) {
    console.warn(
      "THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."
    ),
      super(e, t, n, i, s);
  }
}
class PM extends ea {
  constructor(e, t, n, i, s, a) {
    console.warn(
      "THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."
    ),
      super(e, t, n, i, s, a);
  }
}
class LM extends ta {
  constructor(e, t, n, i, s) {
    console.warn(
      "THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."
    ),
      super(e, t, n, i, s);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: po } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = po));
const mp = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: kd,
      AddEquation: Wi,
      AddOperation: Od,
      AdditiveAnimationBlendMode: Pc,
      AdditiveBlending: Ll,
      AlphaFormat: Wd,
      AlwaysCompare: df,
      AlwaysDepth: Cd,
      AlwaysStencilFunc: sf,
      AmbientLight: ip,
      AmbientLightProbe: Rv,
      AnimationAction: up,
      AnimationClip: Xs,
      AnimationLoader: _v,
      AnimationMixer: dp,
      AnimationObjectGroup: Wv,
      AnimationUtils: fv,
      ArcCurve: Df,
      ArrayCamera: Tf,
      ArrowHelper: hM,
      Audio: cp,
      AudioAnalyser: Uv,
      AudioContext: ch,
      AudioListener: Lv,
      AudioLoader: Av,
      AxesHelper: uM,
      BackSide: wt,
      BasicDepthPacking: ef,
      BasicShadowMap: Bp,
      Bone: To,
      BooleanKeyframeTrack: rs,
      Box2: jv,
      Box3: Vt,
      Box3Helper: lM,
      BoxBufferGeometry: fM,
      BoxGeometry: at,
      BoxHelper: oM,
      BufferAttribute: nt,
      BufferGeometry: He,
      BufferGeometryLoader: op,
      ByteType: Gd,
      Cache: ss,
      Camera: Mo,
      CameraHelper: aM,
      CanvasTexture: If,
      CapsuleBufferGeometry: pM,
      CapsuleGeometry: Xr,
      CatmullRomCurve3: Uf,
      CineonToneMapping: zd,
      CircleBufferGeometry: mM,
      CircleGeometry: Yr,
      ClampToEdgeWrapping: Dt,
      Clock: hh,
      Color: de,
      ColorKeyframeTrack: ih,
      ColorManagement: nn,
      CompressedArrayTexture: Fy,
      CompressedTexture: qc,
      CompressedTextureLoader: xv,
      ConeBufferGeometry: gM,
      ConeGeometry: qr,
      CubeCamera: yf,
      CubeReflectionMapping: yi,
      CubeRefractionMapping: vi,
      CubeTexture: Gr,
      CubeTextureLoader: yv,
      CubeUVReflectionMapping: Zs,
      CubicBezierCurve: $c,
      CubicBezierCurve3: Nf,
      CubicInterpolant: Jf,
      CullFaceBack: Pl,
      CullFaceFront: pd,
      CullFaceFrontBack: Fp,
      CullFaceNone: fd,
      Curve: Sn,
      CurvePath: Ff,
      CustomBlending: gd,
      CustomToneMapping: Hd,
      CylinderBufferGeometry: _M,
      CylinderGeometry: mt,
      Cylindrical: Kv,
      Data3DTexture: Hr,
      DataArrayTexture: yo,
      DataTexture: Ns,
      DataTextureLoader: vv,
      DataUtils: qm,
      DecrementStencilOp: qp,
      DecrementWrapStencilOp: $p,
      DefaultLoadingManager: tp,
      DepthFormat: gi,
      DepthStencilFormat: ts,
      DepthTexture: Rf,
      DirectionalLight: lh,
      DirectionalLightHelper: rM,
      DiscreteInterpolant: Qf,
      DisplayP3ColorSpace: Dc,
      DodecahedronBufferGeometry: xM,
      DodecahedronGeometry: Zr,
      DoubleSide: Gt,
      DstAlphaFactor: bd,
      DstColorFactor: Ed,
      DynamicCopyUsage: hm,
      DynamicDrawUsage: sm,
      DynamicReadUsage: om,
      EdgesGeometry: Bf,
      EllipseCurve: Co,
      EqualCompare: of,
      EqualDepth: Ld,
      EqualStencilFunc: Qp,
      EquirectangularReflectionMapping: Er,
      EquirectangularRefractionMapping: Ar,
      Euler: an,
      EventDispatcher: Un,
      ExtrudeBufferGeometry: yM,
      ExtrudeGeometry: $r,
      FileLoader: vn,
      Float16BufferAttribute: Qm,
      Float32BufferAttribute: Te,
      Float64BufferAttribute: eg,
      FloatType: on,
      Fog: Eo,
      FogExp2: wo,
      FramebufferTexture: Oy,
      FrontSide: Zt,
      Frustum: So,
      GLBufferAttribute: $v,
      GLSL1: dm,
      GLSL3: Pr,
      GreaterCompare: cf,
      GreaterDepth: Dd,
      GreaterEqualCompare: uf,
      GreaterEqualDepth: Id,
      GreaterEqualStencilFunc: im,
      GreaterStencilFunc: tm,
      GridHelper: iM,
      Group: $n,
      HalfFloatType: Bs,
      HemisphereLight: np,
      HemisphereLightHelper: nM,
      HemisphereLightProbe: Tv,
      IcosahedronBufferGeometry: vM,
      IcosahedronGeometry: Kr,
      ImageBitmapLoader: lp,
      ImageLoader: Ys,
      ImageUtils: Nc,
      IncrementStencilOp: Yp,
      IncrementWrapStencilOp: Zp,
      InstancedBufferAttribute: Gs,
      InstancedBufferGeometry: ap,
      InstancedInterleavedBuffer: Zv,
      InstancedMesh: Wc,
      Int16BufferAttribute: jm,
      Int32BufferAttribute: Jm,
      Int8BufferAttribute: Zm,
      IntType: bc,
      InterleavedBuffer: Vr,
      InterleavedBufferAttribute: Si,
      Interpolant: Qs,
      InterpolateDiscrete: zs,
      InterpolateLinear: ns,
      InterpolateSmooth: io,
      InvertStencilOp: Kp,
      KeepStencilOp: so,
      KeyframeTrack: bn,
      LOD: Lf,
      LatheBufferGeometry: MM,
      LatheGeometry: Js,
      Layers: vo,
      LessCompare: af,
      LessDepth: Pd,
      LessEqualCompare: lf,
      LessEqualDepth: oo,
      LessEqualStencilFunc: em,
      LessStencilFunc: Jp,
      Light: Ei,
      LightProbe: Io,
      Line: It,
      Line3: fp,
      LineBasicMaterial: Nt,
      LineCurve: Po,
      LineCurve3: Of,
      LineDashedMaterial: Kf,
      LineLoop: Xc,
      LineSegments: Mn,
      LinearEncoding: Ic,
      LinearFilter: ot,
      LinearInterpolant: nh,
      LinearMipMapLinearFilter: Vp,
      LinearMipMapNearestFilter: Gp,
      LinearMipmapLinearFilter: Dn,
      LinearMipmapNearestFilter: go,
      LinearSRGBColorSpace: xn,
      LinearToneMapping: Fd,
      Loader: $t,
      LoaderUtils: qs,
      LoadingManager: sh,
      LoopOnce: Kd,
      LoopPingPong: Jd,
      LoopRepeat: jd,
      LuminanceAlphaFormat: Yd,
      LuminanceFormat: Xd,
      MOUSE: ki,
      Material: At,
      MaterialLoader: Do,
      MathUtils: pf,
      Matrix3: We,
      Matrix4: Ue,
      MaxEquation: Nl,
      Mesh: ce,
      MeshBasicMaterial: Ut,
      MeshDepthMaterial: zc,
      MeshDistanceMaterial: kc,
      MeshLambertMaterial: Zf,
      MeshMatcapMaterial: $f,
      MeshNormalMaterial: qf,
      MeshPhongMaterial: Xf,
      MeshPhysicalMaterial: Nn,
      MeshStandardMaterial: na,
      MeshToonMaterial: Yf,
      MinEquation: Ul,
      MirroredRepeatWrapping: Fs,
      MixOperation: Nd,
      MultiplyBlending: Dl,
      MultiplyOperation: kr,
      NearestFilter: gt,
      NearestMipMapLinearFilter: Hp,
      NearestMipMapNearestFilter: kp,
      NearestMipmapLinearFilter: Ds,
      NearestMipmapNearestFilter: Tr,
      NeverCompare: rf,
      NeverDepth: Rd,
      NeverStencilFunc: jp,
      NoBlending: jn,
      NoColorSpace: xi,
      NoToneMapping: Pn,
      NormalAnimationBlendMode: xo,
      NormalBlending: ji,
      NotEqualCompare: hf,
      NotEqualDepth: Ud,
      NotEqualStencilFunc: nm,
      NumberKeyframeTrack: Vs,
      Object3D: qe,
      ObjectLoader: wv,
      ObjectSpaceNormalMap: nf,
      OctahedronBufferGeometry: SM,
      OctahedronGeometry: Cn,
      OneFactor: vd,
      OneMinusDstAlphaFactor: wd,
      OneMinusDstColorFactor: Ad,
      OneMinusSrcAlphaFactor: Sc,
      OneMinusSrcColorFactor: Sd,
      OrthographicCamera: Ks,
      PCFShadowMap: vc,
      PCFSoftShadowMap: md,
      PMREMGenerator: ac,
      Path: Dr,
      PerspectiveCamera: Et,
      Plane: ui,
      PlaneBufferGeometry: bM,
      PlaneGeometry: Qn,
      PlaneHelper: cM,
      PointLight: er,
      PointLightHelper: eM,
      Points: Yc,
      PointsMaterial: Ro,
      PolarGridHelper: sM,
      PolyhedronBufferGeometry: wM,
      PolyhedronGeometry: ei,
      PositionalAudio: Dv,
      PropertyBinding: Je,
      PropertyMixer: hp,
      QuadraticBezierCurve: Kc,
      QuadraticBezierCurve3: jc,
      Quaternion: et,
      QuaternionKeyframeTrack: bi,
      QuaternionLinearInterpolant: ep,
      RED_GREEN_RGTC2_Format: ic,
      RED_RGTC1_Format: $d,
      REVISION: po,
      RGBADepthPacking: tf,
      RGBAFormat: qt,
      RGBAIntegerFormat: Cc,
      RGBA_ASTC_10x10_Format: Ql,
      RGBA_ASTC_10x5_Format: Kl,
      RGBA_ASTC_10x6_Format: jl,
      RGBA_ASTC_10x8_Format: Jl,
      RGBA_ASTC_12x10_Format: ec,
      RGBA_ASTC_12x12_Format: tc,
      RGBA_ASTC_4x4_Format: Gl,
      RGBA_ASTC_5x4_Format: Vl,
      RGBA_ASTC_5x5_Format: Wl,
      RGBA_ASTC_6x5_Format: Xl,
      RGBA_ASTC_6x6_Format: Yl,
      RGBA_ASTC_8x5_Format: ql,
      RGBA_ASTC_8x6_Format: Zl,
      RGBA_ASTC_8x8_Format: $l,
      RGBA_BPTC_Format: no,
      RGBA_ETC2_EAC_Format: Hl,
      RGBA_PVRTC_2BPPV1_Format: zl,
      RGBA_PVRTC_4BPPV1_Format: Bl,
      RGBA_S3TC_DXT1_Format: Qa,
      RGBA_S3TC_DXT3_Format: eo,
      RGBA_S3TC_DXT5_Format: to,
      RGB_ETC1_Format: Zd,
      RGB_ETC2_Format: kl,
      RGB_PVRTC_2BPPV1_Format: Fl,
      RGB_PVRTC_4BPPV1_Format: Ol,
      RGB_S3TC_DXT1_Format: Ja,
      RGFormat: qd,
      RGIntegerFormat: Rc,
      RawShaderMaterial: Wf,
      Ray: $s,
      Raycaster: ph,
      RectAreaLight: sp,
      RedFormat: Ac,
      RedIntegerFormat: Tc,
      ReinhardToneMapping: Bd,
      RepeatWrapping: Mi,
      ReplaceStencilOp: Xp,
      ReverseSubtractEquation: xd,
      RingBufferGeometry: EM,
      RingGeometry: jr,
      SIGNED_RED_GREEN_RGTC2_Format: sc,
      SIGNED_RED_RGTC1_Format: nc,
      SRGBColorSpace: Oe,
      Scene: Gc,
      ShaderChunk: Ve,
      ShaderLib: mn,
      ShaderMaterial: cn,
      ShadowMaterial: Vf,
      Shape: Qi,
      ShapeBufferGeometry: AM,
      ShapeGeometry: Jr,
      ShapePath: dM,
      ShapeUtils: Ln,
      ShortType: Vd,
      Skeleton: Wr,
      SkeletonHelper: Qv,
      SkinnedMesh: Vc,
      Source: Zi,
      Sphere: hn,
      SphereBufferGeometry: TM,
      SphereGeometry: ti,
      Spherical: fc,
      SphericalHarmonics3: rp,
      SplineCurve: Jc,
      SpotLight: oh,
      SpotLightHelper: Jv,
      Sprite: di,
      SpriteMaterial: Ao,
      SrcAlphaFactor: Mc,
      SrcAlphaSaturateFactor: Td,
      SrcColorFactor: Md,
      StaticCopyUsage: cm,
      StaticDrawUsage: Cr,
      StaticReadUsage: am,
      StereoCamera: Cv,
      StreamCopyUsage: um,
      StreamDrawUsage: rm,
      StreamReadUsage: lm,
      StringKeyframeTrack: as,
      SubtractEquation: _d,
      SubtractiveBlending: Il,
      TOUCH: Hi,
      TangentSpaceNormalMap: wi,
      TetrahedronBufferGeometry: RM,
      TetrahedronGeometry: Qr,
      Texture: ht,
      TextureLoader: rh,
      TorusBufferGeometry: CM,
      TorusGeometry: Tn,
      TorusKnotBufferGeometry: PM,
      TorusKnotGeometry: ea,
      Triangle: Yt,
      TriangleFanDrawMode: lo,
      TriangleStripDrawMode: Lc,
      TrianglesDrawMode: Qd,
      TubeBufferGeometry: LM,
      TubeGeometry: ta,
      TwoPassDoubleSide: zp,
      UVMapping: mo,
      Uint16BufferAttribute: Oc,
      Uint32BufferAttribute: Fc,
      Uint8BufferAttribute: $m,
      Uint8ClampedBufferAttribute: Km,
      Uniform: fh,
      UniformsGroup: qv,
      UniformsLib: fe,
      UniformsUtils: xf,
      UnsignedByteType: _n,
      UnsignedInt248Type: mi,
      UnsignedIntType: Zn,
      UnsignedShort4444Type: wc,
      UnsignedShort5551Type: Ec,
      UnsignedShortType: _o,
      VSMShadowMap: An,
      Vector2: K,
      Vector3: b,
      Vector4: tt,
      VectorKeyframeTrack: Ws,
      VideoTexture: Ny,
      WebGL1Renderer: Cf,
      WebGL3DRenderTarget: Om,
      WebGLArrayRenderTarget: Nm,
      WebGLCoordinateSystem: Rn,
      WebGLCubeRenderTarget: vf,
      WebGLMultipleRenderTargets: Fm,
      WebGLRenderTarget: yn,
      WebGLRenderer: Hc,
      WebGLUtils: Af,
      WebGPUCoordinateSystem: Lr,
      WireframeGeometry: Gf,
      WrapAroundEnding: Rr,
      ZeroCurvatureEnding: Yi,
      ZeroFactor: yd,
      ZeroSlopeEnding: qi,
      ZeroStencilOp: Wp,
      _SRGBAFormat: co,
      sRGBEncoding: _i,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.17.0
 * @author George Michael Brower
 * @license MIT
 */ class In {
  constructor(e, t, n, i, s = "div") {
    (this.parent = e),
      (this.object = t),
      (this.property = n),
      (this._disabled = !1),
      (this._hidden = !1),
      (this.initialValue = this.getValue()),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("controller"),
      this.domElement.classList.add(i),
      (this.$name = document.createElement("div")),
      this.$name.classList.add("name"),
      (In.nextNameID = In.nextNameID || 0),
      (this.$name.id = "lil-gui-name-" + ++In.nextNameID),
      (this.$widget = document.createElement(s)),
      this.$widget.classList.add("widget"),
      (this.$disable = this.$widget),
      this.domElement.appendChild(this.$name),
      this.domElement.appendChild(this.$widget),
      this.parent.children.push(this),
      this.parent.controllers.push(this),
      this.parent.$children.appendChild(this.domElement),
      (this._listenCallback = this._listenCallback.bind(this)),
      this.name(n);
  }
  name(e) {
    return (this._name = e), (this.$name.innerHTML = e), this;
  }
  onChange(e) {
    return (this._onChange = e), this;
  }
  _callOnChange() {
    this.parent._callOnChange(this),
      this._onChange !== void 0 && this._onChange.call(this, this.getValue()),
      (this._changed = !0);
  }
  onFinishChange(e) {
    return (this._onFinishChange = e), this;
  }
  _callOnFinishChange() {
    this._changed &&
      (this.parent._callOnFinishChange(this),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, this.getValue())),
      (this._changed = !1);
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this;
  }
  enable(e = !0) {
    return this.disable(!e);
  }
  disable(e = !0) {
    return (
      e === this._disabled ||
        ((this._disabled = e),
        this.domElement.classList.toggle("disabled", e),
        this.$disable.toggleAttribute("disabled", e)),
      this
    );
  }
  show(e = !0) {
    return (
      (this._hidden = !e),
      (this.domElement.style.display = this._hidden ? "none" : ""),
      this
    );
  }
  hide() {
    return this.show(!1);
  }
  options(e) {
    const t = this.parent.add(this.object, this.property, e);
    return t.name(this._name), this.destroy(), t;
  }
  min(e) {
    return this;
  }
  max(e) {
    return this;
  }
  step(e) {
    return this;
  }
  decimals(e) {
    return this;
  }
  listen(e = !0) {
    return (
      (this._listening = e),
      this._listenCallbackID !== void 0 &&
        (cancelAnimationFrame(this._listenCallbackID),
        (this._listenCallbackID = void 0)),
      this._listening && this._listenCallback(),
      this
    );
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback);
    const e = this.save();
    e !== this._listenPrevValue && this.updateDisplay(),
      (this._listenPrevValue = e);
  }
  getValue() {
    return this.object[this.property];
  }
  setValue(e) {
    return (
      (this.object[this.property] = e),
      this._callOnChange(),
      this.updateDisplay(),
      this
    );
  }
  updateDisplay() {
    return this;
  }
  load(e) {
    return this.setValue(e), this._callOnFinishChange(), this;
  }
  save() {
    return this.getValue();
  }
  destroy() {
    this.listen(!1),
      this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
      this.parent.$children.removeChild(this.domElement);
  }
}
class IM extends In {
  constructor(e, t, n) {
    super(e, t, n, "boolean", "label"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "checkbox"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      this.$input.addEventListener("change", () => {
        this.setValue(this.$input.checked), this._callOnFinishChange();
      }),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.checked = this.getValue()), this;
  }
}
function pc(r) {
  let e, t;
  return (
    (e = r.match(/(#|0x)?([a-f0-9]{6})/i))
      ? (t = e[2])
      : (e = r.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
      ? (t =
          parseInt(e[1]).toString(16).padStart(2, 0) +
          parseInt(e[2]).toString(16).padStart(2, 0) +
          parseInt(e[3]).toString(16).padStart(2, 0))
      : (e = r.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
        (t = e[1] + e[1] + e[2] + e[2] + e[3] + e[3]),
    !!t && "#" + t
  );
}
const DM = {
    isPrimitive: !0,
    match: (r) => typeof r == "string",
    fromHexString: pc,
    toHexString: pc,
  },
  Fr = {
    isPrimitive: !0,
    match: (r) => typeof r == "number",
    fromHexString: (r) => parseInt(r.substring(1), 16),
    toHexString: (r) => "#" + r.toString(16).padStart(6, 0),
  },
  UM = {
    isPrimitive: !1,
    match: Array.isArray,
    fromHexString(r, e, t = 1) {
      const n = Fr.fromHexString(r);
      (e[0] = (((n >> 16) & 255) / 255) * t),
        (e[1] = (((n >> 8) & 255) / 255) * t),
        (e[2] = ((255 & n) / 255) * t);
    },
    toHexString: ([r, e, t], n = 1) =>
      Fr.toHexString(
        ((r * (n = 255 / n)) << 16) ^ ((e * n) << 8) ^ ((t * n) << 0)
      ),
  },
  NM = {
    isPrimitive: !1,
    match: (r) => Object(r) === r,
    fromHexString(r, e, t = 1) {
      const n = Fr.fromHexString(r);
      (e.r = (((n >> 16) & 255) / 255) * t),
        (e.g = (((n >> 8) & 255) / 255) * t),
        (e.b = ((255 & n) / 255) * t);
    },
    toHexString: ({ r, g: e, b: t }, n = 1) =>
      Fr.toHexString(
        ((r * (n = 255 / n)) << 16) ^ ((e * n) << 8) ^ ((t * n) << 0)
      ),
  },
  OM = [DM, Fr, UM, NM];
class FM extends In {
  constructor(e, t, n, i) {
    var s;
    super(e, t, n, "color"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "color"),
      this.$input.setAttribute("tabindex", -1),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      (this.$text = document.createElement("input")),
      this.$text.setAttribute("type", "text"),
      this.$text.setAttribute("spellcheck", "false"),
      this.$text.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      this.$display.appendChild(this.$input),
      this.$widget.appendChild(this.$display),
      this.$widget.appendChild(this.$text),
      (this._format = ((s = this.initialValue), OM.find((a) => a.match(s)))),
      (this._rgbScale = i),
      (this._initialValueHexString = this.save()),
      (this._textFocused = !1),
      this.$input.addEventListener("input", () => {
        this._setValueFromHexString(this.$input.value);
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$text.addEventListener("input", () => {
        const a = pc(this.$text.value);
        a && this._setValueFromHexString(a);
      }),
      this.$text.addEventListener("focus", () => {
        (this._textFocused = !0), this.$text.select();
      }),
      this.$text.addEventListener("blur", () => {
        (this._textFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange();
      }),
      (this.$disable = this.$text),
      this.updateDisplay();
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this;
  }
  _setValueFromHexString(e) {
    if (this._format.isPrimitive) {
      const t = this._format.fromHexString(e);
      this.setValue(t);
    } else
      this._format.fromHexString(e, this.getValue(), this._rgbScale),
        this._callOnChange(),
        this.updateDisplay();
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale);
  }
  load(e) {
    return this._setValueFromHexString(e), this._callOnFinishChange(), this;
  }
  updateDisplay() {
    return (
      (this.$input.value = this._format.toHexString(
        this.getValue(),
        this._rgbScale
      )),
      this._textFocused || (this.$text.value = this.$input.value.substring(1)),
      (this.$display.style.backgroundColor = this.$input.value),
      this
    );
  }
}
class xl extends In {
  constructor(e, t, n) {
    super(e, t, n, "function"),
      (this.$button = document.createElement("button")),
      this.$button.appendChild(this.$name),
      this.$widget.appendChild(this.$button),
      this.$button.addEventListener("click", (i) => {
        i.preventDefault(), this.getValue().call(this.object);
      }),
      this.$button.addEventListener("touchstart", () => {}, { passive: !0 }),
      (this.$disable = this.$button);
  }
}
class BM extends In {
  constructor(e, t, n, i, s, a) {
    super(e, t, n, "number"), this._initInput(), this.min(i), this.max(s);
    const o = a !== void 0;
    this.step(o ? a : this._getImplicitStep(), o), this.updateDisplay();
  }
  decimals(e) {
    return (this._decimals = e), this.updateDisplay(), this;
  }
  min(e) {
    return (this._min = e), this._onUpdateMinMax(), this;
  }
  max(e) {
    return (this._max = e), this._onUpdateMinMax(), this;
  }
  step(e, t = !0) {
    return (this._step = e), (this._stepExplicit = t), this;
  }
  updateDisplay() {
    const e = this.getValue();
    if (this._hasSlider) {
      let t = (e - this._min) / (this._max - this._min);
      (t = Math.max(0, Math.min(t, 1))),
        (this.$fill.style.width = 100 * t + "%");
    }
    return (
      this._inputFocused ||
        (this.$input.value =
          this._decimals === void 0 ? e : e.toFixed(this._decimals)),
      this
    );
  }
  _initInput() {
    (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "number"),
      this.$input.setAttribute("step", "any"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input);
    const e = (h) => {
      const u = parseFloat(this.$input.value);
      isNaN(u) ||
        (this._snapClampSetValue(u + h), (this.$input.value = this.getValue()));
    };
    let t,
      n,
      i,
      s,
      a,
      o = !1;
    const l = (h) => {
        if (o) {
          const u = h.clientX - t,
            d = h.clientY - n;
          Math.abs(d) > 5
            ? (h.preventDefault(),
              this.$input.blur(),
              (o = !1),
              this._setDraggingStyle(!0, "vertical"))
            : Math.abs(u) > 5 && c();
        }
        if (!o) {
          const u = h.clientY - i;
          (a -= u * this._step * this._arrowKeyMultiplier(h)),
            s + a > this._max
              ? (a = this._max - s)
              : s + a < this._min && (a = this._min - s),
            this._snapClampSetValue(s + a);
        }
        i = h.clientY;
      },
      c = () => {
        this._setDraggingStyle(!1, "vertical"),
          this._callOnFinishChange(),
          window.removeEventListener("mousemove", l),
          window.removeEventListener("mouseup", c);
      };
    this.$input.addEventListener("input", () => {
      let h = parseFloat(this.$input.value);
      isNaN(h) ||
        (this._stepExplicit && (h = this._snap(h)),
        this.setValue(this._clamp(h)));
    }),
      this.$input.addEventListener("keydown", (h) => {
        h.code === "Enter" && this.$input.blur(),
          h.code === "ArrowUp" &&
            (h.preventDefault(), e(this._step * this._arrowKeyMultiplier(h))),
          h.code === "ArrowDown" &&
            (h.preventDefault(),
            e(this._step * this._arrowKeyMultiplier(h) * -1));
      }),
      this.$input.addEventListener(
        "wheel",
        (h) => {
          this._inputFocused &&
            (h.preventDefault(), e(this._step * this._normalizeMouseWheel(h)));
        },
        { passive: !1 }
      ),
      this.$input.addEventListener("mousedown", (h) => {
        (t = h.clientX),
          (n = i = h.clientY),
          (o = !0),
          (s = this.getValue()),
          (a = 0),
          window.addEventListener("mousemove", l),
          window.addEventListener("mouseup", c);
      }),
      this.$input.addEventListener("focus", () => {
        this._inputFocused = !0;
      }),
      this.$input.addEventListener("blur", () => {
        (this._inputFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange();
      });
  }
  _initSlider() {
    (this._hasSlider = !0),
      (this.$slider = document.createElement("div")),
      this.$slider.classList.add("slider"),
      (this.$fill = document.createElement("div")),
      this.$fill.classList.add("fill"),
      this.$slider.appendChild(this.$fill),
      this.$widget.insertBefore(this.$slider, this.$input),
      this.domElement.classList.add("hasSlider");
    const e = (d) => {
        const f = this.$slider.getBoundingClientRect();
        let m =
          ((_ = d),
          (g = f.left),
          (p = f.right),
          (v = this._min),
          (x = this._max),
          ((_ - g) / (p - g)) * (x - v) + v);
        var _, g, p, v, x;
        this._snapClampSetValue(m);
      },
      t = (d) => {
        e(d.clientX);
      },
      n = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener("mousemove", t),
          window.removeEventListener("mouseup", n);
      };
    let i,
      s,
      a = !1;
    const o = (d) => {
        d.preventDefault(),
          this._setDraggingStyle(!0),
          e(d.touches[0].clientX),
          (a = !1);
      },
      l = (d) => {
        if (a) {
          const f = d.touches[0].clientX - i,
            m = d.touches[0].clientY - s;
          Math.abs(f) > Math.abs(m)
            ? o(d)
            : (window.removeEventListener("touchmove", l),
              window.removeEventListener("touchend", c));
        } else d.preventDefault(), e(d.touches[0].clientX);
      },
      c = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener("touchmove", l),
          window.removeEventListener("touchend", c);
      },
      h = this._callOnFinishChange.bind(this);
    let u;
    this.$slider.addEventListener("mousedown", (d) => {
      this._setDraggingStyle(!0),
        e(d.clientX),
        window.addEventListener("mousemove", t),
        window.addEventListener("mouseup", n);
    }),
      this.$slider.addEventListener(
        "touchstart",
        (d) => {
          d.touches.length > 1 ||
            (this._hasScrollBar
              ? ((i = d.touches[0].clientX),
                (s = d.touches[0].clientY),
                (a = !0))
              : o(d),
            window.addEventListener("touchmove", l, { passive: !1 }),
            window.addEventListener("touchend", c));
        },
        { passive: !1 }
      ),
      this.$slider.addEventListener(
        "wheel",
        (d) => {
          if (Math.abs(d.deltaX) < Math.abs(d.deltaY) && this._hasScrollBar)
            return;
          d.preventDefault();
          const f = this._normalizeMouseWheel(d) * this._step;
          this._snapClampSetValue(this.getValue() + f),
            (this.$input.value = this.getValue()),
            clearTimeout(u),
            (u = setTimeout(h, 400));
        },
        { passive: !1 }
      );
  }
  _setDraggingStyle(e, t = "horizontal") {
    this.$slider && this.$slider.classList.toggle("active", e),
      document.body.classList.toggle("lil-gui-dragging", e),
      document.body.classList.toggle("lil-gui-" + t, e);
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1;
  }
  _onUpdateMinMax() {
    !this._hasSlider &&
      this._hasMin &&
      this._hasMax &&
      (this._stepExplicit || this.step(this._getImplicitStep(), !1),
      this._initSlider(),
      this.updateDisplay());
  }
  _normalizeMouseWheel(e) {
    let { deltaX: t, deltaY: n } = e;
    return (
      Math.floor(e.deltaY) !== e.deltaY &&
        e.wheelDelta &&
        ((t = 0),
        (n = -e.wheelDelta / 120),
        (n *= this._stepExplicit ? 1 : 10)),
      t + -n
    );
  }
  _arrowKeyMultiplier(e) {
    let t = this._stepExplicit ? 1 : 10;
    return e.shiftKey ? (t *= 10) : e.altKey && (t /= 10), t;
  }
  _snap(e) {
    const t = Math.round(e / this._step) * this._step;
    return parseFloat(t.toPrecision(15));
  }
  _clamp(e) {
    return (
      e < this._min && (e = this._min), e > this._max && (e = this._max), e
    );
  }
  _snapClampSetValue(e) {
    this.setValue(this._clamp(this._snap(e)));
  }
  get _hasScrollBar() {
    const e = this.parent.root.$children;
    return e.scrollHeight > e.clientHeight;
  }
  get _hasMin() {
    return this._min !== void 0;
  }
  get _hasMax() {
    return this._max !== void 0;
  }
}
class zM extends In {
  constructor(e, t, n, i) {
    super(e, t, n, "option"),
      (this.$select = document.createElement("select")),
      this.$select.setAttribute("aria-labelledby", this.$name.id),
      (this.$display = document.createElement("div")),
      this.$display.classList.add("display"),
      (this._values = Array.isArray(i) ? i : Object.values(i)),
      (this._names = Array.isArray(i) ? i : Object.keys(i)),
      this._names.forEach((s) => {
        const a = document.createElement("option");
        (a.innerHTML = s), this.$select.appendChild(a);
      }),
      this.$select.addEventListener("change", () => {
        this.setValue(this._values[this.$select.selectedIndex]),
          this._callOnFinishChange();
      }),
      this.$select.addEventListener("focus", () => {
        this.$display.classList.add("focus");
      }),
      this.$select.addEventListener("blur", () => {
        this.$display.classList.remove("focus");
      }),
      this.$widget.appendChild(this.$select),
      this.$widget.appendChild(this.$display),
      (this.$disable = this.$select),
      this.updateDisplay();
  }
  updateDisplay() {
    const e = this.getValue(),
      t = this._values.indexOf(e);
    return (
      (this.$select.selectedIndex = t),
      (this.$display.innerHTML = t === -1 ? e : this._names[t]),
      this
    );
  }
}
class kM extends In {
  constructor(e, t, n) {
    super(e, t, n, "string"),
      (this.$input = document.createElement("input")),
      this.$input.setAttribute("type", "text"),
      this.$input.setAttribute("aria-labelledby", this.$name.id),
      this.$input.addEventListener("input", () => {
        this.setValue(this.$input.value);
      }),
      this.$input.addEventListener("keydown", (i) => {
        i.code === "Enter" && this.$input.blur();
      }),
      this.$input.addEventListener("blur", () => {
        this._callOnFinishChange();
      }),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input),
      this.updateDisplay();
  }
  updateDisplay() {
    return (this.$input.value = this.getValue()), this;
  }
}
let ju = !1;
class mh {
  constructor({
    parent: e,
    autoPlace: t = e === void 0,
    container: n,
    width: i,
    title: s = "Controls",
    injectStyles: a = !0,
    touchStyles: o = !0,
  } = {}) {
    if (
      ((this.parent = e),
      (this.root = e ? e.root : this),
      (this.children = []),
      (this.controllers = []),
      (this.folders = []),
      (this._closed = !1),
      (this._hidden = !1),
      (this.domElement = document.createElement("div")),
      this.domElement.classList.add("lil-gui"),
      (this.$title = document.createElement("div")),
      this.$title.classList.add("title"),
      this.$title.setAttribute("role", "button"),
      this.$title.setAttribute("aria-expanded", !0),
      this.$title.setAttribute("tabindex", 0),
      this.$title.addEventListener("click", () =>
        this.openAnimated(this._closed)
      ),
      this.$title.addEventListener("keydown", (l) => {
        (l.code !== "Enter" && l.code !== "Space") ||
          (l.preventDefault(), this.$title.click());
      }),
      this.$title.addEventListener("touchstart", () => {}, { passive: !0 }),
      (this.$children = document.createElement("div")),
      this.$children.classList.add("children"),
      this.domElement.appendChild(this.$title),
      this.domElement.appendChild(this.$children),
      this.title(s),
      o && this.domElement.classList.add("allow-touch-styles"),
      this.parent)
    )
      return (
        this.parent.children.push(this),
        this.parent.folders.push(this),
        void this.parent.$children.appendChild(this.domElement)
      );
    this.domElement.classList.add("root"),
      !ju &&
        a &&
        ((function (l) {
          const c = document.createElement("style");
          c.innerHTML = l;
          const h = document.querySelector(
            "head link[rel=stylesheet], head style"
          );
          h ? document.head.insertBefore(c, h) : document.head.appendChild(c);
        })(
          '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}'
        ),
        (ju = !0)),
      n
        ? n.appendChild(this.domElement)
        : t &&
          (this.domElement.classList.add("autoPlace"),
          document.body.appendChild(this.domElement)),
      i && this.domElement.style.setProperty("--width", i + "px"),
      this.domElement.addEventListener("keydown", (l) => l.stopPropagation()),
      this.domElement.addEventListener("keyup", (l) => l.stopPropagation());
  }
  add(e, t, n, i, s) {
    if (Object(n) === n) return new zM(this, e, t, n);
    const a = e[t];
    switch (typeof a) {
      case "number":
        return new BM(this, e, t, n, i, s);
      case "boolean":
        return new IM(this, e, t);
      case "string":
        return new kM(this, e, t);
      case "function":
        return new xl(this, e, t);
    }
    console.error(
      `gui.add failed
	property:`,
      t,
      `
	object:`,
      e,
      `
	value:`,
      a
    );
  }
  addColor(e, t, n = 1) {
    return new FM(this, e, t, n);
  }
  addFolder(e) {
    return new mh({ parent: this, title: e });
  }
  load(e, t = !0) {
    return (
      e.controllers &&
        this.controllers.forEach((n) => {
          n instanceof xl ||
            (n._name in e.controllers && n.load(e.controllers[n._name]));
        }),
      t &&
        e.folders &&
        this.folders.forEach((n) => {
          n._title in e.folders && n.load(e.folders[n._title]);
        }),
      this
    );
  }
  save(e = !0) {
    const t = { controllers: {}, folders: {} };
    return (
      this.controllers.forEach((n) => {
        if (!(n instanceof xl)) {
          if (n._name in t.controllers)
            throw new Error(
              `Cannot save GUI with duplicate property "${n._name}"`
            );
          t.controllers[n._name] = n.save();
        }
      }),
      e &&
        this.folders.forEach((n) => {
          if (n._title in t.folders)
            throw new Error(
              `Cannot save GUI with duplicate folder "${n._title}"`
            );
          t.folders[n._title] = n.save();
        }),
      t
    );
  }
  open(e = !0) {
    return (
      (this._closed = !e),
      this.$title.setAttribute("aria-expanded", !this._closed),
      this.domElement.classList.toggle("closed", this._closed),
      this
    );
  }
  close() {
    return this.open(!1);
  }
  show(e = !0) {
    return (
      (this._hidden = !e),
      (this.domElement.style.display = this._hidden ? "none" : ""),
      this
    );
  }
  hide() {
    return this.show(!1);
  }
  openAnimated(e = !0) {
    return (
      (this._closed = !e),
      this.$title.setAttribute("aria-expanded", !this._closed),
      requestAnimationFrame(() => {
        const t = this.$children.clientHeight;
        (this.$children.style.height = t + "px"),
          this.domElement.classList.add("transition");
        const n = (s) => {
          s.target === this.$children &&
            ((this.$children.style.height = ""),
            this.domElement.classList.remove("transition"),
            this.$children.removeEventListener("transitionend", n));
        };
        this.$children.addEventListener("transitionend", n);
        const i = e ? this.$children.scrollHeight : 0;
        this.domElement.classList.toggle("closed", !e),
          requestAnimationFrame(() => {
            this.$children.style.height = i + "px";
          });
      }),
      this
    );
  }
  title(e) {
    return (this._title = e), (this.$title.innerHTML = e), this;
  }
  reset(e = !0) {
    return (
      (e ? this.controllersRecursive() : this.controllers).forEach((t) =>
        t.reset()
      ),
      this
    );
  }
  onChange(e) {
    return (this._onChange = e), this;
  }
  _callOnChange(e) {
    this.parent && this.parent._callOnChange(e),
      this._onChange !== void 0 &&
        this._onChange.call(this, {
          object: e.object,
          property: e.property,
          value: e.getValue(),
          controller: e,
        });
  }
  onFinishChange(e) {
    return (this._onFinishChange = e), this;
  }
  _callOnFinishChange(e) {
    this.parent && this.parent._callOnFinishChange(e),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, {
          object: e.object,
          property: e.property,
          value: e.getValue(),
          controller: e,
        });
  }
  destroy() {
    this.parent &&
      (this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
      this.domElement.parentElement &&
        this.domElement.parentElement.removeChild(this.domElement),
      Array.from(this.children).forEach((e) => e.destroy());
  }
  controllersRecursive() {
    let e = Array.from(this.controllers);
    return (
      this.folders.forEach((t) => {
        e = e.concat(t.controllersRecursive());
      }),
      e
    );
  }
  foldersRecursive() {
    let e = Array.from(this.folders);
    return (
      this.folders.forEach((t) => {
        e = e.concat(t.foldersRecursive());
      }),
      e
    );
  }
}
const Ju = { type: "change" },
  yl = { type: "start" },
  Qu = { type: "end" };
class HM extends Un {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new b()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ki.ROTATE,
        MIDDLE: ki.DOLLY,
        RIGHT: ki.PAN,
      }),
      (this.touches = { ONE: Hi.ROTATE, TWO: Hi.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return o.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return o.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (L) {
        L.addEventListener("keydown", Le), (this._domElementKeyEvents = L);
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener("keydown", Le),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = function () {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = function () {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(Ju),
          n.update(),
          (s = i.NONE);
      }),
      (this.update = (function () {
        const L = new b(),
          te = new et().setFromUnitVectors(e.up, new b(0, 1, 0)),
          re = te.clone().invert(),
          W = new b(),
          Se = new et(),
          Re = new b(),
          Ee = 2 * Math.PI;
        return function () {
          const ve = n.object.position;
          L.copy(ve).sub(n.target),
            L.applyQuaternion(te),
            o.setFromVector3(L),
            n.autoRotate && s === i.NONE && M(R()),
            n.enableDamping
              ? ((o.theta += l.theta * n.dampingFactor),
                (o.phi += l.phi * n.dampingFactor))
              : ((o.theta += l.theta), (o.phi += l.phi));
          let Ie = n.minAzimuthAngle,
            Ye = n.maxAzimuthAngle;
          return (
            isFinite(Ie) &&
              isFinite(Ye) &&
              (Ie < -Math.PI ? (Ie += Ee) : Ie > Math.PI && (Ie -= Ee),
              Ye < -Math.PI ? (Ye += Ee) : Ye > Math.PI && (Ye -= Ee),
              Ie <= Ye
                ? (o.theta = Math.max(Ie, Math.min(Ye, o.theta)))
                : (o.theta =
                    o.theta > (Ie + Ye) / 2
                      ? Math.max(Ie, o.theta)
                      : Math.min(Ye, o.theta))),
            (o.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, o.phi)
            )),
            o.makeSafe(),
            (o.radius *= c),
            (o.radius = Math.max(
              n.minDistance,
              Math.min(n.maxDistance, o.radius)
            )),
            n.enableDamping === !0
              ? n.target.addScaledVector(h, n.dampingFactor)
              : n.target.add(h),
            L.setFromSpherical(o),
            L.applyQuaternion(re),
            ve.copy(n.target).add(L),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((l.theta *= 1 - n.dampingFactor),
                (l.phi *= 1 - n.dampingFactor),
                h.multiplyScalar(1 - n.dampingFactor))
              : (l.set(0, 0, 0), h.set(0, 0, 0)),
            (c = 1),
            u ||
            W.distanceToSquared(n.object.position) > a ||
            8 * (1 - Se.dot(n.object.quaternion)) > a ||
            Re.distanceToSquared(n.target) > 0
              ? (n.dispatchEvent(Ju),
                W.copy(n.object.position),
                Se.copy(n.object.quaternion),
                Re.copy(n.target),
                (u = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", C),
          n.domElement.removeEventListener("pointerdown", Q),
          n.domElement.removeEventListener("pointercancel", ee),
          n.domElement.removeEventListener("wheel", xe),
          n.domElement.removeEventListener("pointermove", oe),
          n.domElement.removeEventListener("pointerup", ee),
          n._domElementKeyEvents !== null &&
            (n._domElementKeyEvents.removeEventListener("keydown", Le),
            (n._domElementKeyEvents = null));
      });
    const n = this,
      i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let s = i.NONE;
    const a = 1e-6,
      o = new fc(),
      l = new fc();
    let c = 1;
    const h = new b();
    let u = !1;
    const d = new K(),
      f = new K(),
      m = new K(),
      _ = new K(),
      g = new K(),
      p = new K(),
      v = new K(),
      x = new K(),
      y = new K(),
      S = [],
      w = {};
    function R() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function P() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function M(L) {
      l.theta -= L;
    }
    function A(L) {
      l.phi -= L;
    }
    const k = (function () {
        const L = new b();
        return function (re, W) {
          L.setFromMatrixColumn(W, 0), L.multiplyScalar(-re), h.add(L);
        };
      })(),
      X = (function () {
        const L = new b();
        return function (re, W) {
          n.screenSpacePanning === !0
            ? L.setFromMatrixColumn(W, 1)
            : (L.setFromMatrixColumn(W, 0), L.crossVectors(n.object.up, L)),
            L.multiplyScalar(re),
            h.add(L);
        };
      })(),
      U = (function () {
        const L = new b();
        return function (re, W) {
          const Se = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const Re = n.object.position;
            L.copy(Re).sub(n.target);
            let Ee = L.length();
            (Ee *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              k((2 * re * Ee) / Se.clientHeight, n.object.matrix),
              X((2 * W * Ee) / Se.clientHeight, n.object.matrix);
          } else
            n.object.isOrthographicCamera
              ? (k(
                  (re * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    Se.clientWidth,
                  n.object.matrix
                ),
                X(
                  (W * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    Se.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function O(L) {
      n.object.isPerspectiveCamera
        ? (c /= L)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom * L)
          )),
          n.object.updateProjectionMatrix(),
          (u = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function N(L) {
      n.object.isPerspectiveCamera
        ? (c *= L)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom / L)
          )),
          n.object.updateProjectionMatrix(),
          (u = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function Z(L) {
      d.set(L.clientX, L.clientY);
    }
    function B(L) {
      v.set(L.clientX, L.clientY);
    }
    function G(L) {
      _.set(L.clientX, L.clientY);
    }
    function $(L) {
      f.set(L.clientX, L.clientY),
        m.subVectors(f, d).multiplyScalar(n.rotateSpeed);
      const te = n.domElement;
      M((2 * Math.PI * m.x) / te.clientHeight),
        A((2 * Math.PI * m.y) / te.clientHeight),
        d.copy(f),
        n.update();
    }
    function Y(L) {
      x.set(L.clientX, L.clientY),
        y.subVectors(x, v),
        y.y > 0 ? O(P()) : y.y < 0 && N(P()),
        v.copy(x),
        n.update();
    }
    function he(L) {
      g.set(L.clientX, L.clientY),
        p.subVectors(g, _).multiplyScalar(n.panSpeed),
        U(p.x, p.y),
        _.copy(g),
        n.update();
    }
    function F(L) {
      L.deltaY < 0 ? N(P()) : L.deltaY > 0 && O(P()), n.update();
    }
    function ne(L) {
      let te = !1;
      switch (L.code) {
        case n.keys.UP:
          L.ctrlKey || L.metaKey || L.shiftKey
            ? A((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : U(0, n.keyPanSpeed),
            (te = !0);
          break;
        case n.keys.BOTTOM:
          L.ctrlKey || L.metaKey || L.shiftKey
            ? A((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : U(0, -n.keyPanSpeed),
            (te = !0);
          break;
        case n.keys.LEFT:
          L.ctrlKey || L.metaKey || L.shiftKey
            ? M((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : U(n.keyPanSpeed, 0),
            (te = !0);
          break;
        case n.keys.RIGHT:
          L.ctrlKey || L.metaKey || L.shiftKey
            ? M((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : U(-n.keyPanSpeed, 0),
            (te = !0);
          break;
      }
      te && (L.preventDefault(), n.update());
    }
    function ie() {
      if (S.length === 1) d.set(S[0].pageX, S[0].pageY);
      else {
        const L = 0.5 * (S[0].pageX + S[1].pageX),
          te = 0.5 * (S[0].pageY + S[1].pageY);
        d.set(L, te);
      }
    }
    function me() {
      if (S.length === 1) _.set(S[0].pageX, S[0].pageY);
      else {
        const L = 0.5 * (S[0].pageX + S[1].pageX),
          te = 0.5 * (S[0].pageY + S[1].pageY);
        _.set(L, te);
      }
    }
    function ge() {
      const L = S[0].pageX - S[1].pageX,
        te = S[0].pageY - S[1].pageY,
        re = Math.sqrt(L * L + te * te);
      v.set(0, re);
    }
    function Me() {
      n.enableZoom && ge(), n.enablePan && me();
    }
    function Ne() {
      n.enableZoom && ge(), n.enableRotate && ie();
    }
    function Ce(L) {
      if (S.length == 1) f.set(L.pageX, L.pageY);
      else {
        const re = se(L),
          W = 0.5 * (L.pageX + re.x),
          Se = 0.5 * (L.pageY + re.y);
        f.set(W, Se);
      }
      m.subVectors(f, d).multiplyScalar(n.rotateSpeed);
      const te = n.domElement;
      M((2 * Math.PI * m.x) / te.clientHeight),
        A((2 * Math.PI * m.y) / te.clientHeight),
        d.copy(f);
    }
    function Ze(L) {
      if (S.length === 1) g.set(L.pageX, L.pageY);
      else {
        const te = se(L),
          re = 0.5 * (L.pageX + te.x),
          W = 0.5 * (L.pageY + te.y);
        g.set(re, W);
      }
      p.subVectors(g, _).multiplyScalar(n.panSpeed), U(p.x, p.y), _.copy(g);
    }
    function Pe(L) {
      const te = se(L),
        re = L.pageX - te.x,
        W = L.pageY - te.y,
        Se = Math.sqrt(re * re + W * W);
      x.set(0, Se),
        y.set(0, Math.pow(x.y / v.y, n.zoomSpeed)),
        O(y.y),
        v.copy(x);
    }
    function I(L) {
      n.enableZoom && Pe(L), n.enablePan && Ze(L);
    }
    function le(L) {
      n.enableZoom && Pe(L), n.enableRotate && Ce(L);
    }
    function Q(L) {
      n.enabled !== !1 &&
        (S.length === 0 &&
          (n.domElement.setPointerCapture(L.pointerId),
          n.domElement.addEventListener("pointermove", oe),
          n.domElement.addEventListener("pointerup", ee)),
        E(L),
        L.pointerType === "touch" ? ze(L) : we(L));
    }
    function oe(L) {
      n.enabled !== !1 && (L.pointerType === "touch" ? it(L) : _e(L));
    }
    function ee(L) {
      q(L),
        S.length === 0 &&
          (n.domElement.releasePointerCapture(L.pointerId),
          n.domElement.removeEventListener("pointermove", oe),
          n.domElement.removeEventListener("pointerup", ee)),
        n.dispatchEvent(Qu),
        (s = i.NONE);
    }
    function we(L) {
      let te;
      switch (L.button) {
        case 0:
          te = n.mouseButtons.LEFT;
          break;
        case 1:
          te = n.mouseButtons.MIDDLE;
          break;
        case 2:
          te = n.mouseButtons.RIGHT;
          break;
        default:
          te = -1;
      }
      switch (te) {
        case ki.DOLLY:
          if (n.enableZoom === !1) return;
          B(L), (s = i.DOLLY);
          break;
        case ki.ROTATE:
          if (L.ctrlKey || L.metaKey || L.shiftKey) {
            if (n.enablePan === !1) return;
            G(L), (s = i.PAN);
          } else {
            if (n.enableRotate === !1) return;
            Z(L), (s = i.ROTATE);
          }
          break;
        case ki.PAN:
          if (L.ctrlKey || L.metaKey || L.shiftKey) {
            if (n.enableRotate === !1) return;
            Z(L), (s = i.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            G(L), (s = i.PAN);
          }
          break;
        default:
          s = i.NONE;
      }
      s !== i.NONE && n.dispatchEvent(yl);
    }
    function _e(L) {
      switch (s) {
        case i.ROTATE:
          if (n.enableRotate === !1) return;
          $(L);
          break;
        case i.DOLLY:
          if (n.enableZoom === !1) return;
          Y(L);
          break;
        case i.PAN:
          if (n.enablePan === !1) return;
          he(L);
          break;
      }
    }
    function xe(L) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        s !== i.NONE ||
        (L.preventDefault(), n.dispatchEvent(yl), F(L), n.dispatchEvent(Qu));
    }
    function Le(L) {
      n.enabled === !1 || n.enablePan === !1 || ne(L);
    }
    function ze(L) {
      switch ((ae(L), S.length)) {
        case 1:
          switch (n.touches.ONE) {
            case Hi.ROTATE:
              if (n.enableRotate === !1) return;
              ie(), (s = i.TOUCH_ROTATE);
              break;
            case Hi.PAN:
              if (n.enablePan === !1) return;
              me(), (s = i.TOUCH_PAN);
              break;
            default:
              s = i.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Hi.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              Me(), (s = i.TOUCH_DOLLY_PAN);
              break;
            case Hi.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              Ne(), (s = i.TOUCH_DOLLY_ROTATE);
              break;
            default:
              s = i.NONE;
          }
          break;
        default:
          s = i.NONE;
      }
      s !== i.NONE && n.dispatchEvent(yl);
    }
    function it(L) {
      switch ((ae(L), s)) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          Ce(L), n.update();
          break;
        case i.TOUCH_PAN:
          if (n.enablePan === !1) return;
          Ze(L), n.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          I(L), n.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          le(L), n.update();
          break;
        default:
          s = i.NONE;
      }
    }
    function C(L) {
      n.enabled !== !1 && L.preventDefault();
    }
    function E(L) {
      S.push(L);
    }
    function q(L) {
      delete w[L.pointerId];
      for (let te = 0; te < S.length; te++)
        if (S[te].pointerId == L.pointerId) {
          S.splice(te, 1);
          return;
        }
    }
    function ae(L) {
      let te = w[L.pointerId];
      te === void 0 && ((te = new K()), (w[L.pointerId] = te)),
        te.set(L.pageX, L.pageY);
    }
    function se(L) {
      const te = L.pointerId === S[0].pointerId ? S[1] : S[0];
      return w[te.pointerId];
    }
    n.domElement.addEventListener("contextmenu", C),
      n.domElement.addEventListener("pointerdown", Q),
      n.domElement.addEventListener("pointercancel", ee),
      n.domElement.addEventListener("wheel", xe, { passive: !1 }),
      this.update();
  }
}
const Bi = new ph(),
  Xt = new b(),
  li = new b(),
  lt = new et(),
  ed = { X: new b(1, 0, 0), Y: new b(0, 1, 0), Z: new b(0, 0, 1) },
  vl = { type: "change" },
  td = { type: "mouseDown" },
  nd = { type: "mouseUp", mode: null },
  id = { type: "objectChange" };
class GM extends qe {
  constructor(e, t) {
    super(),
      t === void 0 &&
        (console.warn(
          'THREE.TransformControls: The second parameter "domElement" is now mandatory.'
        ),
        (t = document)),
      (this.isTransformControls = !0),
      (this.visible = !1),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none");
    const n = new ZM();
    (this._gizmo = n), this.add(n);
    const i = new $M();
    (this._plane = i), this.add(i);
    const s = this;
    function a(v, x) {
      let y = x;
      Object.defineProperty(s, v, {
        get: function () {
          return y !== void 0 ? y : x;
        },
        set: function (S) {
          y !== S &&
            ((y = S),
            (i[v] = S),
            (n[v] = S),
            s.dispatchEvent({ type: v + "-changed", value: S }),
            s.dispatchEvent(vl));
        },
      }),
        (s[v] = x),
        (i[v] = x),
        (n[v] = x);
    }
    a("camera", e),
      a("object", void 0),
      a("enabled", !0),
      a("axis", null),
      a("mode", "translate"),
      a("translationSnap", null),
      a("rotationSnap", null),
      a("scaleSnap", null),
      a("space", "world"),
      a("size", 1),
      a("dragging", !1),
      a("showX", !0),
      a("showY", !0),
      a("showZ", !0);
    const o = new b(),
      l = new b(),
      c = new et(),
      h = new et(),
      u = new b(),
      d = new et(),
      f = new b(),
      m = new b(),
      _ = new b(),
      g = 0,
      p = new b();
    a("worldPosition", o),
      a("worldPositionStart", l),
      a("worldQuaternion", c),
      a("worldQuaternionStart", h),
      a("cameraPosition", u),
      a("cameraQuaternion", d),
      a("pointStart", f),
      a("pointEnd", m),
      a("rotationAxis", _),
      a("rotationAngle", g),
      a("eye", p),
      (this._offset = new b()),
      (this._startNorm = new b()),
      (this._endNorm = new b()),
      (this._cameraScale = new b()),
      (this._parentPosition = new b()),
      (this._parentQuaternion = new et()),
      (this._parentQuaternionInv = new et()),
      (this._parentScale = new b()),
      (this._worldScaleStart = new b()),
      (this._worldQuaternionInv = new et()),
      (this._worldScale = new b()),
      (this._positionStart = new b()),
      (this._quaternionStart = new et()),
      (this._scaleStart = new b()),
      (this._getPointer = VM.bind(this)),
      (this._onPointerDown = XM.bind(this)),
      (this._onPointerHover = WM.bind(this)),
      (this._onPointerMove = YM.bind(this)),
      (this._onPointerUp = qM.bind(this)),
      this.domElement.addEventListener("pointerdown", this._onPointerDown),
      this.domElement.addEventListener("pointermove", this._onPointerHover),
      this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 &&
      (this.object.updateMatrixWorld(),
      this.object.parent === null
        ? console.error(
            "TransformControls: The attached 3D object must be a part of the scene graph."
          )
        : this.object.parent.matrixWorld.decompose(
            this._parentPosition,
            this._parentQuaternion,
            this._parentScale
          ),
      this.object.matrixWorld.decompose(
        this.worldPosition,
        this.worldQuaternion,
        this._worldScale
      ),
      this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
      this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
      this.camera.updateMatrixWorld(),
      this.camera.matrixWorld.decompose(
        this.cameraPosition,
        this.cameraQuaternion,
        this._cameraScale
      ),
      this.camera.isOrthographicCamera
        ? this.camera.getWorldDirection(this.eye).negate()
        : this.eye
            .copy(this.cameraPosition)
            .sub(this.worldPosition)
            .normalize(),
      super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    Bi.setFromCamera(e, this.camera);
    const t = Ml(this._gizmo.picker[this.mode], Bi);
    t ? (this.axis = t.object.name) : (this.axis = null);
  }
  pointerDown(e) {
    if (
      !(this.object === void 0 || this.dragging === !0 || e.button !== 0) &&
      this.axis !== null
    ) {
      Bi.setFromCamera(e, this.camera);
      const t = Ml(this._plane, Bi, !0);
      t &&
        (this.object.updateMatrixWorld(),
        this.object.parent.updateMatrixWorld(),
        this._positionStart.copy(this.object.position),
        this._quaternionStart.copy(this.object.quaternion),
        this._scaleStart.copy(this.object.scale),
        this.object.matrixWorld.decompose(
          this.worldPositionStart,
          this.worldQuaternionStart,
          this._worldScaleStart
        ),
        this.pointStart.copy(t.point).sub(this.worldPositionStart)),
        (this.dragging = !0),
        (td.mode = this.mode),
        this.dispatchEvent(td);
    }
  }
  pointerMove(e) {
    const t = this.axis,
      n = this.mode,
      i = this.object;
    let s = this.space;
    if (
      (n === "scale"
        ? (s = "local")
        : (t === "E" || t === "XYZE" || t === "XYZ") && (s = "world"),
      i === void 0 || t === null || this.dragging === !1 || e.button !== -1)
    )
      return;
    Bi.setFromCamera(e, this.camera);
    const a = Ml(this._plane, Bi, !0);
    if (a) {
      if (
        (this.pointEnd.copy(a.point).sub(this.worldPositionStart),
        n === "translate")
      )
        this._offset.copy(this.pointEnd).sub(this.pointStart),
          s === "local" &&
            t !== "XYZ" &&
            this._offset.applyQuaternion(this._worldQuaternionInv),
          t.indexOf("X") === -1 && (this._offset.x = 0),
          t.indexOf("Y") === -1 && (this._offset.y = 0),
          t.indexOf("Z") === -1 && (this._offset.z = 0),
          s === "local" && t !== "XYZ"
            ? this._offset
                .applyQuaternion(this._quaternionStart)
                .divide(this._parentScale)
            : this._offset
                .applyQuaternion(this._parentQuaternionInv)
                .divide(this._parentScale),
          i.position.copy(this._offset).add(this._positionStart),
          this.translationSnap &&
            (s === "local" &&
              (i.position.applyQuaternion(
                lt.copy(this._quaternionStart).invert()
              ),
              t.search("X") !== -1 &&
                (i.position.x =
                  Math.round(i.position.x / this.translationSnap) *
                  this.translationSnap),
              t.search("Y") !== -1 &&
                (i.position.y =
                  Math.round(i.position.y / this.translationSnap) *
                  this.translationSnap),
              t.search("Z") !== -1 &&
                (i.position.z =
                  Math.round(i.position.z / this.translationSnap) *
                  this.translationSnap),
              i.position.applyQuaternion(this._quaternionStart)),
            s === "world" &&
              (i.parent &&
                i.position.add(Xt.setFromMatrixPosition(i.parent.matrixWorld)),
              t.search("X") !== -1 &&
                (i.position.x =
                  Math.round(i.position.x / this.translationSnap) *
                  this.translationSnap),
              t.search("Y") !== -1 &&
                (i.position.y =
                  Math.round(i.position.y / this.translationSnap) *
                  this.translationSnap),
              t.search("Z") !== -1 &&
                (i.position.z =
                  Math.round(i.position.z / this.translationSnap) *
                  this.translationSnap),
              i.parent &&
                i.position.sub(
                  Xt.setFromMatrixPosition(i.parent.matrixWorld)
                )));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let o = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (o *= -1), li.set(o, o, o);
        } else
          Xt.copy(this.pointStart),
            li.copy(this.pointEnd),
            Xt.applyQuaternion(this._worldQuaternionInv),
            li.applyQuaternion(this._worldQuaternionInv),
            li.divide(Xt),
            t.search("X") === -1 && (li.x = 1),
            t.search("Y") === -1 && (li.y = 1),
            t.search("Z") === -1 && (li.z = 1);
        i.scale.copy(this._scaleStart).multiply(li),
          this.scaleSnap &&
            (t.search("X") !== -1 &&
              (i.scale.x =
                Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            t.search("Y") !== -1 &&
              (i.scale.y =
                Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            t.search("Z") !== -1 &&
              (i.scale.z =
                Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const o =
          20 /
          this.worldPosition.distanceTo(
            Xt.setFromMatrixPosition(this.camera.matrixWorld)
          );
        t === "E"
          ? (this.rotationAxis.copy(this.eye),
            (this.rotationAngle = this.pointEnd.angleTo(this.pointStart)),
            this._startNorm.copy(this.pointStart).normalize(),
            this._endNorm.copy(this.pointEnd).normalize(),
            (this.rotationAngle *=
              this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1))
          : t === "XYZE"
          ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),
            (this.rotationAngle =
              this._offset.dot(Xt.copy(this.rotationAxis).cross(this.eye)) * o))
          : (t === "X" || t === "Y" || t === "Z") &&
            (this.rotationAxis.copy(ed[t]),
            Xt.copy(ed[t]),
            s === "local" && Xt.applyQuaternion(this.worldQuaternion),
            (this.rotationAngle =
              this._offset.dot(Xt.cross(this.eye).normalize()) * o)),
          this.rotationSnap &&
            (this.rotationAngle =
              Math.round(this.rotationAngle / this.rotationSnap) *
              this.rotationSnap),
          s === "local" && t !== "E" && t !== "XYZE"
            ? (i.quaternion.copy(this._quaternionStart),
              i.quaternion
                .multiply(
                  lt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
                )
                .normalize())
            : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv),
              i.quaternion.copy(
                lt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
              ),
              i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(vl), this.dispatchEvent(id);
    }
  }
  pointerUp(e) {
    e.button === 0 &&
      (this.dragging &&
        this.axis !== null &&
        ((nd.mode = this.mode), this.dispatchEvent(nd)),
      (this.dragging = !1),
      (this.axis = null));
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
      this.domElement.removeEventListener("pointermove", this._onPointerHover),
      this.domElement.removeEventListener("pointermove", this._onPointerMove),
      this.domElement.removeEventListener("pointerup", this._onPointerUp),
      this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
  }
  attach(e) {
    return (this.object = e), (this.visible = !0), this;
  }
  detach() {
    return (
      (this.object = void 0), (this.visible = !1), (this.axis = null), this
    );
  }
  reset() {
    this.enabled &&
      this.dragging &&
      (this.object.position.copy(this._positionStart),
      this.object.quaternion.copy(this._quaternionStart),
      this.object.scale.copy(this._scaleStart),
      this.dispatchEvent(vl),
      this.dispatchEvent(id),
      this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Bi;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function VM(r) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: r.button };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: ((r.clientX - e.left) / e.width) * 2 - 1,
      y: (-(r.clientY - e.top) / e.height) * 2 + 1,
      button: r.button,
    };
  }
}
function WM(r) {
  if (this.enabled)
    switch (r.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(r));
        break;
    }
}
function XM(r) {
  this.enabled &&
    (document.pointerLockElement ||
      this.domElement.setPointerCapture(r.pointerId),
    this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.pointerHover(this._getPointer(r)),
    this.pointerDown(this._getPointer(r)));
}
function YM(r) {
  this.enabled && this.pointerMove(this._getPointer(r));
}
function qM(r) {
  this.enabled &&
    (this.domElement.releasePointerCapture(r.pointerId),
    this.domElement.removeEventListener("pointermove", this._onPointerMove),
    this.pointerUp(this._getPointer(r)));
}
function Ml(r, e, t) {
  const n = e.intersectObject(r, !0);
  for (let i = 0; i < n.length; i++) if (n[i].object.visible || t) return n[i];
  return !1;
}
const Za = new an(),
  st = new b(0, 1, 0),
  sd = new b(0, 0, 0),
  rd = new Ue(),
  $a = new et(),
  ao = new et(),
  En = new b(),
  ad = new Ue(),
  xr = new b(1, 0, 0),
  Vi = new b(0, 1, 0),
  yr = new b(0, 0, 1),
  Ka = new b(),
  dr = new b(),
  fr = new b();
class ZM extends qe {
  constructor() {
    super(),
      (this.isTransformControlsGizmo = !0),
      (this.type = "TransformControlsGizmo");
    const e = new Ut({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      t = new Nt({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      n = e.clone();
    n.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const s = e.clone();
    s.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const o = e.clone();
    o.color.setHex(255);
    const l = e.clone();
    l.color.setHex(16711680), (l.opacity = 0.5);
    const c = e.clone();
    c.color.setHex(65280), (c.opacity = 0.5);
    const h = e.clone();
    h.color.setHex(255), (h.opacity = 0.5);
    const u = e.clone();
    u.opacity = 0.25;
    const d = e.clone();
    d.color.setHex(16776960),
      (d.opacity = 0.25),
      e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const _ = new mt(0, 0.04, 0.1, 12);
    _.translate(0, 0.05, 0);
    const g = new at(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const p = new He();
    p.setAttribute("position", new Te([0, 0, 0, 1, 0, 0], 3));
    const v = new mt(0.0075, 0.0075, 0.5, 3);
    v.translate(0, 0.25, 0);
    function x(N, Z) {
      const B = new Tn(N, 0.0075, 3, 64, Z * Math.PI * 2);
      return B.rotateY(Math.PI / 2), B.rotateX(Math.PI / 2), B;
    }
    function y() {
      const N = new He();
      return N.setAttribute("position", new Te([0, 0, 0, 1, 1, 1], 3)), N;
    }
    const S = {
        X: [
          [new ce(_, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new ce(_, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
          [new ce(v, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        Y: [
          [new ce(_, a), [0, 0.5, 0]],
          [new ce(_, a), [0, -0.5, 0], [Math.PI, 0, 0]],
          [new ce(v, a)],
        ],
        Z: [
          [new ce(_, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new ce(_, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
          [new ce(v, o), null, [Math.PI / 2, 0, 0]],
        ],
        XYZ: [[new ce(new Cn(0.1, 0), u.clone()), [0, 0, 0]]],
        XY: [[new ce(new at(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]],
        YZ: [
          [
            new ce(new at(0.15, 0.15, 0.01), l.clone()),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new ce(new at(0.15, 0.15, 0.01), c.clone()),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      w = {
        X: [
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new ce(new Cn(0.2, 0), n)]],
        XY: [[new ce(new at(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]],
        YZ: [
          [
            new ce(new at(0.2, 0.2, 0.01), n),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new ce(new at(0.2, 0.2, 0.01), n),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      R = {
        START: [[new ce(new Cn(0.01, 2), i), null, null, null, "helper"]],
        END: [[new ce(new Cn(0.01, 2), i), null, null, null, "helper"]],
        DELTA: [[new It(y(), i), null, null, null, "helper"]],
        X: [[new It(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new It(p, i.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new It(p, i.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      },
      P = {
        XYZE: [[new ce(x(0.5, 1), m), null, [0, Math.PI / 2, 0]]],
        X: [[new ce(x(0.5, 0.5), s)]],
        Y: [[new ce(x(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]],
        Z: [[new ce(x(0.5, 0.5), o), null, [0, Math.PI / 2, 0]]],
        E: [[new ce(x(0.75, 1), d), null, [0, Math.PI / 2, 0]]],
      },
      M = {
        AXIS: [
          [new It(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"],
        ],
      },
      A = {
        XYZE: [[new ce(new ti(0.25, 10, 8), n)]],
        X: [
          [
            new ce(new Tn(0.5, 0.1, 4, 24), n),
            [0, 0, 0],
            [0, -Math.PI / 2, -Math.PI / 2],
          ],
        ],
        Y: [
          [new ce(new Tn(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]],
        ],
        Z: [
          [new ce(new Tn(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        E: [[new ce(new Tn(0.75, 0.1, 2, 24), n)]],
      },
      k = {
        X: [
          [new ce(g, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new ce(v, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
          [new ce(g, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        ],
        Y: [
          [new ce(g, a), [0, 0.5, 0]],
          [new ce(v, a)],
          [new ce(g, a), [0, -0.5, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new ce(g, o), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new ce(v, o), [0, 0, 0], [Math.PI / 2, 0, 0]],
          [new ce(g, o), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        ],
        XY: [[new ce(new at(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]],
        YZ: [
          [
            new ce(new at(0.15, 0.15, 0.01), l),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new ce(new at(0.15, 0.15, 0.01), c),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new ce(new at(0.1, 0.1, 0.1), u.clone())]],
      },
      X = {
        X: [
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new ce(new mt(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new ce(new mt(0.2, 0, 0.6, 4), n),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XY: [[new ce(new at(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]],
        YZ: [
          [
            new ce(new at(0.2, 0.2, 0.01), n),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new ce(new at(0.2, 0.2, 0.01), n),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new ce(new at(0.2, 0.2, 0.2), n), [0, 0, 0]]],
      },
      U = {
        X: [[new It(p, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new It(p, i.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new It(p, i.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      };
    function O(N) {
      const Z = new qe();
      for (const B in N)
        for (let G = N[B].length; G--; ) {
          const $ = N[B][G][0].clone(),
            Y = N[B][G][1],
            he = N[B][G][2],
            F = N[B][G][3],
            ne = N[B][G][4];
          ($.name = B),
            ($.tag = ne),
            Y && $.position.set(Y[0], Y[1], Y[2]),
            he && $.rotation.set(he[0], he[1], he[2]),
            F && $.scale.set(F[0], F[1], F[2]),
            $.updateMatrix();
          const ie = $.geometry.clone();
          ie.applyMatrix4($.matrix),
            ($.geometry = ie),
            ($.renderOrder = 1 / 0),
            $.position.set(0, 0, 0),
            $.rotation.set(0, 0, 0),
            $.scale.set(1, 1, 1),
            Z.add($);
        }
      return Z;
    }
    (this.gizmo = {}),
      (this.picker = {}),
      (this.helper = {}),
      this.add((this.gizmo.translate = O(S))),
      this.add((this.gizmo.rotate = O(P))),
      this.add((this.gizmo.scale = O(k))),
      this.add((this.picker.translate = O(w))),
      this.add((this.picker.rotate = O(A))),
      this.add((this.picker.scale = O(X))),
      this.add((this.helper.translate = O(R))),
      this.add((this.helper.rotate = O(M))),
      this.add((this.helper.scale = O(U))),
      (this.picker.translate.visible = !1),
      (this.picker.rotate.visible = !1),
      (this.picker.scale.visible = !1);
  }
  updateMatrixWorld(e) {
    const n =
      (this.mode === "scale" ? "local" : this.space) === "local"
        ? this.worldQuaternion
        : ao;
    (this.gizmo.translate.visible = this.mode === "translate"),
      (this.gizmo.rotate.visible = this.mode === "rotate"),
      (this.gizmo.scale.visible = this.mode === "scale"),
      (this.helper.translate.visible = this.mode === "translate"),
      (this.helper.rotate.visible = this.mode === "rotate"),
      (this.helper.scale.visible = this.mode === "scale");
    let i = [];
    (i = i.concat(this.picker[this.mode].children)),
      (i = i.concat(this.gizmo[this.mode].children)),
      (i = i.concat(this.helper[this.mode].children));
    for (let s = 0; s < i.length; s++) {
      const a = i[s];
      (a.visible = !0),
        a.rotation.set(0, 0, 0),
        a.position.copy(this.worldPosition);
      let o;
      if (
        (this.camera.isOrthographicCamera
          ? (o = (this.camera.top - this.camera.bottom) / this.camera.zoom)
          : (o =
              this.worldPosition.distanceTo(this.cameraPosition) *
              Math.min(
                (1.9 * Math.tan((Math.PI * this.camera.fov) / 360)) /
                  this.camera.zoom,
                7
              )),
        a.scale.set(1, 1, 1).multiplyScalar((o * this.size) / 4),
        a.tag === "helper")
      ) {
        (a.visible = !1),
          a.name === "AXIS"
            ? ((a.visible = !!this.axis),
              this.axis === "X" &&
                (lt.setFromEuler(Za.set(0, 0, 0)),
                a.quaternion.copy(n).multiply(lt),
                Math.abs(st.copy(xr).applyQuaternion(n).dot(this.eye)) > 0.9 &&
                  (a.visible = !1)),
              this.axis === "Y" &&
                (lt.setFromEuler(Za.set(0, 0, Math.PI / 2)),
                a.quaternion.copy(n).multiply(lt),
                Math.abs(st.copy(Vi).applyQuaternion(n).dot(this.eye)) > 0.9 &&
                  (a.visible = !1)),
              this.axis === "Z" &&
                (lt.setFromEuler(Za.set(0, Math.PI / 2, 0)),
                a.quaternion.copy(n).multiply(lt),
                Math.abs(st.copy(yr).applyQuaternion(n).dot(this.eye)) > 0.9 &&
                  (a.visible = !1)),
              this.axis === "XYZE" &&
                (lt.setFromEuler(Za.set(0, Math.PI / 2, 0)),
                st.copy(this.rotationAxis),
                a.quaternion.setFromRotationMatrix(rd.lookAt(sd, st, Vi)),
                a.quaternion.multiply(lt),
                (a.visible = this.dragging)),
              this.axis === "E" && (a.visible = !1))
            : a.name === "START"
            ? (a.position.copy(this.worldPositionStart),
              (a.visible = this.dragging))
            : a.name === "END"
            ? (a.position.copy(this.worldPosition), (a.visible = this.dragging))
            : a.name === "DELTA"
            ? (a.position.copy(this.worldPositionStart),
              a.quaternion.copy(this.worldQuaternionStart),
              Xt.set(1e-10, 1e-10, 1e-10)
                .add(this.worldPositionStart)
                .sub(this.worldPosition)
                .multiplyScalar(-1),
              Xt.applyQuaternion(this.worldQuaternionStart.clone().invert()),
              a.scale.copy(Xt),
              (a.visible = this.dragging))
            : (a.quaternion.copy(n),
              this.dragging
                ? a.position.copy(this.worldPositionStart)
                : a.position.copy(this.worldPosition),
              this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(n),
        this.mode === "translate" || this.mode === "scale"
          ? (a.name === "X" &&
              Math.abs(st.copy(xr).applyQuaternion(n).dot(this.eye)) > 0.99 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
            a.name === "Y" &&
              Math.abs(st.copy(Vi).applyQuaternion(n).dot(this.eye)) > 0.99 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
            a.name === "Z" &&
              Math.abs(st.copy(yr).applyQuaternion(n).dot(this.eye)) > 0.99 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
            a.name === "XY" &&
              Math.abs(st.copy(yr).applyQuaternion(n).dot(this.eye)) < 0.2 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
            a.name === "YZ" &&
              Math.abs(st.copy(xr).applyQuaternion(n).dot(this.eye)) < 0.2 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)),
            a.name === "XZ" &&
              Math.abs(st.copy(Vi).applyQuaternion(n).dot(this.eye)) < 0.2 &&
              (a.scale.set(1e-10, 1e-10, 1e-10), (a.visible = !1)))
          : this.mode === "rotate" &&
            ($a.copy(n),
            st.copy(this.eye).applyQuaternion(lt.copy(n).invert()),
            a.name.search("E") !== -1 &&
              a.quaternion.setFromRotationMatrix(rd.lookAt(this.eye, sd, Vi)),
            a.name === "X" &&
              (lt.setFromAxisAngle(xr, Math.atan2(-st.y, st.z)),
              lt.multiplyQuaternions($a, lt),
              a.quaternion.copy(lt)),
            a.name === "Y" &&
              (lt.setFromAxisAngle(Vi, Math.atan2(st.x, st.z)),
              lt.multiplyQuaternions($a, lt),
              a.quaternion.copy(lt)),
            a.name === "Z" &&
              (lt.setFromAxisAngle(yr, Math.atan2(st.y, st.x)),
              lt.multiplyQuaternions($a, lt),
              a.quaternion.copy(lt))),
        (a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX)),
        (a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY)),
        (a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ)),
        (a.visible =
          a.visible &&
          (a.name.indexOf("E") === -1 ||
            (this.showX && this.showY && this.showZ))),
        (a.material._color = a.material._color || a.material.color.clone()),
        (a.material._opacity = a.material._opacity || a.material.opacity),
        a.material.color.copy(a.material._color),
        (a.material.opacity = a.material._opacity),
        this.enabled &&
          this.axis &&
          (a.name === this.axis ||
            this.axis.split("").some(function (l) {
              return a.name === l;
            })) &&
          (a.material.color.setHex(16776960), (a.material.opacity = 1));
    }
    super.updateMatrixWorld(e);
  }
}
class $M extends ce {
  constructor() {
    super(
      new Qn(1e5, 1e5, 2, 2),
      new Ut({
        visible: !1,
        wireframe: !0,
        side: Gt,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1,
      })
    ),
      (this.isTransformControlsPlane = !0),
      (this.type = "TransformControlsPlane");
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (
      (this.position.copy(this.worldPosition),
      this.mode === "scale" && (t = "local"),
      Ka.copy(xr).applyQuaternion(t === "local" ? this.worldQuaternion : ao),
      dr.copy(Vi).applyQuaternion(t === "local" ? this.worldQuaternion : ao),
      fr.copy(yr).applyQuaternion(t === "local" ? this.worldQuaternion : ao),
      st.copy(dr),
      this.mode)
    ) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            st.copy(this.eye).cross(Ka), En.copy(Ka).cross(st);
            break;
          case "Y":
            st.copy(this.eye).cross(dr), En.copy(dr).cross(st);
            break;
          case "Z":
            st.copy(this.eye).cross(fr), En.copy(fr).cross(st);
            break;
          case "XY":
            En.copy(fr);
            break;
          case "YZ":
            En.copy(Ka);
            break;
          case "XZ":
            st.copy(fr), En.copy(dr);
            break;
          case "XYZ":
          case "E":
            En.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        En.set(0, 0, 0);
    }
    En.length() === 0
      ? this.quaternion.copy(this.cameraQuaternion)
      : (ad.lookAt(Xt.set(0, 0, 0), En, st),
        this.quaternion.setFromRotationMatrix(ad)),
      super.updateMatrixWorld(e);
  }
}
class KM extends qe {
  constructor(e, t) {
    super(),
      (this.isViewHelper = !0),
      (this.animating = !1),
      (this.center = new b());
    const n = new de("#ff3653"),
      i = new de("#8adb00"),
      s = new de("#2c8fff"),
      a = [],
      o = new ph(),
      l = new K(),
      c = new qe(),
      h = new Ks(-2, 2, 2, -2, 0, 4);
    h.position.set(0, 0, 2);
    const u = new at(0.8, 0.05, 0.05).translate(0.4, 0, 0),
      d = new ce(u, N(n)),
      f = new ce(u, N(i)),
      m = new ce(u, N(s));
    (f.rotation.z = Math.PI / 2),
      (m.rotation.y = -Math.PI / 2),
      this.add(d),
      this.add(m),
      this.add(f);
    const _ = new di(Z(n, "X"));
    _.userData.type = "posX";
    const g = new di(Z(i, "Y"));
    g.userData.type = "posY";
    const p = new di(Z(s, "Z"));
    p.userData.type = "posZ";
    const v = new di(Z(n));
    v.userData.type = "negX";
    const x = new di(Z(i));
    x.userData.type = "negY";
    const y = new di(Z(s));
    (y.userData.type = "negZ"),
      (_.position.x = 1),
      (g.position.y = 1),
      (p.position.z = 1),
      (v.position.x = -1),
      v.scale.setScalar(0.8),
      (x.position.y = -1),
      x.scale.setScalar(0.8),
      (y.position.z = -1),
      y.scale.setScalar(0.8),
      this.add(_),
      this.add(g),
      this.add(p),
      this.add(v),
      this.add(x),
      this.add(y),
      a.push(_),
      a.push(g),
      a.push(p),
      a.push(v),
      a.push(x),
      a.push(y);
    const S = new b(),
      w = 128,
      R = 2 * Math.PI;
    this.render = function (B) {
      this.quaternion.copy(e.quaternion).invert(),
        this.updateMatrixWorld(),
        S.set(0, 0, 1),
        S.applyQuaternion(e.quaternion),
        S.x >= 0
          ? ((_.material.opacity = 1), (v.material.opacity = 0.5))
          : ((_.material.opacity = 0.5), (v.material.opacity = 1)),
        S.y >= 0
          ? ((g.material.opacity = 1), (x.material.opacity = 0.5))
          : ((g.material.opacity = 0.5), (x.material.opacity = 1)),
        S.z >= 0
          ? ((p.material.opacity = 1), (y.material.opacity = 0.5))
          : ((p.material.opacity = 0.5), (y.material.opacity = 1));
      const G = t.offsetWidth - w;
      B.clearDepth(),
        B.getViewport(X),
        B.setViewport(G, 0, w, w),
        B.render(this, h),
        B.setViewport(X.x, X.y, X.z, X.w);
    };
    const P = new b(),
      M = new et(),
      A = new et(),
      k = new et(),
      X = new tt();
    let U = 0;
    (this.handleClick = function (B) {
      if (this.animating === !0) return !1;
      const G = t.getBoundingClientRect(),
        $ = G.left + (t.offsetWidth - w),
        Y = G.top + (t.offsetHeight - w);
      (l.x = ((B.clientX - $) / (G.right - $)) * 2 - 1),
        (l.y = -((B.clientY - Y) / (G.bottom - Y)) * 2 + 1),
        o.setFromCamera(l, h);
      const he = o.intersectObjects(a);
      if (he.length > 0) {
        const ne = he[0].object;
        return O(ne, this.center), (this.animating = !0), !0;
      } else return !1;
    }),
      (this.update = function (B) {
        const G = B * R;
        A.rotateTowards(k, G),
          e.position
            .set(0, 0, 1)
            .applyQuaternion(A)
            .multiplyScalar(U)
            .add(this.center),
          e.quaternion.rotateTowards(M, G),
          A.angleTo(k) === 0 && (this.animating = !1);
      }),
      (this.dispose = function () {
        u.dispose(),
          d.material.dispose(),
          f.material.dispose(),
          m.material.dispose(),
          _.material.map.dispose(),
          g.material.map.dispose(),
          p.material.map.dispose(),
          v.material.map.dispose(),
          x.material.map.dispose(),
          y.material.map.dispose(),
          _.material.dispose(),
          g.material.dispose(),
          p.material.dispose(),
          v.material.dispose(),
          x.material.dispose(),
          y.material.dispose();
      });
    function O(B, G) {
      switch (B.userData.type) {
        case "posX":
          P.set(1, 0, 0), M.setFromEuler(new an(0, Math.PI * 0.5, 0));
          break;
        case "posY":
          P.set(0, 1, 0), M.setFromEuler(new an(-Math.PI * 0.5, 0, 0));
          break;
        case "posZ":
          P.set(0, 0, 1), M.setFromEuler(new an());
          break;
        case "negX":
          P.set(-1, 0, 0), M.setFromEuler(new an(0, -Math.PI * 0.5, 0));
          break;
        case "negY":
          P.set(0, -1, 0), M.setFromEuler(new an(Math.PI * 0.5, 0, 0));
          break;
        case "negZ":
          P.set(0, 0, -1), M.setFromEuler(new an(0, Math.PI, 0));
          break;
        default:
          console.error("ViewHelper: Invalid axis.");
      }
      (U = e.position.distanceTo(G)),
        P.multiplyScalar(U).add(G),
        c.position.copy(G),
        c.lookAt(e.position),
        A.copy(c.quaternion),
        c.lookAt(P),
        k.copy(c.quaternion);
    }
    function N(B) {
      return new Ut({ color: B, toneMapped: !1 });
    }
    function Z(B, G = null) {
      const $ = document.createElement("canvas");
      ($.width = 64), ($.height = 64);
      const Y = $.getContext("2d");
      Y.beginPath(),
        Y.arc(32, 32, 16, 0, 2 * Math.PI),
        Y.closePath(),
        (Y.fillStyle = B.getStyle()),
        Y.fill(),
        G !== null &&
          ((Y.font = "24px Arial"),
          (Y.textAlign = "center"),
          (Y.fillStyle = "#000000"),
          Y.fillText(G, 32, 41));
      const he = new If($);
      return new Ao({ map: he, toneMapped: !1 });
    }
  }
}
function od(r, e) {
  if (e === Qd)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      r
    );
  if (e === lo || e === Lc) {
    let t = r.getIndex();
    if (t === null) {
      const a = [],
        o = r.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++) a.push(l);
        r.setIndex(a), (t = r.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          r
        );
    }
    const n = t.count - 2,
      i = [];
    if (e === lo)
      for (let a = 1; a <= n; a++)
        i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0
          ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2)))
          : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = r.clone();
    return s.setIndex(i), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      r
    );
}
class jM extends $t {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new nS(t);
      }),
      this.register(function (t) {
        return new hS(t);
      }),
      this.register(function (t) {
        return new uS(t);
      }),
      this.register(function (t) {
        return new dS(t);
      }),
      this.register(function (t) {
        return new sS(t);
      }),
      this.register(function (t) {
        return new rS(t);
      }),
      this.register(function (t) {
        return new aS(t);
      }),
      this.register(function (t) {
        return new oS(t);
      }),
      this.register(function (t) {
        return new tS(t);
      }),
      this.register(function (t) {
        return new lS(t);
      }),
      this.register(function (t) {
        return new iS(t);
      }),
      this.register(function (t) {
        return new cS(t);
      }),
      this.register(function (t) {
        return new QM(t);
      }),
      this.register(function (t) {
        return new fS(t);
      }),
      this.register(function (t) {
        return new pS(t);
      });
  }
  load(e, t, n, i) {
    const s = this;
    let a;
    this.resourcePath !== ""
      ? (a = this.resourcePath)
      : this.path !== ""
      ? (a = this.path)
      : (a = qs.extractUrlBase(e)),
      this.manager.itemStart(e);
    const o = function (c) {
        i ? i(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new vn(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              a,
              function (h) {
                t(h), s.manager.itemEnd(e);
              },
              o
            );
          } catch (h) {
            o(h);
          }
        },
        n,
        o
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let s;
    const a = {},
      o = {},
      l = new TextDecoder();
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === gp) {
        try {
          a[Ke.KHR_BINARY_GLTF] = new mS(e);
        } catch (u) {
          i && i(u);
          return;
        }
        s = JSON.parse(a[Ke.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(l.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new RS(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      (o[u.name] = u), (a[u.name] = !0);
    }
    if (s.extensionsUsed)
      for (let h = 0; h < s.extensionsUsed.length; ++h) {
        const u = s.extensionsUsed[h],
          d = s.extensionsRequired || [];
        switch (u) {
          case Ke.KHR_MATERIALS_UNLIT:
            a[u] = new eS();
            break;
          case Ke.KHR_DRACO_MESH_COMPRESSION:
            a[u] = new gS(s, this.dracoLoader);
            break;
          case Ke.KHR_TEXTURE_TRANSFORM:
            a[u] = new _S();
            break;
          case Ke.KHR_MESH_QUANTIZATION:
            a[u] = new xS();
            break;
          default:
            d.indexOf(u) >= 0 &&
              o[u] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.parse(e, t, i, s);
    });
  }
}
function JM() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    },
  };
}
const Ke = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class QM {
  constructor(e) {
    (this.parser = e),
      (this.name = Ke.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const h = new de(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new lh(h)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new er(h)), (c.distance = u);
        break;
      case "spot":
        (c = new oh(h)),
          (c.distance = u),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      fi(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(c)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      s = n.json.nodes[e],
      o = ((s.extensions && s.extensions[this.name]) || {}).light;
    return o === void 0
      ? null
      : this._loadLight(o).then(function (l) {
          return n._getNodeRef(t.cache, o, l);
        });
  }
}
class eS {
  constructor() {
    this.name = Ke.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ut;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new de(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.fromArray(a), (e.opacity = a[3]);
      }
      s.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", s.baseColorTexture, Oe));
    }
    return Promise.all(i);
  }
}
class tS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class nS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture
          )
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (s.push(
          n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new K(o, o);
    }
    return Promise.all(s);
  }
}
class iS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class sS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new de(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = i.extensions[this.name];
    return (
      a.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(a.sheenColorFactor),
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Oe)),
      a.sheenRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class rS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class aS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const o = a.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new de(o[0], o[1], o[2])), Promise.all(s);
  }
}
class oS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class lS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new de(o[0], o[1], o[2])),
      a.specularColorTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "specularColorMap", a.specularColorTexture, Oe)
        ),
      Promise.all(s)
    );
  }
}
class cS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Nn;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength),
      a.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = a.anisotropyRotation),
      a.anisotropyTexture !== void 0 &&
        s.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class hS {
  constructor(e) {
    (this.parser = e), (this.name = Ke.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const s = i.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class uS {
  constructor(e) {
    (this.parser = e),
      (this.name = Ke.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class dS {
  constructor(e) {
    (this.parser = e),
      (this.name = Ke.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class fS {
  constructor(e) {
    (this.name = Ke.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        s = this.parser.getDependency("buffer", i.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (o) {
        const l = i.byteOffset || 0,
          c = i.byteLength || 0,
          h = i.count,
          u = i.byteStride,
          d = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(h, u, d, i.mode, i.filter)
              .then(function (f) {
                return f.buffer;
              })
          : a.ready.then(function () {
              const f = new ArrayBuffer(h * u);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(f),
                  h,
                  u,
                  d,
                  i.mode,
                  i.filter
                ),
                f
              );
            });
      });
    } else return null;
  }
}
class pS {
  constructor(e) {
    (this.name = Ke.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (
        c.mode !== sn.TRIANGLES &&
        c.mode !== sn.TRIANGLE_STRIP &&
        c.mode !== sn.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const a = n.extensions[this.name].attributes,
      o = [],
      l = {};
    for (const c in a)
      o.push(
        this.parser
          .getDependency("accessor", a[c])
          .then((h) => ((l[c] = h), l[c]))
      );
    return o.length < 1
      ? null
      : (o.push(this.parser.createNodeMesh(e)),
        Promise.all(o).then((c) => {
          const h = c.pop(),
            u = h.isGroup ? h.children : [h],
            d = c[0].count,
            f = [];
          for (const m of u) {
            const _ = new Ue(),
              g = new b(),
              p = new et(),
              v = new b(1, 1, 1),
              x = new Wc(m.geometry, m.material, d);
            for (let y = 0; y < d; y++)
              l.TRANSLATION && g.fromBufferAttribute(l.TRANSLATION, y),
                l.ROTATION && p.fromBufferAttribute(l.ROTATION, y),
                l.SCALE && v.fromBufferAttribute(l.SCALE, y),
                x.setMatrixAt(y, _.compose(g, p, v));
            for (const y in l)
              y !== "TRANSLATION" &&
                y !== "ROTATION" &&
                y !== "SCALE" &&
                m.geometry.setAttribute(y, l[y]);
            qe.prototype.copy.call(x, m),
              this.parser.assignFinalMaterial(x),
              f.push(x);
          }
          return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
        }));
  }
}
const gp = "glTF",
  pr = 12,
  ld = { JSON: 1313821514, BIN: 5130562 };
class mS {
  constructor(e) {
    (this.name = Ke.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, pr),
      n = new TextDecoder();
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== gp)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - pr,
      s = new DataView(e, pr);
    let a = 0;
    for (; a < i; ) {
      const o = s.getUint32(a, !0);
      a += 4;
      const l = s.getUint32(a, !0);
      if (((a += 4), l === ld.JSON)) {
        const c = new Uint8Array(e, pr + a, o);
        this.content = n.decode(c);
      } else if (l === ld.BIN) {
        const c = pr + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class gS {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Ke.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      o = {},
      l = {},
      c = {};
    for (const h in a) {
      const u = mc[h] || h.toLowerCase();
      o[u] = a[h];
    }
    for (const h in e.attributes) {
      const u = mc[h] || h.toLowerCase();
      if (a[h] !== void 0) {
        const d = n.accessors[e.attributes[h]],
          f = Os[d.componentType];
        (c[u] = f.name), (l[u] = d.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (h) {
      return new Promise(function (u) {
        i.decodeDracoFile(
          h,
          function (d) {
            for (const f in d.attributes) {
              const m = d.attributes[f],
                _ = l[f];
              _ !== void 0 && (m.normalized = _);
            }
            u(d);
          },
          o,
          c
        );
      });
    });
  }
}
class _S {
  constructor() {
    this.name = Ke.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class xS {
  constructor() {
    this.name = Ke.KHR_MESH_QUANTIZATION;
  }
}
class _p extends Qs {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i * 3 + i;
    for (let a = 0; a !== i; a++) t[a] = n[s + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = o * 2,
      c = o * 3,
      h = i - t,
      u = (n - t) / h,
      d = u * u,
      f = d * u,
      m = e * c,
      _ = m - c,
      g = -2 * f + 3 * d,
      p = f - d,
      v = 1 - g,
      x = p - d + u;
    for (let y = 0; y !== o; y++) {
      const S = a[_ + y + o],
        w = a[_ + y + l] * h,
        R = a[m + y + o],
        P = a[m + y] * h;
      s[y] = v * S + x * w + g * R + p * P;
    }
    return s;
  }
}
const yS = new et();
class vS extends _p {
  interpolate_(e, t, n, i) {
    const s = super.interpolate_(e, t, n, i);
    return yS.fromArray(s).normalize().toArray(s), s;
  }
}
const sn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Os = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  cd = { 9728: gt, 9729: ot, 9984: Tr, 9985: go, 9986: Ds, 9987: Dn },
  hd = { 33071: Dt, 33648: Fs, 10497: Mi },
  Sl = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  mc = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  ci = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  MS = { CUBICSPLINE: void 0, LINEAR: ns, STEP: zs },
  bl = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function SS(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new na({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Zt,
      })),
    r.DefaultMaterial
  );
}
function zi(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function fi(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(r.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function bS(r, e, t) {
  let n = !1,
    i = !1,
    s = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (
      (u.POSITION !== void 0 && (n = !0),
      u.NORMAL !== void 0 && (i = !0),
      u.COLOR_0 !== void 0 && (s = !0),
      n && i && s)
    )
      break;
  }
  if (!n && !i && !s) return Promise.resolve(r);
  const a = [],
    o = [],
    l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const d =
        u.POSITION !== void 0
          ? t.getDependency("accessor", u.POSITION)
          : r.attributes.position;
      a.push(d);
    }
    if (i) {
      const d =
        u.NORMAL !== void 0
          ? t.getDependency("accessor", u.NORMAL)
          : r.attributes.normal;
      o.push(d);
    }
    if (s) {
      const d =
        u.COLOR_0 !== void 0
          ? t.getDependency("accessor", u.COLOR_0)
          : r.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
    function (c) {
      const h = c[0],
        u = c[1],
        d = c[2];
      return (
        n && (r.morphAttributes.position = h),
        i && (r.morphAttributes.normal = u),
        s && (r.morphAttributes.color = d),
        (r.morphTargetsRelative = !0),
        r
      );
    }
  );
}
function wS(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        r.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function ES(r) {
  let e;
  const t = r.extensions && r.extensions[Ke.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + wl(t.attributes))
      : (e = r.indices + ":" + wl(r.attributes) + ":" + r.mode),
    r.targets !== void 0)
  )
    for (let n = 0, i = r.targets.length; n < i; n++)
      e += ":" + wl(r.targets[n]);
  return e;
}
function wl(r) {
  let e = "";
  const t = Object.keys(r).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
  return e;
}
function gc(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function AS(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const TS = new Ue();
class RS {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new JM()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      s = -1;
    typeof navigator < "u" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || n || (i && s < 98)
        ? (this.textureLoader = new rh(this.options.manager))
        : (this.textureLoader = new lp(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new vn(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const o = {
            scene: a[0][i.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          zi(s, o, i),
            fi(o, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(o);
              })
            ).then(function () {
              e(o);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i].joints;
      for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      const a = e[i];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      s = (a, o) => {
        const l = this.associations.get(a);
        l != null && this.associations.set(o, l);
        for (const [c, h] of a.children.entries()) s(h, o.children[c]);
      };
    return s(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const s = e(t[i]);
      s && n.push(s);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (s, a) {
          return n.getDependency(e, a);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ke.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (s, a) {
      n.load(qs.resolveURL(t.uri, i.path), s, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        s = t.byteOffset || 0;
      return n.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = Sl[i.type],
        o = Os[i.componentType],
        l = i.normalized === !0,
        c = new o(i.count * a);
      return Promise.resolve(new nt(c, a, l));
    }
    const s = [];
    return (
      i.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", i.bufferView))
        : s.push(null),
      i.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(s).then(function (a) {
        const o = a[0],
          l = Sl[i.type],
          c = Os[i.componentType],
          h = c.BYTES_PER_ELEMENT,
          u = h * l,
          d = i.byteOffset || 0,
          f =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          m = i.normalized === !0;
        let _, g;
        if (f && f !== u) {
          const p = Math.floor(d / f),
            v =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              p +
              ":" +
              i.count;
          let x = t.cache.get(v);
          x ||
            ((_ = new c(o, p * f, (i.count * f) / h)),
            (x = new Vr(_, f / h)),
            t.cache.add(v, x)),
            (g = new Si(x, l, (d % f) / h, m));
        } else o === null ? (_ = new c(i.count * l)) : (_ = new c(o, d, i.count * l)), (g = new nt(_, l, m));
        if (i.sparse !== void 0) {
          const p = Sl.SCALAR,
            v = Os[i.sparse.indices.componentType],
            x = i.sparse.indices.byteOffset || 0,
            y = i.sparse.values.byteOffset || 0,
            S = new v(a[1], x, i.sparse.count * p),
            w = new c(a[2], y, i.sparse.count * l);
          o !== null && (g = new nt(g.array.slice(), g.itemSize, g.normalized));
          for (let R = 0, P = S.length; R < P; R++) {
            const M = S[R];
            if (
              (g.setX(M, w[R * l]),
              l >= 2 && g.setY(M, w[R * l + 1]),
              l >= 3 && g.setZ(M, w[R * l + 2]),
              l >= 4 && g.setW(M, w[R * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return g;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      s = t.textures[e].source,
      a = t.images[s];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, s, o);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      s = this.json,
      a = s.textures[e],
      o = s.images[t],
      l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, n)
      .then(function (h) {
        (h.flipY = !1),
          (h.name = a.name || o.name || ""),
          h.name === "" &&
            typeof o.uri == "string" &&
            o.uri.startsWith("data:image/") === !1 &&
            (h.name = o.uri);
        const d = (s.samplers || {})[a.sampler] || {};
        return (
          (h.magFilter = cd[d.magFilter] || ot),
          (h.minFilter = cd[d.minFilter] || Dn),
          (h.wrapS = hd[d.wrapS] || Mi),
          (h.wrapT = hd[d.wrapT] || Mi),
          i.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const a = i.images[e],
      o = self.URL || self.webkitURL;
    let l = a.uri || "",
      c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function (u) {
        c = !0;
        const d = new Blob([u], { type: a.mimeType });
        return (l = o.createObjectURL(d)), l;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (u) {
        return new Promise(function (d, f) {
          let m = d;
          t.isImageBitmapLoader === !0 &&
            (m = function (_) {
              const g = new ht(_);
              (g.needsUpdate = !0), d(g);
            }),
            t.load(qs.resolveURL(u, s.path), m, void 0, f);
        });
      })
      .then(function (u) {
        return (
          c === !0 && o.revokeObjectURL(l),
          (u.userData.mimeType = a.mimeType || AS(a.uri)),
          u
        );
      })
      .catch(function (u) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), u);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, n, i) {
    const s = this;
    return this.getDependency("texture", n.index).then(function (a) {
      if (!a) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((a = a.clone()), (a.channel = n.texCoord)),
        s.extensions[Ke.KHR_TEXTURE_TRANSFORM])
      ) {
        const o =
          n.extensions !== void 0
            ? n.extensions[Ke.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (o) {
          const l = s.associations.get(a);
          (a = s.extensions[Ke.KHR_TEXTURE_TRANSFORM].extendTexture(a, o)),
            s.associations.set(a, l);
        }
      }
      return i !== void 0 && (a.colorSpace = i), (e[t] = a), a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new Ro()),
        At.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(o, l)),
        (n = l);
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new Nt()),
        At.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        this.cache.add(o, l)),
        (n = l);
    }
    if (i || s || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      i && (o += "derivative-tangents:"),
        s && (o += "vertex-colors:"),
        a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l ||
        ((l = n.clone()),
        s && (l.vertexColors = !0),
        a && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(o, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l);
    }
    e.material = n;
  }
  getMaterialType() {
    return na;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[e];
    let a;
    const o = {},
      l = s.extensions || {},
      c = [];
    if (l[Ke.KHR_MATERIALS_UNLIT]) {
      const u = i[Ke.KHR_MATERIALS_UNLIT];
      (a = u.getMaterialType()), c.push(u.extendParams(o, s, t));
    } else {
      const u = s.pbrMetallicRoughness || {};
      if (
        ((o.color = new de(1, 1, 1)),
        (o.opacity = 1),
        Array.isArray(u.baseColorFactor))
      ) {
        const d = u.baseColorFactor;
        o.color.fromArray(d), (o.opacity = d[3]);
      }
      u.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(o, "map", u.baseColorTexture, Oe)),
        (o.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1),
        (o.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
        u.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture)
          )),
        (a = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, o);
            })
          )
        );
    }
    s.doubleSided === !0 && (o.side = Gt);
    const h = s.alphaMode || bl.OPAQUE;
    if (
      (h === bl.BLEND
        ? ((o.transparent = !0), (o.depthWrite = !1))
        : ((o.transparent = !1),
          h === bl.MASK &&
            (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        a !== Ut &&
        (c.push(t.assignTexture(o, "normalMap", s.normalTexture)),
        (o.normalScale = new K(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const u = s.normalTexture.scale;
      o.normalScale.set(u, u);
    }
    return (
      s.occlusionTexture !== void 0 &&
        a !== Ut &&
        (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (o.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        a !== Ut &&
        (o.emissive = new de().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        a !== Ut &&
        c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Oe)),
      Promise.all(c).then(function () {
        const u = new a(o);
        return (
          s.name && (u.name = s.name),
          fi(u, s),
          t.associations.set(u, { materials: e }),
          s.extensions && zi(i, u, s),
          u
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Je.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function s(o) {
      return n[Ke.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(o, t)
        .then(function (l) {
          return ud(l, o, t);
        });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        h = ES(c),
        u = i[h];
      if (u) a.push(u.promise);
      else {
        let d;
        c.extensions && c.extensions[Ke.KHR_DRACO_MESH_COMPRESSION]
          ? (d = s(c))
          : (d = ud(new He(), c, t)),
          (i[h] = { primitive: c, promise: d }),
          a.push(d);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[e],
      a = s.primitives,
      o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const h =
        a[l].material === void 0
          ? SS(this.cache)
          : this.getDependency("material", a[l].material);
      o.push(h);
    }
    return (
      o.push(t.loadGeometries(a)),
      Promise.all(o).then(function (l) {
        const c = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          u = [];
        for (let f = 0, m = h.length; f < m; f++) {
          const _ = h[f],
            g = a[f];
          let p;
          const v = c[f];
          if (
            g.mode === sn.TRIANGLES ||
            g.mode === sn.TRIANGLE_STRIP ||
            g.mode === sn.TRIANGLE_FAN ||
            g.mode === void 0
          )
            (p = s.isSkinnedMesh === !0 ? new Vc(_, v) : new ce(_, v)),
              p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
              g.mode === sn.TRIANGLE_STRIP
                ? (p.geometry = od(p.geometry, Lc))
                : g.mode === sn.TRIANGLE_FAN &&
                  (p.geometry = od(p.geometry, lo));
          else if (g.mode === sn.LINES) p = new Mn(_, v);
          else if (g.mode === sn.LINE_STRIP) p = new It(_, v);
          else if (g.mode === sn.LINE_LOOP) p = new Xc(_, v);
          else if (g.mode === sn.POINTS) p = new Yc(_, v);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + g.mode
            );
          Object.keys(p.geometry.morphAttributes).length > 0 && wS(p, s),
            (p.name = t.createUniqueName(s.name || "mesh_" + e)),
            fi(p, s),
            g.extensions && zi(i, p, g),
            t.assignFinalMaterial(p),
            u.push(p);
        }
        for (let f = 0, m = u.length; f < m; f++)
          t.associations.set(u[f], { meshes: e, primitives: f });
        if (u.length === 1) return s.extensions && zi(i, u[0], s), u[0];
        const d = new $n();
        s.extensions && zi(i, d, s), t.associations.set(d, { meshes: e });
        for (let f = 0, m = u.length; f < m; f++) d.add(u[f]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new Et(
            pf.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new Ks(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      fi(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, s = t.joints.length; i < s; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const s = i.pop(),
          a = i,
          o = [],
          l = [];
        for (let c = 0, h = a.length; c < h; c++) {
          const u = a[c];
          if (u) {
            o.push(u);
            const d = new Ue();
            s !== null && d.fromArray(s.array, c * 16), l.push(d);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c]
            );
        }
        return new Wr(o, l);
      })
    );
  }
  loadAnimation(e) {
    const n = this.json.animations[e],
      i = n.name ? n.name : "animation_" + e,
      s = [],
      a = [],
      o = [],
      l = [],
      c = [];
    for (let h = 0, u = n.channels.length; h < u; h++) {
      const d = n.channels[h],
        f = n.samplers[d.sampler],
        m = d.target,
        _ = m.node,
        g = n.parameters !== void 0 ? n.parameters[f.input] : f.input,
        p = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
      m.node !== void 0 &&
        (s.push(this.getDependency("node", _)),
        a.push(this.getDependency("accessor", g)),
        o.push(this.getDependency("accessor", p)),
        l.push(f),
        c.push(m));
    }
    return Promise.all([
      Promise.all(s),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
    ]).then(function (h) {
      const u = h[0],
        d = h[1],
        f = h[2],
        m = h[3],
        _ = h[4],
        g = [];
      for (let p = 0, v = u.length; p < v; p++) {
        const x = u[p],
          y = d[p],
          S = f[p],
          w = m[p],
          R = _[p];
        if (x === void 0) continue;
        x.updateMatrix();
        let P;
        switch (ci[R.path]) {
          case ci.weights:
            P = Vs;
            break;
          case ci.rotation:
            P = bi;
            break;
          case ci.position:
          case ci.scale:
          default:
            P = Ws;
            break;
        }
        const M = x.name ? x.name : x.uuid,
          A = w.interpolation !== void 0 ? MS[w.interpolation] : ns,
          k = [];
        ci[R.path] === ci.weights
          ? x.traverse(function (U) {
              U.morphTargetInfluences && k.push(U.name ? U.name : U.uuid);
            })
          : k.push(M);
        let X = S.array;
        if (S.normalized) {
          const U = gc(X.constructor),
            O = new Float32Array(X.length);
          for (let N = 0, Z = X.length; N < Z; N++) O[N] = X[N] * U;
          X = O;
        }
        for (let U = 0, O = k.length; U < O; U++) {
          const N = new P(k[U] + "." + ci[R.path], y.array, X, A);
          w.interpolation === "CUBICSPLINE" &&
            ((N.createInterpolant = function (B) {
              const G = this instanceof bi ? vS : _p;
              return new G(this.times, this.values, this.getValueSize() / 3, B);
            }),
            (N.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            g.push(N);
        }
      }
      return new Xs(i, void 0, g);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (s) {
          const a = n._getNodeRef(n.meshCache, i.mesh, s);
          return (
            i.weights !== void 0 &&
              a.traverse(function (o) {
                if (o.isMesh)
                  for (let l = 0, c = i.weights.length; l < c; l++)
                    o.morphTargetInfluences[l] = i.weights[l];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      s = n._loadNodeShallow(e),
      a = [],
      o = i.children || [];
    for (let c = 0, h = o.length; c < h; c++)
      a.push(n.getDependency("node", o[c]));
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([s, Promise.all(a), l]).then(function (c) {
      const h = c[0],
        u = c[1],
        d = c[2];
      d !== null &&
        h.traverse(function (f) {
          f.isSkinnedMesh && f.bind(d, TS);
        });
      for (let f = 0, m = u.length; f < m; f++) h.add(u[f]);
      return h;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      a = s.name ? i.createUniqueName(s.name) : "",
      o = [],
      l = i._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && o.push(l),
      s.camera !== void 0 &&
        o.push(
          i.getDependency("camera", s.camera).then(function (c) {
            return i._getNodeRef(i.cameraCache, s.camera, c);
          })
        ),
      i
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          o.push(c);
        }),
      (this.nodeCache[e] = Promise.all(o).then(function (c) {
        let h;
        if (
          (s.isBone === !0
            ? (h = new To())
            : c.length > 1
            ? (h = new $n())
            : c.length === 1
            ? (h = c[0])
            : (h = new qe()),
          h !== c[0])
        )
          for (let u = 0, d = c.length; u < d; u++) h.add(c[u]);
        if (
          (s.name && ((h.userData.name = s.name), (h.name = a)),
          fi(h, s),
          s.extensions && zi(n, h, s),
          s.matrix !== void 0)
        ) {
          const u = new Ue();
          u.fromArray(s.matrix), h.applyMatrix4(u);
        } else s.translation !== void 0 && h.position.fromArray(s.translation), s.rotation !== void 0 && h.quaternion.fromArray(s.rotation), s.scale !== void 0 && h.scale.fromArray(s.scale);
        return (
          i.associations.has(h) || i.associations.set(h, {}),
          (i.associations.get(h).nodes = e),
          h
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      s = new $n();
    n.name && (s.name = i.createUniqueName(n.name)),
      fi(s, n),
      n.extensions && zi(t, s, n);
    const a = n.nodes || [],
      o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(i.getDependency("node", a[l]));
    return Promise.all(o).then(function (l) {
      for (let h = 0, u = l.length; h < u; h++) s.add(l[h]);
      const c = (h) => {
        const u = new Map();
        for (const [d, f] of i.associations)
          (d instanceof At || d instanceof ht) && u.set(d, f);
        return (
          h.traverse((d) => {
            const f = i.associations.get(d);
            f != null && u.set(d, f);
          }),
          u
        );
      };
      return (i.associations = c(s)), s;
    });
  }
}
function CS(r, e, t) {
  const n = e.attributes,
    i = new Vt();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION],
      l = o.min,
      c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (i.set(new b(l[0], l[1], l[2]), new b(c[0], c[1], c[2])), o.normalized)
      ) {
        const h = gc(Os[o.componentType]);
        i.min.multiplyScalar(h), i.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const o = new b(),
      l = new b();
    for (let c = 0, h = s.length; c < h; c++) {
      const u = s[c];
      if (u.POSITION !== void 0) {
        const d = t.json.accessors[u.POSITION],
          f = d.min,
          m = d.max;
        if (f !== void 0 && m !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(f[0]), Math.abs(m[0]))),
            l.setY(Math.max(Math.abs(f[1]), Math.abs(m[1]))),
            l.setZ(Math.max(Math.abs(f[2]), Math.abs(m[2]))),
            d.normalized)
          ) {
            const _ = gc(Os[d.componentType]);
            l.multiplyScalar(_);
          }
          o.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(o);
  }
  r.boundingBox = i;
  const a = new hn();
  i.getCenter(a.center),
    (a.radius = i.min.distanceTo(i.max) / 2),
    (r.boundingSphere = a);
}
function ud(r, e, t) {
  const n = e.attributes,
    i = [];
  function s(a, o) {
    return t.getDependency("accessor", a).then(function (l) {
      r.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = mc[a] || a.toLowerCase();
    o in r.attributes || i.push(s(n[a], o));
  }
  if (e.indices !== void 0 && !r.index) {
    const a = t.getDependency("accessor", e.indices).then(function (o) {
      r.setIndex(o);
    });
    i.push(a);
  }
  return (
    fi(r, e),
    CS(r, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? bS(r, e.targets, t) : r;
    })
  );
}
window.THREE = mp;
var Yn = new mh();
Yn.title("控制器");
new Ys();
var ln = new Gc();
ln.background = new de(4473924);
var xp = new hh(),
  yp = new dp(ln),
  PS = new jM(),
  Jn = new Et(75, window.innerWidth / window.innerHeight, 0.1, 1e4);
Jn.position.set(0, 0, 100);
Jn.lookAt(new b());
var ni = new Hc({ antialias: !0 });
ni.setPixelRatio(window.devicePixelRatio);
ni.setSize(window.innerWidth, window.innerHeight);
ni.localClippingEnabled = !0;
document.body.appendChild(ni.domElement);
var vp = new HM(Jn, ni.domElement),
  Ki = new GM(Jn, ni.domElement);
ln.add(Ki);
Ki.addEventListener("dragging-changed", function (r) {
  vp.enabled = !r.value;
});
var On = [];
On[0] = new er(16777215, 1, 0);
On[1] = new er(16777215, 1, 0);
On[2] = new er(16777215, 1, 0);
On[0].position.set(0, 200, 0);
On[1].position.set(100, 200, 100);
On[2].position.set(-100, -200, -100);
ln.add(On[0]);
ln.add(On[1]);
ln.add(On[2]);
var Uo = new KM(Jn);
Uo.scale.set(10, 10, 10);
for (const r of Uo.children) r.material.depthTest = !1;
ln.add(Uo);
window.addEventListener("resize", function () {
  (Jn.aspect = window.innerWidth / window.innerHeight),
    Jn.updateProjectionMatrix(),
    ni.setSize(window.innerWidth, window.innerHeight);
});
Object.assign(window, {
  gui: Yn,
  scene: ln,
  camera: Jn,
  webglrenderer: ni,
  orbit: vp,
  lights: On,
  clock: xp,
  mixer: yp,
  viewHelper: Uo,
});
function Mp() {
  requestAnimationFrame(Mp), yp.update(xp.getDelta()), ni.render(ln, Jn);
}
var gn = ((r) => (
  (r[(r.x = 0)] = "x"), (r[(r.y = 1)] = "y"), (r[(r.z = 2)] = "z"), r
))(gn || {});
((r) => {
  function e(i) {
    return r[i];
  }
  r.toKey = e;
  function t(i) {
    return r[i];
  }
  r.toIndex = t;
  function n(i) {
    const s = (i + 1) % 3,
      a = (i + 2) % 3;
    return [s, a];
  }
  r.getCrossAxiss = n;
})(gn || (gn = {}));
var _c = ((r) => (
  (r[(r.x = 0)] = "x"),
  (r[(r.y = 1)] = "y"),
  (r[(r.z = 2)] = "z"),
  (r[(r.w = 3)] = "w"),
  r
))(_c || {});
((r) => {
  function e(i) {
    return r[i];
  }
  r.toKey = e;
  function t(i) {
    return r[i];
  }
  r.toIndex = t;
  function n(i) {
    const s = (i + 1) % 4,
      a = (i + 2) % 4;
    return [s, a];
  }
  r.getCrossAxiss = n;
})(_c || (_c = {}));
var LS = Object.defineProperty,
  IS = (r, e, t) =>
    e in r
      ? LS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (r[e] = t),
  hi = (r, e, t) => (IS(r, typeof e != "symbol" ? e + "" : e, t), t);
function Sp(r, e, t, n = "srgb") {
  const i = new OffscreenCanvas(e, t).getContext("2d"),
    s = i.createLinearGradient(0, 0, 256, 1);
  for (const [a, o] of r) s.addColorStop(Number(a), o);
  return (
    (i.fillStyle = s),
    i.fillRect(0, 0, e, t),
    i.getImageData(0, 0, e, t, { colorSpace: n })
  );
}
function DS(r, e) {
  let { area: t, width: n, height: i, colorSpace: s } = e || {};
  (s = s ?? "srgb"), (t = t || {});
  const a = t.x ?? 0,
    o = t.y ?? 0,
    l = US(r),
    c = t.width ?? l.width,
    h = t.height ?? l.height;
  (n = n ?? c), (i = i ?? h);
  const u = new OffscreenCanvas(n, i).getContext("2d");
  return (
    u.drawImage(r, a, o, c, h, 0, 0, n, i),
    u.getImageData(0, 0, n, i, { colorSpace: s })
  );
}
function US(r) {
  let e = 0,
    t = 0;
  return (
    r instanceof HTMLImageElement
      ? ((e = r.naturalWidth), (t = r.naturalHeight))
      : r instanceof HTMLVideoElement
      ? ((e = r.videoWidth), (t = r.videoHeight))
      : ((e = r.width), (t = r.height)),
    { width: e, height: t }
  );
}
function bp(r, e, t) {
  const { data: n, width: i } = r,
    s = (e * i + t) * 4;
  return n.slice(s, s + 4);
}
function wp(r) {
  return r && r.data != null && r.width != null && r.height != null;
}
function xc(r) {
  return wp(r) && r.depth != null;
}
function Ep(r, e) {
  const { x: t, y: n } = e;
  return r.z * n * t + r.y * t + r.x;
}
function Ap(r, e, t = 1) {
  let { x: n, y: i, z: s } = e;
  const a = r.size;
  return (
    (n = Math.max(0, Math.min(a.x - 1, n))),
    (i = Math.max(0, Math.min(a.y - 1, i))),
    (s = Math.max(0, Math.min(a.z - 1, s))),
    Tp(r, { x: n, y: i, z: s }, t)
  );
}
function Tp(r, e, t = 1) {
  const { data: n, size: i } = r,
    s = Ep(e, i);
  let a = [];
  if (t > 0) {
    const o = s * t;
    for (let l = 0; l < t; l++) a.push(n[o + l]);
  }
  return { index: s, value: a };
}
function NS(r, e) {
  let { x: t, y: n, z: i } = e;
  const s = r.size;
  return (
    (t = Math.max(0, Math.min(s.x - 1, t))),
    (n = Math.max(0, Math.min(s.y - 1, n))),
    (i = Math.max(0, Math.min(s.z - 1, i))),
    OS(r, { x: t, y: n, z: i })
  );
}
function OS(r, e) {
  const { data: t, size: n } = r,
    i = Ep(e, n);
  return { index: i, value: t[i] };
}
function gh(r, e, t, n = 1) {
  const { size: i } = r,
    s = gn.toKey(e),
    [a, o] = gn.getCrossAxiss(e),
    l = gn.toKey(a),
    c = gn.toKey(o),
    h = i[l],
    u = i[c],
    d = [],
    f = i[s];
  (t = Math.trunc(t)), (t = Math.max(0, Math.min(f - 1, t)));
  let m = { x: 0, y: 0, z: 0 };
  m[s] = t;
  for (let _ = 0; _ < u; _++) {
    m[c] = _;
    for (let g = 0; g < h; g++) {
      m[l] = g;
      const { value: p } = Tp(r, m, n);
      d.push(...p);
    }
  }
  return { data: d, size: { x: h, y: u } };
}
class FS {
  constructor(e) {
    hi(this, "isImageData3DSlice", !0),
      hi(this, "_image3D"),
      hi(this, "_canvas"),
      hi(this, "_context"),
      hi(this, "_axis", gn.z),
      hi(this, "_depth", 0),
      hi(this, "_sliceSize", null),
      hi(this, "_slice"),
      (this.image3D = e);
  }
  get image3D() {
    return this._image3D;
  }
  set image3D(e) {
    (this._image3D = e), this.updateSize();
  }
  get canvas() {
    let e = this._canvas;
    return (
      e ||
        ((e = this._canvas = document.createElement("canvas")),
        (e.width = this.sliceSize.x),
        (e.height = this.sliceSize.y)),
      e
    );
  }
  get context() {
    return this._context ?? (this._context = this.canvas.getContext("2d"));
  }
  get axis() {
    return this._axis;
  }
  set axis(e) {
    (this._axis = e), this.updateSize();
  }
  get depth() {
    return this._depth;
  }
  set depth(e) {
    (this._depth = e), this.updateSlice();
  }
  get sliceSize() {
    let e = this._sliceSize;
    if (!e) {
      const { axis: t, image3D: n } = this,
        { width: i, height: s, depth: a } = n,
        [o, l] = gn.getCrossAxiss(t),
        c = [i, s, a];
      this._sliceSize = e = { x: c[o], y: c[l] };
    }
    return e;
  }
  get slice() {
    return this._slice ?? (this._slice = this.getSlice(this.axis, this.depth));
  }
  getSlice(e, t) {
    const {
        data: n,
        width: i,
        height: s,
        depth: a,
        colorSpace: o,
      } = this.image3D,
      { data: l, size: c } = gh(
        { data: n, size: { x: i, y: s, z: a } },
        e,
        t,
        4
      ),
      h = l instanceof Uint8ClampedArray ? l : Uint8ClampedArray.from(l);
    return new ImageData(h, c.x, c.y, { colorSpace: o });
  }
  getDataURL() {
    return this.canvas.toDataURL();
  }
  getColor(e) {
    const { x: t, y: n } = e;
    return bp(this.slice, n, t);
  }
  updateSize() {
    this._sliceSize = null;
    const e = this.canvas;
    (e.width = this.sliceSize.x),
      (e.height = this.sliceSize.y),
      this.updateSlice();
  }
  updateSlice() {
    (this._slice = null), this.context.putImageData(this.slice, 0, 0);
  }
}
var BS = Object.defineProperty,
  zS = (r, e, t) =>
    e in r
      ? BS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (r[e] = t),
  vr = (r, e, t) => (zS(r, typeof e != "symbol" ? e + "" : e, t), t);
function kS(r) {
  return r.w !== void 0 ? [tt, 4] : r.z !== void 0 ? [b, 3] : [K, 2];
}
function HS(r) {
  const e = r.length,
    t = [];
  if (e === 0) return t;
  const [n, i] = kS(r[0]);
  for (let s = 0; s < e; s++) {
    const a = r[s],
      o = new n().copy(a),
      l = a.radius,
      c = t[s] ?? (t[s] = []);
    for (let h = s + 1; h < e; h++) {
      const u = r[h];
      o.distanceToSquared(u) <= (u.radius + l) ** 2 &&
        (c.push(h), (t[h] = []).push(s));
    }
  }
  return t;
}
let dd;
function Cs(r) {
  if (typeof r == "string") return (dd || (dd = new rh())).load(r);
  if (r.isTexture) return r;
  const e = Array.isArray(r) ? Sp(r, 256, 1) : r,
    t = new ht(e);
  return (
    e.colorSpace === "srgb" && (t.colorSpace = "srgb"), (t.needsUpdate = !0), t
  );
}
function GS(r, e) {
  const t = Math.sqrt(r.lengthSq() * e.lengthSq());
  if (t === 0) return 0;
  let n = r.dot(e) / t;
  return (n = Math.max(-1, Math.min(1, n))), Math.acos(n);
}
function El(r, e, t) {
  let n = GS(r, e);
  return n === 0 ? n : r.clone().cross(e).dot(t) < 0 ? -n : n;
}
function VS(r, e, t) {
  const n = e.clone().negate(),
    i = t.clone().projectOnPlane(e),
    s = r.clone().projectOnPlane(i),
    a = El(e, s, i),
    o = e.clone().cross(i),
    l = r.clone().projectOnPlane(o),
    c = El(e, l, o),
    h = r.clone().projectOnPlane(n),
    u = El(i, h, n);
  return { yaw: a, pitch: c, roll: u };
}
const Al = 180 / Math.PI,
  yc = {
    yaw: [
      { name: "前", range: [-15, 15] },
      { name: "左", range: [15, 165] },
      { name: "右", range: [-165, -15] },
      { name: "后", range: [-180.1, -165] },
      { name: "后", range: [165, 180.1] },
    ],
    pitch: [
      { name: "前", range: [-15, 15] },
      { name: "上", range: [15, 165] },
      { name: "下", range: [-165, -15] },
      { name: "后", range: [-180.1, -165] },
      { name: "后", range: [165, 180.1] },
    ],
    roll: [
      { name: "上", range: [-15, 15] },
      { name: "左", range: [15, 165] },
      { name: "右", range: [-165, -15] },
      { name: "下", range: [-180.1, -165] },
      { name: "下", range: [165, 180.1] },
    ],
  };
function WS(r) {
  const e = {};
  for (const [t, n] of Object.entries(r))
    e[t] = Array.isArray(n)
      ? n
      : Object.entries(n).map(([i, s]) => ({ name: i, range: s }));
  return e;
}
const Tl = {
  degrees: !0,
  map: yc,
  front: { x: 0, y: 0, z: 1 },
  up: { x: 0, y: 1, z: 0 },
};
class Rp {
  constructor(e) {
    vr(this, "_options"),
      vr(this, "_listMap"),
      vr(this, "_front"),
      vr(this, "_up"),
      e && (this.options = e);
  }
  static get options() {
    return this._options ?? (this.options = Tl);
  }
  static set options(e) {
    this._options = Object.assign({}, structuredClone(yc), e);
  }
  get defaultOptions() {
    return this.constructor.options;
  }
  get options() {
    return this._options ?? (this.options = this.defaultOptions);
  }
  set options(e) {
    (this._options = Object.assign(
      {},
      structuredClone(this.defaultOptions),
      e
    )),
      (this._listMap = null),
      (this._front = null),
      (this._up = null);
  }
  get degrees() {
    return (
      this.options.degrees ??
      (this.options.degrees = this.defaultOptions.degrees ?? !0)
    );
  }
  set degrees(e) {
    this.options.degrees = e;
  }
  get map() {
    return (
      this.options.map || (this.map = this.defaultOptions.map), this.options.map
    );
  }
  set map(e) {
    const t = structuredClone(this.defaultOptions.map),
      n = structuredClone(yc);
    (e = e
      ? {
          yaw: e.yaw ?? t.yaw ?? n.yaw,
          pitch: e.pitch ?? t.pitch ?? n.pitch,
          roll: e.roll ?? t.roll ?? n.roll,
        }
      : t),
      (this.options.map = e),
      (this._listMap = null);
  }
  get listMap() {
    return this._listMap ?? (this._listMap = WS(this.map ?? {}));
  }
  get front() {
    return (
      this._front ||
        (this.front =
          this.options.front ?? this.defaultOptions.front ?? Tl.front),
      this._front
    );
  }
  set front(e) {
    this._front = new b().copy(e);
  }
  get up() {
    return (
      this._up ||
        (this.up = this.options.up ?? this.defaultOptions.up ?? Tl.up),
      this._up
    );
  }
  set up(e) {
    this._up = new b().copy(e);
  }
  computeAzimuth(e, t, n) {
    const i = new b().copy(e),
      s = new b().copy(t ?? this.front),
      a = new b().copy(n ?? this.up);
    let { yaw: o, pitch: l, roll: c } = VS(i, s, a);
    return (
      this.degrees && ((o *= Al), (l *= Al), (c *= Al)),
      {
        yaw: { angle: o, name: this.findAzimuthNames("yaw", o) },
        pitch: { angle: l, name: this.findAzimuthNames("pitch", l) },
        roll: { angle: c, name: this.findAzimuthNames("roll", c) },
      }
    );
  }
  findAzimuthNames(e, t) {
    const n = [],
      i = this.listMap[e];
    if (!i) return n;
    for (const {
      name: s,
      range: [a, o],
    } of i)
      ((t >= a && t < o) || (t <= a && t > o)) && n.push(s);
    return n;
  }
}
vr(Rp, "_options");
new Rp();
var XS = Object.defineProperty,
  YS = (r, e, t) =>
    e in r
      ? XS(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (r[e] = t),
  Lt = (r, e, t) => (YS(r, typeof e != "symbol" ? e + "" : e, t), t);
const qS = `precision highp sampler3D;

uniform sampler3D map;
uniform vec3 containerMin;
uniform vec3 containerMax;

// 0: 充满；1: 对齐；2: 原始
uniform int fit;


out vec3 cameraPos;
out vec3 lookDir;
out vec3 displayMin;
out vec3 displayMax;



void main() {
    cameraPos = vec3( inverse( modelMatrix ) * vec4( cameraPosition, 1.0 ) ).xyz;
    lookDir = position - cameraPos;

    vec3 containerSize = containerMax - containerMin;
    vec3 origin = containerMin;
    vec3 textSize =  vec3(textureSize(map,0));
    displayMin = containerMin;
    displayMax = containerMax;

    switch (fit) {
        case 1:
            displayMax = displayMin + textSize;
            break;
        case 2:
            origin = vec3(0.0);
            break;
        default:
            textSize = containerSize;
    }

    vec3 scale = 1.0/textSize;
    cameraPos = (cameraPos - origin)*scale;
    lookDir *= scale;

    displayMin = max((displayMin - origin)*scale,vec3(0.0));
    displayMax = min((displayMax - origin)*scale,vec3(1.0));
    
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
var qn = ((r) => (
  (r[(r.Fill = 0)] = "Fill"),
  (r[(r.Align = 1)] = "Align"),
  (r[(r.Raw = 2)] = "Raw"),
  r
))(qn || {});
class ZS extends cn {
  constructor(e, t) {
    const n = e ?? {},
      { map: i } = n,
      s = n.opacity ?? 1,
      a = n.accFactor ?? 1,
      o = n.steps ?? 100,
      l = new K().copy(n.alphaRange ?? { x: 0, y: 0.95 }),
      c = n.fit ?? 0,
      h = n.atomize ?? !0,
      u = n.side ?? Zt,
      d = new b().copy(n.containerMin ?? { x: 0, y: 0, z: 0 }),
      f = new b();
    if (n.containerMax) f.copy(n.containerMax);
    else if (i) {
      const { width: p, height: v, depth: x } = i.image,
        y = new b(p - 1, v - 1, x - 1);
      f.addVectors(d, y);
    }
    const { uniforms: m, ..._ } = t || {},
      g = {
        map: { value: i },
        containerMin: { value: d },
        containerMax: { value: f },
        fit: { value: c },
        opacity: { value: s },
        alphaRange: { value: l },
        accFactor: { value: a },
        steps: { value: o },
        isDoubleSide: { value: !1 },
        atomize: { value: h },
        ...m,
      };
    super({
      glslVersion: Pr,
      uniforms: g,
      transparent: !0,
      vertexShader: qS,
      ..._,
    }),
      Lt(this, "isVolumeMaterial", !0),
      Lt(this, "_side", Zt),
      (this.opacity = s),
      (this.side = u);
  }
  get map() {
    return this.uniforms.map.value;
  }
  set map(e) {
    (this.uniforms.map.value = e), (this.uniformsNeedUpdate = !0);
  }
  get containerMin() {
    return this.uniforms.containerMin.value;
  }
  set containerMin(e) {
    this.uniforms.containerMin.value.copy(e), (this.uniformsNeedUpdate = !0);
  }
  get containerMax() {
    return this.uniforms.containerMax.value;
  }
  set containerMax(e) {
    this.uniforms.containerMax.value.copy(e), (this.uniformsNeedUpdate = !0);
  }
  get fit() {
    return this.uniforms.fit.value;
  }
  set fit(e) {
    (this.uniforms.fit.value = e), (this.uniformsNeedUpdate = !0);
  }
  get side() {
    return this._side;
  }
  set side(e) {
    (this._side = e),
      this.uniforms &&
        ((this.uniforms.isDoubleSide.value = e === Gt),
        (this.uniformsNeedUpdate = !0));
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e),
      (this.uniformsNeedUpdate = !0);
  }
  get alphaRange() {
    return this.uniforms.alphaRange.value;
  }
  set alphaRange(e) {
    this.uniforms.alphaRange.value.copy(e), (this.uniformsNeedUpdate = !0);
  }
  get atomize() {
    return this.uniforms.atomize.value;
  }
  set atomize(e) {
    (this.uniforms.atomize.value = e), (this.uniformsNeedUpdate = !0);
  }
  get steps() {
    return this.uniforms.steps.value;
  }
  set steps(e) {
    (this.uniforms.steps.value = e), (this.uniformsNeedUpdate = !0);
  }
  get accFactor() {
    return this.uniforms.accFactor.value;
  }
  set accFactor(e) {
    this.uniforms && (this.uniforms.accFactor.value = e),
      (this.uniformsNeedUpdate = !0);
  }
}
function $S(r) {
  r.boundingBox || r.computeBoundingBox();
  const { x: e, y: t, z: n } = r.boundingBox.min;
  return r.translate(-e, -t, -n), r;
}
class KS extends ce {
  constructor(e) {
    var t;
    const {
        width: n,
        height: i,
        depth: s,
      } = ((t = e.map) == null ? void 0 : t.image) || {},
      a = new at(n, i, s);
    $S(a),
      super(a, e),
      Lt(this, "isVolumeMesh", !0),
      Lt(this, "_geometry"),
      Lt(this, "autoUpdateMaterial", !0),
      Lt(this, "_material"),
      Lt(this, "autoUpdateGeometry", !0),
      Lt(this, "autoNormalize", !1),
      Object.defineProperties(this, {
        geometry: {
          get: () => this._geometry,
          set: (o) => {
            (this._geometry = o),
              this.autoNormalize
                ? this.normalize()
                : this.autoUpdateMaterial && this.updateMaterial();
          },
        },
        material: {
          get: () => this._material,
          set: (o) => {
            (this._material = o),
              this.autoUpdateGeometry && this.updateGeometry();
          },
        },
      }),
      (this.geometry = a),
      (this.material = e);
  }
  updateMaterial() {
    const { geometry: e, material: t } = this;
    if (!(t && e)) return !1;
    e.boundingBox || e.computeBoundingBox();
    const { min: n, max: i } = e.boundingBox;
    (t.containerMin = n), (t.containerMax = i);
  }
  updateGeometry() {
    var e;
    const { geometry: t, material: n, autoUpdateMaterial: i } = this,
      s = (e = n.map) == null ? void 0 : e.image;
    if (!s) return !1;
    t.boundingBox || t.computeBoundingBox();
    const { width: a, height: o, depth: l } = s,
      c = t.boundingBox.getSize(new b());
    t.scale(a / c.x, o / c.y, l / c.z), i && this.updateMaterial();
  }
  normalize() {
    const { geometry: e, autoUpdateMaterial: t } = this;
    e.boundingBox || e.computeBoundingBox();
    const { x: n, y: i, z: s } = e.boundingBox.min;
    e.translate(-n, -i, -s), t && this.updateMaterial();
  }
}
const jS = `precision highp float;
precision highp sampler3D;

uniform sampler3D map;
uniform sampler2D gradient;

uniform bool atomize;
uniform float steps;
// 颜色累积系数
uniform float accFactor;
uniform vec2 range;
// 是否丢弃超出范围的像素
uniform bool discardOut;
// 空值范围
uniform vec2 voidRange;
uniform float opacity;
uniform vec2 alphaRange;
uniform bool isDoubleSide;

in vec3 cameraPos;
in vec3 lookDir;
in vec3 displayMin;
in vec3 displayMax;
out vec4 fragColor;

vec4 colorBlend(vec4 near,vec4 far){
    float nA = near.a;
    if  (nA >= 1.0){
        return near;
    }
    if  (nA <= 0.0){
        return far;
    }
    
    float fA = far.a;
    float a = fA + nA - fA*nA;
    vec3 color = (far.rgb * fA * (1.0 - nA) + near.rgb*nA)/a;
    return vec4(color,a);
}




vec2 intersectBox( vec3 orig, vec3 dir ) {
    vec3 inv_dir = 1.0 / dir;
    vec3 tmin_tmp = (displayMin - orig ) * inv_dir;
    vec3 tmax_tmp = (displayMax - orig ) * inv_dir;
    vec3 tmin = min( tmin_tmp, tmax_tmp );
    vec3 tmax = max( tmin_tmp, tmax_tmp );
    float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
    float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
    return vec2( t0, t1 );
}

float getValue( vec3 point ) {
    return texture( map, point ).r;
}

// 获取梯度颜色
vec4 getGradientColor(float val) {
    val = clamp( val, 0.0,1.0);
    return texture2D(gradient, vec2(val, 0.5));
}




void main(){
    vec3 rayDir = normalize( lookDir );

    vec2 times = intersectBox( cameraPos, rayDir );
    float tMin = times.x;
    float tMax = times.y;
    if ( tMin > tMax || tMax < 0.0 ) discard;
    tMin = max( tMin, 0.0 );

    vec3 point = cameraPos + tMin * rayDir;
    
    float step = 1.0/steps;
    float opacityFactor = atomize ? step * accFactor : 1.0;


    float invRangeLen = 1.0/(range.y - range.x);
    vec3 stepDir = rayDir * step;

    vec4 finalColor = vec4( 0,0,0,0);
    float alphaMax = alphaRange.y;

    for ( float t = tMin; t <= tMax; t += step,point += stepDir ) {
        float val = getValue( point);
        if (voidRange.x <= val && val <= voidRange.y ) continue;
        val = (val - range.x) * invRangeLen;
        if (discardOut && (val < 0.0 || val > 1.0)) continue;

        vec4 gradientColor = getGradientColor(val);
        gradientColor.a *= opacityFactor;
        finalColor = colorBlend(finalColor,gradientColor);
        if ( finalColor.a >= alphaMax ) break;
    }

    finalColor.a *= opacity;
    if ( finalColor.a <= alphaRange.x ) discard;
    if (isDoubleSide){
        finalColor.a = 1.0 - sqrt(1.0 - finalColor.a);
    }
    fragColor = finalColor;

}`;
class JS extends ZS {
  constructor(e) {
    const t = e ?? {},
      { gradient: n } = t,
      i = new K().copy(t.range ?? { x: 0, y: 100 }),
      s = t.discardOut ?? !0,
      a = new K().copy(t.voidRange ?? { x: -100, y: -1 }),
      o = {
        gradient: { value: n == null ? n : Cs(n) },
        range: { value: i },
        discardOut: { value: s },
        voidRange: { value: a },
      };
    super(e, { fragmentShader: jS, uniforms: o }),
      Lt(this, "isGradientVolumeMaterial", !0);
  }
  get gradient() {
    return this.uniforms.gradient.value;
  }
  set gradient(e) {
    (this.uniforms.gradient.value = e), (this.uniformsNeedUpdate = !0);
  }
  get range() {
    return this.uniforms.range.value;
  }
  set range(e) {
    this.uniforms.range.value.copy(e), (this.uniformsNeedUpdate = !0);
  }
  get discardOut() {
    return this.uniforms.discardOut.value;
  }
  set discardOut(e) {
    (this.uniforms.discardOut.value = e), (this.uniformsNeedUpdate = !0);
  }
  get voidRange() {
    return this.uniforms.voidRange.value;
  }
  set voidRange(e) {
    this.uniforms.voidRange.value.copy(e), (this.uniformsNeedUpdate = !0);
  }
}
class QS extends Hr {
  constructor(e, t, n, i, s) {
    super(e, t, n, i),
      Lt(this, "isGradientData3DTexture", !0),
      (this.format = Ac),
      (this.type = s ?? on),
      (this.minFilter = this.magFilter = ot),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
  getData3DSlice(e, t) {
    const { data: n, width: i, height: s, depth: a } = this.image;
    return gh({ data: n, size: { x: i, y: s, z: a } }, e, t, 1);
  }
  getItem(e) {
    const { data: t, width: n, height: i, depth: s } = this.image;
    return Ap({ data: t, size: { x: n, y: i, z: s } }, e).value;
  }
  getValue(e) {
    const { data: t, width: n, height: i, depth: s } = this.image;
    return NS({ data: t, size: { x: n, y: i, z: s } }, e).value;
  }
}
function eb(r, e) {
  const { data: t, size: n } = r,
    { x: i, y: s, z: a } = n,
    o = i * s * a,
    { voidValue: l = 0, uint8: c } = e ?? {};
  let h;
  if (c) {
    h = new Uint8Array(o);
    for (let d = 0; d < o; d++) {
      const f = t[d] ?? l;
      h[d] = Math.trunc(f);
    }
  } else {
    h = new Float32Array(o);
    for (let d = 0; d < o; d++) {
      const f = t[d] ?? l;
      h[d] = f;
    }
  }
  const u = c ? _n : on;
  return new QS(h, i, s, a, u);
}
function tb(r, e, t) {
  const n = t ?? {},
    { x: i, y: s } = n.range ?? { x: 0, y: 100 },
    a = n.discardOut ?? !0,
    { x: o, y: l } = n.voidRange ?? { x: -100, y: -1 },
    c = n.voidColor ?? [0, 0, 0, 0],
    { width: h, height: u } = e,
    d = Math.trunc(u / 2),
    f = h - 1;
  function m(y) {
    const S = Math.trunc(f * y);
    return bp(e, d, S);
  }
  const _ = 1 / (s - i),
    { data: g, size: p } = r,
    v = g.length,
    x = [];
  for (let y = 0; y < v; y++) {
    let S = c,
      w = g[y];
    (w <= o || l <= w) &&
      ((w = (w - i) * _),
      (a && (w < 0 || w > 1)) ||
        ((w = Math.min(Math.max(w, 0), 1)), (S = m(w)))),
      x.push(...S);
  }
  return { data: x, size: p };
}
class nb extends Hr {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      Lt(this, "isImageData3DTexture", !0),
      (this.format = qt),
      (this.type = _n),
      (this.minFilter = this.magFilter = ot),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
  getData3DSlice(e, t) {
    const { data: n, width: i, height: s, depth: a } = this.image;
    return gh({ data: n, size: { x: i, y: s, z: a } }, e, t, 4);
  }
  getItem(e) {
    return this.getColor(e);
  }
  getColor(e) {
    const { data: t, width: n, height: i, depth: s } = this.image;
    return Ap({ data: t, size: { x: n, y: i, z: s } }, e, 4).value;
  }
}
function ib(r, e) {
  const t = e.gradient,
    n = Array.isArray(t) ? Sp(t, 256, 1) : wp(t) ? t : DS(t);
  let i = r;
  xc(r) &&
    (i = { data: r.data, size: { x: r.width, y: r.height, z: r.depth } });
  const { data: s, size: a } = tb(i, n, e),
    o = Uint8ClampedArray.from(s);
  return new nb(o, a.x, a.y, a.z);
}
const sb = `	out vec2 vUv;
    
	void main() {
		vUv = uv;
		gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
	}`,
  rb = `precision highp float;
precision highp sampler3D;

uniform sampler3D map;

uniform float opacity;
uniform int axis;
uniform float depth;

in vec2 vUv;
out vec4 fragColor;

void main(){
    vec3 uv3 = vec3(0.0);
    int depthSize = textureSize(map,0)[axis];
    uv3[axis] = depth/float(depthSize);
    int xIndex = (axis + 1)%3;
    int yIndex = (axis + 2)%3;
    uv3[xIndex] = vUv.x;
    uv3[yIndex] = vUv.y;

    fragColor = texture(map, uv3);
    fragColor.a *= opacity;
}`;
class ab extends cn {
  constructor(e) {
    const t = e ?? {};
    let { map: n, opacity: i, axis: s, depth: a, side: o, ...l } = t;
    (i = i ?? 1),
      (s = s ?? gn.z),
      (a = a ?? 0),
      (o = o ?? Gt),
      super({
        ...l,
        glslVersion: Pr,
        uniforms: {
          map: { value: n },
          opacity: { value: i },
          axis: { value: s },
          depth: { value: a },
        },
        transparent: !0,
        vertexShader: sb,
        fragmentShader: rb,
        side: o,
      }),
      Lt(this, "isSliceMaterial", !0),
      Lt(this, "_sliceSize", null),
      (this.opacity = i);
  }
  get map() {
    return this.uniforms.map.value;
  }
  set map(e) {
    (this.uniforms.map.value = e),
      (this._sliceSize = null),
      (this.uniformsNeedUpdate = !0);
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e),
      (this.uniformsNeedUpdate = !0);
  }
  get axis() {
    return this.uniforms.axis.value;
  }
  set axis(e) {
    (this.uniforms.axis.value = e),
      (this._sliceSize = null),
      (this.uniformsNeedUpdate = !0);
  }
  get depth() {
    return this.uniforms.depth.value;
  }
  set depth(e) {
    (this.uniforms.depth.value = e), (this.uniformsNeedUpdate = !0);
  }
  get sliceSize() {
    let e = this._sliceSize;
    if (!e) {
      this._sliceSize = e = new K(1, 1);
      const { axis: t, map: n } = this;
      if (n) {
        const { width: i, height: s, depth: a } = n.image,
          [o, l] = gn.getCrossAxiss(t),
          c = [i, s, a];
        e.set(c[o], c[l]);
      }
    }
    return e;
  }
}
class ob extends ce {
  constructor(e) {
    const t = new ab(e),
      n = new Qn();
    super(n, t),
      Lt(this, "isSliceMesh", !0),
      Lt(this, "_geometry"),
      Lt(this, "_material"),
      Lt(this, "autoUpdateGeometry", !0),
      Object.defineProperties(this, {
        geometry: {
          get: () => this._geometry,
          set: (i) => {
            (this._geometry = i),
              this.autoUpdateGeometry && this.updateGeometry();
          },
        },
        material: {
          get: () => this._material,
          set: (i) => {
            (this._material = i),
              this.autoUpdateGeometry && this.updateGeometry();
          },
        },
      }),
      (this.geometry = n),
      (this.material = t);
  }
  updateGeometry() {
    var e;
    const { geometry: t, material: n } = this;
    if (!n || !((e = n.map) != null && e.image)) return !1;
    t.boundingBox || t.computeBoundingBox();
    const i = n.sliceSize,
      s = t.boundingBox.getSize(new b());
    t.scale(i.x / s.x, i.y / s.y, 1);
  }
  get map() {
    return this.material.map;
  }
  set map(e) {
    (this.material.map = e), (this.material = this.material);
  }
  get axis() {
    return this.material.axis;
  }
  set axis(e) {
    (this.material.axis = e), (this.material = this.material);
  }
  get depth() {
    return this.material.depth;
  }
  set depth(e) {
    this.material.depth = e;
  }
  get sliceSize() {
    return this.material.sliceSize;
  }
}
class lb extends FS {
  constructor(e) {
    const t = xc(e) ? e : e.image;
    super(t), Lt(this, "isImageData3DTextureSlice", !0);
  }
  set texture(e) {
    this.image3D = xc(e) ? e : e.image;
  }
}
function Cp({ ratio: r, value: e }) {
  return e - e * r;
}
function cb(r, e) {
  const { x: t, y: n } = e;
  let i = 0;
  for (const {
    value: s,
    clim: { x: a, y: o },
  } of r)
    i += (s - a) / (o - a);
  return i * (n - t) + t;
}
function hb(r, e, t) {
  const { size: n, data3D: i, tags: s } = e,
    {
      clim: a,
      radius: o,
      value: l,
      hollow: c,
      valueGradient: h,
      valuesAccumulate: u,
    } = r,
    d = new b().copy(r),
    f = [],
    m = [],
    _ = { particles: f, values: m },
    g = o * c,
    p = d.clone().subScalar(o),
    v = d.clone().addScalar(o);
  p.max(new b(0, 0, 0));
  const x = new b().copy(n).subScalar(1);
  v.min(x);
  let { x: y, y: S, z: w } = p;
  (y = Math.trunc(y)), (S = Math.trunc(S)), (w = Math.trunc(w));
  let { x: R, y: P, z: M } = v;
  if (
    ((R = Math.trunc(R)),
    (P = Math.trunc(P)),
    (M = Math.trunc(M)),
    y > R || S > P || w > M)
  )
    return _;
  const { x: A, y: k } = n,
    X = A * k;
  for (let U = w; U <= M; U++) {
    const O = U * X;
    for (let N = S; N <= P; N++) {
      const Z = O + N * A;
      e: for (let B = y; B <= R; B++) {
        const G = Z + B;
        if (s[G]) continue;
        const $ = new b(B, N, U),
          Y = $.distanceTo(d);
        if (Y > o || Y < g) continue;
        s[G] = !0;
        const he = {
            radius: o,
            hollow: c,
            hollowRadius: g,
            distance: Y,
            clim: a,
            value: l,
          },
          F = [],
          ne = { ...he, ratio: Y / o, distance: Y, point: $ },
          ie = h(ne);
        F.push({ ...r, ...ne, value: ie });
        for (const ge of t) {
          const Me = $.distanceTo(ge),
            { hollow: Ne, radius: Ce } = ge;
          if (Me <= Ce) {
            const Ze = Ce * Ne;
            if (Me < Ze) continue e;
            const Pe = {
                ...ge,
                ratio: Me / Ce,
                distance: Me,
                hollowRadius: Ze,
                point: $,
              },
              I = h(Pe);
            F.push({ ...Pe, value: I });
          }
        }
        const me = u(F, a);
        (i[G] = me), f.push($), m.push(me);
      }
    }
  }
  return _;
}
function ub(r) {
  const {
      points: e,
      clim: t = { x: 0, y: 100 },
      radius: n = 10,
      value: i = 100,
      hollow: s = 0,
      valueGradient: a = Cp,
      valuesAccumulate: o = cb,
      size: l,
    } = r,
    c = {
      clim: t,
      radius: n,
      value: i,
      hollow: s,
      valueGradient: a,
      valuesAccumulate: o,
    },
    h = e.map((y) => ({ ...c, ...y }));
  let u = l;
  l || (u = new Vt().setFromPoints(h).max.addScalar(1));
  const d = HS(h);
  let { x: f, y: m, z: _ } = u;
  (f = u.x = Math.trunc(f)),
    (m = u.y = Math.trunc(m)),
    (_ = u.z = Math.trunc(_));
  const g = new Array(f * m * _),
    p = new Array(f * m * _),
    v = { size: u, data3D: g, tags: p },
    x = h.length;
  for (let y = 0; y < x; y++) {
    const S = h[y],
      w = d[y].map((R) => h[R]);
    hb(S, v, w);
  }
  return { data: g, size: u };
}
function db({ startRadius: r, addedRadius: e, ratio: t }) {
  return e * t + r;
}
function fb({ startHollow: r, addedHollow: e, ratio: t }) {
  return e * t + r;
}
function pb({ startValue: r, addedValue: e, ratio: t }) {
  return e * t + r;
}
function mb(r, e) {
  const { x: t, y: n } = e;
  return r.reduce((i, s) => i + s - t, 0);
}
function gb(r) {
  const {
      points: e,
      size: t,
      clim: n = { x: 0, y: 100 },
      radius: i = 10,
      value: s = 100,
      hollow: a = 0,
      valueGradient: o = Cp,
      radiusGradient: l = db,
      hollowGradient: c = fb,
      lineValueGradient: h = pb,
      valuesAccumulate: u = mb,
    } = r,
    d = { radius: i, value: s, hollow: a },
    f = e.map(function (k) {
      return Object.assign(new b(), d, k);
    }),
    m = t ? new b().copy(t).subScalar(1) : new Vt().setFromPoints(f).max;
  (m.x = Math.trunc(m.x)), (m.y = Math.trunc(m.y)), (m.z = Math.trunc(m.z));
  const _ = m.clone().addScalar(1),
    { x: g, y: p, z: v } = _,
    x = g * p,
    y = new Array(x * v),
    S = [],
    w = [],
    R = { particles: S, values: w, size: _, data: y },
    P = new b(0, 0, 0),
    M = e.length,
    A = Math.trunc(M / 2);
  for (let k = 0; k < A; k++) {
    const X = k * 2,
      U = f[X],
      O = X + 1,
      N = f[O],
      Z = new fp(U, N),
      B = Z.distance(),
      G = Z.delta(new b()).normalize(),
      $ = new et();
    $.setFromUnitVectors(new b(0, 1, 0), G);
    const Y = new Ue().makeRotationFromQuaternion($);
    Y.setPosition(U);
    const { radius: he, value: F, hollow: ne } = U,
      { radius: ie, value: me, hollow: ge } = N,
      Me = ie - he,
      Ne = me - F,
      Ce = ge - ne,
      Ze = {
        length: B,
        startRadius: he,
        endRadius: ie,
        addedRadius: Me,
        defaultRadius: i,
        radius: i,
        startValue: F,
        endValue: me,
        addedValue: Ne,
        defaultValue: s,
        startHollow: ne,
        endHollow: ge,
        addedHollow: Ce,
        defaultHollow: a,
        clim: n,
      },
      Pe = Math.max(he, ie),
      I = new b(-Pe, 0, -Pe),
      le = new b(Pe, B, Pe),
      Q = new Vt(I, le);
    Q.applyMatrix4(Y);
    const { min: oe, max: ee } = Q;
    oe.max(P), ee.min(m);
    let { x: we, y: _e, z: xe } = oe;
    (we = Math.trunc(we)), (_e = Math.trunc(_e)), (xe = Math.trunc(xe));
    let { x: Le, y: ze, z: it } = ee;
    if (
      ((Le = Math.trunc(Le)),
      (ze = Math.trunc(ze)),
      (it = Math.trunc(it)),
      we > Le || _e > ze || xe > it)
    )
      return R;
    Y.invert();
    for (let C = xe; C <= it; C++) {
      const E = C * x;
      for (let q = _e; q <= ze; q++) {
        const ae = E + q * g;
        for (let se = we; se <= Le; se++) {
          const L = ae + se,
            te = new b(se, q, C),
            re = te.clone();
          re.applyMatrix4(Y);
          const { x: W, y: Se, z: Re } = re;
          if (Se < 0 || Se > B) continue;
          const Ee = Math.hypot(W, Re),
            be = { ...Ze, ratio: Se / B, point: te },
            ve = l(be);
          be.radius = ve;
          const Ie = c(be),
            Ye = ve * Ie;
          if (Ee > ve || Ee < Ye) continue;
          const D = h(be),
            pe = {
              ...Ze,
              value: D,
              ratio: Ee / ve,
              radius: ve,
              hollow: Ie,
              hollowRadius: Ye,
              distance: Ee,
              point: te,
            };
          let V = o(pe);
          const ue = w[L];
          ue !== void 0 && (V = u([ue, V], n)),
            (y[L] = V),
            S.push(te),
            w.push(V);
        }
      }
    }
  }
  return R;
}
function _b(r, e, t = 1) {
  let { points: n, size: i, radius: s, ...a } = r;
  if ((s && (s *= t), n)) {
    const o = [];
    for (let { x: l, y: c, z: h, radius: u, ...d } of n) {
      u && (u *= t);
      const f = new b(l, c, h).add(e).multiplyScalar(t);
      Object.assign(f, d, { radius: u }), o.push(f);
    }
    n = o;
  }
  return (
    i && (i = new b().copy(i).add(e).multiplyScalar(t)),
    { points: n, size: i, radius: s, ...a }
  );
}
function xb(r, e) {
  const { points: t, radius: n } = r;
  if (!t) return r;
  const i = new Vt();
  for (const u of t) {
    const d = new b().copy(u),
      f = u.radius ?? n;
    f
      ? (i.expandByPoint(d.clone().subScalar(f)),
        i.expandByPoint(d.addScalar(f)))
      : i.expandByPoint(d);
  }
  const s = new b().max(i.min),
    a = i.max.clone().sub(s).addScalar(1);
  r.size && a.min(r.size);
  let { scale: o, maxSize: l } = e || {};
  o || ((l = l ?? 100), (o = l / Math.max(a.x, a.y, a.z))), a.multiplyScalar(o);
  const c = s.clone().negate(),
    h = _b(r, c, o);
  return (h.size = a), { options: h, position: s, scale: 1 / o };
}
new b(1, 1, 1), new K(1, 1);
window.THREE = mp;
var yb = [
  { x: 30, y: 70, z: 70, value: 100, radius: 60 },
  { x: 90, y: 70, z: 70, value: 100, radius: 60 },
];
let vb = 60,
  Pp = [];
for (; vb-- > 0; )
  Pp.push({
    x: Math.random() * 90,
    y: Math.random() * 30,
    z: Math.random() * 60,
    value: Math.random() * 50,
    radius: Math.random() * 30,
  });
var Mb = [
  { x: 50, y: 0, z: 50, value: 50, radius: 20 },
  { x: 50, y: 70, z: 50, value: 50, radius: 20 },
];
const uo = { x: -100, y: -50 };
var Sb = (uo.x + uo.y) / 2;
let Rl = {
    points: yb,
    size: { x: 100, y: 130, z: 130 },
    range: { x: 0, y: 100 },
    voidRange: uo,
  },
  Lp = {
    热力融合: Rl,
    热力云: {
      ...Rl,
      range: { x: 0, y: 150 },
      voidRange: uo,
      points: Pp,
      size: { x: 90, y: 30, z: 60 },
    },
    圆柱: { ...Rl, points: Mb },
    路灯射光椎: {
      points: [
        { x: 60, y: 40, z: 60, value: 50, radius: 0 },
        { x: 60, y: 0, z: 60, value: 0, radius: 20 },
      ],
      valueGradient: function (r) {
        var { value: e, ratio: t } = r;
        return t < 0.6 ? e : (1 - (t - 0.6) / (1 - 0.6)) ** 5 * e;
      },
      lineValueGradient: function ({
        ratio: r,
        startValue: e,
        endValue: t,
        addedValue: n,
      }) {
        return e + n * r ** 3;
      },
    },
    花瓶: {
      points: [
        { x: 50, y: 0, z: 50, value: 100, radius: 40 },
        { x: 50, y: 60, z: 50, value: 100, radius: 20 },
      ],
      radiusGradient: function (r) {
        let { startRadius: e, endRadius: t, ratio: n } = r;
        var i = t / 2;
        return Math.abs(Math.cos(n * 2)) * (e - i) + i;
      },
      hollowGradient: function (r) {
        var { radius: e, ratio: t, length: n } = r;
        return t * n < 5 ? 0 : 1 - 10 / e;
      },
      valueGradient: function ({ value: r }) {
        return r;
      },
    },
  };
var bt,
  ct,
  mr,
  _h = { 球: new ti(100), 圆柱: new mt(80, 160, 200), 平面: new Qn(200, 200) };
_h.平面.rotateX(-Math.PI / 10);
var ja = {
    自定义1: [
      [0, "rgba(0,255,0,0)"],
      [0.5, "rgba(64,255,255,0.5)"],
      [1, "rgba(255,64,255,1)"],
    ],
    自定义2: [
      [0, "rgba(0,255,0,0)"],
      [0.5, "rgba(64,255,255,1)"],
      [1, "rgba(255,64,255,1)"],
    ],
    自定义3: [
      [0, "rgba(255,255,255,0)"],
      [0.6, "rgba(255,255,255,0.8)"],
      [1, "rgba(255,255,255,1)"],
    ],
    自定义4: [
      [0, "rgba(255,255,255,1)"],
      [1, "rgba(255,255,255,1)"],
    ],
  },
  pi = {
    图片: Cs("../assets/gradient.png"),
    自定义1: Cs(ja.自定义1),
    自定义2: Cs(ja.自定义2),
    自定义3: Cs(ja.自定义3),
    自定义4: Cs(ja.自定义4),
  },
  xh = {},
  ia = {},
  Br = {
    热力云: {
      steps: 100,
      opacity: 1,
      accFactor: 2,
      discardOut: !1,
      range: { x: 0, y: 100 },
      voidRange: { x: -100, y: -50 },
      side: wt,
      fit: qn.Raw,
      gradient: pi.自定义1,
    },
    热力融合: {
      steps: 100,
      opacity: 1,
      accFactor: 3,
      discardOut: !1,
      range: { x: 0, y: 100 },
      voidRange: { x: -100, y: -50 },
      side: wt,
      fit: qn.Raw,
      gradient: pi.自定义2,
    },
    圆柱: {
      steps: 100,
      opacity: 1,
      accFactor: 2,
      discardOut: !1,
      range: { x: 0, y: 50 },
      voidRange: { x: -100, y: -50 },
      side: wt,
      fit: qn.Raw,
      gradient: pi.自定义1,
    },
    路灯射光椎: {
      steps: 100,
      opacity: 1,
      accFactor: 2,
      side: Zt,
      discardOut: !0,
      range: { x: -16, y: 51 },
      voidRange: { x: -500, y: -500 },
      fit: qn.Raw,
      gradient: pi.自定义3,
    },
    花瓶: {
      steps: 100,
      opacity: 1,
      accFactor: 1,
      side: wt,
      discardOut: !0,
      range: { x: 0, y: 100 },
      voidRange: { x: -500, y: -500 },
      fit: qn.Raw,
      gradient: pi.自定义4,
    },
  },
  fo = {};
Object.assign(window, {
  textureMap: ia,
  gradientOptionsMap: Lp,
  optimizeMap: xh,
});
function sa(r, e) {
  const t = Lp[r],
    n = xb(t, { maxSize: 80 });
  xh[r] = n;
  var i = e ? gb(n.options) : ub(n.options);
  const s = Br[r];
  return (
    (fo[r] = ib(i, { ...Br[r], gradient: s.image ?? pi.自定义1.image })),
    (ia[r] = eb(i, { voidValue: Sb }))
  );
}
sa("热力云");
sa("热力融合");
sa("圆柱", !0);
sa("路灯射光椎", !0);
sa("花瓶", !0);
var es, zr;
function bb() {
  PS.load("../assets/floor.glb", (n) => {
    (mr = window.model = n.scene),
      mr.scale.multiplyScalar(2),
      mr.position.copy({
        x: 48.49175763627945,
        y: 6.059975879290931,
        z: 25.089185142637064,
      }),
      ln.add(mr),
      Yn.add(mr, "visible").name("显示模型");
  });
  const r = "热力云";
  (ct = new JS({ ...Br[r], gradient: pi.自定义1, map: ia[r] })),
    (window.material = ct),
    (bt = new KS(ct));
  const { position: e, scale: t } = xh[r];
  bt.position.copy(e),
    bt.position.set(t, t, t),
    (_h.Box = bt.geometry),
    (bt.material.discardOut = !1),
    ln.add(bt),
    Ki.attach(bt),
    (window.mesh = bt),
    (es = window.slice = new ob({ map: fo[r] })),
    es.position.set(-100, -100, -100),
    ln.add(es),
    (zr = window.imageSlice = new lb(fo.热力云)),
    document.getElementById("left-top").appendChild(zr.canvas);
}
var wb = { 示例: "热力云" };
function Eb(r) {
  es.map = zr.texture = fo[r];
  var e = bt.material;
  (e.map = ia[r]), Object.assign(e, Br[r]), bt.updateGeometry();
}
function Ab() {
  const r = Yn.addFolder("变换控制器");
  r.close(),
    r.add(Ki, "enabled").onFinishChange((i) => {
      i ? Ki.attach(bt) : Ki.detach();
    }),
    r.add(Ki, "mode", { 平移: "translate", 旋转: "rotate", 缩放: "scale" }),
    Yn.add(wb, "示例", Object.keys(Br)).onFinishChange(Eb);
  const e = Yn.addFolder("几何体");
  e.close(),
    e.add(bt, "geometry", _h).listen(),
    e.add(bt, "autoUpdateMaterial"),
    e.add(bt, "updateMaterial"),
    e.add(bt, "autoUpdateGeometry"),
    e.add(bt, "updateGeometry"),
    e.add(bt, "autoNormalize"),
    e.add(bt, "normalize");
  const t = Yn.addFolder("材质");
  t.add(ct, "gradient", pi).listen(),
    t.add(ct, "steps", 0, 100, 1).listen(),
    t.add(ct, "opacity", 0, 1).listen(),
    t.add(ct, "accFactor", 0, 100).listen(),
    t.add(ct, "atomize"),
    t.add(ct, "fit", { 充满: qn.Fill, 对齐: qn.Align, 原始: qn.Raw }).listen(),
    t.add(ct, "side", { FrontSide: Zt, BackSide: wt, DoubleSide: Gt }).listen(),
    t.add(ct.alphaRange, "x", 0, 1).name("alphaRange.x").listen(),
    t.add(ct.alphaRange, "y", 0, 1).name("alphaRange.y").listen(),
    t.add(ct.containerMin, "x", -500, 500).name("containerMin.x").listen(),
    t.add(ct.containerMin, "y", -500, 500).name("containerMin.y").listen(),
    t.add(ct.containerMin, "z", -500, 500).name("containerMin.z").listen(),
    t.add(ct.containerMax, "x", -500, 500).name("containerMax.x").listen(),
    t.add(ct.containerMax, "y", -500, 500).name("containerMax.y").listen(),
    t.add(ct.containerMax, "z", -500, 500).name("containerMax.z").listen(),
    t.add(ct, "discardOut").listen(),
    t.add(ct.range, "x", -500, 500).name("range.x").listen(),
    t.add(ct.range, "y", -500, 500).name("range.y").listen(),
    t.add(ct.voidRange, "x", -500, 500).name("voidRange.x").listen(),
    t.add(ct.voidRange, "y", -500, 500).name("voidRange.y").listen(),
    t.add(ct, "map", ia).listen();
  const n = Yn.addFolder("切片");
  n
    .add(es, "depth", 0, 200)
    .listen()
    .onChange((i) => {
      zr.depth = i;
    }),
    n
      .add(es, "axis", { x: 0, y: 1, z: 2 })
      .listen()
      .onChange((i) => {
        zr.axis = i;
      }),
    n.add(es.material, "opacity", 0, 1).listen();
}
var Kn;
function Tb() {
  const r = new ti(1, 32, 32),
    e = new Ut({ color: 16776960 });
  (Kn = new ce(r, e)),
    bt.add(Kn),
    Kn.position.set(10, 10, 10),
    Kn.scale.multiplyScalar(2);
}
function Rb() {
  var r = Yn.addFolder("数据拾取");
  r.add(Kn, "visible").listen(),
    r.add(Kn.position, "x", -100, 100, 1).listen().onChange(Cl),
    r.add(Kn.position, "y", -100, 100, 1).listen().onChange(Cl),
    r.add(Kn.position, "z", -100, 100, 1).listen().onChange(Cl);
}
function Cl() {
  let r = bt.material.map.getValue(Kn.position),
    e = document.getElementById("valueBox"),
    t = document.getElementById("value");
  (e.hidden = r == null), (t.textContent = r ?? "空");
}
function Cb() {
  bb(), Tb(), Ab(), Rb(), Mp();
}
Cb();
