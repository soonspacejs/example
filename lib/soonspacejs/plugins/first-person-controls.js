/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function t(t,s,e){return Math.max(s,Math.min(e,t))}class s{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.isQuaternion=!0,this._x=t,this._y=s,this._z=e,this._w=i}static slerp(t,s,e,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),e.slerpQuaternions(t,s,i)}static slerpFlat(t,s,e,i,n,h,r){let a=e[i+0],o=e[i+1],c=e[i+2],l=e[i+3];const m=n[h+0],u=n[h+1],y=n[h+2],x=n[h+3];if(0===r)return t[s+0]=a,t[s+1]=o,t[s+2]=c,void(t[s+3]=l);if(1===r)return t[s+0]=m,t[s+1]=u,t[s+2]=y,void(t[s+3]=x);if(l!==x||a!==m||o!==u||c!==y){let t=1-r;const s=a*m+o*u+c*y+l*x,e=s>=0?1:-1,i=1-s*s;if(i>Number.EPSILON){const n=Math.sqrt(i),h=Math.atan2(n,s*e);t=Math.sin(t*h)/n,r=Math.sin(r*h)/n}const n=r*e;if(a=a*t+m*n,o=o*t+u*n,c=c*t+y*n,l=l*t+x*n,t===1-r){const t=1/Math.sqrt(a*a+o*o+c*c+l*l);a*=t,o*=t,c*=t,l*=t}}t[s]=a,t[s+1]=o,t[s+2]=c,t[s+3]=l}static multiplyQuaternionsFlat(t,s,e,i,n,h){const r=e[i],a=e[i+1],o=e[i+2],c=e[i+3],l=n[h],m=n[h+1],u=n[h+2],y=n[h+3];return t[s]=r*y+c*l+a*u-o*m,t[s+1]=a*y+c*m+o*l-r*u,t[s+2]=o*y+c*u+r*m-a*l,t[s+3]=c*y-r*l-a*m-o*u,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const e=t._x,i=t._y,n=t._z,h=t._order,r=Math.cos,a=Math.sin,o=r(e/2),c=r(i/2),l=r(n/2),m=a(e/2),u=a(i/2),y=a(n/2);switch(h){case"XYZ":this._x=m*c*l+o*u*y,this._y=o*u*l-m*c*y,this._z=o*c*y+m*u*l,this._w=o*c*l-m*u*y;break;case"YXZ":this._x=m*c*l+o*u*y,this._y=o*u*l-m*c*y,this._z=o*c*y-m*u*l,this._w=o*c*l+m*u*y;break;case"ZXY":this._x=m*c*l-o*u*y,this._y=o*u*l+m*c*y,this._z=o*c*y+m*u*l,this._w=o*c*l-m*u*y;break;case"ZYX":this._x=m*c*l-o*u*y,this._y=o*u*l+m*c*y,this._z=o*c*y-m*u*l,this._w=o*c*l+m*u*y;break;case"YZX":this._x=m*c*l+o*u*y,this._y=o*u*l+m*c*y,this._z=o*c*y-m*u*l,this._w=o*c*l-m*u*y;break;case"XZY":this._x=m*c*l-o*u*y,this._y=o*u*l-m*c*y,this._z=o*c*y+m*u*l,this._w=o*c*l+m*u*y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+h)}return!1!==s&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const e=s/2,i=Math.sin(e);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,e=s[0],i=s[4],n=s[8],h=s[1],r=s[5],a=s[9],o=s[2],c=s[6],l=s[10],m=e+r+l;if(m>0){const t=.5/Math.sqrt(m+1);this._w=.25/t,this._x=(c-a)*t,this._y=(n-o)*t,this._z=(h-i)*t}else if(e>r&&e>l){const t=2*Math.sqrt(1+e-r-l);this._w=(c-a)/t,this._x=.25*t,this._y=(i+h)/t,this._z=(n+o)/t}else if(r>l){const t=2*Math.sqrt(1+r-e-l);this._w=(n-o)/t,this._x=(i+h)/t,this._y=.25*t,this._z=(a+c)/t}else{const t=2*Math.sqrt(1+l-e-r);this._w=(h-i)/t,this._x=(n+o)/t,this._y=(a+c)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let e=t.dot(s)+1;return e<Number.EPSILON?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=e),this.normalize()}angleTo(s){return 2*Math.acos(Math.abs(t(this.dot(s),-1,1)))}rotateTowards(t,s){const e=this.angleTo(t);if(0===e)return this;const i=Math.min(1,s/e);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return void 0!==s?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const e=t._x,i=t._y,n=t._z,h=t._w,r=s._x,a=s._y,o=s._z,c=s._w;return this._x=e*c+h*r+i*o-n*a,this._y=i*c+h*a+n*r-e*o,this._z=n*c+h*o+e*a-i*r,this._w=h*c-e*r-i*a-n*o,this._onChangeCallback(),this}slerp(t,s){if(0===s)return this;if(1===s)return this.copy(t);const e=this._x,i=this._y,n=this._z,h=this._w;let r=h*t._w+e*t._x+i*t._y+n*t._z;if(r<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,r=-r):this.copy(t),r>=1)return this._w=h,this._x=e,this._y=i,this._z=n,this;const a=1-r*r;if(a<=Number.EPSILON){const t=1-s;return this._w=t*h+s*this._w,this._x=t*e+s*this._x,this._y=t*i+s*this._y,this._z=t*n+s*this._z,this.normalize(),this._onChangeCallback(),this}const o=Math.sqrt(a),c=Math.atan2(o,r),l=Math.sin((1-s)*c)/o,m=Math.sin(s*c)/o;return this._w=h*l+this._w*m,this._x=e*l+this._x*m,this._y=i*l+this._y*m,this._z=n*l+this._z*m,this._onChangeCallback(),this}slerpQuaternions(t,s,e){return this.copy(t).slerp(s,e)}random(){const t=Math.random(),s=Math.sqrt(1-t),e=Math.sqrt(t),i=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(s*Math.cos(i),e*Math.sin(n),e*Math.cos(n),s*Math.sin(i))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class e{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;e.prototype.isVector3=!0,this.x=t,this.y=s,this.z=i}set(t,s,e){return void 0===e&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return void 0!==s?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return void 0!==s?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(n.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(n.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,n=t.elements;return this.x=n[0]*s+n[3]*e+n[6]*i,this.y=n[1]*s+n[4]*e+n[7]*i,this.z=n[2]*s+n[5]*e+n[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,n=t.elements,h=1/(n[3]*s+n[7]*e+n[11]*i+n[15]);return this.x=(n[0]*s+n[4]*e+n[8]*i+n[12])*h,this.y=(n[1]*s+n[5]*e+n[9]*i+n[13])*h,this.z=(n[2]*s+n[6]*e+n[10]*i+n[14])*h,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,n=t.x,h=t.y,r=t.z,a=t.w,o=a*s+h*i-r*e,c=a*e+r*s-n*i,l=a*i+n*e-h*s,m=-n*s-h*e-r*i;return this.x=o*a+m*-n+c*-r-l*-h,this.y=c*a+m*-h+l*-n-o*-r,this.z=l*a+m*-r+o*-h-c*-n,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,n=t.elements;return this.x=n[0]*s+n[4]*e+n[8]*i,this.y=n[1]*s+n[5]*e+n[9]*i,this.z=n[2]*s+n[6]*e+n[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(Math.max(t,Math.min(s,e)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t,s){return void 0!==s?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,n=t.z,h=s.x,r=s.y,a=s.z;return this.x=i*a-n*r,this.y=n*h-e*a,this.z=e*r-i*h,this}projectOnVector(t){const s=t.lengthSq();if(0===s)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return i.copy(this).projectOnVector(t),this.sub(i)}reflect(t){return this.sub(i.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(s){const e=Math.sqrt(this.lengthSq()*s.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(s)/e;return Math.acos(t(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,4*s)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,3*s)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,e){return void 0!==e&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=2*(Math.random()-.5),s=Math.random()*Math.PI*2,e=Math.sqrt(1-t**2);return this.x=e*Math.cos(s),this.y=e*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const i=new e,n=new s;class h{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new e(1/0,1/0,1/0),s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new e(-1/0,-1/0,-1/0);this.isBox3=!0,this.min=t,this.max=s}set(t,s){return this.min.copy(t),this.max.copy(s),this}setFromArray(t){let s=1/0,e=1/0,i=1/0,n=-1/0,h=-1/0,r=-1/0;for(let a=0,o=t.length;a<o;a+=3){const o=t[a],c=t[a+1],l=t[a+2];o<s&&(s=o),c<e&&(e=c),l<i&&(i=l),o>n&&(n=o),c>h&&(h=c),l>r&&(r=l)}return this.min.set(s,e,i),this.max.set(n,h,r),this}setFromBufferAttribute(t){let s=1/0,e=1/0,i=1/0,n=-1/0,h=-1/0,r=-1/0;for(let a=0,o=t.count;a<o;a++){const o=t.getX(a),c=t.getY(a),l=t.getZ(a);o<s&&(s=o),c<e&&(e=c),l<i&&(i=l),o>n&&(n=o),c>h&&(h=c),l>r&&(r=l)}return this.min.set(s,e,i),this.max.set(n,h,r),this}setFromPoints(t){this.makeEmpty();for(let s=0,e=t.length;s<e;s++)this.expandByPoint(t[s]);return this}setFromCenterAndSize(t,s){const e=a.copy(s).multiplyScalar(.5);return this.min.copy(t).sub(e),this.max.copy(t).add(e),this}setFromObject(t){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.makeEmpty(),this.expandByObject(t,s)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];t.updateWorldMatrix(!1,!1);const e=t.geometry;if(void 0!==e)if(s&&null!=e.attributes&&void 0!==e.attributes.position){const s=e.attributes.position;for(let e=0,i=s.count;e<i;e++)a.fromBufferAttribute(s,e).applyMatrix4(t.matrixWorld),this.expandByPoint(a)}else null===e.boundingBox&&e.computeBoundingBox(),o.copy(e.boundingBox),o.applyMatrix4(t.matrixWorld),this.union(o);const i=t.children;for(let t=0,e=i.length;t<e;t++)this.expandByObject(i[t],s);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,s){return s.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,a),a.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let s,e;return t.normal.x>0?(s=t.normal.x*this.min.x,e=t.normal.x*this.max.x):(s=t.normal.x*this.max.x,e=t.normal.x*this.min.x),t.normal.y>0?(s+=t.normal.y*this.min.y,e+=t.normal.y*this.max.y):(s+=t.normal.y*this.max.y,e+=t.normal.y*this.min.y),t.normal.z>0?(s+=t.normal.z*this.min.z,e+=t.normal.z*this.max.z):(s+=t.normal.z*this.max.z,e+=t.normal.z*this.min.z),s<=-t.constant&&e>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(d),p.subVectors(this.max,d),c.subVectors(t.a,d),l.subVectors(t.b,d),m.subVectors(t.c,d),u.subVectors(l,c),y.subVectors(m,l),x.subVectors(c,m);let s=[0,-u.z,u.y,0,-y.z,y.y,0,-x.z,x.y,u.z,0,-u.x,y.z,0,-y.x,x.z,0,-x.x,-u.y,u.x,0,-y.y,y.x,0,-x.y,x.x,0];return!!g(s,c,l,m,p)&&(s=[1,0,0,0,1,0,0,0,1],!!g(s,c,l,m,p)&&(_.crossVectors(u,y),s=[_.x,_.y,_.z],g(s,c,l,m,p)))}clampPoint(t,s){return s.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return a.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(a).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(r[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),r[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),r[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),r[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),r[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),r[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),r[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),r[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(r)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const r=[new e,new e,new e,new e,new e,new e,new e,new e],a=new e,o=new h,c=new e,l=new e,m=new e,u=new e,y=new e,x=new e,d=new e,p=new e,_=new e,z=new e;function g(t,s,e,i,n){for(let h=0,r=t.length-3;h<=r;h+=3){z.fromArray(t,h);const r=n.x*Math.abs(z.x)+n.y*Math.abs(z.y)+n.z*Math.abs(z.z),a=s.dot(z),o=e.dot(z),c=i.dot(z);if(Math.max(-Math.max(a,o,c),Math.min(a,o,c))>r)return!1}return!0}class M{constructor(){M.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,s,e,i,n,h,r,a,o,c,l,m,u,y,x,d){const p=this.elements;return p[0]=t,p[4]=s,p[8]=e,p[12]=i,p[1]=n,p[5]=h,p[9]=r,p[13]=a,p[2]=o,p[6]=c,p[10]=l,p[14]=m,p[3]=u,p[7]=y,p[11]=x,p[15]=d,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new M).fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/w.setFromMatrixColumn(t,0).length(),n=1/w.setFromMatrixColumn(t,1).length(),h=1/w.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*n,s[5]=e[5]*n,s[6]=e[6]*n,s[7]=0,s[8]=e[8]*h,s[9]=e[9]*h,s[10]=e[10]*h,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const s=this.elements,e=t.x,i=t.y,n=t.z,h=Math.cos(e),r=Math.sin(e),a=Math.cos(i),o=Math.sin(i),c=Math.cos(n),l=Math.sin(n);if("XYZ"===t.order){const t=h*c,e=h*l,i=r*c,n=r*l;s[0]=a*c,s[4]=-a*l,s[8]=o,s[1]=e+i*o,s[5]=t-n*o,s[9]=-r*a,s[2]=n-t*o,s[6]=i+e*o,s[10]=h*a}else if("YXZ"===t.order){const t=a*c,e=a*l,i=o*c,n=o*l;s[0]=t+n*r,s[4]=i*r-e,s[8]=h*o,s[1]=h*l,s[5]=h*c,s[9]=-r,s[2]=e*r-i,s[6]=n+t*r,s[10]=h*a}else if("ZXY"===t.order){const t=a*c,e=a*l,i=o*c,n=o*l;s[0]=t-n*r,s[4]=-h*l,s[8]=i+e*r,s[1]=e+i*r,s[5]=h*c,s[9]=n-t*r,s[2]=-h*o,s[6]=r,s[10]=h*a}else if("ZYX"===t.order){const t=h*c,e=h*l,i=r*c,n=r*l;s[0]=a*c,s[4]=i*o-e,s[8]=t*o+n,s[1]=a*l,s[5]=n*o+t,s[9]=e*o-i,s[2]=-o,s[6]=r*a,s[10]=h*a}else if("YZX"===t.order){const t=h*a,e=h*o,i=r*a,n=r*o;s[0]=a*c,s[4]=n-t*l,s[8]=i*l+e,s[1]=l,s[5]=h*c,s[9]=-r*c,s[2]=-o*c,s[6]=e*l+i,s[10]=t-n*l}else if("XZY"===t.order){const t=h*a,e=h*o,i=r*a,n=r*o;s[0]=a*c,s[4]=-l,s[8]=o*c,s[1]=t*l+n,s[5]=h*c,s[9]=e*l-i,s[2]=i*l-e,s[6]=r*c,s[10]=n*l+t}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(b,t,f)}lookAt(t,s,e){const i=this.elements;return k.subVectors(t,s),0===k.lengthSq()&&(k.z=1),k.normalize(),C.crossVectors(e,k),0===C.lengthSq()&&(1===Math.abs(e.z)?k.x+=1e-4:k.z+=1e-4,k.normalize(),C.crossVectors(e,k)),C.normalize(),E.crossVectors(k,C),i[0]=C.x,i[4]=E.x,i[8]=k.x,i[1]=C.y,i[5]=E.y,i[9]=k.y,i[2]=C.z,i[6]=E.z,i[10]=k.z,this}multiply(t,s){return void 0!==s?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,s)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,n=this.elements,h=e[0],r=e[4],a=e[8],o=e[12],c=e[1],l=e[5],m=e[9],u=e[13],y=e[2],x=e[6],d=e[10],p=e[14],_=e[3],z=e[7],g=e[11],M=e[15],w=i[0],v=i[4],b=i[8],f=i[12],C=i[1],E=i[5],k=i[9],R=i[13],S=i[2],j=i[6],F=i[10],T=i[14],O=i[3],V=i[7],A=i[11],H=i[15];return n[0]=h*w+r*C+a*S+o*O,n[4]=h*v+r*E+a*j+o*V,n[8]=h*b+r*k+a*F+o*A,n[12]=h*f+r*R+a*T+o*H,n[1]=c*w+l*C+m*S+u*O,n[5]=c*v+l*E+m*j+u*V,n[9]=c*b+l*k+m*F+u*A,n[13]=c*f+l*R+m*T+u*H,n[2]=y*w+x*C+d*S+p*O,n[6]=y*v+x*E+d*j+p*V,n[10]=y*b+x*k+d*F+p*A,n[14]=y*f+x*R+d*T+p*H,n[3]=_*w+z*C+g*S+M*O,n[7]=_*v+z*E+g*j+M*V,n[11]=_*b+z*k+g*F+M*A,n[15]=_*f+z*R+g*T+M*H,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],n=t[12],h=t[1],r=t[5],a=t[9],o=t[13],c=t[2],l=t[6],m=t[10],u=t[14];return t[3]*(+n*a*l-i*o*l-n*r*m+e*o*m+i*r*u-e*a*u)+t[7]*(+s*a*u-s*o*m+n*h*m-i*h*u+i*o*c-n*a*c)+t[11]*(+s*o*l-s*r*u-n*h*l+e*h*u+n*r*c-e*o*c)+t[15]*(-i*r*c-s*a*l+s*r*m+i*h*l-e*h*m+e*a*c)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}invert(){const t=this.elements,s=t[0],e=t[1],i=t[2],n=t[3],h=t[4],r=t[5],a=t[6],o=t[7],c=t[8],l=t[9],m=t[10],u=t[11],y=t[12],x=t[13],d=t[14],p=t[15],_=l*d*o-x*m*o+x*a*u-r*d*u-l*a*p+r*m*p,z=y*m*o-c*d*o-y*a*u+h*d*u+c*a*p-h*m*p,g=c*x*o-y*l*o+y*r*u-h*x*u-c*r*p+h*l*p,M=y*l*a-c*x*a-y*r*m+h*x*m+c*r*d-h*l*d,w=s*_+e*z+i*g+n*M;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const v=1/w;return t[0]=_*v,t[1]=(x*m*n-l*d*n-x*i*u+e*d*u+l*i*p-e*m*p)*v,t[2]=(r*d*n-x*a*n+x*i*o-e*d*o-r*i*p+e*a*p)*v,t[3]=(l*a*n-r*m*n-l*i*o+e*m*o+r*i*u-e*a*u)*v,t[4]=z*v,t[5]=(c*d*n-y*m*n+y*i*u-s*d*u-c*i*p+s*m*p)*v,t[6]=(y*a*n-h*d*n-y*i*o+s*d*o+h*i*p-s*a*p)*v,t[7]=(h*m*n-c*a*n+c*i*o-s*m*o-h*i*u+s*a*u)*v,t[8]=g*v,t[9]=(y*l*n-c*x*n-y*e*u+s*x*u+c*e*p-s*l*p)*v,t[10]=(h*x*n-y*r*n+y*e*o-s*x*o-h*e*p+s*r*p)*v,t[11]=(c*r*n-h*l*n-c*e*o+s*l*o+h*e*u-s*r*u)*v,t[12]=M*v,t[13]=(c*x*i-y*l*i+y*e*m-s*x*m-c*e*d+s*l*d)*v,t[14]=(y*r*i-h*x*i-y*e*a+s*x*a+h*e*d-s*r*d)*v,t[15]=(h*l*i-c*r*i+c*e*a-s*l*a-h*e*m+s*r*m)*v,this}scale(t){const s=this.elements,e=t.x,i=t.y,n=t.z;return s[0]*=e,s[4]*=i,s[8]*=n,s[1]*=e,s[5]*=i,s[9]*=n,s[2]*=e,s[6]*=i,s[10]*=n,s[3]*=e,s[7]*=i,s[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),n=1-e,h=t.x,r=t.y,a=t.z,o=n*h,c=n*r;return this.set(o*h+e,o*r-i*a,o*a+i*r,0,o*r+i*a,c*r+e,c*a-i*h,0,o*a-i*r,c*a+i*h,n*a*a+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e,i,n,h){return this.set(1,e,n,0,t,1,h,0,s,i,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,n=s._x,h=s._y,r=s._z,a=s._w,o=n+n,c=h+h,l=r+r,m=n*o,u=n*c,y=n*l,x=h*c,d=h*l,p=r*l,_=a*o,z=a*c,g=a*l,M=e.x,w=e.y,v=e.z;return i[0]=(1-(x+p))*M,i[1]=(u+g)*M,i[2]=(y-z)*M,i[3]=0,i[4]=(u-g)*w,i[5]=(1-(m+p))*w,i[6]=(d+_)*w,i[7]=0,i[8]=(y+z)*v,i[9]=(d-_)*v,i[10]=(1-(m+x))*v,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let n=w.set(i[0],i[1],i[2]).length();const h=w.set(i[4],i[5],i[6]).length(),r=w.set(i[8],i[9],i[10]).length();this.determinant()<0&&(n=-n),t.x=i[12],t.y=i[13],t.z=i[14],v.copy(this);const a=1/n,o=1/h,c=1/r;return v.elements[0]*=a,v.elements[1]*=a,v.elements[2]*=a,v.elements[4]*=o,v.elements[5]*=o,v.elements[6]*=o,v.elements[8]*=c,v.elements[9]*=c,v.elements[10]*=c,s.setFromRotationMatrix(v),e.x=n,e.y=h,e.z=r,this}makePerspective(t,s,e,i,n,h){void 0===h&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const r=this.elements,a=2*n/(s-t),o=2*n/(e-i),c=(s+t)/(s-t),l=(e+i)/(e-i),m=-(h+n)/(h-n),u=-2*h*n/(h-n);return r[0]=a,r[4]=0,r[8]=c,r[12]=0,r[1]=0,r[5]=o,r[9]=l,r[13]=0,r[2]=0,r[6]=0,r[10]=m,r[14]=u,r[3]=0,r[7]=0,r[11]=-1,r[15]=0,this}makeOrthographic(t,s,e,i,n,h){const r=this.elements,a=1/(s-t),o=1/(e-i),c=1/(h-n),l=(s+t)*a,m=(e+i)*o,u=(h+n)*c;return r[0]=2*a,r[4]=0,r[8]=0,r[12]=-l,r[1]=0,r[5]=2*o,r[9]=0,r[13]=-m,r[2]=0,r[6]=0,r[10]=-2*c,r[14]=-u,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let t=0;t<16;t++)if(s[t]!==e[t])return!1;return!0}fromArray(t){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}const w=new e,v=new M,b=new e(0,0,0),f=new e(1,1,1),C=new e,E=new e,k=new e;function R(t,s){const i=function(t){const s=new h,i=s.min.clone(),n=s.max.clone();if(s.setFromObject(t),s.min.equals(i)&&s.max.equals(n)){const i=new e;t.getWorldPosition(i),s.min.copy(i),s.max.copy(i)}if(t.isInstancedMesh){const{count:e,matrixWorld:i,geometry:n}=t;let h=n.boundingBox;if(h||(n.computeBoundingBox(),h=n.boundingBox),h){const n=i.clone();for(let i=0;i<e;i++){const e=new M;t.getMatrixAt(i,e),e.premultiply(n);const r=h.clone();r.applyMatrix4(n),s.union(r)}}}return s}(s);return t.intersectsBox(i)}function S(t,s){t.disableAll();for(const e of s)t.enable(e)}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"142"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="142");let j=performance.now();let F;class T{constructor(t,s){this._camera=null,this.isExternalCamera=!1,this.gravitySpeed=10,this.jumpOffset=0,this.clashCheckDistance=200,this.clashDistance=50,this.reverseRotate=!1,this._rotate=!0,this.horizontalRotate=!0,this.verticalRotate=!0,this._touch=null,this.searchRadiusFactor=3,this.checkedObjects=null,this.sceneObjectsChanged=()=>{this.checkedObjects=null},this.gravitySearchFactor=3,this.gravityCheckedObjects=null,this.gravityInterObject=null,this.kneeInterObject=null,this.eyeInterObject=null,this.hasUpdated=!1,this.ssp=t,this._camera=null!=s?s:null,this.viewport=t.viewport,this.enabled=!1,this.rotationAngle={min:-Math.PI/2,max:Math.PI/2},this.state={moveForward:!1,moveBackward:!1,moveLeft:!1,moveRight:!1,moveUp:!1,moveDown:!1,canJump:!1,canRotate:!1},this.moveSpeed=10,this.eyeHeight=160,this.kneeHeight=50,this.jumpHeight=110,this.enableClash=!0,this.enableGravity=!0,this.onKeyDown=this.onKeyDown.bind(this),this.onKeyUp=this.onKeyUp.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this);const e=this.ssp.THREE,{Vector3:i,Sphere:n,Vector2:h,Box3:r}=e;this.velocity=new i,this.vector=new i,this.movement=new h,this.lastDirection=new i,this.checkedSphere=new n,this.gravityCheckedBox=new r}get camera(){let t=this._camera;return t||(t=this._camera=this.viewport.cameraManager.createCamera("firstPersonCamera"),this.isExternalCamera=!1),t}set camera(t){this._camera=t,this.isExternalCamera=!0}get rotate(){return this._rotate&&(this.horizontalRotate||this.verticalRotate)}set rotate(t){this._rotate=t}onKeyDown(t){if(!1!==this.enabled){switch(t.code){case"ArrowUp":case"KeyW":this.state.moveForward=!0;break;case"ArrowLeft":case"KeyA":this.state.moveLeft=!0;break;case"ArrowDown":case"KeyS":this.state.moveBackward=!0;break;case"ArrowRight":case"KeyD":this.state.moveRight=!0;break;case"KeyI":this.state.canRotate=!0,this.movement.x=0,this.movement.y=-10;break;case"KeyJ":this.state.canRotate=!0,this.movement.x=-10,this.movement.y=0;break;case"KeyK":this.state.canRotate=!0,this.movement.x=0,this.movement.y=10;break;case"KeyL":this.state.canRotate=!0,this.movement.x=10,this.movement.y=0;break;case"KeyQ":this.state.moveUp=!0;break;case"KeyE":this.state.moveDown=!0;break;case"Space":!0===this.state.canJump&&(this.jumpOffset+=3*this.jumpHeight),this.state.canJump=!1}(this.jumpOffset||Object.values(this.state).some((t=>t)))&&this.needUpdate()}}onKeyUp(t){if(!1!==this.enabled)switch(t.code){case"ArrowUp":case"KeyW":this.state.moveForward=!1;break;case"ArrowLeft":case"KeyA":this.state.moveLeft=!1;break;case"ArrowDown":case"KeyS":this.state.moveBackward=!1;break;case"ArrowRight":case"KeyD":this.state.moveRight=!1;break;case"KeyI":case"KeyJ":case"KeyK":case"KeyL":this.state.canRotate=!1;break;case"KeyQ":this.state.moveUp=!1;break;case"KeyE":this.state.moveDown=!1}}onMouseDown(t){this.state.canRotate=!0}onMouseUp(t){this.state.canRotate=!1}onMouseMove(t){if(this.enabled&&this.state.canRotate){let s=t.movementY,e=t.movementX;0===e&&(t.clientX<20?e=-10:t.clientX>this.viewport.interactiveContainer.clientWidth-20&&(e=10)),this.reverseRotate&&(e=-e,s=-s),this.movement.x=e,this.movement.y=s,this.needUpdate()}}onTouchStart(t){this._touch=t.targetTouches[0],this._touch&&(this.state.canRotate=!0)}onTouchEnd(t){const s=this._touch;if(!s)return;if(t.targetTouches.length>0){if(!Array.from(t.targetTouches).find((t=>t.identifier===s.identifier)))return}this._touch=null,this.state.canRotate=!1}onTouchMove(t){const s=this._touch;if(!s)return;const e=Array.from(t.targetTouches).find((t=>t.identifier===s.identifier));if(!e)return;if(!this.enabled||!this.state.canRotate)return;let i=e.screenX-s.screenX,n=e.screenY-s.screenY;0===i&&(e.clientX<20?i=-10:e.clientX>this.viewport.interactiveContainer.clientWidth-20&&(i=10)),this.reverseRotate&&(i=-i,n=-n),this.movement.x=i,this.movement.y=n,this._touch=e,this.needUpdate()}clearClashCache(){this.kneeInterObject=null,this.eyeInterObject=null}onClashCheck(t,s){const e=s.length(),i=s.clone().divideScalar(e);i.distanceToSquared(this.lastDirection)>1e-9&&this.clearClashCache(),this.lastDirection=i;const n=this.ssp.THREE,{eyeHeight:h,kneeHeight:r,camera:a,clashCheckDistance:o,clashDistance:c,clashLayers:l}=this;let{kneeInterObject:m,eyeInterObject:u}=this;if(!m){const s=t.clone().setY(t.y-h+r),e=new this.ssp.THREE.Raycaster(s,i,0,o);e.firstHitOnly=!0,null!=l&&S(e.layers,l),e.camera=a;const n=this.getCheckedObjects(s),c=e.intersectObjects(n);this.kneeInterObject=m=c[0]}let y=-e;if(m&&(y+=m.distance,y<c))return!0;if(!u){const s=new n.Raycaster(t,i,0,o);s.firstHitOnly=!0,null!=l&&S(s.layers,l),s.camera=a;const e=this.getCheckedObjects(t),h=s.intersectObjects(e);this.eyeInterObject=u=h[0]}let x=-e;if(u){if(x+=u.distance,x<c)return!0;u.distance=x}return m&&(m.distance=y),!1}getCheckedObjects(t){const{clashDistance:s,clashCheckDistance:e,searchRadiusFactor:i,clashFilter:n}=this,h=e*i,r=this.checkedSphere,a=h+s;r.set(t,a);const o=null!=n?n:function(){return!0};return this.viewport.scener.intersectsList.getAll().filter((t=>!!o(t)&&R(r,t)))}getGravityCheckedObjects(t,s){const e=this.gravityCheckedBox;let i=this.gravityCheckedObjects;if(i){const n=t.clone();n.y=s,e.containsPoint(t)&&e.containsPoint(n)||(i=null)}if(!i){const{eyeHeight:s,clashCheckDistance:n,gravitySearchFactor:h,clashDistance:r,clashFilter:a}=this,o=n+r,c=new this.ssp.THREE.Vector3(o,o,0),l=t.clone().add(c),m=t.clone().sub(c);m.y-=s*h,e.set(m,l);const u=this.viewport.scener.intersectsList.getAll(),y=null!=a?a:function(){return!0};this.checkedObjects=i=u.filter((t=>!!y(t)&&R(e,t)))}return i}gravityClashCheck(t,s){var e;let i=this.gravityInterObject;if(i){const{Vector3:s,Matrix4:n}=this.ssp.THREE,{object:h,face:r,instanceId:a}=i,o=null===(e=h.geometry)||void 0===e?void 0:e.getAttribute("position");if(o&&r){let e=i.facePoints;if(!e){let t=h.matrixWorld;if(null!=a){const s=new n;h.getMatrixAt(a,s),t=s.premultiply(t)}const{a:c,b:l,c:m}=r,u=new s(o.getX(c),o.getY(c),o.getZ(c));u.applyMatrix4(t),u.setY(0);const y=new s(o.getX(l),o.getY(l),o.getZ(l));y.applyMatrix4(t),y.setY(0);const x=new s(o.getX(m),o.getY(m),o.getZ(m));x.applyMatrix4(t),x.setY(0),i.facePoints=e=[u,y,x]}let c=e[2],l=null;const m=t.clone();m.y=0;e.every((t=>{const s=t.clone();s.sub(c);const e=m.clone();if(e.sub(c),s.cross(e),l){if(s.dot(l)<=0)return!1}return l=s,c=t,!0}))||(this.gravityInterObject=i=null)}}if(!i){const e=new THREE.Raycaster(t,new THREE.Vector3(0,-1,0));e.firstHitOnly=!0;const n=this.clashLayers;null!=n&&S(e.layers,n),e.camera=this.camera;const h=this.getGravityCheckedObjects(t,s),r=e.intersectObjects(h);this.gravityInterObject=i=r[0]}return i}setOptions(t){const{position:s,rotation:i,moveSpeed:n,eyeHeight:h,kneeHeight:r,jumpHeight:a,enableClash:o,enableGravity:c,searchRadiusFactor:l,clashDistance:m,clashCheckDistance:u,gravitySpeed:y,gravitySearchFactor:x,reverseRotate:d,rotate:p,horizontalRotate:_,verticalRotate:z,clashFilter:g,clashLayers:M}=t;if(h){const t=this.eyeHeight;this.eyeHeight=h;const s=null==t?h:h-t;this.camera.position.add(new e(0,s,0))}r&&(this.kneeHeight=r),a&&(this.jumpHeight=a),l&&(this.searchRadiusFactor=l),m&&(this.clashDistance=m),u&&(this.clashCheckDistance=u),y&&(this.gravitySpeed=y),x&&(this.gravitySearchFactor=x),null!=d&&(this.reverseRotate=d),null!=p&&(this.rotate=p),null!=_&&(this.horizontalRotate=_),null!=z&&(this.verticalRotate=z),null!=o&&(this.enableClash=o),null!=c&&(this.enableGravity=c),null!=g&&(this.clashFilter=g),null!=M&&(this.clashLayers=M),s&&this.camera.position.set(s.x,s.y+this.eyeHeight,s.z),i&&this.camera.rotation.set(i.x,i.y,i.z),n&&(this.moveSpeed=n),this.ssp.signals.cameraChange.dispatch(this.camera.position.clone())}start(t){F=this.ssp.getCameraViewpoint(),this.viewport.controls.currentControls.enabled=!1,this.enabled=!0,this.isExternalCamera||this.viewport.cameraManager.setCurrentCamera(this.camera),this.setOptions(t),this.viewport.postRender.set("FirstPersonControls",this.update.bind(this)),this.ssp.signals.mouseDown.add(this.onMouseDown),this.ssp.signals.mouseUp.add(this.onMouseUp),this.ssp.signals.mouseMove.add(this.onMouseMove),this.ssp.signals.keyDown.add(this.onKeyDown),this.ssp.signals.keyUp.add(this.onKeyUp);const s=this.ssp.viewport.container;s.addEventListener("touchstart",this.onTouchStart),s.addEventListener("touchmove",this.onTouchMove),s.addEventListener("touchend",this.onTouchEnd),this.ssp.signals.objectAdded.add(this.sceneObjectsChanged),this.ssp.signals.objectRemoved.add(this.sceneObjectsChanged)}stop(){F&&this.ssp.setCameraViewpoint(F),this.viewport.controls.currentControls.enabled=!0,this.enabled=!1,this.isExternalCamera||this.viewport.cameraManager.setCurrentCamera(this.viewport.cameraManager.getMainCamera()),this.viewport.postRender.delete("FirstPersonControls"),this.ssp.signals.mouseDown.remove(this.onMouseDown),this.ssp.signals.mouseUp.remove(this.onMouseUp),this.ssp.signals.mouseMove.remove(this.onMouseMove),this.ssp.signals.keyDown.remove(this.onKeyDown),this.ssp.signals.keyUp.remove(this.onKeyUp);const t=this.ssp.viewport.container;t.removeEventListener("touchstart",this.onTouchStart),t.removeEventListener("touchmove",this.onTouchMove),t.removeEventListener("touchend",this.onTouchEnd),this.ssp.signals.objectAdded.remove(this.sceneObjectsChanged),this.ssp.signals.objectRemoved.remove(this.sceneObjectsChanged),this.needUpdate()}needUpdate(){this.hasUpdated&&(this.hasUpdated=!1,j=performance.now(),this.ssp.signals.cameraChange.dispatch(this.camera.position.clone()))}update(){if(!this.enabled)return;const t=performance.now(),s=(t-j)/1e3;j=t;const e=this.ssp.THREE,{Vector3:i}=e,n=new e.Vector3,{state:h,camera:r,eyeHeight:a,kneeHeight:o}=this,c=20*this.moveSpeed,l=20*this.gravitySpeed,{position:m,quaternion:u}=r;let y=0,x=!1;h.moveForward&&(n.z-=c),h.moveBackward&&(n.z+=c),h.moveLeft&&(n.x-=c),h.moveRight&&(n.x+=c),h.moveUp&&(y+=c),h.moveDown&&(y-=c),n.multiplyScalar(s);const d=new e.Euler(0,0,0,"YXZ");d.setFromQuaternion(u);const{x:p,y:_}=this.movement,z=this.horizontalRotate&&0!==p,g=this.verticalRotate&&0!==_;if(this.rotate&&h.canRotate&&(z||g)){g&&(d.x-=.003*_),z&&(d.y-=.003*p);const{max:t,min:s}=this.rotationAngle;d.x=Math.min(t,Math.max(d.x,s)),r.quaternion.setFromEuler(d),x=!0}const M=this.jumpOffset+y*s;if(0!==d.y&&!n.equals(new i)){const t=new e.Quaternion;t.setFromAxisAngle(new i(0,1,0),d.y),n.applyQuaternion(t)}const w=m.clone();if((M||!n.equals(new i))&&(n.y+=M,!this.onClashCheck(m,n)&&(w.add(n),this.gravityInterObject))){const t=this.gravityInterObject.point.clone().sub(w);t.y=0,t.length()>o&&(this.gravityInterObject=null)}let v=w.y;if(this.enableGravity){const t=v;v-=l*s,h.canJump=!1;const e=this.gravityClashCheck(w,v);if(e){const t=e.point.y+a;v<t&&(v=t,h.canJump=!0)}t!==v&&this.clearClashCache()}w.y=v;const b=!m.equals(w);b&&r.position.copy(w),this.jumpOffset=0,(b||x)&&this.ssp.signals.cameraChange.dispatch(this.camera.position.clone()),this.hasUpdated=!0}}export{T as default};
